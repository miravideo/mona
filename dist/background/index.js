{ /* eslint-disable no-unused-vars */

/**
 * This file is used by entire `src` except `injected`.
 * `global` is used instead of WebPack's polyfill which we disable in webpack.conf.js.
 * `safeCall` is used by our modified babel-plugin-safe-bind.js.
 * Standard globals are extracted for better minification and marginally improved lookup speed.
 * Not exporting NodeJS built-in globals as this file is imported in the test scripts.
 */
const global = function _() {
  return this || globalThis; // eslint-disable-line no-undef
}();

const {
  Boolean,
  Error,
  Object,
  Promise,
  document,
  window
} = global;
const PromiseSafe = Promise; // alias used by browser.js

const ErrorSafe = Error; // alias used by browser.js

const {
  hasOwnProperty,
  toString: objectToString
} = {};
const safeCall = Object.call.bind(Object.call);
const IS_FIREFOX = !global.chrome.app;/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"background/index": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./src/background/index.js","public/lib/tldjs","common"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@ffmpeg/ffmpeg/package.json":
/*!**************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/package.json ***!
  \**************************************************/
/*! exports provided: name, version, description, main, types, directories, scripts, browser, repository, keywords, author, license, bugs, engines, homepage, dependencies, devDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@ffmpeg/ffmpeg\",\"version\":\"0.10.1\",\"description\":\"FFmpeg WebAssembly version\",\"main\":\"src/index.js\",\"types\":\"src/index.d.ts\",\"directories\":{\"example\":\"examples\"},\"scripts\":{\"start\":\"node scripts/server.js\",\"build\":\"rimraf dist && webpack --config scripts/webpack.config.prod.js\",\"prepublishOnly\":\"npm run build\",\"lint\":\"eslint src\",\"wait\":\"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\",\"test\":\"npm-run-all -p -r start test:all\",\"test:all\":\"npm-run-all wait test:browser:ffmpeg test:node:all\",\"test:node\":\"node --experimental-wasm-threads --experimental-wasm-bulk-memory node_modules/.bin/_mocha --exit --bail --require ./scripts/test-helper.js\",\"test:node:all\":\"npm run test:node -- ./tests/*.test.js\",\"test:browser\":\"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\",\"test:browser:ffmpeg\":\"npm run test:browser -- -f ./tests/ffmpeg.test.html\"},\"browser\":{\"./src/node/index.js\":\"./src/browser/index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\"},\"keywords\":[\"ffmpeg\",\"WebAssembly\",\"video\"],\"author\":\"Jerome Wu <jeromewus@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\"},\"engines\":{\"node\":\">=12.16.1\"},\"homepage\":\"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\",\"dependencies\":{\"is-url\":\"^1.2.4\",\"node-fetch\":\"^2.6.1\",\"regenerator-runtime\":\"^0.13.7\",\"resolve-url\":\"^0.2.1\"},\"devDependencies\":{\"@babel/core\":\"^7.12.3\",\"@babel/preset-env\":\"^7.12.1\",\"@ffmpeg/core\":\"^0.10.0\",\"@types/emscripten\":\"^1.39.4\",\"babel-loader\":\"^8.1.0\",\"chai\":\"^4.2.0\",\"cors\":\"^2.8.5\",\"eslint\":\"^7.12.1\",\"eslint-config-airbnb-base\":\"^14.1.0\",\"eslint-plugin-import\":\"^2.22.1\",\"express\":\"^4.17.1\",\"mocha\":\"^8.2.1\",\"mocha-headless-chrome\":\"^2.0.3\",\"npm-run-all\":\"^4.1.5\",\"wait-on\":\"^5.3.0\",\"webpack\":\"^5.3.2\",\"webpack-cli\":\"^4.1.0\",\"webpack-dev-middleware\":\"^4.0.0\"}}");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const resolveURL = __webpack_require__(/*! resolve-url */ "./node_modules/resolve-url/resolve-url.js");
const { devDependencies } = __webpack_require__(/*! ../../package.json */ "./node_modules/@ffmpeg/ffmpeg/package.json");

/*
 * Default options for browser environment
 */
module.exports = {
  corePath:  true
    ? resolveURL('/node_modules/@ffmpeg/core/dist/ffmpeg-core.js')
    : undefined,
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const resolveURL = __webpack_require__(/*! resolve-url */ "./node_modules/resolve-url/resolve-url.js");

const readFromBlobOrFile = (blob) => (
  new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.onload = () => {
      resolve(fileReader.result);
    };
    fileReader.onerror = ({ target: { error: { code } } }) => {
      reject(Error(`File could not be read! Code=${code}`));
    };
    fileReader.readAsArrayBuffer(blob);
  })
);

module.exports = async (_data) => {
  let data = _data;
  if (typeof _data === 'undefined') {
    return new Uint8Array();
  }

  if (typeof _data === 'string') {
    /* From base64 format */
    if (/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(_data)) {
      data = atob(_data.split(',')[1])
        .split('')
        .map((c) => c.charCodeAt(0));
    /* From remote server/URL */
    } else {
      const res = await fetch(resolveURL(_data));
      data = await res.arrayBuffer();
    }
  /* From Blob or File */
  } else if (_data instanceof File || _data instanceof Blob) {
    data = await readFromBlobOrFile(_data);
  }

  return new Uint8Array(data);
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-undef */
const resolveURL = __webpack_require__(/*! resolve-url */ "./node_modules/resolve-url/resolve-url.js");
const { log } = __webpack_require__(/*! ../utils/log */ "./node_modules/@ffmpeg/ffmpeg/src/utils/log.js");

/*
 * Fetch data from remote URL and convert to blob URL
 * to avoid CORS issue
 */
const toBlobURL = async (url, mimeType) => {
  log('info', `fetch ${url}`);
  const buf = await (await fetch(url)).arrayBuffer();
  log('info', `${url} file size = ${buf.byteLength} bytes`);
  const blob = new Blob([buf], { type: mimeType });
  const blobURL = URL.createObjectURL(blob);
  log('info', `${url} blob URL = ${blobURL}`);
  return blobURL;
};

module.exports = async ({ corePath: _corePath }) => {
  if (typeof _corePath !== 'string') {
    throw Error('corePath should be a string!');
  }
  const coreRemotePath = resolveURL(_corePath);
  const corePath = await toBlobURL(
    coreRemotePath,
    'application/javascript',
  );
  const wasmPath = await toBlobURL(
    coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),
    'application/wasm',
  );
  const workerPath = await toBlobURL(
    coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),
    'application/javascript',
  );
  if (typeof createFFmpegCore === 'undefined') {
    return new Promise((resolve) => {
      const script = document.createElement('script');
      const eventHandler = () => {
        script.removeEventListener('load', eventHandler);
        log('info', 'ffmpeg-core.js script loaded');
        resolve({
          createFFmpegCore,
          corePath,
          wasmPath,
          workerPath,
        });
      };
      script.src = corePath;
      script.type = 'text/javascript';
      script.addEventListener('load', eventHandler);
      document.getElementsByTagName('head')[0].appendChild(script);
    });
  }
  log('info', 'ffmpeg-core.js script is loaded already');
  return Promise.resolve({
    createFFmpegCore,
    corePath,
    wasmPath,
    workerPath,
  });
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const defaultOptions = __webpack_require__(/*! ./defaultOptions */ "./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js");
const getCreateFFmpegCore = __webpack_require__(/*! ./getCreateFFmpegCore */ "./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js");
const fetchFile = __webpack_require__(/*! ./fetchFile */ "./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js");

module.exports = {
  defaultOptions,
  getCreateFFmpegCore,
  fetchFile,
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/config.js":
/*!***************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/config.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  defaultArgs: [
    /* args[0] is always the binary path */
    './ffmpeg',
    /* Disable interaction mode */
    '-nostdin',
    /* Force to override output file */
    '-y',
  ],
  baseOptions: {
    /* Flag to turn on/off log messages in console */
    log: false,
    /*
     * Custom logger to get ffmpeg.wasm output messages.
     * a sample logger looks like this:
     *
     * ```
     * logger = ({ type, message }) => {
     *   console.log(type, message);
     * }
     * ```
     *
     * type can be one of following:
     *
     * info: internal workflow debug messages
     * fferr: ffmpeg native stderr output
     * ffout: ffmpeg native stdout output
     */
    logger: () => {},
    /*
     * Progress handler to get current progress of ffmpeg command.
     * a sample progress handler looks like this:
     *
     * ```
     * progress = ({ ratio }) => {
     *   console.log(ratio);
     * }
     * ```
     *
     * ratio is a float number between 0 to 1.
     */
    progress: () => {},
    /*
     * Path to find/download ffmpeg.wasm-core,
     * this value should be overwriten by `defaultOptions` in
     * each environment.
     */
    corePath: '',
  },
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { defaultArgs, baseOptions } = __webpack_require__(/*! ./config */ "./node_modules/@ffmpeg/ffmpeg/src/config.js");
const { setLogging, setCustomLogger, log } = __webpack_require__(/*! ./utils/log */ "./node_modules/@ffmpeg/ffmpeg/src/utils/log.js");
const parseProgress = __webpack_require__(/*! ./utils/parseProgress */ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js");
const parseArgs = __webpack_require__(/*! ./utils/parseArgs */ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js");
const { defaultOptions, getCreateFFmpegCore } = __webpack_require__(/*! ./node */ "./node_modules/@ffmpeg/ffmpeg/src/browser/index.js");
const { version } = __webpack_require__(/*! ../package.json */ "./node_modules/@ffmpeg/ffmpeg/package.json");

const NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');

module.exports = (_options = {}) => {
  const {
    log: logging,
    logger,
    progress: optProgress,
    ...options
  } = {
    ...baseOptions,
    ...defaultOptions,
    ..._options,
  };
  let Core = null;
  let ffmpeg = null;
  let runResolve = null;
  let running = false;
  let progress = optProgress;
  const detectCompletion = (message) => {
    if (message === 'FFMPEG_END' && runResolve !== null) {
      runResolve();
      runResolve = null;
      running = false;
    }
  };
  const parseMessage = ({ type, message }) => {
    log(type, message);
    parseProgress(message, progress);
    detectCompletion(message);
  };

  /*
   * Load ffmpeg.wasm-core script.
   * In browser environment, the ffmpeg.wasm-core script is fetch from
   * CDN and can be assign to a local path by assigning `corePath`.
   * In node environment, we use dynamic require and the default `corePath`
   * is `$ffmpeg/core`.
   *
   * Typically the load() func might take few seconds to minutes to complete,
   * better to do it as early as possible.
   *
   */
  const load = async () => {
    log('info', 'load ffmpeg-core');
    if (Core === null) {
      log('info', 'loading ffmpeg-core');
      /*
       * In node environment, all paths are undefined as there
       * is no need to set them.
       */
      const {
        createFFmpegCore,
        corePath,
        workerPath,
        wasmPath,
      } = await getCreateFFmpegCore(options);
      Core = await createFFmpegCore({
        /*
         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue
         * as there is no document.currentScript in the context of content_scripts
         */
        mainScriptUrlOrBlob: corePath,
        printErr: (message) => parseMessage({ type: 'fferr', message }),
        print: (message) => parseMessage({ type: 'ffout', message }),
        /*
         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).
         * It is critical for browser environment and we override both wasm and worker paths
         * as we are using blob URL instead of original URL to avoid cross origin issues.
         */
        locateFile: (path, prefix) => {
          if (typeof window !== 'undefined') {
            if (typeof wasmPath !== 'undefined'
              && path.endsWith('ffmpeg-core.wasm')) {
              return wasmPath;
            }
            if (typeof workerPath !== 'undefined'
              && path.endsWith('ffmpeg-core.worker.js')) {
              return workerPath;
            }
          }
          return prefix + path;
        },
      });
      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);
      log('info', 'ffmpeg-core loaded');
    } else {
      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');
    }
  };

  /*
   * Determine whether the Core is loaded.
   */
  const isLoaded = () => Core !== null;

  /*
   * Run ffmpeg command.
   * This is the major function in ffmpeg.wasm, you can just imagine it
   * as ffmpeg native cli and what you need to pass is the same.
   *
   * For example, you can convert native command below:
   *
   * ```
   * $ ffmpeg -i video.avi -c:v libx264 video.mp4
   * ```
   *
   * To
   *
   * ```
   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');
   * ```
   *
   */
  const run = (..._args) => {
    log('info', `run ffmpeg command: ${_args.join(' ')}`);
    if (Core === null) {
      throw NO_LOAD;
    } else if (running) {
      throw Error('ffmpeg.wasm can only run one command at a time');
    } else {
      running = true;
      return new Promise((resolve) => {
        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);
        runResolve = resolve;
        ffmpeg(...parseArgs(Core, args));
      });
    }
  };

  /*
   * Run FS operations.
   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS
   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS
   * methods provided by Emscripten.
   *
   * Common methods to use are:
   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes
   * data to MEMFS. You need to use Uint8Array for binary data.
   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.
   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.
   *
   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html
   *
   */
  const FS = (method, ...args) => {
    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);
    if (Core === null) {
      throw NO_LOAD;
    } else {
      let ret = null;
      try {
        ret = Core.FS[method](...args);
      } catch (e) {
        if (method === 'readdir') {
          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);
        } else if (method === 'readFile') {
          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);
        } else {
          throw Error('Oops, something went wrong in FS operation.');
        }
      }
      return ret;
    }
  };

  /**
   * forcibly terminate the ffmpeg program.
   */
  const exit = () => {
    if (Core === null) {
      throw NO_LOAD;
    } else {
      running = false;
      Core.exit(1);
      Core = null;
      ffmpeg = null;
      runResolve = null;
    }
  };

  const setProgress = (_progress) => {
    progress = _progress;
  };

  const setLogger = (_logger) => {
    setCustomLogger(_logger);
  };

  setLogging(logging);
  setCustomLogger(logger);

  log('info', `use ffmpeg.wasm v${version}`);

  return {
    setProgress,
    setLogger,
    setLogging,
    load,
    isLoaded,
    run,
    exit,
    FS,
  };
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
const createFFmpeg = __webpack_require__(/*! ./createFFmpeg */ "./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js");
const { fetchFile } = __webpack_require__(/*! ./node */ "./node_modules/@ffmpeg/ffmpeg/src/browser/index.js");

module.exports = {
  /*
   * Create ffmpeg instance.
   * Each ffmpeg instance owns an isolated MEMFS and works
   * independently.
   *
   * For example:
   *
   * ```
   * const ffmpeg = createFFmpeg({
   *  log: true,
   *  logger: () => {},
   *  progress: () => {},
   *  corePath: '',
   * })
   * ```
   *
   * For the usage of these four arguments, check config.js
   *
   */
  createFFmpeg,
  /*
   * Helper function for fetching files from various resource.
   * Sometimes the video/audio file you want to process may located
   * in a remote URL and somewhere in your local file system.
   *
   * This helper function helps you to fetch to file and return an
   * Uint8Array variable for ffmpeg.wasm to consume.
   *
   */
  fetchFile,
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/log.js":
/*!******************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/log.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

let logging = false;
let customLogger = () => {};

const setLogging = (_logging) => {
  logging = _logging;
};

const setCustomLogger = (logger) => {
  customLogger = logger;
};

const log = (type, message) => {
  customLogger({ type, message });
  if (logging) {
    console.log(`[${type}] ${message}`);
  }
};

module.exports = {
  logging,
  setLogging,
  setCustomLogger,
  log,
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js":
/*!************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = (Core, args) => {
  const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);
  args.forEach((s, idx) => {
    const buf = Core._malloc(s.length + 1);
    Core.writeAsciiToMemory(s, buf);
    Core.setValue(argsPtr + (Uint32Array.BYTES_PER_ELEMENT * idx), buf, 'i32');
  });
  return [args.length, argsPtr];
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

let duration = 0;
let ratio = 0;

const ts2sec = (ts) => {
  const [h, m, s] = ts.split(':');
  return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);
};

module.exports = (message, progress) => {
  if (typeof message === 'string') {
    if (message.startsWith('  Duration')) {
      const ts = message.split(', ')[0].split(': ')[1];
      const d = ts2sec(ts);
      progress({ duration: d, ratio });
      if (duration === 0 || duration > d) {
        duration = d;
      }
    } else if (message.startsWith('frame') || message.startsWith('size')) {
      const ts = message.split('time=')[1].split(' ')[0];
      const t = ts2sec(ts);
      ratio = t / duration;
      progress({ ratio, time: t });
    } else if (message.startsWith('video:')) {
      progress({ ratio: 1 });
      duration = 0;
    }
  }
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jbinary/dist/browser/jbinary.js":
/*!******************************************************!*\
  !*** ./node_modules/jbinary/dist/browser/jbinary.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e){var i=this; true?module.exports=e(i,__webpack_require__(/*! jdataview */ "./node_modules/jdataview/dist/node/jdataview.js")):undefined}(function(h,i){"use strict";var o,u,n=h.document;"atob"in h&&"btoa"in h||(o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",u=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1],h.btoa||(h.btoa=function(t){for(var e,i,n,r=t.length,a=0,s="";a<r;){if(e=255&t.charCodeAt(a++),a==r){s+=o.charAt(e>>2),s+=o.charAt((3&e)<<4),s+="==";break}if(i=t.charCodeAt(a++),a==r){s+=o.charAt(e>>2),s+=o.charAt((3&e)<<4|(240&i)>>4),s+=o.charAt((15&i)<<2),s+="=";break}n=t.charCodeAt(a++),s+=o.charAt(e>>2),s+=o.charAt((3&e)<<4|(240&i)>>4),s+=o.charAt((15&i)<<2|(192&n)>>6),s+=o.charAt(63&n)}return s}),h.atob||(h.atob=function(t){for(var e,i,n,r,a=t.length,s=0,o="";s<a;){for(;e=u[255&t.charCodeAt(s++)],s<a&&-1==e;);if(-1==e)break;for(;i=u[255&t.charCodeAt(s++)],s<a&&-1==i;);if(-1==i)break;o+=String.fromCharCode(e<<2|(48&i)>>4);do{if(61==(n=255&t.charCodeAt(s++)))return o}while(n=u[n],s<a&&-1==n);if(-1==n)break;o+=String.fromCharCode((15&i)<<4|(60&n)>>2);do{if(61==(r=255&t.charCodeAt(s++)))return o}while(r=u[r],s<a&&-1==r);if(-1==r)break;o+=String.fromCharCode((3&n)<<6|r)}return o}));var c=h.Promise||function(t){this.then=t};function f(t,e){return e&&t instanceof e}function r(t){for(var e=1,i=arguments.length;e<i;++e){var n,r=arguments[e];for(n in r)void 0!==r[n]&&(t[n]=r[n])}return t}function l(t){return arguments[0]=e(t),r.apply(null,arguments)}function a(t,e,i){return f(i,Function)?i.call(t,e.contexts[0]):i}function t(s){return function(){var t=arguments,e=t.length-1,r=s.length-1,i=t[e];if(t.length=1+r,!f(i,Function)){var a=this;return new c(function(i,n){t[r]=function(t,e){return t?n(t):i(e)},s.apply(a,t)})}t[e]=void 0,t[r]=i,s.apply(this,t)}}function s(t,e){return f(t,s)?t.as(e):(f(t,i)||(t=new i(t,void 0,void 0,e?e["jBinary.littleEndian"]:void 0)),f(this,s)?(this.view=t,this.view.seek(0),this.contexts=[],this.as(e,!0)):new s(t,e))}var e=(e=Object.create)||function(t){function e(){}return e.prototype=t,new e},p=s.prototype,y=p.typeSet={};p.toValue=function(t){return a(this,this,t)},p._named=function(t,e,i){return t.displayName=e+" @ "+(void 0!==i?i:this.view.tell()),t};var d=Object.defineProperty;if(1,d)try{d({},"x",{})}catch(t){d=void 0}else d=function(t,e,i,n){n&&(t[e]=i.value)};var v="jBinary.Cache",b=0;function g(t){return l(g.prototype,t)}function w(i){return l(w.prototype,i,{createProperty:function(t){var e=(i.createProperty||w.prototype.createProperty).apply(this,arguments);return e.getBaseType&&(e.baseType=e.binary.getType(e.getBaseType(e.binary.contexts[0]))),e}})}p._getCached=function(t,e,i){if(t.hasOwnProperty(this.cacheKey))return t[this.cacheKey];e=e.call(this,t);return d(t,this.cacheKey,{value:e},i),e},p.getContext=function(e){switch(typeof e){case"undefined":e=0;case"number":return this.contexts[e];case"string":return this.getContext(function(t){return e in t});case"function":for(var t=0,i=this.contexts.length;t<i;t++){var n=this.contexts[t];if(e.call(this,n))return n}}},p.inContext=function(t,e){this.contexts.unshift(t);e=e.call(this);return this.contexts.shift(),e},g.prototype={inherit:function(n,a){var r,s=this;function t(t,e){var i=s[t];i&&(r=r||l(s),e.call(r,i),r[t]=null)}return t("params",function(t){for(var e=0,i=t.length;e<i;e++)this[t[e]]=n[e]}),t("setParams",function(t){t.apply(this,n)}),t("typeParams",function(t){for(var e=0,i=t.length;e<i;e++){var n=t[e],r=this[n];r&&(this[n]=a(r))}}),t("resolve",function(t){t.call(this,a)}),r||s},createProperty:function(t){return l(this,{binary:t,view:t.view})},toValue:function(t,e){return!1!==e&&"string"==typeof t?this.binary.getContext(t)[t]:a(this,this.binary,t)}},w.prototype=l((s.Type=g).prototype,{setParams:function(){this.baseType&&(this.typeParams=["baseType"].concat(this.typeParams||[]))},baseRead:function(){return this.binary.read(this.baseType)},baseWrite:function(t){return this.binary.write(this.baseType,t)}}),r(w.prototype,{read:w.prototype.baseRead,write:w.prototype.baseWrite}),s.Template=w,p.as=function(t,e){e=e?this:l(this);return e.typeSet=(t=t||y)===y||y.isPrototypeOf(t)?t:l(y,t),e.cacheKey=v,e.cacheKey=e._getCached(t,function(){return v+"."+ ++b},!0),e},p.seek=function(t,e){if(t=this.toValue(t),void 0===e)return this.view.seek(t);var i=this.view.tell();this.view.seek(t);e=e.call(this);return this.view.seek(i),e},p.tell=function(){return this.view.tell()},p.skip=function(t,e){return this.seek(this.tell()+this.toValue(t),e)},p.slice=function(t,e,i){return new s(this.view.slice(t,e,i),this.typeSet)},p._getType=function(t,e){switch(typeof t){case"string":if(!(t in this.typeSet))throw new ReferenceError("Unknown type: "+t);return this._getType(this.typeSet[t],e);case"number":return this._getType(y.bitfield,[t]);case"object":if(f(t,g)){var i=this;return t.inherit(e||[],function(t){return i.getType(t)})}return f(t,Array)?this._getCached(t,function(t){return this.getType(t[0],t.slice(1))},!0):this._getCached(t,function(t){return this.getType(y.object,[t])},!1)}},p.getType=function(t,e){e=this._getType(t,e);return e&&!f(t,g)&&(e.name="object"==typeof t?f(t,Array)?t[0]+"("+t.slice(1).join(", ")+")":"object":String(t)),e},p._action=function(t,e,i){if(void 0!==t){t=this.getType(t);var n=this._named(function(){return i.call(this,t.createProperty(this),this.contexts[0])},"["+t.name+"]",e);return void 0!==e?this.seek(e,n):n.call(this)}},p.read=function(t,e){return this._action(t,e,function(t,e){return t.read(e)})},p.readAll=function(){return this.read("jBinary.all",0)},p.write=function(t,n,e){return this._action(t,e,function(t,e){var i=this.tell();return t.write(n,e),this.tell()-i})},p.writeAll=function(t){return this.write("jBinary.all",t,0)},function(t,e){for(var i=0,n=e.length;i<n;i++){var r=e[i];y[r.toLowerCase()]=l(t,{dataType:r})}}(g({params:["littleEndian"],read:function(){return this.view["get"+this.dataType](void 0,this.littleEndian)},write:function(t){this.view["write"+this.dataType](t,this.littleEndian)}}),["Uint8","Uint16","Uint32","Uint64","Int8","Int16","Int32","Int64","Float32","Float64","Char"]),r(y,{byte:y.uint8,float:y.float32,double:y.float64}),y.array=w({params:["baseType","length"],read:function(){var t=this.toValue(this.length);if(this.baseType===y.uint8)return this.view.getBytes(t,void 0,!0,!0);if(void 0!==t)for(var e=new Array(t),i=0;i<t;i++)e[i]=this.baseRead();else{var n=this.view.byteLength;for(e=[];this.binary.tell()<n;)e.push(this.baseRead())}return e},write:function(t){if(this.baseType===y.uint8)return this.view.writeBytes(t);for(var e=0,i=t.length;e<i;e++)this.baseWrite(t[e])}}),y.binary=w({params:["length","typeSet"],read:function(){var t=this.binary.tell(),e=this.binary.skip(this.toValue(this.length));return new s(this.view.slice(t,e),this.typeSet)},write:function(t){this.binary.write("blob",t.read("blob",0))}}),y.bitfield=g({params:["bitSize"],read:function(){return this.view.getUnsigned(this.bitSize)},write:function(t){this.view.writeUnsigned(t,this.bitSize)}}),y.blob=g({params:["length"],read:function(){return this.view.getBytes(this.toValue(this.length))},write:function(t){this.view.writeBytes(t,!0)}}),y.const=w({params:["baseType","value","strict"],read:function(){var t=this.baseRead();if(this.strict&&t!==this.value){if(f(this.strict,Function))return this.strict(t);throw new TypeError("Unexpected value ("+t+" !== "+this.value+").")}return t},write:function(t){this.baseWrite(this.strict||void 0===t?this.value:t)}}),y.enum=w({params:["baseType","matches"],setParams:function(t,e){for(var i in this.backMatches={},e)this.backMatches[e[i]]=i},read:function(){var t=this.baseRead();return t in this.matches?this.matches[t]:t},write:function(t){this.baseWrite(t in this.backMatches?this.backMatches[t]:t)}}),y.extend=g({setParams:function(){this.parts=arguments},resolve:function(t){for(var e=this.parts,i=e.length,n=new Array(i),r=0;r<i;r++)n[r]=t(e[r]);this.parts=n},read:function(){var i=this.parts,n=this.binary.read(i[0]);return this.binary.inContext(n,function(){for(var t=1,e=i.length;t<e;t++)r(n,this.read(i[t]))}),n},write:function(i){var n=this.parts;this.binary.inContext(i,function(){for(var t=0,e=n.length;t<e;t++)this.write(n[t],i)})}}),y.if=w({params:["condition","trueType","falseType"],typeParams:["trueType","falseType"],getBaseType:function(t){return this.toValue(this.condition)?this.trueType:this.falseType}}),y.if_not=y.ifNot=w({setParams:function(t,e,i){this.baseType=["if",t,i,e]}}),y.lazy=w({marker:"jBinary.Lazy",params:["innerType","length"],getBaseType:function(){return["binary",this.length,this.binary.typeSet]},read:function(){var e=function(t){return 0===arguments.length?"value"in e?e.value:e.value=e.binary.read(e.innerType):r(e,{wasChanged:!0,value:t}).value};return e[this.marker]=!0,r(e,{binary:r(this.baseRead(),{contexts:this.binary.contexts.slice()}),innerType:this.innerType})},write:function(t){t.wasChanged||!t[this.marker]?this.binary.write(this.innerType,t()):this.baseWrite(t.binary)}}),y.object=g({params:["structure","proto"],resolve:function(t){var e,i={};for(e in this.structure)i[e]=f(this.structure[e],Function)?this.structure[e]:t(this.structure[e]);this.structure=i},read:function(){var i=this,n=this.structure,r=this.proto?l(this.proto):{};return this.binary.inContext(r,function(){for(var e in n)this._named(function(){var t=f(n[e],Function)?n[e].call(i,r):this.read(n[e]);void 0!==t&&(r[e]=t)},e).call(this)}),r},write:function(e){var i=this,n=this.structure;this.binary.inContext(e,function(){for(var t in n)this._named(function(){f(n[t],Function)?e[t]=n[t].call(i,e):this.write(n[t],e[t])},t).call(this)})}}),y.skip=g({params:["length"],read:function(){this.view.skip(this.toValue(this.length))},write:function(){this.read()}}),y.string=w({params:["length","encoding"],read:function(){return this.view.getString(this.toValue(this.length),void 0,this.encoding)},write:function(t){this.view.writeString(t,this.encoding)}}),y.string0=g({params:["length","encoding"],read:function(){var t=this.view;if(void 0!==(n=this.length))return t.getString(n,void 0,this.encoding).replace(/\0.*$/,"");for(var e=t.tell(),i=0,n=t.byteLength-e;i<n&&t.getUint8();)i++;e=t.getString(i,e,this.encoding);return i<n&&t.skip(1),e},write:function(t){var e=this.view,i=void 0===this.length?1:this.length-t.length;e.writeString(t,void 0,this.encoding),0<i&&(e.writeUint8(0),e.skip(i-1))}});s.loadData=t(function(t,e){var i;if(f(t,h.Blob))if("FileReader"in h)(a=new FileReader).onload=a.onerror=function(){e(this.error,this.result)},a.readAsArrayBuffer(t);else{var n,r,a=new FileReaderSync;try{r=a.readAsArrayBuffer(t)}catch(t){n=t}finally{e(n,r)}}else if(0,"string"!=typeof t)e(new TypeError("Unsupported source type."));else if(r=t.match(/^data:(.+?)(;base64)?,(.*)$/))try{var s=r[2],o=r[3];e(null,(s?atob:decodeURIComponent)(o))}catch(t){e(t)}else"XMLHttpRequest"in h?((o=new XMLHttpRequest).open("GET",t,!0),"responseType"in o?o.responseType="arraybuffer":"overrideMimeType"in o?o.overrideMimeType("text/plain; charset=x-user-defined"):o.setRequestHeader("Accept-Charset","x-user-defined"),"onload"in o||(o.onreadystatechange=function(){4===this.readyState&&this.onload()}),i=function(t){e(new Error(t))},o.onload=function(){if(0!==this.status&&200!==this.status)return i("HTTP Error #"+this.status+": "+this.statusText);"response"in this||(this.response=new VBArray(this.responseBody).toArray()),e(null,this.response)},o.onerror=function(){i("Network error.")},o.send(null)):e(new TypeError("Unsupported source type."))}),(s.load=t(function(t,e,i){var n=s.loadData(t);s.load.getTypeSet(t,e,function(e){n.then(function(t){i(null,new s(t,e))},i)})})).getTypeSet=function(t,e,i){i(e)},p._toURI="URL"in h&&"createObjectURL"in URL?function(t){var e=this.seek(0,function(){return this.view.getBytes()});return URL.createObjectURL(new Blob([e],{type:t}))}:function(t){var e=this.seek(0,function(){return this.view.getString(void 0,void 0,"binary")});return"data:"+t+";base64,"+btoa(e)},p._mimeType=function(t){return t||this.typeSet["jBinary.mimeType"]||"application/octet-stream"};var m;p.toURI=function(t){return this._toURI(this._mimeType(t))};return n&&((m=s.downloader=n.createElement("a")).style.display="none"),p.saveAs=t(function(t,e,i){"string"==typeof t?("msSaveBlob"in navigator?navigator.msSaveBlob(new Blob([this.read("blob",0)],{type:this._mimeType(e)}),t):n?(m.parentNode||n.body.appendChild(m),m.href=this.toURI(e),m.download=t,m.click(),m.href=m.download=""):i(new TypeError("Saving from Web Worker is not supported.")),i()):i(new TypeError("Unsupported storage type."))}),s});
//# sourceMappingURL=jbinary.js.map

/***/ }),

/***/ "./node_modules/jdataview/dist/node/jdataview.js":
/*!*******************************************************!*\
  !*** ./node_modules/jdataview/dist/node/jdataview.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {!function(factory) {
    var global = this;
    module.exports = factory(global);
}(function(global) {
    "use strict";
    function is(obj, Ctor) {
        return "object" != typeof obj || null === obj ? !1 : obj.constructor === Ctor || Object.prototype.toString.call(obj) === "[object " + Ctor.name + "]";
    }
    function arrayFrom(arrayLike, forceCopy) {
        return !forceCopy && is(arrayLike, Array) ? arrayLike : Array.prototype.slice.call(arrayLike);
    }
    function defined(value, defaultValue) {
        return void 0 !== value ? value : defaultValue;
    }
    function jDataView(buffer, byteOffset, byteLength, littleEndian) {
        if (jDataView.is(buffer)) {
            var result = buffer.slice(byteOffset, byteOffset + byteLength);
            return result._littleEndian = defined(littleEndian, result._littleEndian), result;
        }
        if (!jDataView.is(this)) return new jDataView(buffer, byteOffset, byteLength, littleEndian);
        if (this.buffer = buffer = jDataView.wrapBuffer(buffer), this._isArrayBuffer = compatibility.ArrayBuffer && is(buffer, ArrayBuffer), 
        this._isPixelData = !1, this._isDataView = compatibility.DataView && this._isArrayBuffer, 
        this._isNodeBuffer =  true && compatibility.NodeBuffer && is(buffer, Buffer), !this._isNodeBuffer && !this._isArrayBuffer && !is(buffer, Array)) throw new TypeError("jDataView buffer has an incompatible type");
        this._littleEndian = !!littleEndian;
        var bufferLength = "byteLength" in buffer ? buffer.byteLength : buffer.length;
        this.byteOffset = byteOffset = defined(byteOffset, 0), this.byteLength = byteLength = defined(byteLength, bufferLength - byteOffset), 
        this._offset = this._bitOffset = 0, this._isDataView ? this._view = new DataView(buffer, byteOffset, byteLength) : this._checkBounds(byteOffset, byteLength, bufferLength), 
        this._engineAction = this._isDataView ? this._dataViewAction : this._isNodeBuffer ? this._nodeBufferAction : this._isArrayBuffer ? this._arrayBufferAction : this._arrayAction;
    }
    function getCharCodes(string) {
        if (compatibility.NodeBuffer) return new Buffer(string, "binary");
        for (var Type = compatibility.ArrayBuffer ? Uint8Array : Array, codes = new Type(string.length), i = 0, length = string.length; length > i; i++) codes[i] = 255 & string.charCodeAt(i);
        return codes;
    }
    function pow2(n) {
        return n >= 0 && 31 > n ? 1 << n : pow2[n] || (pow2[n] = Math.pow(2, n));
    }
    function Uint64(lo, hi) {
        this.lo = lo, this.hi = hi;
    }
    function Int64() {
        Uint64.apply(this, arguments);
    }
    var compatibility = {
        NodeBuffer:  true && "Buffer" in global,
        DataView: "DataView" in global,
        ArrayBuffer: "ArrayBuffer" in global,
        PixelData: !1
    }, TextEncoder = global.TextEncoder, TextDecoder = global.TextDecoder;
    compatibility.NodeBuffer && !function(buffer) {
        try {
            buffer.writeFloatLE(1/0, 0);
        } catch (e) {
            compatibility.NodeBuffer = !1;
        }
    }(new Buffer(4));
    var dataTypes = {
        Int8: 1,
        Int16: 2,
        Int32: 4,
        Uint8: 1,
        Uint16: 2,
        Uint32: 4,
        Float32: 4,
        Float64: 8
    };
    jDataView.wrapBuffer = function(buffer) {
        switch (typeof buffer) {
          case "number":
            if (compatibility.NodeBuffer) buffer = new Buffer(buffer), buffer.fill(0); else if (compatibility.ArrayBuffer) buffer = new Uint8Array(buffer).buffer; else {
                buffer = new Array(buffer);
                for (var i = 0; i < buffer.length; i++) buffer[i] = 0;
            }
            return buffer;

          case "string":
            buffer = getCharCodes(buffer);

          default:
            return "length" in buffer && !(compatibility.NodeBuffer && is(buffer, Buffer) || compatibility.ArrayBuffer && is(buffer, ArrayBuffer)) && (compatibility.NodeBuffer ? buffer = new Buffer(buffer) : compatibility.ArrayBuffer ? is(buffer, ArrayBuffer) || (buffer = new Uint8Array(buffer).buffer, 
            is(buffer, ArrayBuffer) || (buffer = new Uint8Array(arrayFrom(buffer, !0)).buffer)) : buffer = arrayFrom(buffer)), 
            buffer;
        }
    }, jDataView.is = function(view) {
        return view && view.jDataView;
    }, jDataView.from = function() {
        return new jDataView(arguments);
    }, jDataView.Uint64 = Uint64, Uint64.prototype = {
        valueOf: function() {
            return this.lo + pow2(32) * this.hi;
        },
        toString: function() {
            return Number.prototype.toString.apply(this.valueOf(), arguments);
        }
    }, Uint64.fromNumber = function(number) {
        var hi = Math.floor(number / pow2(32)), lo = number - hi * pow2(32);
        return new Uint64(lo, hi);
    }, jDataView.Int64 = Int64, Int64.prototype = "create" in Object ? Object.create(Uint64.prototype) : new Uint64(), 
    Int64.prototype.valueOf = function() {
        return this.hi < pow2(31) ? Uint64.prototype.valueOf.apply(this, arguments) : -(pow2(32) - this.lo + pow2(32) * (pow2(32) - 1 - this.hi));
    }, Int64.fromNumber = function(number) {
        var lo, hi;
        if (number >= 0) {
            var unsigned = Uint64.fromNumber(number);
            lo = unsigned.lo, hi = unsigned.hi;
        } else hi = Math.floor(number / pow2(32)), lo = number - hi * pow2(32), hi += pow2(32);
        return new Int64(lo, hi);
    };
    var proto = jDataView.prototype = {
        compatibility: compatibility,
        jDataView: !0,
        _checkBounds: function(byteOffset, byteLength, maxLength) {
            if ("number" != typeof byteOffset) throw new TypeError("Offset is not a number.");
            if ("number" != typeof byteLength) throw new TypeError("Size is not a number.");
            if (0 > byteLength) throw new RangeError("Length is negative.");
            if (0 > byteOffset || byteOffset + byteLength > defined(maxLength, this.byteLength)) throw new RangeError("Offsets are out of bounds.");
        },
        _action: function(type, isReadAction, byteOffset, littleEndian, value) {
            return this._engineAction(type, isReadAction, defined(byteOffset, this._offset), defined(littleEndian, this._littleEndian), value);
        },
        _dataViewAction: function(type, isReadAction, byteOffset, littleEndian, value) {
            return this._offset = byteOffset + dataTypes[type], isReadAction ? this._view["get" + type](byteOffset, littleEndian) : this._view["set" + type](byteOffset, value, littleEndian);
        },
        _arrayBufferAction: function(type, isReadAction, byteOffset, littleEndian, value) {
            var typedArray, size = dataTypes[type], TypedArray = global[type + "Array"];
            if (littleEndian = defined(littleEndian, this._littleEndian), 1 === size || (this.byteOffset + byteOffset) % size === 0 && littleEndian) return typedArray = new TypedArray(this.buffer, this.byteOffset + byteOffset, 1), 
            this._offset = byteOffset + size, isReadAction ? typedArray[0] : typedArray[0] = value;
            var bytes = new Uint8Array(isReadAction ? this.getBytes(size, byteOffset, littleEndian, !0) : size);
            return typedArray = new TypedArray(bytes.buffer, 0, 1), isReadAction ? typedArray[0] : (typedArray[0] = value, 
            void this._setBytes(byteOffset, bytes, littleEndian));
        },
        _arrayAction: function(type, isReadAction, byteOffset, littleEndian, value) {
            return isReadAction ? this["_get" + type](byteOffset, littleEndian) : this["_set" + type](byteOffset, value, littleEndian);
        },
        _getBytes: function(length, byteOffset, littleEndian) {
            littleEndian = defined(littleEndian, this._littleEndian), byteOffset = defined(byteOffset, this._offset), 
            length = defined(length, this.byteLength - byteOffset), this._checkBounds(byteOffset, length), 
            byteOffset += this.byteOffset, this._offset = byteOffset - this.byteOffset + length;
            var result = this._isArrayBuffer ? new Uint8Array(this.buffer, byteOffset, length) : (this.buffer.slice || Array.prototype.slice).call(this.buffer, byteOffset, byteOffset + length);
            return littleEndian || 1 >= length ? result : arrayFrom(result).reverse();
        },
        getBytes: function(length, byteOffset, littleEndian, toArray) {
            var result = this._getBytes(length, byteOffset, defined(littleEndian, !0));
            return toArray ? arrayFrom(result) : result;
        },
        _setBytes: function(byteOffset, bytes, littleEndian) {
            var length = bytes.length;
            if (0 !== length) {
                if (littleEndian = defined(littleEndian, this._littleEndian), byteOffset = defined(byteOffset, this._offset), 
                this._checkBounds(byteOffset, length), !littleEndian && length > 1 && (bytes = arrayFrom(bytes, !0).reverse()), 
                byteOffset += this.byteOffset, this._isArrayBuffer) new Uint8Array(this.buffer, byteOffset, length).set(bytes); else if (this._isNodeBuffer) new Buffer(bytes).copy(this.buffer, byteOffset); else for (var i = 0; length > i; i++) this.buffer[byteOffset + i] = bytes[i];
                this._offset = byteOffset - this.byteOffset + length;
            }
        },
        setBytes: function(byteOffset, bytes, littleEndian) {
            this._setBytes(byteOffset, bytes, defined(littleEndian, !0));
        },
        getString: function(byteLength, byteOffset, encoding) {
            if (this._isNodeBuffer) return byteOffset = defined(byteOffset, this._offset), byteLength = defined(byteLength, this.byteLength - byteOffset), 
            this._checkBounds(byteOffset, byteLength), this._offset = byteOffset + byteLength, 
            this.buffer.toString(encoding || "binary", this.byteOffset + byteOffset, this.byteOffset + this._offset);
            var bytes = this._getBytes(byteLength, byteOffset, !0);
            if (encoding = "utf8" === encoding ? "utf-8" : encoding || "binary", TextDecoder && "binary" !== encoding) return new TextDecoder(encoding).decode(this._isArrayBuffer ? bytes : new Uint8Array(bytes));
            var string = "";
            byteLength = bytes.length;
            for (var i = 0; byteLength > i; i++) string += String.fromCharCode(bytes[i]);
            return "utf-8" === encoding && (string = decodeURIComponent(escape(string))), string;
        },
        setString: function(byteOffset, subString, encoding) {
            if (this._isNodeBuffer) return byteOffset = defined(byteOffset, this._offset), this._checkBounds(byteOffset, subString.length), 
            void (this._offset = byteOffset + this.buffer.write(subString, this.byteOffset + byteOffset, encoding || "binary"));
            encoding = "utf8" === encoding ? "utf-8" : encoding || "binary";
            var bytes;
            TextEncoder && "binary" !== encoding ? bytes = new TextEncoder(encoding).encode(subString) : ("utf-8" === encoding && (subString = unescape(encodeURIComponent(subString))), 
            bytes = getCharCodes(subString)), this._setBytes(byteOffset, bytes, !0);
        },
        getChar: function(byteOffset) {
            return this.getString(1, byteOffset);
        },
        setChar: function(byteOffset, character) {
            this.setString(byteOffset, character);
        },
        tell: function() {
            return this._offset;
        },
        seek: function(byteOffset) {
            return this._checkBounds(byteOffset, 0), this._offset = byteOffset;
        },
        skip: function(byteLength) {
            return this.seek(this._offset + byteLength);
        },
        slice: function(start, end, forceCopy) {
            function normalizeOffset(offset, byteLength) {
                return 0 > offset ? offset + byteLength : offset;
            }
            return start = normalizeOffset(start, this.byteLength), end = normalizeOffset(defined(end, this.byteLength), this.byteLength), 
            forceCopy ? new jDataView(this.getBytes(end - start, start, !0, !0), void 0, void 0, this._littleEndian) : new jDataView(this.buffer, this.byteOffset + start, end - start, this._littleEndian);
        },
        alignBy: function(byteCount) {
            return this._bitOffset = 0, 1 !== defined(byteCount, 1) ? this.skip(byteCount - (this._offset % byteCount || byteCount)) : this._offset;
        },
        _getFloat64: function(byteOffset, littleEndian) {
            var b = this._getBytes(8, byteOffset, littleEndian), sign = 1 - 2 * (b[7] >> 7), exponent = ((b[7] << 1 & 255) << 3 | b[6] >> 4) - 1023, mantissa = (15 & b[6]) * pow2(48) + b[5] * pow2(40) + b[4] * pow2(32) + b[3] * pow2(24) + b[2] * pow2(16) + b[1] * pow2(8) + b[0];
            return 1024 === exponent ? 0 !== mantissa ? 0/0 : 1/0 * sign : -1023 === exponent ? sign * mantissa * pow2(-1074) : sign * (1 + mantissa * pow2(-52)) * pow2(exponent);
        },
        _getFloat32: function(byteOffset, littleEndian) {
            var b = this._getBytes(4, byteOffset, littleEndian), sign = 1 - 2 * (b[3] >> 7), exponent = (b[3] << 1 & 255 | b[2] >> 7) - 127, mantissa = (127 & b[2]) << 16 | b[1] << 8 | b[0];
            return 128 === exponent ? 0 !== mantissa ? 0/0 : 1/0 * sign : -127 === exponent ? sign * mantissa * pow2(-149) : sign * (1 + mantissa * pow2(-23)) * pow2(exponent);
        },
        _get64: function(Type, byteOffset, littleEndian) {
            littleEndian = defined(littleEndian, this._littleEndian), byteOffset = defined(byteOffset, this._offset);
            for (var parts = littleEndian ? [ 0, 4 ] : [ 4, 0 ], i = 0; 2 > i; i++) parts[i] = this.getUint32(byteOffset + parts[i], littleEndian);
            return this._offset = byteOffset + 8, new Type(parts[0], parts[1]);
        },
        getInt64: function(byteOffset, littleEndian) {
            return this._get64(Int64, byteOffset, littleEndian);
        },
        getUint64: function(byteOffset, littleEndian) {
            return this._get64(Uint64, byteOffset, littleEndian);
        },
        _getInt32: function(byteOffset, littleEndian) {
            var b = this._getBytes(4, byteOffset, littleEndian);
            return b[3] << 24 | b[2] << 16 | b[1] << 8 | b[0];
        },
        _getUint32: function(byteOffset, littleEndian) {
            return this._getInt32(byteOffset, littleEndian) >>> 0;
        },
        _getInt16: function(byteOffset, littleEndian) {
            return this._getUint16(byteOffset, littleEndian) << 16 >> 16;
        },
        _getUint16: function(byteOffset, littleEndian) {
            var b = this._getBytes(2, byteOffset, littleEndian);
            return b[1] << 8 | b[0];
        },
        _getInt8: function(byteOffset) {
            return this._getUint8(byteOffset) << 24 >> 24;
        },
        _getUint8: function(byteOffset) {
            return this._getBytes(1, byteOffset)[0];
        },
        _getBitRangeData: function(bitLength, byteOffset) {
            var startBit = (defined(byteOffset, this._offset) << 3) + this._bitOffset, endBit = startBit + bitLength, start = startBit >>> 3, end = endBit + 7 >>> 3, b = this._getBytes(end - start, start, !0), wideValue = 0;
            (this._bitOffset = 7 & endBit) && (this._bitOffset -= 8);
            for (var i = 0, length = b.length; length > i; i++) wideValue = wideValue << 8 | b[i];
            return {
                start: start,
                bytes: b,
                wideValue: wideValue
            };
        },
        getSigned: function(bitLength, byteOffset) {
            var shift = 32 - bitLength;
            return this.getUnsigned(bitLength, byteOffset) << shift >> shift;
        },
        getUnsigned: function(bitLength, byteOffset) {
            var value = this._getBitRangeData(bitLength, byteOffset).wideValue >>> -this._bitOffset;
            return 32 > bitLength ? value & ~(-1 << bitLength) : value;
        },
        _setBinaryFloat: function(byteOffset, value, mantSize, expSize, littleEndian) {
            var exponent, mantissa, signBit = 0 > value ? 1 : 0, eMax = ~(-1 << expSize - 1), eMin = 1 - eMax;
            0 > value && (value = -value), 0 === value ? (exponent = 0, mantissa = 0) : isNaN(value) ? (exponent = 2 * eMax + 1, 
            mantissa = 1) : 1/0 === value ? (exponent = 2 * eMax + 1, mantissa = 0) : (exponent = Math.floor(Math.log(value) / Math.LN2), 
            exponent >= eMin && eMax >= exponent ? (mantissa = Math.floor((value * pow2(-exponent) - 1) * pow2(mantSize)), 
            exponent += eMax) : (mantissa = Math.floor(value / pow2(eMin - mantSize)), exponent = 0));
            for (var b = []; mantSize >= 8; ) b.push(mantissa % 256), mantissa = Math.floor(mantissa / 256), 
            mantSize -= 8;
            for (exponent = exponent << mantSize | mantissa, expSize += mantSize; expSize >= 8; ) b.push(255 & exponent), 
            exponent >>>= 8, expSize -= 8;
            b.push(signBit << expSize | exponent), this._setBytes(byteOffset, b, littleEndian);
        },
        _setFloat32: function(byteOffset, value, littleEndian) {
            this._setBinaryFloat(byteOffset, value, 23, 8, littleEndian);
        },
        _setFloat64: function(byteOffset, value, littleEndian) {
            this._setBinaryFloat(byteOffset, value, 52, 11, littleEndian);
        },
        _set64: function(Type, byteOffset, value, littleEndian) {
            "object" != typeof value && (value = Type.fromNumber(value)), littleEndian = defined(littleEndian, this._littleEndian), 
            byteOffset = defined(byteOffset, this._offset);
            var parts = littleEndian ? {
                lo: 0,
                hi: 4
            } : {
                lo: 4,
                hi: 0
            };
            for (var partName in parts) this.setUint32(byteOffset + parts[partName], value[partName], littleEndian);
            this._offset = byteOffset + 8;
        },
        setInt64: function(byteOffset, value, littleEndian) {
            this._set64(Int64, byteOffset, value, littleEndian);
        },
        setUint64: function(byteOffset, value, littleEndian) {
            this._set64(Uint64, byteOffset, value, littleEndian);
        },
        _setUint32: function(byteOffset, value, littleEndian) {
            this._setBytes(byteOffset, [ 255 & value, value >>> 8 & 255, value >>> 16 & 255, value >>> 24 ], littleEndian);
        },
        _setUint16: function(byteOffset, value, littleEndian) {
            this._setBytes(byteOffset, [ 255 & value, value >>> 8 & 255 ], littleEndian);
        },
        _setUint8: function(byteOffset, value) {
            this._setBytes(byteOffset, [ 255 & value ]);
        },
        setUnsigned: function(byteOffset, value, bitLength) {
            var data = this._getBitRangeData(bitLength, byteOffset), wideValue = data.wideValue, b = data.bytes;
            wideValue &= ~(~(-1 << bitLength) << -this._bitOffset), wideValue |= (32 > bitLength ? value & ~(-1 << bitLength) : value) << -this._bitOffset;
            for (var i = b.length - 1; i >= 0; i--) b[i] = 255 & wideValue, wideValue >>>= 8;
            this._setBytes(data.start, b, !0);
        }
    }, nodeNaming = {
        Int8: "Int8",
        Int16: "Int16",
        Int32: "Int32",
        Uint8: "UInt8",
        Uint16: "UInt16",
        Uint32: "UInt32",
        Float32: "Float",
        Float64: "Double"
    };
    proto._nodeBufferAction = function(type, isReadAction, byteOffset, littleEndian, value) {
        this._offset = byteOffset + dataTypes[type];
        var nodeName = nodeNaming[type] + ("Int8" === type || "Uint8" === type ? "" : littleEndian ? "LE" : "BE");
        return byteOffset += this.byteOffset, isReadAction ? this.buffer["read" + nodeName](byteOffset) : this.buffer["write" + nodeName](value, byteOffset);
    };
    for (var type in dataTypes) !function(type) {
        proto["get" + type] = function(byteOffset, littleEndian) {
            return this._action(type, !0, byteOffset, littleEndian);
        }, proto["set" + type] = function(byteOffset, value, littleEndian) {
            this._action(type, !1, byteOffset, littleEndian, value);
        };
    }(type);
    proto._setInt32 = proto._setUint32, proto._setInt16 = proto._setUint16, proto._setInt8 = proto._setUint8, 
    proto.setSigned = proto.setUnsigned;
    for (var method in proto) "set" === method.slice(0, 3) && !function(type) {
        proto["write" + type] = function() {
            Array.prototype.unshift.call(arguments, void 0), this["set" + type].apply(this, arguments);
        };
    }(method.slice(3));
    return jDataView;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/adts.js":
/*!**********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/adts.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
	'use strict';

	return {
		ADTSPacket: {
			_start: function () { return this.binary.tell() },
			_syncWord: ['const', 12, 0xfff, true],
			version: ['enum', 1, ['mpeg-4', 'mpeg-2']],
			layer: ['const', 2, 0],
			isProtectionAbsent: 1,
			profileMinusOne: 2, // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Object_Types minus one
			samplingFreq: ['enum', 4, [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350]], // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Sampling_Frequencies
			_privateStream: 1,
			channelConfig: 3, // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Channel_Configurations
			_reserved: 4, // originality, home, copyrighted, copyright start bits
			frameLength: 13,
			bufferFullness: 11,
			aacFramesCountMinusOne: 2,
			data: ['blob', function (context) { return context.frameLength - (this.binary.tell() - context._start) }]
		}
	};
}));

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/h264.js":
/*!**********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/h264.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jBinary) {
	'use strict';

	return {
		ExpGolomb: jBinary.Type({
			params: ['isSigned'],
			read: function () {
				var count = 0;
				while (!this.binary.read(1)) count++;
				var value = (1 << count) | this.binary.read(count);
				return this.isSigned ? (value & 1 ? -(value >> 1) : value >> 1) : value - 1;
			},
			write: function (value) {
				if (this.isSigned) {
					value <<= 1;
					if (value <= 0) {
						value = -value | 1;
					}
				} else {
					value++;
				}
				var length = value.toString(2).length;
				this.binary.write(length - 1, 0);
				this.binary.write(length, value);
			}
		}),

		Optional: jBinary.Template({
		    params: ['baseType'],
			read: function () {
				if (this.binary.read(1)) return this.baseRead();
			},
			write: function (value) {
				this.binary.write(value != null ? 1 : 0);
				if (value != null) {
					this.baseWrite(value);
				}
			}
		}),

		ScalingList: jBinary.Template({
			setParams: function (size) {
				this.baseType = ['array', { /* TODO: implement scaling list */ }, size];
			}
		}),

		SPS: [
			'extend',
			{
				profile_idc: 'uint8',
				constraint_set_flags: ['array', 1, 8],
				level_idc: 'uint8',
				seq_parameter_set_id: 'ExpGolomb'
			},
			['if', function (context) { return [100, 110, 122, 244, 44, 83, 86, 118].indexOf(context.profile_idc) >= 0 }, {
				chroma_format: ['enum', 'ExpGolomb', ['MONO', 'YUV420', 'YUV422', 'YUV444']],
				separate_color_plane_flag: ['if', function (context) { return context.chroma_format === 'YUV444' }, 1],
				bit_depth_luma_minus8: 'ExpGolomb',
				bit_depth_chroma_minus8: 'ExpGolomb',
				qpprime_y_zero_transform_bypass_flag: 1,
				scaling_matrix: ['Optional', {
					scalingList4x4: ['array', ['ScalingList', 16], 6],
					scalingList8x8: ['array', ['ScalingList', 64], function () { return this.binary.getContext(1).chroma_format !== 'YUV444' ? 2 : 6 }]
				}]
			}],
			{
				log2_max_frame_num_minus4: 'ExpGolomb',
				pic_order_cnt_type: 'ExpGolomb',
				pic_order: ['if_not', 'pic_order_cnt_type', {log2_max_pic_order_cnt_lsb_minus4: 'ExpGolomb'}, [
					'if',
					function (context) { return context.pic_order_cnt_type === 1 },
					{
						delta_pic_order_always_zero_flag: 1,
						offset_for_non_ref_pic: ['ExpGolomb', true],
						offset_for_top_to_bottom_field: ['ExpGolomb', true],
						_num_ref_frames_in_pic_order_cnt_cycle: jBinary.Template({
							baseType: 'ExpGolomb',
							write: function (value, context) { this.baseWrite(context.offset_for_ref_frame.length) }
						}),
						offset_for_ref_frame: ['array', ['ExpGolomb', true], function (context) { return context._num_ref_frames_in_pic_order_cnt_cycle }]
					}
				]],
				max_num_ref_frames: 'ExpGolomb',
				gaps_in_frame_num_value_allowed_flag: 1,
				pic_width_in_mbs_minus_1: 'ExpGolomb',
				pic_height_in_map_units_minus_1: 'ExpGolomb',
				frame_mbs_only_flag: 1,
				mb_adaptive_frame_field_flag: ['if_not', 'frame_mbs_only_flag', 1],
				direct_8x8_inference_flag: 1,
				frame_cropping: ['Optional', {
					left: 'ExpGolomb',
					right: 'ExpGolomb',
					top: 'ExpGolomb',
					bottom: 'ExpGolomb'
				}]
				// TODO: add VUI parameters
			}
		],

		NALUnit: jBinary.Type({
			read: function () {
				var sync = this.binary.read(['blob', 3]); // [0, 0, 1] or [0, 0, 0, 1]
				if (sync[2] === 0) this.binary.skip(1);
				var end = this.binary.view.byteLength, pos = this.binary.tell();
				var bytes = this.binary.skip(0, function () { return this.view.getBytes() });
				for (var i = 1, length = bytes.length - 3; i < length; i++) {
					if (bytes[i] === 0 && bytes[i + 1] === 0 && (bytes[i + 2] === 1 || (bytes[i + 2] === 0 && bytes[i + 3] === 1))) {
						end = pos + i;
						break;
					}
				}
				var data = this.binary.read(['blob', end - pos]);
				// TODO: ideally there should be Annex.B conversion from [0, 0, 3, X=0..3] to [0, 0, X]
				return data;
			}
		})
	};
}));

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jdataview */ "./node_modules/jdataview/dist/node/jdataview.js"), __webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js"), __webpack_require__(/*! ./mp4 */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/mp4.js"), __webpack_require__(/*! ./h264 */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/h264.js"), __webpack_require__(/*! ./pes */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/pes.js"), __webpack_require__(/*! ./adts */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/adts.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jDataView, jBinary, MP4, H264, PES, ADTS) {
	'use strict';


	/**
	 * Copied from mux.js => https://github.com/videojs/mux.js/blob/957441d44307a47d801af3db5c51072ed241f8c2/lib/codecs/h264.js#L266
	 * Expunge any "Emulation Prevention" bytes from a "Raw Byte
	 * Sequence Payload"
	 * @param data {Uint8Array} the bytes of a RBSP from a NAL
	 * unit
	 * @return {Uint8Array} the RBSP without any Emulation
	 * Prevention Bytes
	 */
	var discardEmulationPreventionBytes = function(data) {
		var
		length = data.byteLength,
		emulationPreventionBytesPositions = [],
		i = 0,
		newLength, newData;

		// Find all `Emulation Prevention Bytes`
		while (i < length - 2) {
		if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
			emulationPreventionBytesPositions.push(i + 2);
			i += 2;
		} else {
			i++;
		}
		}

		// If no Emulation Prevention Bytes were found just return the original
		// array
		if (emulationPreventionBytesPositions.length === 0) {
		return data;
		}

		// Create a new array to hold the NAL unit data
		newLength = length - emulationPreventionBytesPositions.length;
		newData = new Uint8Array(newLength);
		var sourceIndex = 0;

		for (i = 0; i < newLength; sourceIndex++, i++) {
		if (sourceIndex === emulationPreventionBytesPositions[0]) {
			// Skip this byte
			sourceIndex++;
			// Remove this position index
			emulationPreventionBytesPositions.shift();
		}
		newData[i] = data[sourceIndex];
		}

		return newData;
	};


	return function (mpegts) {
		var packets = mpegts.read('File');
		
		// extracting and concatenating raw stream parts
		var stream = new jDataView(mpegts.view.byteLength);
		for (var i = 0, length = packets.length; i < length; i++) {
			var packet = packets[i], adaptation = packet.adaptationField, payload = packet.payload;
			if (payload && payload._rawStream) {
				stream.writeBytes(payload._rawStream);
			}
		}
		
		var pesStream = new jBinary(stream.slice(0, stream.tell()), PES),
			audioStream = new jBinary(stream.byteLength, ADTS),
			samples = [],
			audioSamples = [];

		stream = new jDataView(stream.byteLength);
		
		while (pesStream.tell() < pesStream.view.byteLength) {
			var packet = pesStream.read('PESPacket');

			if (packet.streamId === 0xC0) {
				// 0xC0 means we have got first audio stream
				audioStream.write('blob', packet.data);
			} else
			if (packet.streamId === 0xE0) {
				var nalStream = new jBinary(packet.data, H264),
					pts = packet.pts,
					dts = packet.dts,
					curSample = {offset: stream.tell(), pts: pts, dts: dts !== undefined ? dts : pts};
				
				samples.push(curSample);
				
				// collecting info from H.264 NAL units
				while (nalStream.tell() < nalStream.view.byteLength) {
					var nalUnit = nalStream.read('NALUnit');
					switch (nalUnit[0] & 0x1F) {
						case 7:
							if (!sps) {
								var sps = nalUnit;
								// remove Emulation Prevention Bytes to get correct width & height
								// See http://blog.51cto.com/danielllf/1758115
								var spsInfo = new jBinary(discardEmulationPreventionBytes(sps.subarray(1)), H264).read('SPS');
								var width = (spsInfo.pic_width_in_mbs_minus_1 + 1) * 16;
								var height = (2 - spsInfo.frame_mbs_only_flag) * (spsInfo.pic_height_in_map_units_minus_1 + 1) * 16;
								var cropping = spsInfo.frame_cropping;
								if (cropping) {
									width -= 2 * (cropping.left + cropping.right);
									height -= 2 * (cropping.top + cropping.bottom);
								}
							}
							break;

						case 8:
							if (!pps) {
								var pps = nalUnit;
							}
							break;

						case 5:
							curSample.isIDR = true;
						/* falls through */
						default:
							stream.writeUint32(nalUnit.length);
							stream.writeBytes(nalUnit);
					}
				}
			}
		}
		
		samples.push({offset: stream.tell()});

		var sizes = [],
			dtsDiffs = [],
			accessIndexes = [],
			pts_dts_Diffs = [],
			current = samples[0],
			frameRate = {sum: 0, count: 0},
			duration = 0;
		
		// calculating PTS/DTS differences and collecting keyframes
		
		for (var i = 0, length = samples.length - 1; i < length; i++) {
			var next = samples[i + 1];
			sizes.push(next.offset - current.offset);
			var dtsDiff = next.dts - current.dts;
			if (dtsDiff) {
				dtsDiffs.push({sample_count: 1, sample_delta: dtsDiff});
				duration += dtsDiff;
				frameRate.sum += dtsDiff;
				frameRate.count++;
			} else {
				dtsDiffs.length++;
			}
			if (current.isIDR) {
				accessIndexes.push(i + 1);
			}
			pts_dts_Diffs.push({
				first_chunk: pts_dts_Diffs.length + 1,
				sample_count: 1,
				sample_offset: current.dtsFix = current.pts - current.dts
			});
			current = next;
		}
		
		frameRate = Math.round(frameRate.sum / frameRate.count);
		
		for (var i = 0, length = dtsDiffs.length; i < length; i++) {
			if (dtsDiffs[i] === undefined) {
				dtsDiffs[i] = {first_chunk: i + 1, sample_count: 1, sample_delta: frameRate};
				duration += frameRate;
				//samples[i + 1].dts = samples[i].dts + frameRate;
			}
		}

		// checking if DTS differences are same everywhere to pack them into one item
		
		var dtsDiffsSame = true;
		
		for (var i = 1, length = dtsDiffs.length; i < length; i++) {
			if (dtsDiffs[i].sample_delta !== dtsDiffs[0].sample_delta) {
				dtsDiffsSame = false;
				break;
			}
		}
		
		if (dtsDiffsSame) {
			dtsDiffs = [{first_chunk: 1, sample_count: sizes.length, sample_delta: dtsDiffs[0].sample_delta}];
		}

		// building audio metadata

		var audioStart = stream.tell(),
			audioSize = audioStream.tell(),
			audioSizes = [],
			audioHeader,
			maxAudioSize = 0;
			
		audioStream.seek(0);
		
		while (audioStream.tell() < audioSize) {
			audioHeader = audioStream.read('ADTSPacket');
			audioSizes.push(audioHeader.data.length);
			if (audioHeader.data.length > maxAudioSize) {
				maxAudioSize = audioHeader.data.length;
			}
			stream.writeBytes(audioHeader.data);
		}

		// generating resulting MP4

		var mp4 = new jBinary(stream.byteLength, MP4);
		
		var trak = [{
			atoms: {
				tkhd: [{
					version: 0,
					flags: 15,
					track_ID: 1,
					duration: duration,
					layer: 0,
					alternate_group: 0,
					volume: 1,
					matrix: {
						a: 1, b: 0, x: 0,
						c: 0, d: 1, y: 0,
						u: 0, v: 0, w: 1
					},
					dimensions: {
						horz: width,
						vert: height
					}
				}],
				mdia: [{
					atoms: {
						mdhd: [{
							version: 0,
							flags: 0,
							timescale: 90000,
							duration: duration,
							lang: 'und'
						}],
						hdlr: [{
							version: 0,
							flags: 0,
							handler_type: 'vide',
							name: 'VideoHandler'
						}],
						minf: [{
							atoms: {
								vmhd: [{
									version: 0,
									flags: 1,
									graphicsmode: 0,
									opcolor: {r: 0, g: 0, b: 0}
								}],
								dinf: [{
									atoms: {
										dref: [{
											version: 0,
											flags: 0,
											entries: [{
												type: 'url ',
												version: 0,
												flags: 1,
												location: ''
											}]
										}]
									}
								}],
								stbl: [{
									atoms: {
										stsd: [{
											version: 0,
											flags: 0,
											entries: [{
												type: 'avc1',
												data_reference_index: 1,
												dimensions: {
													horz: width,
													vert: height
												},
												resolution: {
													horz: 72,
													vert: 72
												},
												frame_count: 1,
												compressorname: '',
												depth: 24,
												atoms: {
													avcC: [{
														version: 1,
														profileIndication: spsInfo.profile_idc,
														profileCompatibility: parseInt(spsInfo.constraint_set_flags.join(''), 2),
														levelIndication: spsInfo.level_idc,
														lengthSizeMinusOne: 3,
														seqParamSets: [sps],
														pictParamSets: [pps]
													}]
												}
											}]
										}],
										stts: [{
											version: 0,
											flags: 0,
											entries: dtsDiffs
										}],
										stss: [{
											version: 0,
											flags: 0,
											entries: accessIndexes
										}],
										ctts: [{
											version: 0,
											flags: 0,
											entries: pts_dts_Diffs
										}],
										stsc: [{
											version: 0,
											flags: 0,
											entries: [{
												first_chunk: 1,
												samples_per_chunk: sizes.length,
												sample_description_index: 1
											}]
										}],
										stsz: [{
											version: 0,
											flags: 0,
											sample_size: 0,
											sample_count: sizes.length,
											sample_sizes: sizes
										}],
										stco: [{
											version: 0,
											flags: 0,
											entries: [0x28]
										}]
									}
								}]
							}
						}]
					}
				}]
			}
		}];

		if (audioSize > 0) {
			trak.push({
				atoms: {
					tkhd: [{
						version: 0,
						flags: 15,
						track_ID: 2,
						duration: duration,
						layer: 0,
						alternate_group: 1,
						volume: 1,
						matrix: {
							a: 1, b: 0, x: 0,
							c: 0, d: 1, y: 0,
							u: 0, v: 0, w: 1
						},
						dimensions: {
							horz: 0,
							vert: 0
						}
					}],
					mdia: [{
						atoms: {
							mdhd: [{
								version: 0,
								flags: 0,
								timescale: 90000,
								duration: duration,
								lang: 'eng'
							}],
							hdlr: [{
								version: 0,
								flags: 0,
								handler_type: 'soun',
								name: 'SoundHandler'
							}],
							minf: [{
								atoms: {
									smhd: [{
										version: 0,
										flags: 0,
										balance: 0
									}],
									dinf: [{
										atoms: {
											dref: [{
												version: 0,
												flags: 0,
												entries: [{
													type: 'url ',
													version: 0,
													flags: 1,
													location: ''
												}]
											}]
										}
									}],
									stbl: [{
										atoms: {
											stsd: [{
												version: 0,
												flags: 0,
												entries: [{
													type: 'mp4a',
													data_reference_index: 1,
													channelcount: 2,
													samplesize: 16,
													samplerate: 22050,
													atoms: {
														esds: [{
															version: 0,
															flags: 0,
															sections: [
																{
																	descriptor_type: 3,
																	ext_type: 128,
																	length: 34,
																	es_id: 2,
																	stream_priority: 0
																},
																{
																	descriptor_type: 4,
																	ext_type: 128,
																	length: 20,
																	type: 'mpeg4_audio',
																	stream_type: 'audio',
																	upstream_flag: 0,
																	buffer_size: 0,
																	maxBitrate: Math.round(maxAudioSize / (duration / 90000 / audioSizes.length)),
																	avgBitrate: Math.round((stream.tell() - audioStart) / (duration / 90000))
																},
																{
																	descriptor_type: 5,
																	ext_type: 128,
																	length: 2,
																	audio_profile: audioHeader.profileMinusOne + 1,
																	sampling_freq: audioHeader.samplingFreq,
																	channelConfig: audioHeader.channelConfig
																},
																{
																	descriptor_type: 6,
																	ext_type: 128,
																	length: 1,
																	sl: 2
																}
															]
														}]
													}
												}]
											}],
											stts: [{
												version: 0,
												flags: 0,
												entries: [{
													sample_count: audioSizes.length,
													sample_delta: Math.round(duration / audioSizes.length)
												}]
											}],
											stsc: [{
												version: 0,
												flags: 0,
												entries: [{
													first_chunk: 1,
													samples_per_chunk: audioSizes.length,
													sample_description_index: 1
												}]
											}],
											stsz: [{
												version: 0,
												flags: 0,
												sample_size: 0,
												sample_count: audioSizes.length,
												sample_sizes: audioSizes
											}],
											stco: [{
												version: 0,
												flags: 0,
												entries: [0x28 + audioStart]
											}]
										}
									}]
								}
							}]
						}
					}]
				}
			});
		};
		
		var creationTime = new Date();

		mp4.write('File', {
			ftyp: [{
				major_brand: 'isom',
				minor_version: 512,
				compatible_brands: ['isom', 'iso2', 'avc1', 'mp41']
			}],
			mdat: [{
				_rawData: stream.getBytes(stream.tell(), 0)
			}],
			moov: [{
				atoms: {
					mvhd: [{
						version: 0,
						flags: 0,
						creation_time: creationTime,
						modification_time: creationTime,
						timescale: 90000,
						duration: duration,
						rate: 1,
						volume: 1,
						matrix: {
							a: 1, b: 0, x: 0,
							c: 0, d: 1, y: 0,
							u: 0, v: 0, w: 1
						},
						next_track_ID: 2
					}],
					trak: trak
				}
			}]
		});
		
		return mp4.slice(0, mp4.tell());
	};
}));

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/mp4.js":
/*!*********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/mp4.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jBinary) {
	'use strict';

	var timeBasis = new Date(1970, 0, 1) - new Date(1904, 0, 1);

	function atomFilter(type) {
		return function (atom) {
			return atom.type === type;
		};
	}

	return {
		ShortName: ['string0', 4],
		
		Rate: ['FixedPoint', 'int32', 16],

		Dimensions: jBinary.Template({
			setParams: function (itemType) {
				this.baseType = {
					horz: itemType,
					vert: itemType
				};
			}
		}),

		BoxHeader: {
			_begin: function () {
				return this.binary.tell();
			},
			_size: jBinary.Template({
				baseType: 'uint32',
				write: function (value, context) {
					var size = context.size;
					this.baseWrite(size ? (size < Math.pow(2, 32) ? size : 1) : 0);
				}
			}),
			type: 'ShortName',
			size: jBinary.Type({
				read: function (context) {
					var _size = context._size;
					switch (_size) {
						case 0: return this.binary.view.byteLength - this.binary.tell() + 8;
						case 1: return this.binary.read('uint64');
						default: return _size;
					}
				},
				write: function (value) {
					if (value >= Math.pow(2, 32)) {
						this.binary.write('uint64', value);
					}
				}
			}),
			_end: function (context) {
				return context._begin + context.size;
			}
		},

		FullBox: ['extend', 'BoxHeader', {
			version: 'uint8',
			flags: 24
		}],

		Box: jBinary.Type({
			read: function () {
				var header = this.binary.skip(0, function () {
					return this.read('BoxHeader');
				});
				var box = this.binary.read(header.type) || header;
				if (box === header) console.log(header.type);
				this.binary.seek(header._end);
				return box;
			},
			write: function (box) {
				this.binary.write(box.type, box);
				var size = this.binary.tell() - box._begin;
				this.binary.seek(box._begin, function () {
					this.write('uint32', size);
				});
			}
		}),

		Time: jBinary.Template({
			params: ['baseType'],
			read: function () {
				var intTime = this.baseRead();
				if (intTime) {
					return new Date(intTime + timeBasis);
				}
			},
			write: function (time) {
				this.baseWrite((time - timeBasis) >>> 0);
			}
		}),

		FixedPoint: jBinary.Template({
			params: ['baseType'],
			setParams: function (baseType, shift) {
				this.coef = 1 << shift;
			},
			read: function () {
				return this.baseRead() / this.coef;
			},
			write: function (value) {
				this.baseWrite(value * this.coef);
			}
		}),

		Atoms: jBinary.Type({
			params: ['end'],
			read: function () {
				var atoms = {}, end = this.toValue(this.end) || this.binary.getContext('_end')._end;
				while (this.binary.tell() < end) {
					var item = this.binary.read('Box');
					(atoms[item.type] || (atoms[item.type] = [])).push(item);
				}
				return atoms;
			},
			write: function (parent) {
				for (var type in parent) {
					var atoms = parent[type];
					for (var i = 0, length = atoms.length; i < length; i++) {
						atoms[i].type = type;
						this.binary.write('Box', atoms[i]);
					}
				}
			}
		}),

		ChildAtoms: {
			atoms: 'Atoms'
		},

		MultiBox: ['extend', 'BoxHeader', 'ChildAtoms'],

		TransformationMatrix: {
			a: ['FixedPoint', 'uint32', 16],
			b: ['FixedPoint', 'uint32', 16],
			u: ['FixedPoint', 'uint32', 30],
			c: ['FixedPoint', 'uint32', 16],
			d: ['FixedPoint', 'uint32', 16],
			v: ['FixedPoint', 'uint32', 30],
			x: ['FixedPoint', 'uint32', 16],
			y: ['FixedPoint', 'uint32', 16],
			w: ['FixedPoint', 'uint32', 30]
		},

		Volume: ['FixedPoint', 'uint16', 8],

		FBVersionable: jBinary.Template({
			setParams: function (type0, type1) {
				this.baseType = ['if', 'version', type1, type0];
			}
		}),

		FBUint: ['FBVersionable', 'uint32', 'uint64'],

		FBTime: ['Time', 'FBUint'],

		TimestampBox: ['extend', 'FullBox', {
			creation_time: 'FBTime',
			modification_time: 'FBTime'
		}],

		DurationBox: ['extend', 'TimestampBox', {
			timescale: 'uint32',
			duration: 'FBUint'
		}],

		ftyp: ['extend', 'BoxHeader', {
			major_brand: 'ShortName',
			minor_version: 'uint32',
			compatible_brands: ['array', 'ShortName', function () { return (this.binary.getContext(1)._end - this.binary.tell()) / 4 }]
		}],

		free: 'BoxHeader',

		RawData: {
			_rawData: ['blob', function () { return this.binary.getContext('_end')._end - this.binary.tell() }]
		},

		mdat: ['extend', 'BoxHeader', 'RawData'],

		ParamSets: jBinary.Template({
			setParams: function (numType) {
				this.baseType = ['DynamicArray', numType, jBinary.Template({
					baseType: {
						length: 'uint16',
						paramSet: ['blob', 'length']
					},
					read: function () {
						return this.baseRead().paramSet;
					},
					write: function (paramSet) {
						this.baseWrite({
							length: paramSet.length,
							paramSet: paramSet
						});
					}
				})];
			}
		}),

		avcC: ['extend', 'BoxHeader', {
			version: ['const', 'uint8', 1],
			profileIndication: 'uint8',
			profileCompatibility: 'uint8',
			levelIndication: 'uint8',
			_reserved: ['const', 6, -1],
			lengthSizeMinusOne: 2,
			_reserved2: ['const', 3, -1],
			seqParamSets: ['ParamSets', 5],
			pictParamSets: ['ParamSets', 'uint8']
		}],

		moov: 'MultiBox',

		mvhd: ['extend', 'DurationBox', {
			rate: 'Rate',
			volume: 'Volume',
			_reserved: ['skip', 10],
			matrix: 'TransformationMatrix',
			_reserved2: ['skip', 24],
			next_track_ID: 'uint32'
		}],

		trak: 'MultiBox',

		tkhd: ['extend', 'TimestampBox', {
			track_ID: 'uint32',
			_reserved: ['skip', 4],
			duration: 'FBUint',
			_reserved2: ['skip', 8],
			layer: 'int16',
			alternate_group: 'uint16',
			volume: 'Volume',
			_reserved3: ['skip', 2],
			matrix: 'TransformationMatrix',
			dimensions: ['Dimensions', 'Rate']
		}],

		tref: 'MultiBox',

		TrackReferenceTypeBox: ['extend', 'BoxHeader', {
			track_IDs: ['array', 'uint32', function () { return (this.binary.getContext(1)._end - this.binary.tell()) / 4 }]
		}],

		hint: 'TrackReferenceTypeBox',

		cdsc: 'TrackReferenceTypeBox',

		hind: 'TrackReferenceTypeBox',

		mdia: 'MultiBox',

		mdhd: ['extend', 'DurationBox', {
			_padding: 1,
			lang: jBinary.Type({
				read: function () {
					return String.fromCharCode.apply(
						String,
						this.binary.read(['array', 5, 3]).map(function (code) { return code + 0x60 })
					);
				},
				write: function (value) {
					for (var i = 0; i < 3; i++) {
						this.binary.write(5, value.charCodeAt(i) - 0x60);
					}
				}
			}),
			_reserved: ['skip', 2]
		}],

		hdlr: ['extend', 'FullBox', {
			_reserved: ['skip', 4],
			handler_type: 'ShortName',
			_set_handler_type: function (context) {
				this.binary.getContext(atomFilter('trak'))._handler_type = context.handler_type;
			},
			_reserved2: ['skip', 12],
			name: 'string0'
		}],

		minf: 'MultiBox',

		vmhd: ['extend', 'FullBox', {
			graphicsmode: 'uint16',
			opcolor: {
				r: 'uint16',
				g: 'uint16',
				b: 'uint16'
			}
		}],

		smhd: ['extend', 'FullBox', {
			balance: ['FixedPoint', 'int16', 8],
			_reserved: ['skip', 2]
		}],

		hmhd: ['extend', 'FullBox', {
			maxPDUsize: 'uint16',
			avgPDUsize: 'uint16',
			maxbitrate: 'uint32',
			avgbitrate: 'uint32',
			_reserved: ['skip', 4]
		}],

		stbl: 'MultiBox',

		SampleEntry: ['extend', 'BoxHeader', {
			_reserved: ['skip', 6],
			data_reference_index: 'uint16'
		}],

		btrt: ['extend', 'BoxHeader', {
			bufferSizeDB: 'uint32',
			maxBitrate: 'uint32',
			avgBitrate: 'uint32'
		}],

		metx: ['extend', 'SampleEntry', {
			content_encoding: 'string0',
			namespace: 'string0',
			schema_location: 'string0',
			bitratebox: 'btrt'
		}],

		mett: ['extend', 'SampleEntry', {
			content_encoding: 'string0',
			mime_format: 'string0',
			bitratebox: 'btrt'
		}],

		pasp: ['extend', 'BoxHeader', {
			spacing: ['Dimensions', 'uint32']
		}],

		ClapInnerFormat: ['Dimensions', {
			N: 'uint32',
			D: 'uint32'
		}],

		clap: ['extend', 'BoxHeader', {
			cleanAperture: 'ClapInnerFormat',
			off: 'ClapInnerFormat'
		}],

		VisualSampleEntry: ['extend', 'SampleEntry', {
			_reserved: ['skip', 16],
			dimensions: ['Dimensions', 'uint16'],
			resolution: ['Dimensions', 'Rate'],
			_reserved2: ['skip', 4],
			frame_count: ['const', 'uint16', 1],
			compressorname: jBinary.Template({
				baseType: {
					length: 'uint8',
					string: ['string', 'length'],
					_skip: ['skip', function (context) { return 32 - 1 - context.length }]
				},
				read: function () {
					return this.baseRead().string;
				},
				write: function (value) {
					this.baseWrite({
						length: value.length,
						string: value
					});
				}
			}),
			depth: 'uint16',
			_reserved3: ['const', 'int16', -1]
		}, jBinary.Type({
			setParams: function () {
				this.optional = {
					cleanaperture: 'clap',
					pixelaspectratio: 'pasp'
				};
			},
			read: function () {
				var extension = {};

				for (var propName in this.optional) {
					var type = this.optional[propName];
					var atom = this.binary.skip(0, function () { return this.read('BoxHeader') });
					if (atom.type === type) {
						extension[propName] = this.binary.read(type);
					}
				}

				return extension;
			},
			write: function (box) {
				for (var propName in this.optional) {
					var value = box[propName];
					if (value) {
						this.binary.write(this.optional[propName], value);
					}
				}
			}
		}), 'ChildAtoms'],

		AudioSampleEntry: ['extend', 'SampleEntry', {
			_reserved: ['skip', 8],
			channelcount: 'uint16',
			samplesize: 'uint16',
			_reserved2: ['skip', 4],
			samplerate: 'Rate'
		}, 'ChildAtoms'],

		DynamicArray: jBinary.Template({
			setParams: function (lengthType, itemType) {
				this.baseType = {
					length: lengthType,
					array: ['array', itemType, 'length']
				};
			},
			read: function () {
				return this.baseRead().array;
			},
			write: function (array) {
				this.baseWrite({
					length: array.length,
					array: array
				});
			}
		}),

		ArrayBox: jBinary.Template({
			setParams: function (entryType) {
				this.baseType = ['extend', 'FullBox', {
					entries: ['DynamicArray', 'uint32', entryType]
				}];
			}
		}),

		stsd: ['ArrayBox', jBinary.Template({
			getBaseType: function () {
				return {soun: 'AudioSampleEntry', vide: 'VisualSampleEntry', meta: 'Box'}[this.binary.getContext(atomFilter('trak'))._handler_type] || 'SampleEntry';
			},
			write: function (value) {
				var pos = this.binary.tell();
				this.baseWrite(value);
				var size = this.binary.tell() - pos;
				this.binary.seek(pos, function () { this.write('uint32', size) });
			}
		})],

		stdp: ['extend', 'FullBox', {
			priorities: ['array', 'uint16', function () { return this.binary.getContext(atomFilter('stbl'))._sample_count }]
		}],

		stsl: ['extend', 'FullBox', {
			_reserved: 7,
			constraint_flag: 'bool',
			scale_method: ['enum', 'uint8', [false, 'fill', 'hidden', 'meet', 'slice-x', 'slice-y']],
			display_center: ['Dimensions', 'int16']
		}],

		stts: ['ArrayBox', {
			sample_count: 'uint32',
			sample_delta: 'uint32'
		}],

		ctts: ['ArrayBox', {
			sample_count: 'uint32',
			sample_offset: 'uint32'
		}],

		stss: ['ArrayBox', 'uint32'],

		stsh: ['ArrayBox', {
			shadowed_sample_number: 'uint32',
			sync_sample_number: 'uint32'
		}],

		ExtendedBoolean: ['enum', 2, [undefined, true, false]],

		sdtp: ['extend', 'FullBox', {
			dependencies: ['array', {
				_reserved: 2,
				sample_depends_on: 'ExtendedBoolean',
				sample_is_depended_on: 'ExtendedBoolean',
				sample_has_redundancy: 'ExtendedBoolean'
			}, function () { return this.binary.getContext(atomFilter('stbl'))._sample_count }]
		}],

		edts: 'MultiBox',

		elst: ['ArrayBox', {
			segment_duration: 'FBUint',
			media_time: ['FBVersionable', 'int32', 'int64'],
			media_rate: 'Rate'
		}],

		dinf: 'MultiBox',

		'url ': ['extend', 'FullBox', {
			location: 'string0'
		}],

		'urn ': ['extend', 'FullBox', {
			name: 'string0',
			location: 'string0'
		}],

		dref: ['ArrayBox', 'Box'],

		stsz: ['extend', 'FullBox', {
			sample_size: 'uint32',
			sample_count: 'uint32',
			_sample_count_to_stbl: function (context) {
				this.binary.getContext(atomFilter('stbl'))._sample_count = context.sample_count;
			},
			sample_sizes: ['if_not', 'sample_size',
				['array', 'uint32', 'sample_count']
			]
		}],

		stz2: ['extend', 'FullBox', {
			_reserved: ['skip', 3],
			field_size: 'uint8',
			sample_count: 'uint32',
			_sample_count_to_stbl: function (context) {
				this.binary.getContext(atomFilter('stbl'))._sample_count = context.sample_count;
			},
			sample_sizes: [
				'array',
				jBinary.Template({
					getBaseType: function (context) { return context.field_size }
				}),
				'sample_count'
			]
		}],

		stsc: ['ArrayBox', {
			first_chunk: 'uint32',
			samples_per_chunk: 'uint32',
			sample_description_index: 'uint32'
		}],

		stco: ['ArrayBox', 'uint32'],

		co64: ['ArrayBox', 'uint64'],

		padb: ['extend', 'FullBox', {
			pads: ['DynamicArray', 'uint32', jBinary.Template({
				baseType: {
					_skip: ['const', 1, 0],
					pad: 3
				},
				read: function () {
					return this.baseRead().pad;
				},
				write: function (pad) {
					this.baseWrite({pad: pad});
				}
			})]
		}],

		subs: ['ArrayBox', {
			sample_delta: 'uint32',
			subsamples: ['DynamicArray', 'uint16', {
				subsample_size: ['FBVersionable', 'uint16', 'uint32'],
				subsample_priority: 'uint8',
				discardable: 'uint8',
				_reserved: ['skip', 4]
			}]
		}],

		mvex: 'MultiBox',

		mehd: ['extend', 'FullBox', {
			fragment_duration: 'FBUint'
		}],

		esds_section: ['extend', {
			descriptor_type: 'uint8',
			ext_type: jBinary.Type({
				read: function () {
					var next_byte = this.binary.read('uint8');
					if (next_byte === 0x80 || next_byte === 0x81 || next_byte === 0xFE) {
						this.binary.skip(2);
						return next_byte;
					} else {
						this.binary.skip(-1);
					}
				},
				write: function (filler) {
					if (filler !== undefined) this.binary.write('blob', [filler, filler, filler]);
				}
			}),
			length: 'uint8'
		}, jBinary.Template({
			getBaseType: function (context) {
				switch (context.descriptor_type) {
					case 3: return {
						es_id: 'uint16',
						stream_priority: 'uint8'
					};

					case 4: return {
						type: ['enum', 'uint8', {
							1: 'v1',
							2: 'v2',
							32: 'mpeg4_video',
							33: 'mpeg4_avc_sps',
							34: 'mpeg4_avc_pps',
							64: 'mpeg4_audio',
							96: 'mpeg2_simple_video',
							97: 'mpeg2_main_video',
							98: 'mpeg2_snr_video',
							99: 'mpeg2_spatial_video',
							100: 'mpeg2_high_video',
							101: 'mpeg2_422_video',
							102: 'mpeg4_adts_main',
							103: 'mpeg4_adts_low_complexity',
							104: 'mpeg4_adts_scaleable_sampling',
							105: 'mpeg2_adts_main',
							106: 'mpeg1_video',
							107: 'mpeg1_adts',
							108: 'jpeg_video',
							192: 'private_audio',
							208: 'private_video',
							224: 'pcm_little_endian_audio',
							225: 'vorbis_audio',
							226: 'dolby_v3_audio',
							227: 'alaw_audio',
							228: 'mulaw_audio',
							229: 'adpcm_audio',
							230: 'pcm_big_endian_audio',
							240: 'yv12_video',
							241: 'h264_video',
							242: 'h263_video',
							243: 'h261_video'
						}],
						stream_type: ['enum', 6, [
							null,
							'object',
							'clock',
							'scene',
							'visual',
							'audio',
							'mpeg-7',
							'ipmp',
							'oci',
							'mpeg-java'
						]],
						upstream_flag: 1,
						_reserved: ['const', 1, 1],
						buffer_size: 24,
						maxBitrate: 'uint32',
						avgBitrate: 'uint32'
					};

					case 5: return {
						audio_profile: ['enum', 5, [
							null,
							'aac-main',
							'aac-lc',
							'aac-ssr',
							'aac-ltp',
							'sbr',
							'aac-scalable',
							'twinvq',
							'celp',
							'hxvc',
							null,
							null,
							'ttsi',
							'main-synthesis',
							'wavetable-synthesis',
							'general-midi',
							'algorithmic-synthesis-and-audio-effects',
							'er-aac-lc',
							'reserved',
							'er-aac-ltp',
							'er-aac-scalable',
							'er-twinvq',
							'er-bsac',
							'er-aac-ld',
							'er-celp',
							'er-hvxc',
							'er-hiln',
							'er-parametric',
							'ssc',
							'ps',
							'mpeg-surround'
						]],
						sampling_freq: jBinary.Type({
							setParams: function () {
								this.freqList = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
							},
							read: function () {
								var freqIndex = this.binary.read(4);
								return freqIndex !== 15 ? this.freqList[freqIndex] : this.binary.read(24);
							},
							write: function (value) {
								var freqIndex = this.freqList.indexOf(value);
								if (freqIndex !== -1) {
									this.binary.write(4, freqIndex);
								} else {
									this.binary.write(4, 15);
									this.binary.write(24, value);
								}
							}
						}),
						channelConfig: 4,
						frameLength: ['enum', 1, [1024, 960]],
						dependsOnCoreCoder: 1,
						extensionFlag: 1
					};

					case 6: return {
						sl: ['const', 'uint8', 2]
					};
				}
			}
		})],

		esds: ['extend', 'FullBox', {
			sections: jBinary.Template({
				baseType: 'esds_section',
				read: function () {
					var end = this.binary.getContext('_end')._end, sections = [];
					while (this.binary.tell() < end) {
						sections.push(this.baseRead());
					}
					return sections;
				},
				write: function (sections) {
					for (var i = 0, length = sections.length; i < length; i++) {
						this.baseWrite(sections[i]);
					}
				}
			})
		}],

		File: ['Atoms', function () { return this.binary.view.byteLength }]
	};
}));


/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/mpegts.js":
/*!************************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/mpegts.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jBinary) {
	'use strict';

	return {
		PCR: {
			pts: 33,
			_reserved: 6,
			extension: 9
		},

		DynamicArray: jBinary.Template({
			setParams: function (lengthType, itemType) {
				this.baseType = {
					length: lengthType,
					array: ['array', itemType, 'length']
				};
			},
			read: function () {
				return this.baseRead().array;
			},
			write: function (array) {
				this.baseWrite({
					length: array.length,
					array: array
				});
			}
		}),

		Field: ['DynamicArray', 'uint8', 'uint8'],

		Flag: jBinary.Template({
			baseType: 1,
			params: ['dependentField'],
			write: function (value, context) {
				this.baseWrite(this.dependentField in context ? 1 : 0);
			}
		}),

		FlagDependent: jBinary.Template({
			params: ['flagField', 'baseType'],
			read: function () {
				return this.binary.read(['if', this.flagField, this.baseType]);
			}
		}),

		AdaptationField: {
			length: 'uint8',
			_endOf: function (context) { return this.binary.tell() + context.length },
			discontinuity: 1,
			randomAccess: 1,
			priority: 1,
			_hasPCR: ['Flag', 'pcr'],
			_hasOPCR: ['Flag', 'opcr'],
			_hasSplicingPoint: ['Flag', 'spliceCountdown'],
			_hasTransportPrivateData: ['Flag', 'privateData'],
			_hasExtension: ['Flag', 'extension'],
			pcr: ['FlagDependent', '_hasPCR', 'PCR'],
			opcr: ['FlagDependent', '_hasOPCR', 'PCR'],
			spliceCountdown: ['FlagDependent', '_hasSplicingPoint', 'uint8'],
			privateData: ['FlagDependent', '_hasTransportPrivateData', 'Field'],
			extension: ['FlagDependent', '_hasExtension', 'Field'],
			_toEnd: function (context) { this.binary.seek(context._endOf) }
		},

		ES: {
			_rawStream: ['blob', function () { return this.binary.getContext(1)._endof - this.binary.tell() }]
		},

		PATItem: ['array', {
			programNumber: 'uint16',
			_reserved: 3,
			pid: 13
		}, function (context) { return context._dataLength / 4 }],

		PMTHeader: {
			_reserved: 3,
			pcrPID: 13,
			_reserved2: 4,
			programDescriptors: ['DynamicArray', 12, 'uint8']
		},

		PMTItem: {
			streamType: 'uint8',
			_reserved: 3,
			elementaryPID: 13,
			_reserved2: 4,
			esInfo: ['DynamicArray', 12, 'uint8']
		},

		PrivateSection: ['extend', {
			pointerField: ['if', 'payloadStart', 'uint8'],
			tableId: ['enum', 'uint8', ['PAT', 'CAT', 'PMT']],
			isLongSection: 1,
			isPrivate: 1,
			_reserved: 2,
			_sectionLength: 12
		}, ['if', 'isLongSection', {
				tableIdExt: 'uint16',
				_reserved: 2,
				versionNumber: 5,
				currentNextIndicator: 1,
				sectionNumber: 'uint8',
				lastSectionNumber: 'uint8',

				_dataLength: function () { return this.binary.getContext(1)._sectionLength - 9 },

				data: jBinary.Type({
					read: function (header) {
						var data, file = this.binary.getContext(3), dataLength = header._dataLength;

						switch (this.binary.getContext(1).tableId) {
							case 'PAT':
								data = this.binary.read('PATItem');

								if (header.sectionNumber == 0) {
									file.pat = {};
								}

								for (var i = 0; i < data.length; i++) {
									file.pat[data[i].pid] = data[i];
								}

								break;

							case 'PMT':
								data = this.binary.read('PMTHeader');

								data.mappings = [];

								dataLength -= 4 + data.programDescriptors.length;

								while (dataLength > 0) {
									var mapping = this.binary.read('PMTItem');
									data.mappings.push(mapping);
									dataLength -= 5 + mapping.esInfo.length;
								}

								if (header.sectionNumber == 0) {
									file.pmt = {};
								}

								for (var i = 0; i < data.mappings.length; i++) {
									var mapping = data.mappings[i];
									file.pmt[mapping.elementaryPID] = mapping;
								}

								break;
						}

						return data;
					}
				}),

				crc32: 'uint32'
			},
			['blob', '_sectionLength']
		]],

		Packet: {
			_startof: function () { return this.binary.tell() },
			_endof: function (context) { return context._startof + 188 },

			_syncByte: ['const', 'uint8', 0x47, true],

			transportError: 1,
			payloadStart: 1,
			transportPriority: 1,
			pid: 13,

			scramblingControl: 2,
			_hasAdaptationField: ['Flag', 'adaptationField'],
			_hasPayload: ['Flag', 'payload'],
			contCounter: 4,

			adaptationField: ['FlagDependent', '_hasAdaptationField', 'AdaptationField'],

			payload: ['FlagDependent', '_hasPayload', jBinary.Template({
				getBaseType: function (context) {
					var pid = context.pid, file = this.binary.getContext(1);
					if (pid < 2 || pid in file.pat) {
						return 'PrivateSection';
					}
					if (pid in file.pmt) {
						return 'ES';
					}
				}
			})],

			_toEnd: function (context) { this.binary.seek(context._endof) }
		},

		File: jBinary.Template({
			baseType: ['array', 'Packet'],
			read: function () {
				this.pat = {};
				this.pmt = {};
				var self = this;
				return this.binary.inContext(this, function () {
					return self.baseRead();
				});
			},
			write: function (packets) {
				var self = this;
				this.binary.inContext(this, function () {
					self.baseWrite(packets);
				});
			}
		})
	};
}));

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/pes.js":
/*!*********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/pes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jBinary) {
	'use strict';

	return {
		Flag: jBinary.Template({
			baseType: 1,
			params: ['dependentField'],
			write: function (value, context) {
				this.baseWrite(this.dependentField in context ? 1 : 0);
			}
		}),

		FlagDependent: jBinary.Template({
			params: ['flagField', 'baseType'],
			read: function () {
				return this.binary.read(['if', this.flagField, this.baseType]);
			}
		}),

		PESTimeStamp: jBinary.Template({
			setParams: function (prefix) {
				var skipBit = ['const', 1, 1, true];
				this.baseType = {
					_prefix: ['const', 4, prefix, true],
					hiPart: 3,
					_skip1: skipBit,
					midPart: 15,
					_skip2: skipBit,
					loPart: 15,
					_skip3: skipBit
				};
			},
			read: function () {
				var parts = this.baseRead();
				return parts.loPart | (parts.midPart << 15) | (parts.hiPart << 30);
			},
			write: function (value) {
				this.baseWrite({
					hiPart: value >>> 30,
					midPart: (value >>> 15) & ~(-1 << 15),
					loPart: value & ~(-1 << 15)
				});
			}
		}),

		PESPacket: ['extend', {
			_startCode0: ['const', 'uint8', 0, true],
			_startCode1: ['const', 'uint8', 0, true],
			_startCode2: ['const', 'uint8', 1, true],
			streamId: 'uint8',
			length: 'uint16',
			_end: function (context) {
				var pos = this.binary.tell(), length = context.length;

				if (length) {
					pos += length;
					if (pos > this.view.byteLength - 4) {
						return pos;
					}
					var bytes = this.binary.read(['blob', 4], pos);
					if (bytes[0] === 0 && bytes[1] === 0 && bytes[2] === 1 && (bytes[3] & 0x80)) {
						return pos;
					}
					pos -= length;
				}

				/*
				not sure if it correctly covers cases where `length`==0
				(according to specification, it may be written as zero for video streams of undefined length)
				but should work for H.264 streams since NAL unit types always have clear highest bit (`forbidden_zero_bit`)
				*/
				var fileEnd = this.view.byteLength, bytes = this.binary.read('blob', pos);
				for (var i = 0; i < bytes.length - 4; i++) {
					if (bytes[i] === 0 && bytes[i + 1] === 0 && bytes[i + 2] === 1 && (bytes[i + 3] & 0x80)) {
						return pos + i;
					}
				}
				return fileEnd;
			}
		}, jBinary.Template({
			baseType: {
				_marker: ['const', 2, 2, true],
				scramblingControl: ['enum', 2, ['not_scrambled']],
				priority: 1,
				dataAlignmentIndicator: 1,
				hasCopyright: 1,
				isOriginal: 1,
				_hasPTS: ['Flag', 'pts'],
				_hasDTS: ['Flag', 'dts'],
				_hasESCR: ['Flag', 'escr'],
				_hasESRate: ['Flag', 'esRate'],
				dsmTrickMode: 1,
				_hasAdditionalCopyInfo: ['Flag', 'additionalCopyInfo'],
				_hasPESCRC: ['Flag', 'pesCRC'],
				_hasExtension: ['Flag', 'extension'],
				dataLength: 'uint8',
				_headerEnd: function (context) { return this.binary.tell() + context.dataLength },
				pts: ['FlagDependent', '_hasPTS', ['if', '_hasDTS', ['PESTimeStamp', 3], ['PESTimeStamp', 2]]],
				dts: ['FlagDependent', '_hasDTS', ['PESTimeStamp', 1]],
				_toHeaderEnd: function (context) { this.binary.seek(context._headerEnd) }
			},
			read: function () {
				var pos = this.binary.tell();
				try {
					return this.baseRead();
				} catch (e) {
					this.binary.seek(pos);
					this.binary.view.alignBy();
				}
			}
		}), {
			data: ['blob', function () { return this.binary.getContext('_end')._end - this.binary.tell() }]
		}]
	};
}));

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/punycode/punycode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/resolve-url/resolve-url.js":
/*!*************************************************!*\
  !*** ./node_modules/resolve-url/resolve-url.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell
// X11 (MIT) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/background/index.js":
/*!*********************************!*\
  !*** ./src/background/index.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/browser */ "./src/common/browser.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_browser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_ZhaoJun_Desktop_violentmonkey_src_common_browser__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/common/tld */ "./src/common/tld.js");
/* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sync */ "./src/background/sync/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ "./src/background/utils/index.js");
/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/db */ "./src/background/utils/db.js");
/* harmony import */ var _utils_init__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/init */ "./src/background/utils/init.js");
/* harmony import */ var _utils_options__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/options */ "./src/background/utils/options.js");
/* harmony import */ var _utils_popup_tracker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/popup-tracker */ "./src/background/utils/popup-tracker.js");
/* harmony import */ var _utils_preinject__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/preinject */ "./src/background/utils/preinject.js");
/* harmony import */ var _utils_template_hook__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/template-hook */ "./src/background/utils/template-hook.js");
/* harmony import */ var _utils_values__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/values */ "./src/background/utils/values.js");
/* harmony import */ var _utils_requests__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/requests */ "./src/background/utils/requests.js");
/* harmony import */ var _utils_clipboard__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/clipboard */ "./src/background/utils/clipboard.js");
/* harmony import */ var _utils_hotkeys__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/hotkeys */ "./src/background/utils/hotkeys.js");
/* harmony import */ var _utils_icon__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/icon */ "./src/background/utils/icon.js");
/* harmony import */ var _utils_notifications__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./utils/notifications */ "./src/background/utils/notifications.js");
/* harmony import */ var _utils_script__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils/script */ "./src/background/utils/script.js");
/* harmony import */ var _utils_tabs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/tabs */ "./src/background/utils/tabs.js");
/* harmony import */ var _utils_tester__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/tester */ "./src/background/utils/tester.js");
/* harmony import */ var _utils_update__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./utils/update */ "./src/background/utils/update.js");























Object(_utils_options__WEBPACK_IMPORTED_MODULE_9__["hookOptions"])(changes => {
  if ('autoUpdate' in changes) {
    autoUpdate();
  }

  if (_utils_template_hook__WEBPACK_IMPORTED_MODULE_12__["SCRIPT_TEMPLATE"] in changes) {
    Object(_utils_template_hook__WEBPACK_IMPORTED_MODULE_12__["resetScriptTemplate"])(changes);
  }

  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])('UpdateOptions', changes);
});
Object.assign(_utils__WEBPACK_IMPORTED_MODULE_6__["commands"], {
  /** @return {Promise<{ scripts: VMScript[], cache: Object, sync: Object }>} */
  async GetData(ids) {
    const data = await Object(_utils_db__WEBPACK_IMPORTED_MODULE_7__["getData"])(ids);
    data.sync = _sync__WEBPACK_IMPORTED_MODULE_5__["getStates"]();
    return data;
  },

  /** @return {Promise<Object>} */
  async GetInjected({
    url,
    forceContent
  }, src) {
    const {
      frameId,
      tab
    } = src;
    const tabId = tab.id;
    if (!url) url = src.url || tab.url;

    if (!frameId) {
      Object(_utils_values__WEBPACK_IMPORTED_MODULE_13__["resetValueOpener"])(tabId);
      Object(_utils_requests__WEBPACK_IMPORTED_MODULE_14__["clearRequestsByTabId"])(tabId);
    }

    const res = await Object(_utils_preinject__WEBPACK_IMPORTED_MODULE_11__["getInjectedScripts"])(url, tabId, frameId, forceContent);
    const {
      feedback,
      inject,
      valOpIds
    } = res;
    inject.isPopupShown = _utils_popup_tracker__WEBPACK_IMPORTED_MODULE_10__["popupTabs"][tabId]; // Injecting known content scripts without waiting for InjectionFeedback message.
    // Running in a separate task because it may take a long time to serialize data.

    if (feedback.length) {
      setTimeout(_utils__WEBPACK_IMPORTED_MODULE_6__["commands"].InjectionFeedback, 0, {
        feedback
      }, src);
    }

    Object(_utils_values__WEBPACK_IMPORTED_MODULE_13__["addValueOpener"])(tabId, frameId, valOpIds);
    return inject;
  },

  /** @return {Promise<Object>} */
  async GetTabDomain() {
    const tab = (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getActiveTab"])()) || {};
    const url = tab.pendingUrl || tab.url || '';
    const host = url.match(/^https?:\/\/([^/]+)|$/)[1];
    return {
      tab,
      domain: host && _Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_4__["getDomain"](host) || host
    };
  },

  /**
   * Timers in content scripts are shared with the web page so it can clear them.
   * await sendCmd('SetTimeout', 100) in injected/content
   * await bridge.send('SetTimeout', 100) in injected/web
   */
  SetTimeout(ms) {
    return ms > 0 && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["makePause"])(ms);
  }

}); // commands to sync unconditionally regardless of the returned value from the handler

const commandsToSync = ['MarkRemoved', 'Move', 'ParseScript', 'RemoveScript', 'UpdateScriptInfo']; // commands to sync only if the handler returns a truthy value

const commandsToSyncIfTruthy = ['CheckRemove', 'CheckUpdate', 'CheckUpdateAll'];

async function handleCommandMessage(req, src) {
  var _commands$cmd;

  const {
    cmd
  } = req;
  const res = await ((_commands$cmd = _utils__WEBPACK_IMPORTED_MODULE_6__["commands"][cmd]) == null ? void 0 : _commands$cmd.call(_utils__WEBPACK_IMPORTED_MODULE_6__["commands"], req.data, src));

  if (commandsToSync.includes(cmd) || res && commandsToSyncIfTruthy.includes(cmd)) {
    _sync__WEBPACK_IMPORTED_MODULE_5__["sync"]();
  } // `undefined` is not transferable, but `null` is


  return res != null ? res : null;
}

function autoUpdate() {
  const interval = _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["IS_DEV"] ? 1000 : (+Object(_utils_options__WEBPACK_IMPORTED_MODULE_9__["getOption"])('autoUpdate') || 0) * _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["TIMEOUT_24HOURS"];
  if (!interval) return;
  let elapsed = Date.now() - Object(_utils_options__WEBPACK_IMPORTED_MODULE_9__["getOption"])('lastUpdate');

  if (elapsed >= interval) {
    handleCommandMessage({
      cmd: 'CheckUpdateAll'
    });
    elapsed = 0;
  }

  clearTimeout(autoUpdate.timer);
  autoUpdate.timer = setTimeout(autoUpdate, Math.min(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["TIMEOUT_MAX"], interval - elapsed));
}

async function initBuildin() {
  const {
    data
  } = await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["request"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["BUILD_IN_SCRIPT_SRC"], {
    cache: 'no-cache',
    headers: {
      Accept: 'text/x-userscript-meta,*/*'
    }
  });
  const res = await _utils__WEBPACK_IMPORTED_MODULE_6__["commands"].ParseScript({
    url: _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["BUILD_IN_SCRIPT_SRC"],
    code: data,
    custom: {
      buildIn: true
    }
  });
  _sync__WEBPACK_IMPORTED_MODULE_5__["sync"]();

  if (res.where.id !== 1) {
    throw `wrong id: ${res.where.id}`;
  }
}

Object(_utils_init__WEBPACK_IMPORTED_MODULE_8__["initialize"])(() => {
  global.handleCommandMessage = handleCommandMessage;
  global.deepCopy = _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["deepCopy"];
  browser.runtime.onMessage.addListener(IS_FIREFOX // in FF a rejected Promise value is transferred only if it's an Error object
  ? (...args) => handleCommandMessage(...args).catch(e => Promise.reject(e instanceof Error ? e : new Error(e))) // Didn't use `throw` to avoid interruption in devtools with pause-on-exception enabled.
  : handleCommandMessage); // check and install the build-in script

  initBuildin();
  console.info('initBuildin...');
  setTimeout(autoUpdate, _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["IS_DEV"] ? 1 : 2e4);
  _sync__WEBPACK_IMPORTED_MODULE_5__["initialize"]();
  Object(_utils_db__WEBPACK_IMPORTED_MODULE_7__["checkRemove"])();
  setInterval(_utils_db__WEBPACK_IMPORTED_MODULE_7__["checkRemove"], _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["TIMEOUT_24HOURS"]);
  const api = global.chrome.declarativeContent;

  if (api) {
    // Using declarativeContent to run content scripts earlier than document_start
    api.onPageChanged.getRules(async ([rule]) => {
      const id = rule == null ? void 0 : rule.id;
      const newId = "Violentmonkey:BWVhWPP8nIg=";

      if (id === newId) {
        return;
      }

      if (id) {
        await browser.declarativeContent.onPageChanged.removeRules([id]);
      }

      api.onPageChanged.addRules([{
        id: newId,
        conditions: [new api.PageStateMatcher({
          pageUrl: {
            urlContains: '://'
          } // essentially like <all_urls>

        })],
        actions: [new api.RequestContentScript({
          js: browser.runtime.getManifest().content_scripts[0].js // Not using `allFrames:true` as there's no improvement in frames

        })]
      }]);
    });
  }
});

/***/ }),

/***/ "./src/background/plugin/events.js":
/*!*****************************************!*\
  !*** ./src/background/plugin/events.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/events */ "./src/common/events.js");

/* harmony default export */ __webpack_exports__["default"] = (new _Users_ZhaoJun_Desktop_violentmonkey_src_common_events__WEBPACK_IMPORTED_MODULE_0__["default"](['scriptEdit', 'scriptChanged']));

/***/ }),

/***/ "./src/background/plugin/index.js":
/*!****************************************!*\
  !*** ./src/background/plugin/index.js ***!
  \****************************************/
/*! exports provided: script */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "script", function() { return script; });
/* harmony import */ var _utils_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/message */ "./src/background/utils/message.js");
/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/db */ "./src/background/utils/db.js");


const script = {
  /**
   * Update an existing script identified by the provided id
   * @param {{ id, code, message, isNew, config, custom, props, update }} data
   * @return {Promise<{ isNew?, update, where }>}
   */
  update: _utils_message__WEBPACK_IMPORTED_MODULE_0__["commands"].ParseScript,

  /**
   * List all available scripts, without script code
   * @return {Promise<VMScript[]>}
   */
  list: async () => Object(_utils_db__WEBPACK_IMPORTED_MODULE_1__["getScripts"])(),

  /**
   * Get script code of an existing script
   * @param {number} id
   * @return {Promise<string>}
   */
  get: _utils_message__WEBPACK_IMPORTED_MODULE_0__["commands"].GetScriptCode,

  /**
   * Remove script
   * @param {number} id
   * @return {Promise<void>}
   */
  remove: id => _utils_message__WEBPACK_IMPORTED_MODULE_0__["commands"].MarkRemoved({
    id,
    removed: true
  })
};

/***/ }),

/***/ "./src/background/sync/base.js":
/*!*************************************!*\
  !*** ./src/background/sync/base.js ***!
  \*************************************/
/*! exports provided: getItemFilename, isScriptFile, getURI, getStates, BaseService, register, initialize, sync, authorize, revoke, setConfig, openAuthPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getItemFilename", function() { return getItemFilename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isScriptFile", function() { return isScriptFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getURI", function() { return getURI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStates", function() { return getStates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseService", function() { return BaseService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "register", function() { return register; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialize", function() { return initialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sync", function() { return sync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "authorize", function() { return authorize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "revoke", function() { return revoke; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConfig", function() { return setConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openAuthPage", function() { return openAuthPage; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./src/background/utils/index.js");
/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/db */ "./src/background/utils/db.js");
/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugin */ "./src/background/plugin/index.js");






const serviceNames = [];
const serviceClasses = [];
const services = {};
const autoSync = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["debounce"])(sync, _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["TIMEOUT_HOUR"]);
let working = Promise.resolve();
let syncConfig;
function getItemFilename({
  name,
  uri
}) {
  // When get or remove, current name should be prefered
  if (name) return name; // otherwise uri derived name should be prefered
  // uri is already encoded by `encodeFilename`

  return `vm@2-${uri}`;
}
function isScriptFile(name) {
  return /^vm(?:@\d+)?-/.test(name);
}
function getURI(name) {
  const i = name.indexOf('-');
  const [, version] = name.slice(0, i).split('@');

  if (version === '2') {
    // uri is encoded by `encodedFilename`, so we should not decode it here
    return name.slice(i + 1);
  }

  try {
    return decodeURIComponent(name.slice(3));
  } catch (err) {
    return name.slice(3);
  }
}

function initConfig() {
  function get(key, def) {
    const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
    keys.unshift('sync');
    return Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getOption"])(keys, def);
  }

  function set(key, value) {
    const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
    keys.unshift('sync');
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["setOption"])(keys, value);
  }

  function init() {
    let config = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getOption"])('sync');

    if (!config || !config.services) {
      config = {
        services: {}
      };
      set([], config);
    }
  }

  init();
  return {
    get,
    set
  };
}

function serviceConfig(name) {
  function getKeys(key) {
    const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
    keys.unshift('services', name);
    return keys;
  }

  function get(key, def) {
    return syncConfig.get(getKeys(key), def);
  }

  function set(key, val) {
    if (typeof key === 'object') {
      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], key, ([k, v]) => {
        syncConfig.set(getKeys(k), v);
      });
    } else {
      syncConfig.set(getKeys(key), val);
    }
  }

  function clear() {
    syncConfig.set(getKeys(), {});
  }

  return {
    get,
    set,
    clear
  };
}

function serviceState(validStates, initialState, onChange) {
  let state = initialState || validStates[0];

  function get() {
    return state;
  }

  function set(newState) {
    if (validStates.includes(newState)) {
      state = newState;
      if (onChange) onChange();
    } else {
      console.warn('Invalid state:', newState);
    }

    return get();
  }

  function is(states) {
    return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["ensureArray"])(states).includes(state);
  }

  return {
    get,
    set,
    is
  };
}

function getStates() {
  return serviceNames.map(name => {
    const service = services[name];
    return {
      name: service.name,
      displayName: service.displayName,
      authState: service.authState.get(),
      syncState: service.syncState.get(),
      lastSync: service.config.get('meta', {}).lastSync,
      progress: service.progress,
      properties: service.properties,
      userConfig: service.getUserConfig()
    };
  });
}

function getScriptData(script, syncVersion, extra) {
  let data;

  if (syncVersion === 2) {
    data = {
      version: syncVersion,
      custom: script.custom,
      config: script.config,
      props: Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectPick"])(script.props, ['lastUpdated'])
    };
  } else if (syncVersion === 1) {
    data = {
      version: syncVersion,
      more: {
        custom: script.custom,
        enabled: script.config.enabled,
        update: script.config.shouldUpdate,
        lastUpdated: script.props.lastUpdated
      }
    };
  }

  return Object.assign(data, extra);
}

function parseScriptData(raw) {
  const data = {};

  try {
    const obj = JSON.parse(raw);
    data.code = obj.code;

    if (obj.version === 2) {
      data.config = obj.config;
      data.custom = obj.custom;
      data.props = obj.props;
    } else if (obj.version === 1) {
      if (obj.more) {
        data.custom = obj.more.custom;
        data.config = objectPurify({
          enabled: obj.more.enabled,
          shouldUpdate: obj.more.update
        });
        data.props = objectPurify({
          lastUpdated: obj.more.lastUpdated
        });
      }
    }
  } catch (e) {
    data.code = raw;
  }

  return data;
}

function objectPurify(obj) {
  // Remove keys with undefined values
  if (Array.isArray(obj)) {
    obj.forEach(objectPurify);
  } else if (obj && typeof obj === 'object') {
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], obj, ([key, value]) => {
      if (typeof value === 'undefined') delete obj[key];else objectPurify(value);
    });
  }

  return obj;
}

function serviceFactory(base) {
  const Service = function constructor() {
    this.initialize();
  };

  Service.prototype = base;
  Service.extend = extendService;
  return Service;
}

function extendService(options) {
  return serviceFactory(Object.assign(Object.create(this.prototype), options));
}

const onStateChange = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["debounce"])(() => {
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendCmd"])('UpdateSync', getStates());
});
const BaseService = serviceFactory({
  name: 'base',
  displayName: 'BaseService',
  delayTime: 1000,
  urlPrefix: '',
  metaFile: 'Violentmonkey',
  properties: {
    authType: 'oauth'
  },
  getUserConfig: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],
  setUserConfig: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],

  initialize() {
    this.progress = {
      finished: 0,
      total: 0
    };
    this.config = serviceConfig(this.name);
    this.authState = serviceState(['idle', 'no-auth', 'initializing', 'authorizing', // in case some services require asynchronous requests to get access_tokens
    'authorized', 'unauthorized', 'error'], null, onStateChange);
    this.syncState = serviceState(['idle', 'ready', 'syncing', 'error'], null, onStateChange);
    this.lastFetch = Promise.resolve();
    this.startSync = this.syncFactory();
    const events = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getEventEmitter"])();
    ['on', 'off', 'fire'].forEach(key => {
      this[key] = (...args) => {
        events[key](...args);
      };
    });
  },

  log(...args) {
    console.log(...args); // eslint-disable-line no-console
  },

  syncFactory() {
    let promise;
    let debouncedResolve;

    const shouldSync = () => this.authState.is('authorized') && getCurrent() === this.name;

    const getReady = () => {
      if (!shouldSync()) return Promise.resolve();
      this.log('Ready to sync:', this.displayName);
      this.syncState.set('ready');
      working = working.then(() => new Promise(resolve => {
        debouncedResolve = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["debounce"])(resolve, 10 * 1000);
        debouncedResolve();
      })).then(() => {
        if (shouldSync()) return this.sync();
        this.syncState.set('idle');
      }).catch(err => {
        console.error(err);
      }).then(() => {
        promise = null;
        debouncedResolve = null;
      });
      promise = working;
    };

    function startSync() {
      if (!promise) getReady();
      if (debouncedResolve) debouncedResolve();
      return promise;
    }

    return startSync;
  },

  prepareHeaders() {
    this.headers = {};
  },

  prepare() {
    this.authState.set('initializing');
    return (this.initToken() ? Promise.resolve(this.user()) : Promise.reject({
      type: 'no-auth'
    })).then(() => {
      this.authState.set('authorized');
    }, err => {
      if (['no-auth', 'unauthorized'].includes(err == null ? void 0 : err.type)) {
        this.authState.set(err.type);
      } else {
        console.error(err);
        this.authState.set('error');
      }

      this.syncState.set('idle');
      throw err;
    });
  },

  checkSync() {
    return this.prepare().then(() => this.startSync());
  },

  user: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],
  acquireLock: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],
  releaseLock: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],

  handleMetaError(err) {
    throw err;
  },

  getMeta() {
    return this.get({
      name: this.metaFile
    }).then(data => JSON.parse(data)).catch(err => this.handleMetaError(err)).then(data => ({
      name: this.metaFile,
      data
    }));
  },

  initToken() {
    this.prepareHeaders();
    const token = this.config.get('token');
    this.headers.Authorization = token ? `Bearer ${token}` : null;
    return !!token;
  },

  loadData(options) {
    const {
      progress
    } = this;
    const {
      delay = this.delayTime
    } = options;
    let lastFetch = Promise.resolve();

    if (delay) {
      lastFetch = this.lastFetch.then(ts => Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["makePause"])(delay - (Date.now() - ts))).then(() => Date.now());
      this.lastFetch = lastFetch;
    }

    progress.total += 1;
    onStateChange();
    return lastFetch.then(() => {
      var _options$prefix;

      options = Object.assign({}, options);
      options.headers = Object.assign({}, this.headers, options.headers);
      let {
        url
      } = options;
      if (url.startsWith('/')) url = ((_options$prefix = options.prefix) != null ? _options$prefix : this.urlPrefix) + url;
      return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["request"])(url, options);
    }).then(({
      data
    }) => ({
      data
    }), error => ({
      error
    })).then(({
      data,
      error
    }) => {
      progress.finished += 1;
      onStateChange();
      if (error) return Promise.reject(error);
      return data;
    });
  },

  getLocalData() {
    return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].list();
  },

  getSyncData() {
    return this.getMeta().then(remoteMeta => Promise.all([remoteMeta, this.list(), this.getLocalData()]));
  },

  sync() {
    this.progress = {
      finished: 0,
      total: 0
    };
    this.syncState.set('syncing'); // Avoid simultaneous requests

    return this.prepare().then(() => this.getSyncData()).then(data => Promise.resolve(this.acquireLock()).then(() => data)).then(([remoteMeta, remoteData, localData]) => {
      const remoteMetaData = remoteMeta.data || {};
      const remoteMetaInfo = remoteMetaData.info || {};
      const remoteTimestamp = remoteMetaData.timestamp || 0;
      let remoteChanged = !remoteTimestamp || Object.keys(remoteMetaInfo).length !== remoteData.length;
      const now = Date.now();
      const globalLastModified = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getOption"])('lastModified');
      const remoteItemMap = {};
      const localMeta = this.config.get('meta', {});
      const firstSync = !localMeta.timestamp;
      const outdated = firstSync || remoteTimestamp > localMeta.timestamp;
      this.log('First sync:', firstSync);
      this.log('Outdated:', outdated, '(', 'local:', localMeta.timestamp, 'remote:', remoteTimestamp, ')');
      const putLocal = [];
      const putRemote = [];
      const delRemote = [];
      const delLocal = [];
      const updateLocal = [];
      remoteMetaData.info = remoteData.reduce((info, item) => {
        remoteItemMap[item.uri] = item;
        let itemInfo = remoteMetaInfo[item.uri];

        if (!itemInfo) {
          itemInfo = {};
          remoteChanged = true;
        }

        info[item.uri] = itemInfo;

        if (!itemInfo.modified) {
          itemInfo.modified = now;
          remoteChanged = true;
        }

        return info;
      }, {});
      localData.forEach(item => {
        const {
          props: {
            uri,
            position,
            lastModified
          }
        } = item;
        const remoteInfo = remoteMetaData.info[uri];
        const remoteItem = remoteItemMap[uri];

        if (remoteInfo && remoteItem) {
          if (firstSync || !lastModified || remoteInfo.modified > lastModified) {
            putLocal.push({
              local: item,
              remote: remoteItem,
              info: remoteInfo
            });
          } else {
            if (remoteInfo.modified < lastModified) {
              putRemote.push({
                local: item,
                remote: remoteItem
              });
              remoteInfo.modified = lastModified;
              remoteChanged = true;
            }

            if (remoteInfo.position !== position) {
              if (remoteInfo.position && globalLastModified <= remoteTimestamp) {
                updateLocal.push({
                  local: item,
                  remote: remoteItem,
                  info: remoteInfo
                });
              } else {
                remoteInfo.position = position;
                remoteChanged = true;
              }
            }
          }

          delete remoteItemMap[uri];
        } else if (firstSync || !outdated || lastModified > remoteTimestamp) {
          putRemote.push({
            local: item
          });
        } else {
          delLocal.push({
            local: item
          });
        }
      });
      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], remoteItemMap, ([uri, item]) => {
        const info = remoteMetaData.info[uri];

        if (outdated) {
          putLocal.push({
            remote: item,
            info
          });
        } else {
          delRemote.push({
            remote: item
          });
        }
      });
      const promiseQueue = [...putLocal.map(({
        remote,
        info
      }) => {
        this.log('Download script:', remote.uri);
        return this.get(remote).then(raw => {
          const data = parseScriptData(raw); // Invalid data

          if (!data.code) return;
          if (info.modified) Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectSet"])(data, 'props.lastModified', info.modified);
          const position = +info.position;
          if (position) data.position = position;

          if (!Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getOption"])('syncScriptStatus') && data.config) {
            delete data.config.enabled;
          }

          return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].update(data);
        });
      }), ...putRemote.map(({
        local,
        remote
      }) => {
        this.log('Upload script:', local.props.uri);
        return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].get(local.props.id).then(code => {
          // XXX use version 1 to be compatible with Violentmonkey on other platforms
          const data = getScriptData(local, 1, {
            code
          });
          remoteMetaData.info[local.props.uri] = {
            modified: local.props.lastModified,
            position: local.props.position
          };
          remoteChanged = true;
          return this.put(Object.assign({}, remote, {
            uri: local.props.uri,
            name: null // prefer using uri on PUT

          }), JSON.stringify(data));
        });
      }), ...delRemote.map(({
        remote
      }) => {
        this.log('Remove remote script:', remote.uri);
        delete remoteMetaData.info[remote.uri];
        remoteChanged = true;
        return this.remove(remote);
      }), ...delLocal.map(({
        local
      }) => {
        this.log('Remove local script:', local.props.uri);
        return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].remove(local.props.id);
      }), ...updateLocal.map(({
        local,
        info
      }) => {
        const updates = {};

        if (info.position) {
          updates.props = {
            position: info.position
          };
        }

        return Object(_utils_db__WEBPACK_IMPORTED_MODULE_4__["updateScriptInfo"])(local.props.id, updates);
      })];
      promiseQueue.push(Promise.all(promiseQueue).then(() => Object(_utils_db__WEBPACK_IMPORTED_MODULE_4__["sortScripts"])()).then(changed => {
        if (!changed) return;
        remoteChanged = true;
        return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].list().then(scripts => {
          scripts.forEach(script => {
            const remoteInfo = remoteMetaData.info[script.props.uri];
            if (remoteInfo) remoteInfo.position = script.props.position;
          });
        });
      }));
      promiseQueue.push(Promise.all(promiseQueue).then(() => {
        const promises = [];

        if (remoteChanged) {
          remoteMetaData.timestamp = Date.now();
          promises.push(this.put(remoteMeta, JSON.stringify(remoteMetaData)));
        }

        localMeta.timestamp = remoteMetaData.timestamp;
        localMeta.lastSync = Date.now();
        this.config.set('meta', localMeta);
        return Promise.all(promises);
      })); // ignore errors to ensure all promises are fulfilled

      return Promise.all(promiseQueue.map(promise => promise.then(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"], err => err || true))).then(errors => errors.filter(Boolean)).then(errors => {
        if (errors.length) throw errors;
      });
    }).then(() => {
      this.syncState.set('idle');
      this.log('Sync finished:', this.displayName);
    }, err => {
      this.syncState.set('error');
      this.log('Failed syncing:', this.displayName);
      this.log(err);
    }).then(() => Promise.resolve(this.releaseLock()).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]));
  }

});
function register(Factory) {
  serviceClasses.push(Factory);
}

function getCurrent() {
  return syncConfig.get('current');
}

function getService(name) {
  return services[name || getCurrent()];
}

function initialize() {
  if (!syncConfig) {
    syncConfig = initConfig();
    serviceClasses.forEach(Factory => {
      const service = new Factory();
      const {
        name
      } = service;
      serviceNames.push(name);
      services[name] = service;
    });
  }

  sync();
}

function syncOne(service) {
  if (service.syncState.is(['ready', 'syncing'])) return;
  if (service.authState.is(['idle', 'error'])) return service.checkSync();
  if (service.authState.is('authorized')) return service.startSync();
}

function sync() {
  const service = getService();
  return service && Promise.resolve(syncOne(service)).then(autoSync);
}
function authorize() {
  const service = getService();
  if (service) service.authorize();
}
function revoke() {
  const service = getService();
  if (service) service.revoke();
}
function setConfig(config) {
  const service = getService();

  if (service) {
    service.setUserConfig(config);
    return service.checkSync();
  }
}
async function openAuthPage(url, redirectUri) {
  unregisterWebRequest(); // otherwise our new tabId will be ignored

  browser.webRequest.onBeforeRequest.addListener(onBeforeRequest, {
    urls: [`${redirectUri}*`],
    types: ['main_frame'],
    tabId: (await browser.tabs.create({
      url
    })).id
  }, ['blocking']);
}
/**
 * @param {chrome.webRequest.WebResponseDetails} info
 * @returns {chrome.webRequest.BlockingResponse}
 */

function onBeforeRequest(info) {
  var _getService$checkAuth, _getService;

  if ((_getService$checkAuth = (_getService = getService()).checkAuth) == null ? void 0 : _getService$checkAuth.call(_getService, info.url)) {
    browser.tabs.remove(info.tabId); // If we unregister without setTimeout, API will ignore { cancel: true }

    setTimeout(unregisterWebRequest, 0);
    return {
      cancel: true
    };
  }
}

function unregisterWebRequest() {
  browser.webRequest.onBeforeRequest.removeListener(onBeforeRequest);
}

Object(_utils__WEBPACK_IMPORTED_MODULE_3__["hookOptions"])(data => {
  const value = data == null ? void 0 : data['sync.current'];
  if (value) initialize();
});

/***/ }),

/***/ "./src/background/sync/dropbox.js":
/*!****************************************!*\
  !*** ./src/background/sync/dropbox.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/background/utils/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");


const config = {
  client_id: 'f0q12zup2uys5w8',
  redirect_uri: 'https://violentmonkey.github.io/auth_dropbox.html'
};
const escRE = /[\u007f-\uffff]/g; // eslint-disable-line no-control-regex

const escFunc = m => `\\u${(m.charCodeAt(0) + 0x10000).toString(16).slice(1)}`;

function jsonStringifySafe(obj) {
  const string = JSON.stringify(obj);
  return string.replace(escRE, escFunc);
}

const Dropbox = _base__WEBPACK_IMPORTED_MODULE_1__["BaseService"].extend({
  name: 'dropbox',
  displayName: 'Dropbox',

  user() {
    return this.loadData({
      method: 'POST',
      url: 'https://api.dropboxapi.com/2/users/get_current_account'
    }).catch(err => {
      if (err.status === 401) {
        return Promise.reject({
          type: 'unauthorized'
        });
      }

      return Promise.reject({
        type: 'error',
        data: err
      });
    });
  },

  handleMetaError(res) {
    if (res.status !== 409) throw res;
  },

  list() {
    return this.loadData({
      method: 'POST',
      url: 'https://api.dropboxapi.com/2/files/list_folder',
      body: {
        path: ''
      },
      responseType: 'json'
    }).then(data => data.entries.filter(item => item['.tag'] === 'file' && Object(_base__WEBPACK_IMPORTED_MODULE_1__["isScriptFile"])(item.name)).map(normalize));
  },

  get(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    return this.loadData({
      method: 'POST',
      url: 'https://content.dropboxapi.com/2/files/download',
      headers: {
        'Dropbox-API-Arg': jsonStringifySafe({
          path: `/${name}`
        })
      }
    });
  },

  put(item, data) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    return this.loadData({
      method: 'POST',
      url: 'https://content.dropboxapi.com/2/files/upload',
      headers: {
        'Dropbox-API-Arg': jsonStringifySafe({
          path: `/${name}`,
          mode: 'overwrite'
        }),
        'Content-Type': 'application/octet-stream'
      },
      body: data,
      responseType: 'json'
    }).then(normalize);
  },

  remove(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    return this.loadData({
      method: 'POST',
      url: 'https://api.dropboxapi.com/2/files/delete',
      body: {
        path: `/${name}`
      },
      responseType: 'json'
    }).then(normalize);
  },

  authorize() {
    const params = {
      response_type: 'token',
      client_id: config.client_id,
      redirect_uri: config.redirect_uri
    };
    const url = `https://www.dropbox.com/oauth2/authorize?${Object(_utils__WEBPACK_IMPORTED_MODULE_0__["dumpQuery"])(params)}`;
    Object(_base__WEBPACK_IMPORTED_MODULE_1__["openAuthPage"])(url, config.redirect_uri);
  },

  authorized(raw) {
    const data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["loadQuery"])(raw);

    if (data.access_token) {
      this.config.set({
        uid: data.uid,
        token: data.access_token
      });
    }
  },

  checkAuth(url) {
    const redirectUri = `${config.redirect_uri}#`;

    if (url.startsWith(redirectUri)) {
      this.authorized(url.slice(redirectUri.length));
      this.checkSync();
      return true;
    }
  },

  revoke() {
    this.config.set({
      uid: null,
      token: null
    });
    return this.prepare();
  }

});
Object(_base__WEBPACK_IMPORTED_MODULE_1__["register"])(Dropbox);

function normalize(item) {
  return {
    name: item.name,
    size: item.size,
    uri: Object(_base__WEBPACK_IMPORTED_MODULE_1__["getURI"])(item.name) // modified: new Date(item.server_modified).getTime(),
    // isDeleted: item.is_deleted,

  };
}

/***/ }),

/***/ "./src/background/sync/googledrive.js":
/*!********************************************!*\
  !*** ./src/background/sync/googledrive.js ***!
  \********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/background/utils/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");
// Reference:
// - https://developers.google.com/drive/v3/reference/files
// - https://github.com/google/google-api-nodejs-client




const config = {
  client_id: undefined,
  client_secret: undefined,
  redirect_uri: 'https://violentmonkey.github.io/auth_googledrive.html',
  scope: 'https://www.googleapis.com/auth/drive.appdata'
};
const UNAUTHORIZED = {
  status: 'UNAUTHORIZED'
};
const GoogleDrive = _base__WEBPACK_IMPORTED_MODULE_3__["BaseService"].extend({
  name: 'googledrive',
  displayName: 'Google Drive',
  urlPrefix: 'https://www.googleapis.com/drive/v3',

  refreshToken() {
    const refreshToken = this.config.get('refresh_token');
    if (!refreshToken) return Promise.reject({
      type: 'unauthorized'
    });
    return this.authorized({
      refresh_token: refreshToken,
      grant_type: 'refresh_token'
    }).then(() => this.prepare());
  },

  user() {
    const requestUser = () => this.loadData({
      url: `https://www.googleapis.com/oauth2/v3/tokeninfo?${Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])({
        access_token: this.config.get('token')
      })}`,
      responseType: 'json'
    });

    return requestUser().then(info => {
      // If access was granted with access_type=online, revoke it.
      if (info.access_type === 'online') {
        return this.loadData({
          method: 'POST',
          url: `https://accounts.google.com/o/oauth2/revoke?token=${this.config.get('token')}`,
          prefix: '',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        }).then(() => {
          Object(_utils__WEBPACK_IMPORTED_MODULE_2__["notify"])({
            title: 'Sync Upgraded',
            body: 'Please reauthorize access to your Google Drive to complete the upgradation.'
          });
          return Promise.reject('Online access revoked.');
        });
      }

      if (info.scope !== config.scope) return Promise.reject(UNAUTHORIZED);
    }).catch(res => {
      if (res === UNAUTHORIZED || res.status === 400 && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(res, 'data.error_description') === 'Invalid Value') {
        return this.refreshToken().then(requestUser);
      }

      return Promise.reject({
        type: 'error',
        data: res
      });
    });
  },

  getSyncData() {
    const params = {
      spaces: 'appDataFolder',
      fields: 'files(id,name,size)'
    };
    return this.loadData({
      url: `/files?${Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(params)}`,
      responseType: 'json'
    }).then(({
      files
    }) => {
      let metaFile;
      const remoteData = files.filter(item => {
        if (Object(_base__WEBPACK_IMPORTED_MODULE_3__["isScriptFile"])(item.name)) return true;

        if (!metaFile && item.name === this.metaFile) {
          metaFile = item;
        } else {
          this.remove(item);
        }

        return false;
      }).map(normalize).filter(item => {
        if (!item.size) {
          this.remove(item);
          return false;
        }

        return true;
      });
      const metaItem = metaFile ? normalize(metaFile) : {};
      const gotMeta = this.get(metaItem).then(data => JSON.parse(data)).catch(err => this.handleMetaError(err)).then(data => Object.assign({}, metaItem, {
        name: this.metaFile,
        uri: null,
        data
      }));
      return Promise.all([gotMeta, remoteData, this.getLocalData()]);
    });
  },

  authorize() {
    const params = {
      response_type: 'code',
      access_type: 'offline',
      client_id: config.client_id,
      redirect_uri: config.redirect_uri,
      scope: config.scope
    };
    if (!this.config.get('refresh_token')) params.prompt = 'consent';
    const url = `https://accounts.google.com/o/oauth2/v2/auth?${Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(params)}`;
    Object(_base__WEBPACK_IMPORTED_MODULE_3__["openAuthPage"])(url, config.redirect_uri);
  },

  checkAuth(url) {
    const redirectUri = `${config.redirect_uri}?code=`;

    if (url.startsWith(redirectUri)) {
      this.authState.set('authorizing');
      this.authorized({
        code: decodeURIComponent(url.split('#')[0].slice(redirectUri.length))
      }).then(() => this.checkSync());
      return true;
    }
  },

  revoke() {
    this.config.set({
      token: null,
      refresh_token: null
    });
    return this.prepare();
  },

  authorized(params) {
    return this.loadData({
      method: 'POST',
      url: 'https://www.googleapis.com/oauth2/v4/token',
      prefix: '',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(Object.assign({}, {
        client_id: config.client_id,
        client_secret: config.client_secret,
        redirect_uri: config.redirect_uri,
        grant_type: 'authorization_code'
      }, params)),
      responseType: 'json'
    }).then(data => {
      if (data.access_token) {
        const update = {
          token: data.access_token
        };

        if (data.refresh_token) {
          update.refresh_token = data.refresh_token;
        }

        this.config.set(update);
      } else {
        throw data;
      }
    });
  },

  handleMetaError: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],

  list() {
    throw new Error('Not supported');
  },

  get({
    id
  }) {
    if (!id) return Promise.reject();
    return this.loadData({
      url: `/files/${id}?alt=media`
    });
  },

  put(item, data) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_3__["getItemFilename"])(item);
    const {
      id
    } = item;
    const boundary = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getUniqId"])('violentmonkey-is-great-');
    const headers = {
      'Content-Type': `multipart/related; boundary=${boundary}`
    };
    const metadata = id ? {
      name
    } : {
      name,
      parents: ['appDataFolder']
    };
    const body = [`--${boundary}`, 'Content-Type: application/json; charset=UTF-8', '', JSON.stringify(metadata), `--${boundary}`, 'Content-Type: text/plain', '', data, `--${boundary}--`, ''].join('\r\n');
    const url = id ? `https://www.googleapis.com/upload/drive/v3/files/${id}?uploadType=multipart` : 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart';
    return this.loadData({
      url,
      body,
      headers,
      method: id ? 'PATCH' : 'POST'
    });
  },

  remove({
    id
  }) {
    return this.loadData({
      method: 'DELETE',
      url: `/files/${id}`
    });
  }

});
Object(_base__WEBPACK_IMPORTED_MODULE_3__["register"])(GoogleDrive);

function normalize(item) {
  return {
    id: item.id,
    name: item.name,
    size: +item.size,
    uri: Object(_base__WEBPACK_IMPORTED_MODULE_3__["getURI"])(item.name)
  };
}

/***/ }),

/***/ "./src/background/sync/index.js":
/*!**************************************!*\
  !*** ./src/background/sync/index.js ***!
  \**************************************/
/*! exports provided: initialize, sync, getStates, authorize, revoke */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initialize", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["initialize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sync", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["sync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStates", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["getStates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "authorize", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["authorize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "revoke", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["revoke"]; });

/* harmony import */ var _dropbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dropbox */ "./src/background/sync/dropbox.js");
/* harmony import */ var _onedrive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./onedrive */ "./src/background/sync/onedrive.js");
/* harmony import */ var _googledrive__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./googledrive */ "./src/background/sync/googledrive.js");
/* harmony import */ var _webdav__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webdav */ "./src/background/sync/webdav.js");
/* harmony import */ var _utils_message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/message */ "./src/background/utils/message.js");






Object.assign(_utils_message__WEBPACK_IMPORTED_MODULE_5__["commands"], {
  SyncAuthorize: _base__WEBPACK_IMPORTED_MODULE_0__["authorize"],
  SyncRevoke: _base__WEBPACK_IMPORTED_MODULE_0__["revoke"],
  SyncStart: _base__WEBPACK_IMPORTED_MODULE_0__["sync"],
  SyncSetConfig: _base__WEBPACK_IMPORTED_MODULE_0__["setConfig"]
});


/***/ }),

/***/ "./src/background/sync/onedrive.js":
/*!*****************************************!*\
  !*** ./src/background/sync/onedrive.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/background/utils/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");
// Reference: https://dev.onedrive.com/README.htm




const config = {
  client_id: undefined,
  client_secret: undefined,
  redirect_uri: 'https://violentmonkey.github.io/auth_onedrive.html'
};
const OneDrive = _base__WEBPACK_IMPORTED_MODULE_3__["BaseService"].extend({
  name: 'onedrive',
  displayName: 'OneDrive',
  urlPrefix: 'https://api.onedrive.com/v1.0',

  refreshToken() {
    const refreshToken = this.config.get('refresh_token');
    return this.authorized({
      refresh_token: refreshToken,
      grant_type: 'refresh_token'
    }).then(() => this.prepare());
  },

  user() {
    const requestUser = () => this.loadData({
      url: '/drive',
      responseType: 'json'
    });

    return requestUser().catch(res => {
      if (res.status === 401) {
        return this.refreshToken().then(requestUser);
      }

      throw res;
    }).catch(res => {
      if (res.status === 400 && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(res, 'data.error') === 'invalid_grant') {
        return Promise.reject({
          type: 'unauthorized'
        });
      }

      return Promise.reject({
        type: 'error',
        data: res
      });
    });
  },

  handleMetaError(res) {
    if (res.status === 404) {
      var _res$headers$get;

      const header = ((_res$headers$get = res.headers.get('WWW-Authenticate')) == null ? void 0 : _res$headers$get[0]) || '';

      if (/^Bearer realm="OneDriveAPI"/.test(header)) {
        return this.refreshToken().then(() => this.getMeta());
      }

      return;
    }

    throw res;
  },

  list() {
    return this.loadData({
      url: '/drive/special/approot/children',
      responseType: 'json'
    }).then(data => data.value.filter(item => item.file && Object(_base__WEBPACK_IMPORTED_MODULE_3__["isScriptFile"])(item.name)).map(normalize));
  },

  get(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_3__["getItemFilename"])(item);
    return this.loadData({
      url: `/drive/special/approot:/${encodeURIComponent(name)}`,
      responseType: 'json'
    }).then(data => this.loadData({
      url: data['@content.downloadUrl'],
      delay: false
    }));
  },

  put(item, data) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_3__["getItemFilename"])(item);
    return this.loadData({
      method: 'PUT',
      url: `/drive/special/approot:/${encodeURIComponent(name)}:/content`,
      headers: {
        'Content-Type': 'application/octet-stream'
      },
      body: data,
      responseType: 'json'
    }).then(normalize);
  },

  remove(item) {
    // return 204
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_3__["getItemFilename"])(item);
    return this.loadData({
      method: 'DELETE',
      url: `/drive/special/approot:/${encodeURIComponent(name)}`
    }).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]);
  },

  authorize() {
    const params = {
      client_id: config.client_id,
      scope: 'onedrive.appfolder wl.offline_access',
      response_type: 'code',
      redirect_uri: config.redirect_uri
    };
    const url = `https://login.live.com/oauth20_authorize.srf?${Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(params)}`;
    Object(_base__WEBPACK_IMPORTED_MODULE_3__["openAuthPage"])(url, config.redirect_uri);
  },

  checkAuth(url) {
    const redirectUri = `${config.redirect_uri}?code=`;

    if (url.startsWith(redirectUri)) {
      this.authState.set('authorizing');
      this.authorized({
        code: url.slice(redirectUri.length)
      }).then(() => this.checkSync());
      return true;
    }
  },

  revoke() {
    this.config.set({
      uid: null,
      token: null,
      refresh_token: null
    });
    return this.prepare();
  },

  authorized(params) {
    return this.loadData({
      method: 'POST',
      url: 'https://login.live.com/oauth20_token.srf',
      prefix: '',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(Object.assign({}, {
        client_id: config.client_id,
        client_secret: config.client_secret,
        redirect_uri: config.redirect_uri,
        grant_type: 'authorization_code'
      }, params)),
      responseType: 'json'
    }).then(data => {
      if (data.access_token) {
        this.config.set({
          uid: data.user_id,
          token: data.access_token,
          refresh_token: data.refresh_token
        });
      } else {
        throw data;
      }
    });
  }

});
Object(_base__WEBPACK_IMPORTED_MODULE_3__["register"])(OneDrive);

function normalize(item) {
  return {
    name: item.name,
    size: item.size,
    uri: Object(_base__WEBPACK_IMPORTED_MODULE_3__["getURI"])(item.name) // modified: new Date(item.lastModifiedDateTime).getTime(),

  };
}

/***/ }),

/***/ "./src/background/sync/webdav.js":
/*!***************************************!*\
  !*** ./src/background/sync/webdav.js ***!
  \***************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");


const KEY_CHILDREN = Symbol('children');

class XNode {
  constructor(node, nsMap) {
    this.node = node;
    this.nsMap = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, nsMap);
    this.parseAttrs();
    this.parseName();
  }

  static fromXML(xml) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'application/xml');
    return new XNode(doc);
  }

  parseAttrs() {
    const {
      node,
      nsMap
    } = this;
    const attrs = {};
    const {
      attributes
    } = node;

    if (attributes) {
      for (const attr of node.attributes) {
        const {
          name,
          value
        } = attr;
        if (name === 'xmlns') nsMap.$ = value;else if (name.startsWith('xmlns:')) nsMap[name.slice(6)] = value;
        attrs[name] = value;
      }
    }

    this.attrs = attrs;
  }

  parseName() {
    const {
      node,
      nsMap
    } = this;

    if (node.nodeType === 1) {
      let name = node.tagName;
      let ns = nsMap.$;

      if (name.includes(':')) {
        let prefix;
        [prefix, name] = name.split(':');
        ns = nsMap[prefix];
        if (!ns) throw new Error(`Unknown namespace: ${prefix}`);
      }

      this.name = ns + name;
    }
  }

  text() {
    const {
      node
    } = this;
    if (node) return (node.textContent || '').trim();
  }

  children() {
    if (!this[KEY_CHILDREN]) {
      const {
        node,
        nsMap
      } = this;
      this[KEY_CHILDREN] = [...node.children].map(child => new XNode(child, nsMap));
    }

    return this[KEY_CHILDREN];
  }

  map(callback) {
    return this.children().map(callback);
  }

  getCallback(callback) {
    if (typeof callback === 'string') {
      return (tagName => node => node.name === tagName)(callback);
    }

    return callback;
  }

  filter(callback) {
    return this.children().filter(this.getCallback(callback));
  }

  find(callback) {
    return this.children().find(this.getCallback(callback));
  }

  attr(key) {
    return this.attrs[key];
  }

}

const DEFAULT_CONFIG = {
  serverUrl: '',
  anonymous: false,
  username: '',
  password: ''
};
const WebDAV = _base__WEBPACK_IMPORTED_MODULE_1__["BaseService"].extend({
  name: 'webdav',
  displayName: 'WebDAV',
  properties: {
    authType: 'password',
    serverUrl: null
  },

  getUserConfig() {
    if (!this.userConfig) {
      this.userConfig = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, DEFAULT_CONFIG, {}, this.config.get('userConfig'));
    }

    return this.userConfig;
  },

  setUserConfig(config) {
    Object.assign(this.userConfig, config);
    this.config.set('userConfig', this.userConfig);
  },

  initToken() {
    var _config$serverUrl;

    this.prepareHeaders();
    const config = this.getUserConfig();
    let url = ((_config$serverUrl = config.serverUrl) == null ? void 0 : _config$serverUrl.trim()) || '';
    if (!url.includes('://')) url = `http://${url}`;
    if (!url.endsWith('/')) url += '/';

    try {
      new URL(url); // eslint-disable-line no-new
    } catch (e) {
      this.properties.serverUrl = null;
      return false;
    }

    this.properties.serverUrl = `${url}Violentmonkey/`;
    const {
      anonymous,
      username,
      password
    } = config;
    if (anonymous) return true;
    if (!username || !password) return false;
    const auth = window.btoa(`${username}:${password}`);
    this.headers.Authorization = `Basic ${auth}`;
    return true;
  },

  loadData(options) {
    // Bypassing login CSRF protection in Nextcloud / Owncloud by not sending cookies.
    // We are not using web UI and cookie authentication, so we don't have to worry about that.
    // See https://github.com/violentmonkey/violentmonkey/issues/976
    return _base__WEBPACK_IMPORTED_MODULE_1__["BaseService"].prototype.loadData.call(this, Object.assign({
      credentials: 'omit'
    }, options));
  },

  handleMetaError(res) {
    if (![404, // File not exists
    409 // Directory not exists
    ].includes(res.status)) throw res;
  },

  // Some WebDAV servers do not allow LOCK / UNLOCK

  /*
  acquireLock() {
    const { serverUrl } = this.properties;
    const createLock = () => {
      this.log('Acquire lock...');
      return this.loadData({
        method: 'LOCK',
        url: serverUrl,
        headers: {
          Timeout: `Second-${30 * 60}`,
        },
        body: `\
  <?xml version="1.0" encoding="utf-8" ?>
  <D:lockinfo xmlns:D='DAV:'>
  <D:lockscope><D:exclusive/></D:lockscope>
  <D:locktype><D:write/></D:locktype>
  </D:lockinfo>`,
      })
      .then(xml => {
        const doc = XNode.fromXML(xml);
        const lock = doc.find('DAV:prop')
        .find('DAV:lockdiscovery')
        .find('DAV:activelock')
        .find('DAV:locktoken')
        .find('DAV:href')
        .text();
        this.log('Acquired lock:', lock);
        this.config.set({
          lock,
        });
      });
    };
    const lock = this.config.get('lock');
    if (lock) {
      this.log('Refresh lock:', lock);
      return this.loadData({
        method: 'LOCK',
        url: serverUrl,
        headers: {
          If: `(<${lock}>)`,
        },
      })
      .then(() => {
        this.log('Refreshed lock:', lock);
      }, err => {
        if (err.status === 412) {
          this.log('Refresh lock error');
          this.config.set({ lock: null });
          // Precondition Failed
          return createLock();
        }
        throw err;
      });
    }
    return createLock();
  },
  releaseLock() {
    const lock = this.config.get('lock');
    if (lock) {
      const { serverUrl } = this.properties;
      this.log('Release lock:', lock);
      return this.loadData({
        method: 'UNLOCK',
        url: serverUrl,
        headers: {
          'Lock-Token': `<${lock}>`,
        },
      })
      .then(() => {
        this.log('Released lock');
      }, () => {
        this.log('Release lock error');
      })
      .then(() => {
        this.config.set({ lock: null });
      });
    }
  },
  */
  list() {
    const {
      serverUrl
    } = this.properties;

    const mkdir = () => this.loadData({
      method: 'MKCOL',
      url: serverUrl
    });

    const readdir = () => this.loadData({
      method: 'PROPFIND',
      url: serverUrl,
      headers: {
        depth: '1'
      }
    }).then(xml => {
      const doc = XNode.fromXML(xml);
      const items = doc.children()[0].map(node => {
        const prop = node.find('DAV:propstat').find('DAV:prop');
        const type = prop.find('DAV:resourcetype').find('DAV:collection') ? 'directory' : 'file';

        if (type === 'file') {
          let displayName;
          const displayNameNode = prop.find('DAV:displayname');

          if (displayNameNode !== undefined) {
            displayName = displayNameNode.text();
          } else {
            const href = node.find('DAV:href').text();
            displayName = decodeURIComponent(href.substring(href.lastIndexOf('/') + 1));
          }

          if (Object(_base__WEBPACK_IMPORTED_MODULE_1__["isScriptFile"])(displayName)) {
            const size = prop.find('DAV:getcontentlength');
            return normalize({
              name: displayName,
              size: size ? +size.text() : 0
            });
          }
        }

        return null;
      }).filter(Boolean);
      return items;
    });

    return readdir().catch(err => {
      if (err.status === 404) {
        return mkdir().then(readdir);
      }

      throw err;
    });
  },

  get(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    const {
      serverUrl
    } = this.properties;
    return this.loadData({
      url: serverUrl + name
    });
  },

  put(item, data) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    const headers = {
      'Content-Type': 'text/plain'
    };
    const lock = this.config.get('lock');
    if (lock) headers.If = `(<${lock}>)`;
    const {
      serverUrl
    } = this.properties;
    return this.loadData({
      method: 'PUT',
      url: serverUrl + name,
      body: data,
      headers
    });
  },

  remove(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    const headers = {};
    const lock = this.config.get('lock');
    if (lock) headers.If = `(<${lock}>)`;
    const {
      serverUrl
    } = this.properties;
    return this.loadData({
      method: 'DELETE',
      url: serverUrl + name,
      headers
    });
  }

});
Object(_base__WEBPACK_IMPORTED_MODULE_1__["register"])(WebDAV);

function normalize(item) {
  return {
    name: item.name,
    size: item.size,
    uri: Object(_base__WEBPACK_IMPORTED_MODULE_1__["getURI"])(item.name)
  };
}

/***/ }),

/***/ "./src/background/utils/aes-decryptor.js":
/*!***********************************************!*\
  !*** ./src/background/utils/aes-decryptor.js ***!
  \***********************************************/
/*! exports provided: AESDecryptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AESDecryptor", function() { return AESDecryptor; });
/* eslint-disable */
// refer https://github.com/video-dev/hls.js
function removePadding(buffer) {
  const outputBytes = buffer.byteLength;
  const paddingBytes = outputBytes && new DataView(buffer).getUint8(outputBytes - 1);

  if (paddingBytes) {
    return buffer.slice(0, outputBytes - paddingBytes);
  }

  return buffer;
}

const AESDecryptor = function () {
  return {
    constructor() {
      this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.sBox = new Uint32Array(256);
      this.invSBox = new Uint32Array(256); // Changes during runtime

      this.key = new Uint32Array(0);
      this.initTable();
    },

    // Using view.getUint32() also swaps the byte order.
    uint8ArrayToUint32Array_(arrayBuffer) {
      let view = new DataView(arrayBuffer);
      let newArray = new Uint32Array(4);

      for (let i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }

      return newArray;
    },

    initTable() {
      let sBox = this.sBox;
      let invSBox = this.invSBox;
      let subMix = this.subMix;
      let subMix0 = subMix[0];
      let subMix1 = subMix[1];
      let subMix2 = subMix[2];
      let subMix3 = subMix[3];
      let invSubMix = this.invSubMix;
      let invSubMix0 = invSubMix[0];
      let invSubMix1 = invSubMix[1];
      let invSubMix2 = invSubMix[2];
      let invSubMix3 = invSubMix[3];
      let d = new Uint32Array(256);
      let x = 0;
      let xi = 0;
      let i = 0;

      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x; // Compute multiplication

        let x2 = d[x];
        let x4 = d[x2];
        let x8 = d[x4]; // Compute sub/invSub bytes, mix columns tables

        let t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t; // Compute inv sub bytes, inv mix columns tables

        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t; // Compute next counter

        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    },

    expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      let key = this.uint8ArrayToUint32Array_(keyBuffer);
      let sameKey = true;
      let offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      let keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      let ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      let ksRow;
      let invKsRow;
      let keySchedule = this.keySchedule = new Uint32Array(ksRows);
      let invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      let sbox = this.sBox;
      let rcon = this.rcon;
      let invSubMix = this.invSubMix;
      let invSubMix0 = invSubMix[0];
      let invSubMix1 = invSubMix[1];
      let invSubMix2 = invSubMix[2];
      let invSubMix3 = invSubMix[3];
      let prev;
      let t;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }

        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24; // Sub word

          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff]; // Mix Rcon

          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;

        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    },

    // Adding this as a method greatly improves performance.
    networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    },

    decrypt(inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
      let nRounds = this.keySize + 6;
      let invKeySchedule = this.invKeySchedule;
      let invSBOX = this.invSBox;
      let invSubMix = this.invSubMix;
      let invSubMix0 = invSubMix[0];
      let invSubMix1 = invSubMix[1];
      let invSubMix2 = invSubMix[2];
      let invSubMix3 = invSubMix[3];
      let initVector = this.uint8ArrayToUint32Array_(aesIV);
      let initVector0 = initVector[0];
      let initVector1 = initVector[1];
      let initVector2 = initVector[2];
      let initVector3 = initVector[3];
      let inputInt32 = new Int32Array(inputArrayBuffer);
      let outputInt32 = new Int32Array(inputInt32.length);
      let t0, t1, t2, t3;
      let s0, s1, s2, s3;
      let inputWords0, inputWords1, inputWords2, inputWords3;
      let ksRow, i;
      let swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);
        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];
        ksRow = 4; // Iterate through the rounds of decryption

        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3]; // Update state

          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
          ksRow = ksRow + 4;
        } // Shift rows, sub bytes, add round key


        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3; // Write

        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3); // reset initVector to last 4 unsigned int

        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;
        offset = offset + 4;
      }

      return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
    },

    destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;
      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;
      this.rcon = undefined;
    }

  };
};

/***/ }),

/***/ "./src/background/utils/cache.js":
/*!***************************************!*\
  !*** ./src/background/utils/cache.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/cache */ "./src/common/cache.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");


const cache = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_0__["default"])({
  /* Keeping the data for one hour since chrome.storage.local is insanely slow in Chrome,
     it can takes seconds to read it when injecting tabs with a big script/value, which delays
     all other scripts in this tab and they will never be able to run at document-start. */
  lifetime: 60 * 60 * 1000
});
Object.assign(_message__WEBPACK_IMPORTED_MODULE_1__["commands"], {
  CacheLoad(data) {
    return cache.get(data) || null;
  },

  CacheHit(data) {
    cache.hit(data.key, data.lifetime);
  },

  CachePop(key) {
    return cache.pop(key) || null;
  }

});
/* harmony default export */ __webpack_exports__["default"] = (cache);

/***/ }),

/***/ "./src/background/utils/clipboard.js":
/*!*******************************************!*\
  !*** ./src/background/utils/clipboard.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");

const textarea = document.createElement('textarea');
let clipboardData;
Object.assign(_message__WEBPACK_IMPORTED_MODULE_0__["commands"], {
  SetClipboard(data) {
    clipboardData = data;
    textarea.focus();
    const ret = document.execCommand('copy', false, null);

    if (!ret && false) {
      console.warn('Copy failed!');
    }
  }

});
document.body.appendChild(textarea);
document.addEventListener('copy', e => {
  e.preventDefault();
  const {
    type,
    data
  } = clipboardData;
  e.clipboardData.setData(type || 'text/plain', data);
});

/***/ }),

/***/ "./src/background/utils/db.js":
/*!************************************!*\
  !*** ./src/background/utils/db.js ***!
  \************************************/
/*! exports provided: normalizePosition, sortScripts, getScriptById, getScript, getScripts, getValueStoresByIds, dumpValueStores, ENV_CACHE_KEYS, ENV_REQ_KEYS, ENV_VALUE_IDS, getScriptsByURL, getData, checkRemove, updateScriptInfo, parseScript, fetchResources, vacuum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizePosition", function() { return normalizePosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortScripts", function() { return sortScripts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScriptById", function() { return getScriptById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScript", function() { return getScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScripts", function() { return getScripts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValueStoresByIds", function() { return getValueStoresByIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dumpValueStores", function() { return dumpValueStores; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV_CACHE_KEYS", function() { return ENV_CACHE_KEYS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV_REQ_KEYS", function() { return ENV_REQ_KEYS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV_VALUE_IDS", function() { return ENV_VALUE_IDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScriptsByURL", function() { return getScriptsByURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getData", function() { return getData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkRemove", function() { return checkRemove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateScriptInfo", function() { return updateScriptInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseScript", function() { return parseScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchResources", function() { return fetchResources; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vacuum", function() { return vacuum; });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/common/storage */ "./src/common/storage.js");
/* harmony import */ var _plugin_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugin/events */ "./src/background/plugin/events.js");
/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./script */ "./src/background/utils/script.js");
/* harmony import */ var _tester__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tester */ "./src/background/utils/tester.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _patch_db__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./patch-db */ "./src/background/utils/patch-db.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony import */ var _storage_fetch__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./storage-fetch */ "./src/background/utils/storage-fetch.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");














const store = {};
_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].base.setDataCache(_cache__WEBPACK_IMPORTED_MODULE_13__["default"]);

_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.onDump = item => {
  store.scriptMap[item.props.id] = item;
};

Object.assign(_message__WEBPACK_IMPORTED_MODULE_9__["commands"], {
  CheckPosition: sortScripts,
  CheckRemove: checkRemove,

  /** @return {VMScript} */
  GetScript: getScript,

  /** @return {Promise<{ items: VMScript[], values? }>} */
  async ExportZip({
    values
  }) {
    const scripts = getScripts();
    const ids = scripts.map(getPropsId);
    const codeMap = await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.getMulti(ids);
    return {
      items: scripts.map(script => ({
        script,
        code: codeMap[script.props.id]
      })),
      values: values ? await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.getMulti(ids) : undefined
    };
  },

  /** @return {Promise<string>} */
  GetScriptCode(id) {
    return _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.getOne(id);
  },

  GetScriptVer(opts) {
    const script = getScript(opts);
    return script && !script.config.removed ? script.meta.version : null;
  },

  /** @return {Promise<void>} */
  MarkRemoved({
    id,
    removed
  }) {
    return updateScriptInfo(id, {
      config: {
        removed: removed ? 1 : 0
      },
      props: {
        lastModified: Date.now()
      }
    });
  },

  /** @return {Promise<number>} */
  Move({
    id,
    offset
  }) {
    const script = getScriptById(id);
    const index = store.scripts.indexOf(script);
    store.scripts.splice(index, 1);
    store.scripts.splice(index + offset, 0, script);
    return normalizePosition();
  },

  /** @return {Promise<void>} */
  async RemoveScript(id) {
    const i = store.scripts.indexOf(getScriptById(id));

    if (i >= 0) {
      store.scripts.splice(i, 1);
      await Promise.all([_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.remove(id), _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.remove(id), _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.remove(id)]);
    }

    return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])('RemoveScript', id);
  },

  ParseMeta: _script__WEBPACK_IMPORTED_MODULE_6__["parseMeta"],
  ParseScript: parseScript,

  /** @return {Promise<void>} */
  UpdateScriptInfo({
    id,
    config,
    custom
  }) {
    return updateScriptInfo(id, {
      config,
      custom,
      props: {
        lastModified: Date.now()
      }
    });
  },

  /** @return {Promise<number>} */
  Vacuum: vacuum
});
_init__WEBPACK_IMPORTED_MODULE_8__["preInitialize"].push(async () => {
  var _data$options;

  const {
    version: lastVersion
  } = await browser.storage.local.get('version');
  const version = "2.13.0.12";
  if (!lastVersion) await Object(_patch_db__WEBPACK_IMPORTED_MODULE_10__["default"])();
  if (version !== lastVersion) browser.storage.local.set({
    version
  });
  const data = await browser.storage.local.get();
  const scripts = [];
  const storeInfo = {
    id: 0,
    position: 0
  };
  const idMap = {};
  const uriMap = {};
  const mods = [];
  const resUrls = [];
  /** @this VMScriptCustom.pathMap */

  const rememberUrl = function _(url) {
    resUrls.push(this[url] || url);
  };

  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachEntry"], data, ([key, script]) => {
    _cache__WEBPACK_IMPORTED_MODULE_13__["default"].put(key, script);

    if (key.startsWith(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.prefix)) {
      var _meta$require;

      // {
      //   meta,
      //   custom,
      //   props: { id, position, uri },
      //   config: { enabled, shouldUpdate },
      // }
      const id = getInt(key.slice(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.prefix.length));

      if (!id || idMap[id]) {
        // ID conflicts!
        // Should not happen, discard duplicates.
        return;
      }

      idMap[id] = script;
      const uri = Object(_script__WEBPACK_IMPORTED_MODULE_6__["getNameURI"])(script);

      if (uriMap[uri]) {
        // Namespace conflicts!
        // Should not happen, discard duplicates.
        return;
      }

      uriMap[uri] = script;
      script.props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.props, {
        id,
        uri
      });
      script.custom = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, Object(_script__WEBPACK_IMPORTED_MODULE_6__["getDefaultCustom"])(), {}, script.custom);
      storeInfo.id = Math.max(storeInfo.id, id);
      storeInfo.position = Math.max(storeInfo.position, getInt(script.props.position));
      scripts.push(script); // listing all known resource urls in order to remove unused mod keys

      const {
        custom: {
          pathMap = {}
        } = {},
        meta = script.meta = {}
      } = script;
      meta.grant = [...new Set(meta.grant || [])]; // deduplicate

      (_meta$require = meta.require) == null ? void 0 : _meta$require.forEach(rememberUrl, pathMap);
      Object.values(meta.resources || {}).forEach(rememberUrl, pathMap);
      safeCall(rememberUrl, pathMap, meta.icon);
    } else if (key.startsWith(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].mod.prefix)) {
      mods.push(key.slice(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].mod.prefix.length));
    }
  });
  _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].mod.removeMulti(mods.filter(url => !resUrls.includes(url)));
  Object.assign(store, {
    scripts,
    storeInfo,
    scriptMap: scripts.reduce((map, item) => {
      map[item.props.id] = item;
      return map;
    }, {})
  }); // Switch defaultInjectInto from `page` to `auto` when upgrading VM2.12.7 or older

  if (version !== lastVersion && IS_FIREFOX && ((_data$options = data.options) == null ? void 0 : _data$options.defaultInjectInto) === _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["INJECT_PAGE"] && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["compareVersion"])(lastVersion, '2.12.7') <= 0) {
    Object(_options__WEBPACK_IMPORTED_MODULE_11__["setOption"])('defaultInjectInto', _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["INJECT_AUTO"]);
  }

  if (false) {}

  vacuum(data);
  return sortScripts();
});
/** @return {number} */

function getInt(val) {
  return +val || 0;
}
/** @return {?number} */


function getPropsId(script) {
  return script == null ? void 0 : script.props.id;
}
/** @return {void} */


function updateLastModified() {
  Object(_options__WEBPACK_IMPORTED_MODULE_11__["setOption"])('lastModified', Date.now());
}
/** @return {Promise<number>} */


async function normalizePosition() {
  const updates = store.scripts.filter(({
    props
  }, index) => {
    const position = index + 1;
    const res = props.position !== position;
    if (res) props.position = position;
    return res;
  });
  store.storeInfo.position = store.scripts.length;

  if (updates.length) {
    await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.dump(updates);
    updateLastModified();
  }

  return updates.length;
}
/** @return {Promise<number>} */

async function sortScripts() {
  store.scripts.sort((a, b) => getInt(a.props.position) - getInt(b.props.position));
  const changed = await normalizePosition();
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])('ScriptsUpdated', null);
  return changed;
}
/** @return {?VMScript} */

function getScriptById(id) {
  return store.scriptMap[id];
}
/** @return {?VMScript} */

function getScript({
  id,
  uri,
  meta
}) {
  let script;

  if (id) {
    script = getScriptById(id);
  } else {
    if (!uri) uri = Object(_script__WEBPACK_IMPORTED_MODULE_6__["getNameURI"])({
      meta,
      id: '@@should-have-name'
    });
    script = store.scripts.find(({
      props
    }) => uri === props.uri);
  }

  return script;
}
/** @return {VMScript[]} */

function getScripts() {
  return store.scripts.filter(script => !script.config.removed);
}
/**
 * @desc Load values for batch updates.
 * @param {number[]} ids
 * @return {Promise<Object>}
 */

function getValueStoresByIds(ids) {
  return _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.getMulti(ids);
}
/**
 * @desc Dump values for batch updates.
 * @param {Object} valueDict { id1: value1, id2: value2, ... }
 * @return {Promise<Object>}
 */

async function dumpValueStores(valueDict) {
  if (false) {}
  await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.dump(valueDict);
  return valueDict;
}
const ENV_CACHE_KEYS = 'cacheKeys';
const ENV_REQ_KEYS = 'reqKeys';
const ENV_VALUE_IDS = 'valueIds';
const GMVALUES_RE = /^GM[_.](listValues|([gs]et|delete)Value)$/;
const RUN_AT_RE = /^document-(start|body|end|idle)$/;
/**
 * @desc Get scripts to be injected to page with specific URL.
 */

async function getScriptsByURL(url, isTop) {
  const allScripts = Object(_tester__WEBPACK_IMPORTED_MODULE_7__["testBlacklist"])(url) ? [] : store.scripts.filter(script => {
    var _script$custom$nofram;

    return !script.config.removed && (isTop || !((_script$custom$nofram = script.custom.noframes) != null ? _script$custom$nofram : script.meta.noframes)) && Object(_tester__WEBPACK_IMPORTED_MODULE_7__["testScript"])(url, script);
  });
  const disabledIds = [];
  /** @namespace VMScriptByUrlData */

  const [envStart, envDelayed] = [0, 1].map(() => ({
    ids: [],

    /** @type {(VMScript & VMInjectedScript)[]} */
    scripts: [],
    [ENV_CACHE_KEYS]: [],
    [ENV_REQ_KEYS]: [],
    [ENV_VALUE_IDS]: []
  }));
  allScripts.forEach(script => {
    var _$match;

    const {
      id
    } = script.props;

    if (!script.config.enabled) {
      disabledIds.push(id);
      return;
    }

    const {
      meta,
      custom
    } = script;
    const {
      pathMap = buildPathMap(script)
    } = custom;
    const runAt = ((_$match = `${custom.runAt || meta.runAt || ''}`.match(RUN_AT_RE)) == null ? void 0 : _$match[1]) || 'end';
    const env = runAt === 'start' || runAt === 'body' ? envStart : envDelayed;
    env.ids.push(id);

    if (meta.grant.some(GMVALUES_RE.test, GMVALUES_RE)) {
      env[ENV_VALUE_IDS].push(id);
    }

    for (const [list, name] of [[meta.require, ENV_REQ_KEYS], [Object.values(meta.resources), ENV_CACHE_KEYS]]) {
      list.forEach(key => {
        key = pathMap[key] || key;

        if (!envStart[name].includes(key)) {
          env[name].push(key);
        }
      });
    }
    /** @namespace VMInjectedScript */


    env.scripts.push(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script, {
      runAt
    }));
  });

  if (envDelayed.ids.length) {
    envDelayed.promise = readEnvironmentData(envDelayed);
  }
  /** @namespace VMScriptByUrlData */


  return _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, envStart, {}, (await readEnvironmentData(envStart)), {
    disabledIds,
    envDelayed
  });
}
/**
 * Object keys == areas in `storage` module.
 * @namespace VMScriptByUrlData
 */

const STORAGE_ROUTES = Object.entries({
  cache: ENV_CACHE_KEYS,
  code: 'ids',
  require: ENV_REQ_KEYS,
  value: ENV_VALUE_IDS
});
const retriedStorageKeys = {};

async function readEnvironmentData(env, isRetry) {
  const keys = [];
  STORAGE_ROUTES.forEach(([area, srcIds]) => {
    env[srcIds].forEach(id => {
      keys.push(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"][area].getKey(id));
    });
  });
  const data = await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].base.getMulti(keys);

  for (const [area, srcIds] of STORAGE_ROUTES) {
    env[area] = {};

    for (const id of env[srcIds]) {
      const val = data[_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"][area].getKey(id)];
      env[area][id] = val;

      if (val == null && area !== 'value' && retriedStorageKeys[area + id] !== 2) {
        const err = `The "${area}" storage is missing "${id}"!`;
        const err2 = 'Vacuuming did not help. Please reinstall the affected scripts.';
        retriedStorageKeys[area + id] = isRetry ? 2 : 1;

        if (!isRetry) {
          console.warn(err, 'Vacuuming...');

          if (await vacuum()) {
            return readEnvironmentData(env, true);
          }
        }

        console.error(err, err2);
        Object(_message__WEBPACK_IMPORTED_MODULE_9__["notify"])({
          title: err,
          body: err2
        });
      }
    }
  }

  return env;
}
/**
 * @desc Get data for dashboard.
 * @return {Promise<{ scripts: VMScript[], cache: Object }>}
 */


async function getData(ids) {
  const scripts = ids ? ids.map(getScriptById) : store.scripts;
  return {
    scripts,
    cache: await getIconCache(scripts)
  };
}

function getIconCache(scripts) {
  const iconUrls = [];
  scripts.forEach(script => {
    const {
      icon
    } = script.meta;

    if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(icon)) {
      var _script$custom$pathMa;

      iconUrls.push(((_script$custom$pathMa = script.custom.pathMap) == null ? void 0 : _script$custom$pathMa[icon]) || icon);
    }
  });
  return iconUrls.length ? _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].cache.getMulti(iconUrls, undefined, _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].cache.makeDataUri) : {};
}
/** @return {number} */


function checkRemove({
  force
} = {}) {
  const now = Date.now();
  const toRemove = store.scripts.filter(script => script.config.removed && (force || now - getInt(script.props.lastModified) > _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["TIMEOUT_WEEK"]));

  if (toRemove.length) {
    store.scripts = store.scripts.filter(script => !script.config.removed);
    const ids = toRemove.map(getPropsId);
    _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.removeMulti(ids);
    _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.removeMulti(ids);
    _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.removeMulti(ids);
  }

  return toRemove.length;
}
/** @return {string} */

function getUUID() {
  const rnd = new Uint16Array(8);
  window.crypto.getRandomValues(rnd); // xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
  // We're using UUIDv4 variant 1 so N=4 and M=8
  // See format_uuid_v3or5 in https://tools.ietf.org/rfc/rfc4122.txt

  rnd[3] = rnd[3] & 0x0FFF | 0x4000; // eslint-disable-line no-bitwise

  rnd[4] = rnd[4] & 0x3FFF | 0x8000; // eslint-disable-line no-bitwise

  return '01-2-3-4-567'.replace(/\d/g, i => (rnd[i] + 0x10000).toString(16).slice(-4));
}
/**
 * @param {VMScript} script
 * @param {string} code
 * @return {Promise<VMScript[]>}
 */


async function saveScript(script, code) {
  const config = script.config || {};
  config.enabled = getInt(config.enabled);
  config.shouldUpdate = getInt(config.shouldUpdate);
  const props = script.props || {};
  let oldScript;

  if (!props.id) {
    store.storeInfo.id += 1;
    props.id = store.storeInfo.id;
  } else {
    oldScript = store.scriptMap[props.id];
  }

  props.uri = Object(_script__WEBPACK_IMPORTED_MODULE_6__["getNameURI"])(script);
  props.uuid = props.uuid || (crypto.randomUUID == null ? void 0 : crypto.randomUUID()) || getUUID(); // Do not allow script with same name and namespace

  if (store.scripts.some(({
    props: {
      id,
      uri
    } = {}
  }) => props.id !== id && props.uri === uri)) {
    throw Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgNamespaceConflict');
  }

  if (oldScript) {
    script.config = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, oldScript.config, {}, config);
    script.props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, oldScript.props, {}, props);
    const index = store.scripts.indexOf(oldScript);
    store.scripts[index] = script;
  } else {
    if (!props.position) {
      store.storeInfo.position += 1;
      props.position = store.storeInfo.position;
    } else if (store.storeInfo.position < props.position) {
      store.storeInfo.position = props.position;
    }

    script.config = config;
    script.props = props;
    store.scripts.push(script);
  }

  return Promise.all([_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.dump(script), _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.set(props.id, code)]);
}
/** @return {Promise<void>} */


async function updateScriptInfo(id, data) {
  const script = store.scriptMap[id];
  if (!script) throw null;
  script.props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.props, {}, data.props);
  script.config = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.config, {}, data.config);
  script.custom = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.custom, {}, data.custom);
  await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.dump(script);
  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["CMD_SCRIPT_UPDATE"], {
    where: {
      id
    },
    update: script
  });
}
/** @return {Promise<{ isNew?, update, where }>} */

async function parseScript(src) {
  const meta = Object(_script__WEBPACK_IMPORTED_MODULE_6__["parseMeta"])(src.code);
  if (!meta.name) throw `${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgInvalidScript')}\n${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('labelNoName')}`;
  const result = {
    update: {
      message: src.message == null ? Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgUpdated') : src.message || ''
    }
  };
  let cmd = _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["CMD_SCRIPT_UPDATE"];
  let script;
  const oldScript = await getScript({
    id: src.id,
    meta
  });

  if (oldScript) {
    if (src.isNew) throw Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgNamespaceConflict');
    script = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, oldScript);
  } else {
    ({
      script
    } = Object(_script__WEBPACK_IMPORTED_MODULE_6__["newScript"])());
    cmd = _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["CMD_SCRIPT_ADD"];
    result.isNew = true;
    result.update.message = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgInstalled');
  }

  script.config = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.config, {}, src.config, {
    removed: 0 // force reset `removed` since this is an installation

  });
  script.custom = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.custom, {}, src.custom);
  script.props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.props, {
    lastModified: Date.now(),
    lastUpdated: Date.now()
  }, src.props);
  script.meta = meta;

  if (!meta.homepageURL && !script.custom.homepageURL && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(src.from)) {
    script.custom.homepageURL = src.from;
  }

  if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(src.url)) script.custom.lastInstallURL = src.url;
  if (src.position) script.props.position = +src.position;
  buildPathMap(script, src.url);
  await saveScript(script, src.code);
  fetchResources(script, src);
  Object.assign(result.update, script, src.update);
  result.where = {
    id: script.props.id
  };
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])(cmd, result);
  _plugin_events__WEBPACK_IMPORTED_MODULE_5__["default"].emit('scriptChanged', result);
  return result;
}
/** @return {Object} */

function buildPathMap(script, base) {
  const {
    meta
  } = script;
  const baseUrl = base || script.custom.lastInstallURL;
  const pathMap = baseUrl ? [...meta.require, ...Object.values(meta.resources), meta.icon].reduce((map, key) => {
    if (key) {
      const fullUrl = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getFullUrl"])(key, baseUrl);
      if (fullUrl !== key) map[key] = fullUrl;
    }

    return map;
  }, {}) : {};
  script.custom.pathMap = pathMap;
  return pathMap;
}
/** @return {Promise<?string>} resolves to error text if `resourceCache` is absent */


async function fetchResources(script, resourceCache, reqOptions) {
  const {
    custom: {
      pathMap
    },
    meta
  } = script;

  const snatch = (url, type, validator) => {
    var _resourceCache$type;

    url = pathMap[url] || url;
    const contents = resourceCache == null ? void 0 : (_resourceCache$type = resourceCache[type]) == null ? void 0 : _resourceCache$type[url];
    return contents != null && !validator ? _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"][type].set(url, contents) && null : _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"][type].fetch(url, reqOptions, validator).catch(err => err);
  };

  const errors = await Promise.all([...meta.require.map(url => snatch(url, 'require')), ...Object.values(meta.resources).map(url => snatch(url, 'cache')), Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(meta.icon) && snatch(meta.icon, 'cache', validateImage)]);

  if (!(resourceCache == null ? void 0 : resourceCache.ignoreDepsErrors)) {
    const error = safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["trueJoin"], errors.map(formatHttpError), '\n');

    if (error) {
      const message = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgErrorFetchingResource');
      Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["CMD_SCRIPT_UPDATE"], {
        update: {
          error,
          message
        },
        where: {
          id: script.props.id
        }
      });
      return `${message}\n${error}`;
    }
  }
}
/** @return {Promise<void>} resolves on success, rejects on error */

function validateImage(url, buf, type) {
  return new Promise((resolve, reject) => {
    const blobUrl = URL.createObjectURL(new Blob([buf], {
      type
    }));

    const onDone = e => {
      URL.revokeObjectURL(blobUrl);
      if (e.type === 'load') resolve();else reject(`IMAGE_ERROR: ${url}`);
    };

    const image = new Image();
    image.onload = onDone;
    image.onerror = onDone;
    image.src = blobUrl;
  });
}

function formatHttpError(e) {
  return e && safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["trueJoin"], [e.status && `HTTP${e.status}`, e.url], ' ') || e;
}

let _vacuuming;
/**
 * @param {Object} [data]
 * @return {Promise<number>}
 */


async function vacuum(data) {
  if (_vacuuming) return _vacuuming;
  let numFixes = 0;
  let resolveSelf;
  _vacuuming = new Promise(r => {
    resolveSelf = r;
  });
  const result = {};
  const toFetch = [];
  const keysToRemove = [];
  const valueKeys = {};
  const cacheKeys = {};
  const requireKeys = {};
  const codeKeys = {};
  const mappings = [[_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value, valueKeys], [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].cache, cacheKeys], [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].require, requireKeys], [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code, codeKeys]];
  if (!data) data = await browser.storage.local.get();
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachKey"], data, key => {
    mappings.some(([substore, map]) => {
      const {
        prefix
      } = substore;

      if (key.startsWith(prefix)) {
        // -1 for untouched, 1 for touched, 2 for missing
        map[key.slice(prefix.length)] = -1;
        return true;
      }

      return false;
    });
  });

  const touch = (obj, key, scriptId) => {
    if (obj[key] < 0) {
      obj[key] = 1;
    } else if (!obj[key]) {
      obj[key] = 2 + scriptId;
    }
  };

  store.scripts.forEach(script => {
    const {
      id
    } = script.props;
    touch(codeKeys, id, id);
    touch(valueKeys, id, id);
    if (!script.custom.pathMap) buildPathMap(script);
    const {
      pathMap
    } = script.custom;

    script.meta.require.forEach(url => {
      touch(requireKeys, pathMap[url] || url, id);
    });

    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachValue"], script.meta.resources, url => {
      touch(cacheKeys, pathMap[url] || url, id);
    });
    const {
      icon
    } = script.meta;

    if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(icon)) {
      const fullUrl = pathMap[icon] || icon;
      touch(cacheKeys, fullUrl, id);
    }
  });
  mappings.forEach(([substore, map]) => {
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachEntry"], map, ([key, value]) => {
      if (value < 0) {
        // redundant value
        keysToRemove.push(substore.getKey(key));
        numFixes += 1;
      } else if (value >= 2 && substore.fetch) {
        // missing resource
        keysToRemove.push(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].mod.getKey(key));
        toFetch.push(substore.fetch(key).catch(err => `${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getScriptName"])(getScriptById(value - 2))}: ${formatHttpError(err)}`));
        numFixes += 1;
      }
    });
  });

  if (numFixes) {
    await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].base.removeMulti(keysToRemove); // Removing `mod` before fetching

    result.errors = (await Promise.all(toFetch)).filter(Boolean);
  }

  _vacuuming = null;
  result.fixes = numFixes;
  resolveSelf(result);
  return result;
}
/** @typedef VMScript
 * @property {VMScriptConfig} config
 * @property {VMScriptCustom} custom
 * @property {VMScriptMeta} meta
 * @property {VMScriptProps} props
 */

/** @typedef VMScriptConfig *
 * @property {Boolean} enabled - stored as 0 or 1
 * @property {Boolean} removed - stored as 0 or 1
 * @property {Boolean} shouldUpdate - stored as 0 or 1
 * @property {Boolean | null} notifyUpdates - stored as 0 or 1 or null (default) which means "use global setting"
 */

/** @typedef VMScriptCustom *
 * @property {string} name
 * @property {string} downloadURL
 * @property {string} homepageURL
 * @property {string} lastInstallURL
 * @property {string} updateURL
 * @property {'auto' | 'page' | 'content'} injectInto
 * @property {null | 1 | 0} noframes - null or absence == default (script's value)
 * @property {string[]} exclude
 * @property {string[]} excludeMatch
 * @property {string[]} include
 * @property {string[]} match
 * @property {boolean} origExclude
 * @property {boolean} origExcludeMatch
 * @property {boolean} origInclude
 * @property {boolean} origMatch
 * @property {Object} pathMap
 * @property {VMScriptRunAt} runAt
 */

/** @typedef VMScriptMeta *
 * @property {string} description
 * @property {string} downloadURL
 * @property {string[]} exclude
 * @property {string[]} excludeMatch
 * @property {string[]} grant
 * @property {string} homepageURL
 * @property {string} icon
 * @property {string[]} include
 * @property {'auto' | 'page' | 'content'} injectInto
 * @property {string[]} match
 * @property {string} namespace
 * @property {string} name
 * @property {boolean} noframes
 * @property {string[]} require
 * @property {Object} resources
 * @property {VMScriptRunAt} runAt
 * @property {string} supportURL
 * @property {string} version
 */

/** @typedef VMScriptProps *
 * @property {number} id
 * @property {number} lastModified
 * @property {number} lastUpdated
 * @property {number} position
 * @property {string} uri
 * @property {string} uuid
 */

/**
 * @typedef {
   'document-start' | 'document-body' | 'document-end' | 'document-idle'
 } VMScriptRunAt
 */

/***/ }),

/***/ "./src/background/utils/events.js":
/*!****************************************!*\
  !*** ./src/background/utils/events.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getEventEmitter; });
function getEventEmitter() {
  const events = {};
  return {
    on,
    off,
    fire
  };

  function on(type, func) {
    let list = events[type];

    if (!list) {
      list = [];
      events[type] = list;
    }

    list.push(func);
  }

  function off(type, func) {
    const list = events[type];

    if (list) {
      const i = list.indexOf(func);
      if (i >= 0) list.splice(i, 1);
    }
  }

  function fire(type, data) {
    const list = events[type];

    if (list) {
      list.forEach(func => {
        func(data, type);
      });
    }
  }
}

/***/ }),

/***/ "./src/background/utils/hotkeys.js":
/*!*****************************************!*\
  !*** ./src/background/utils/hotkeys.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");


_init__WEBPACK_IMPORTED_MODULE_0__["postInitialize"].push(() => {
  browser.commands.onCommand.addListener(cmd => {
    if (cmd === 'newScript') {
      _message__WEBPACK_IMPORTED_MODULE_1__["commands"].OpenEditor();
    } else {
      const route = cmd === 'settings' ? `#${cmd}` : '';
      _message__WEBPACK_IMPORTED_MODULE_1__["commands"].TabOpen({
        url: `/options/index.html${route}`
      });
    }
  });
});

/***/ }),

/***/ "./src/background/utils/icon.js":
/*!**************************************!*\
  !*** ./src/background/utils/icon.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony import */ var _tester__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tester */ "./src/background/utils/tester.js");







 // storing in `cache` only for the duration of page load in case there are 2+ identical urls

const CACHE_DURATION = 1000;
Object.assign(_message__WEBPACK_IMPORTED_MODULE_5__["commands"], {
  async GetImageData(url) {
    const key = `GetImageData:${url}`;
    return _cache__WEBPACK_IMPORTED_MODULE_3__["default"].get(key) || _cache__WEBPACK_IMPORTED_MODULE_3__["default"].put(key, loadImageData(url, {
      base64: true
    }).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]), CACHE_DURATION);
  },

  SetBadge: setBadge
}); // Firefox Android does not support such APIs, use noop

const browserAction = (() => {
  const {
    chrome
  } = global; // Using `chrome` namespace in order to skip our browser.js polyfill in Chrome

  const api = chrome.browserAction; // Suppress the "no tab id" error when setting an icon/badge as it cannot be reliably prevented

  const ignoreErrors = () => chrome.runtime.lastError; // Some methods like setBadgeText added callbacks only in Chrome 67+.


  const makeMethod = fn => (...args) => {
    try {
      safeCall(fn, api, ...args, ignoreErrors);
    } catch (e) {
      safeCall(fn, api, ...args);
    }
  };

  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectPick"])(api, ['setIcon', 'setBadgeText', 'setBadgeBackgroundColor', 'setTitle'], fn => fn ? makeMethod(fn) : _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]);
})();

const badges = {};
const KEY_IS_APPLIED = 'isApplied';
const KEY_SHOW_BADGE = 'showBadge';
const KEY_BADGE_COLOR = 'badgeColor';
const KEY_BADGE_COLOR_BLOCKED = 'badgeColorBlocked';
/** @type boolean */

let isApplied;
/** @type VMBadgeMode */

let showBadge;
/** @type string */

let badgeColor;
/** @type string */

let badgeColorBlocked;
/** @type string */

let titleBlacklisted;
/** @type string */

let titleNoninjectable; // We'll cache the icon data in Chrome as it doesn't cache the data and takes up to 40ms
// in our background page context to set the 4 icon sizes for each new tab opened

const iconCache = !IS_FIREFOX && {};
Object(_options__WEBPACK_IMPORTED_MODULE_6__["hookOptions"])(changes => {
  let v;
  const jobs = [];

  if ((v = changes[KEY_IS_APPLIED]) != null) {
    isApplied = v;
    setIcon(); // change the default icon

    jobs.push(setIcon); // change the current tabs' icons
  }

  if ((v = changes[KEY_SHOW_BADGE]) != null) {
    showBadge = v;
    jobs.push(updateBadge);
  }

  if ((v = changes[KEY_BADGE_COLOR]) && (badgeColor = v) || (v = changes[KEY_BADGE_COLOR_BLOCKED]) && (badgeColorBlocked = v)) {
    jobs.push(updateBadgeColor);
  }

  if ('blacklist' in changes) {
    jobs.push(updateState);
  }

  if (jobs.length) {
    Object(_message__WEBPACK_IMPORTED_MODULE_5__["forEachTab"])(tab => jobs.forEach(fn => fn(tab)));
  }
});
_init__WEBPACK_IMPORTED_MODULE_4__["postInitialize"].push(() => {
  isApplied = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])(KEY_IS_APPLIED);
  showBadge = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])(KEY_SHOW_BADGE);
  badgeColor = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])(KEY_BADGE_COLOR);
  badgeColorBlocked = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])(KEY_BADGE_COLOR_BLOCKED);
  titleBlacklisted = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('failureReasonBlacklisted');
  titleNoninjectable = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('failureReasonNoninjectable');
  Object(_message__WEBPACK_IMPORTED_MODULE_5__["forEachTab"])(updateState);
  if (!isApplied) setIcon(); // sets the dimmed icon as default
});
browser.tabs.onRemoved.addListener(id => {
  delete badges[id];
});
browser.tabs.onUpdated.addListener((tabId, info, tab) => {
  const {
    url
  } = info;

  if (info.status === 'loading' // at least about:newtab in Firefox may open without 'loading' status
  || info.favIconUrl && tab.url.startsWith('about:')) {
    updateState(tab, url);
  }
});

function setBadge(ids, {
  tab,
  frameId
}) {
  const tabId = tab.id;
  const data = badges[tabId] || {};

  if (!data.idMap || frameId === 0) {
    // 1) keeping data object to preserve data.blocked
    // 2) 'total' and 'unique' must match showBadge in options-defaults.js
    data.total = 0;
    data.unique = 0;
    data.idMap = {};
    badges[tabId] = data;
  }

  data.total += ids.length;

  if (ids) {
    ids.forEach(id => {
      data.idMap[id] = 1;
    });
    data.unique = Object.keys(data.idMap).length;
  }

  updateBadgeColor(tab, data);
  updateBadge(tab, data);
}

function updateBadge(tab, data = badges[tab.id]) {
  if (data) {
    browserAction.setBadgeText({
      text: `${data[showBadge] || ''}`,
      tabId: tab.id
    });
  }
}

function updateBadgeColor(tab, data = badges[tab.id]) {
  if (data) {
    browserAction.setBadgeBackgroundColor({
      color: data.blocked ? badgeColorBlocked : badgeColor,
      tabId: tab.id
    });
  }
} // Chrome 79+ uses pendingUrl while the tab connects to the newly navigated URL
// https://groups.google.com/a/chromium.org/forum/#!topic/chromium-extensions/5zu_PT0arls


function updateState(tab, url = tab.pendingUrl || tab.url) {
  const tabId = tab.id;
  const injectable = _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECTABLE_TAB_URL_RE"].test(url);
  const blacklisted = injectable ? Object(_tester__WEBPACK_IMPORTED_MODULE_7__["testBlacklist"])(url) : undefined;
  const title = blacklisted && titleBlacklisted || !injectable && titleNoninjectable || ''; // if the user unblacklisted this previously blocked tab in settings,
  // but didn't reload the tab yet, we need to restore the icon and the title

  if (title || (badges[tabId] || {}).blocked) {
    browserAction.setTitle({
      title,
      tabId
    });
    const data = title ? {
      blocked: true
    } : {};
    badges[tabId] = data;
    setIcon(tab, data);
    updateBadge(tab, data);
  }
}

async function setIcon(tab = {}, data = {}) {
  // modern Chrome and Firefox use 16/32, other browsers may still use 19/38 (e.g. Vivaldi)
  const mod = data.blocked && 'b' || !isApplied && 'w' || '';
  const iconData = {};

  for (const n of [16, 19, 32, 38]) {
    const path = `/public/images/icon${n}${mod}.png`;
    let icon = iconCache ? iconCache[path] : path;

    if (!icon) {
      icon = await loadImageData(path);
      iconCache[path] = icon;
    }

    iconData[n] = icon;
  }

  browserAction.setIcon({
    tabId: tab.id,
    [iconCache ? 'imageData' : 'path']: iconData
  });
}

function loadImageData(path, {
  base64
} = {}) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.src = path;

    img.onload = () => {
      const {
        width,
        height
      } = img;

      if (!width) {
        // FF reports 0 for SVG
        resolve(path);
        return;
      }

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      resolve(base64 ? canvas.toDataURL() : ctx.getImageData(0, 0, width, height));
    };

    img.onerror = reject;
  });
}

/***/ }),

/***/ "./src/background/utils/index.js":
/*!***************************************!*\
  !*** ./src/background/utils/index.js ***!
  \***************************************/
/*! exports provided: cache, getEventEmitter, commands, notify, broadcast, sendMessageOrIgnore, forEachTab, getOption, getDefaultOption, setOption, hookOptions, loadQuery, dumpQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cache", function() { return _cache__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ "./src/background/utils/events.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEventEmitter", function() { return _events__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "commands", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["commands"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notify", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["notify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "broadcast", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["broadcast"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sendMessageOrIgnore", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["sendMessageOrIgnore"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEachTab", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["forEachTab"]; });

/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOption", function() { return _options__WEBPACK_IMPORTED_MODULE_3__["getOption"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultOption", function() { return _options__WEBPACK_IMPORTED_MODULE_3__["getDefaultOption"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setOption", function() { return _options__WEBPACK_IMPORTED_MODULE_3__["setOption"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hookOptions", function() { return _options__WEBPACK_IMPORTED_MODULE_3__["hookOptions"]; });

/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./search */ "./src/background/utils/search.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadQuery", function() { return _search__WEBPACK_IMPORTED_MODULE_4__["loadQuery"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dumpQuery", function() { return _search__WEBPACK_IMPORTED_MODULE_4__["dumpQuery"]; });







/***/ }),

/***/ "./src/background/utils/init.js":
/*!**************************************!*\
  !*** ./src/background/utils/init.js ***!
  \**************************************/
/*! exports provided: extensionRoot, preInitialize, postInitialize, initialize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extensionRoot", function() { return extensionRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preInitialize", function() { return preInitialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "postInitialize", function() { return postInitialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialize", function() { return initialize; });
const extensionRoot = browser.runtime.getURL('/');
const preInitialize = [];
const postInitialize = [];
async function initialize(main) {
  const run = init => typeof init === 'function' ? init() : init;

  await Promise.all(preInitialize.map(run));
  await run(main);
  await Promise.all(postInitialize.map(run));
  preInitialize.length = 0;
  postInitialize.length = 0;
}

/***/ }),

/***/ "./src/background/utils/m3u8.js":
/*!**************************************!*\
  !*** ./src/background/utils/m3u8.js ***!
  \**************************************/
/*! exports provided: downloadM3u8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadM3u8", function() { return downloadM3u8; });
/* harmony import */ var jbinary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js");
/* harmony import */ var jbinary__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jbinary__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mpegts_to_mp4_mpegts_to_mp4_mpegts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mpegts_to_mp4/mpegts_to_mp4/mpegts */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/mpegts.js");
/* harmony import */ var mpegts_to_mp4_mpegts_to_mp4_mpegts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mpegts_to_mp4_mpegts_to_mp4_mpegts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mpegts_to_mp4_mpegts_to_mp4_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mpegts_to_mp4/mpegts_to_mp4/index */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/index.js");
/* harmony import */ var mpegts_to_mp4_mpegts_to_mp4_index__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mpegts_to_mp4_mpegts_to_mp4_index__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _aes_decryptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aes-decryptor */ "./src/background/utils/aes-decryptor.js");
/* eslint-disable */

/**
 * credits
 * https://github.com/Momo707577045/m3u8-downloader
 * https://github.com/shellvon/zh-downloader
 */


 // eslint-disable-line camelcase


let tsList = [];
let statusList = [];
let mediaFileList = []; // AES 

const AES = {
  method: '',
  // 
  uri: '',
  // key 
  iv: '',
  // 
  key: '',
  // 
  decryptor: null,
  // 
  stringToBuffer: function (str) {
    return new TextEncoder().encode(str);
  }
};
const downloadM3u8 = function (opts) {
  // clear
  tsList = [];
  statusList = [];
  mediaFileList = [];
  const m3u8 = opts.data[0];
  const baseUrl = opts.url;
  let limit = 5;
  m3u8.split('\n').forEach(line => {
    if (limit > 0 && tsList.length >= limit) return;

    if (line.toLowerCase().indexOf('.ts') > -1) {
      tsList.push(tsUrl(line, baseUrl));
      statusList.push({
        title: line,
        status: 'init'
      });
    }
  }); // console.log('tsList', tsList);

  if (m3u8.indexOf('#EXT-X-KEY') > -1) {
    //  AES 
    AES.method = (m3u8.match(/(.*METHOD=([^,\s]+))/) || ['', '', ''])[2];
    AES.uri = (m3u8.match(/(.*URI="([^"]+))"/) || ['', '', ''])[2];
    AES.uri = tsUrl(AES.uri, baseUrl);
    AES.iv = (m3u8.match(/(.*IV=([^,\s]+))/) || ['', '', ''])[2];
    AES.iv = AES.iv ? AES.stringToBuffer(AES.iv) : ''; // 

    getAES(() => {
      downloadTS(opts);
    });
  } else if (tsList.length > 0) {
    // 
    downloadTS(opts);
  } else {
    console.info('empty m3u8!');
  }
};

const getAES = function (callback) {
  ajax({
    url: AES.uri,
    success: key => {
      AES.key = key;
      AES.decryptor = new _aes_decryptor__WEBPACK_IMPORTED_MODULE_3__["AESDecryptor"]();
      AES.decryptor.constructor();
      AES.decryptor.expandKey(AES.key);
      callback();
    },
    fail: () => {
      console.info('');
    }
  });
};

const tsUrl = function (tsUri, baseURL) {
  if (tsUri.startsWith('http')) {
    return tsUri;
  } else if (tsUri[0] === '/') {
    let domain = baseURL.split('/');
    return domain[0] + '//' + domain[2] + tsUri;
  } else {
    let domain = baseURL.split('/');
    domain.pop();
    return domain.join('/') + '/' + tsUri;
  }
}; // ts  AES 


const decryptTs = function (data, index) {
  let iv = AES.iv || new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, index]);
  return AES.decryptor.decrypt(data, 0, iv.buffer || iv, true);
}; // 


const downloadTS = function (opts) {
  let index = 0;
  let retry = 0;

  let download = () => {
    const i = index;
    index++;

    if (i >= tsList.length) {
      // all succ
      const procList = statusList.filter(s => ['succ', 'loading'].includes(s.status));

      if (procList.length === tsList.length) {
        return;
      }

      if (retry < 5) {
        // retry again
        retry++;
        index = 0;
        setTimeout(() => download(), 1000);
        console.log('retry', retry, procList.length);
        return;
      }
    }

    console.log('download', i);

    if (statusList[i] && ['error', 'init'].includes(statusList[i].status)) {
      statusList[i].status = 'loading';
      ajax({
        url: tsList[i],
        success: data => {
          statusList[i].status = 'succ';
          dealTS(data, i, opts, () => {
            opts.onprogress(mediaFileList.length, tsList.length + 1);
            download();
          });
        },
        fail: e => {
          // let err = e.statusText
          console.log({
            e,
            i
          }); // todo: retry

          statusList[i].status = 'error';
          download();
        }
      });
    } else {
      // 
      download();
    }
  }; //  N


  for (let ii = 0; ii < 3; ii++) {
    download();
  }
};

const mp4ByJbinary = (dataChunks, callback) => {
  const blob = new Blob(dataChunks.map(data => new Uint8Array(data)), {
    type: 'video/mp2t'
  });
  jbinary__WEBPACK_IMPORTED_MODULE_0___default.a.load(blob, mpegts_to_mp4_mpegts_to_mp4_mpegts__WEBPACK_IMPORTED_MODULE_1___default.a, (err, mpegts) => {
    if (err) console.log({
      err
    });
    const start = new Date().getTime();
    const mp4Obj = mpegts_to_mp4_mpegts_to_mp4_index__WEBPACK_IMPORTED_MODULE_2___default()(mpegts);
    console.log(`Converted finished, time elapsed: ${new Date().getTime() - start}ms`);
    const data = {
      downloadLink: mp4Obj.toURI('video/mp4')
    };
    callback(data);
  });
}; //  ts AES mp4 


const dealTS = function (rawData, index, opts, callback) {
  const data = AES.uri ? decryptTs(rawData, index) : rawData;
  mediaFileList[index] = data;

  if (mediaFileList.filter(m => m || false).length === tsList.length) {
    mp4ByJbinary(mediaFileList, res => {
      chrome.downloads.download({
        url: res.downloadLink,
        filename: opts.fileName
      }, downloadId => {
        opts.onload();
        URL.revokeObjectURL(res.downloadLink);
      });
    });
  }

  callback && callback();
};

const ajax = function (options) {
  options = options || {};
  let xhr = new XMLHttpRequest();
  xhr.responseType = 'arraybuffer';

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      let status = xhr.status;

      if (status >= 200 && status < 300) {
        options.success && options.success(xhr.response);
      } else {
        options.fail && options.fail(status);
      }
    }
  };

  xhr.open("GET", options.url, true);
  xhr.send(null);
};

/***/ }),

/***/ "./src/background/utils/merge-video.js":
/*!*********************************************!*\
  !*** ./src/background/utils/merge-video.js ***!
  \*********************************************/
/*! exports provided: mergeVideo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeVideo", function() { return mergeVideo; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");


const {
  createFFmpeg,
  fetchFile
} = __webpack_require__(/*! @ffmpeg/ffmpeg */ "./node_modules/@ffmpeg/ffmpeg/src/index.js");

const {
  chrome
} = global;
let ffmpeg;

async function load() {
  if (ffmpeg) return ffmpeg;
  ffmpeg = createFFmpeg({
    corePath: '/public/lib/ffmpeg-core.js',
    log: false
  });
  await ffmpeg.load();
  console.info('ff loaded', {
    ffmpeg
  });
  return ffmpeg;
}

const merge = async (video, audio) => {
  // console.info({ video, audio });
  ffmpeg.FS('writeFile', 'video.mp4', (await fetchFile(video)));
  ffmpeg.FS('writeFile', 'audio.mp3', (await fetchFile(audio)));
  await ffmpeg.run('-i', 'video.mp4', '-i', 'audio.mp3', '-c', 'copy', 'out.mp4');
  return ffmpeg.FS('readFile', 'out.mp4');
};

async function get(opts, httpRequest, progress) {
  return new Promise((resolve, reject) => {
    opts.requests[opts.id] = {
      id: opts.id,
      tabId: opts.src.tab.id,
      eventsToNotify: ['error', 'load', 'progress'],
      xhr: new XMLHttpRequest()
    };
    opts.type = 'download';
    opts.fileName = null;
    opts.data = [];
    httpRequest(opts, opts.src, res => {
      // console.info('httpRequest', res);
      if (res.type === 'progress') {
        var _res$data, _res$data2;

        // console.info('httpRequest', res.data?.loaded, res.data?.total);
        progress((_res$data = res.data) == null ? void 0 : _res$data.loaded, (_res$data2 = res.data) == null ? void 0 : _res$data2.total);
      } else if (res.type === 'load') {
        resolve(res.data);
      } else if (res.type === 'loadend') {
        reject();
      }
    });
  });
}

async function mergeVideo(opts, httpRequest) {
  // console.info('mergeVideo', opts);
  const progress = {
    video: {
      loaded: 0,
      total: 0
    },
    audio: {
      loaded: 0,
      total: 0
    }
  };

  const onprogress = (pp, loaded, total) => {
    if (loaded && total) Object.assign(pp, {
      loaded,
      total
    });

    const _loaded = progress.video.loaded + progress.audio.loaded;

    const _total = progress.video.total + progress.audio.total;

    if (_loaded && _total) opts.onprogress(_loaded, _total + 1);
  };

  const preloads = [];
  preloads.push(load());
  const videoOpts = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(opts);
  videoOpts.requests = opts.requests;
  videoOpts.id = `${opts.id}.video`;
  preloads.push(get(videoOpts, httpRequest, (loaded, total) => {
    onprogress(progress.video, loaded, total);
  }));
  const audioOpts = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(opts);
  audioOpts.requests = opts.requests;
  audioOpts.url = opts.data[0];
  audioOpts.id = `${opts.id}.audio`;
  preloads.push(get(audioOpts, httpRequest, (loaded, total) => {
    onprogress(progress.audio, loaded, total);
  }));
  const vals = await Promise.all(preloads);

  if (!vals[1] || !vals[2]) {
    // fail
    opts.onerror();
    return;
  } // console.info({ vals });


  const out = await merge(vals[1], vals[2]); // console.info('out', { out });

  const blobConf = {};
  blobConf.type = 'video/mp4';
  const url = URL.createObjectURL(new Blob([out], blobConf)); // console.info('res', { url, filename: opts.fileName });

  chrome.downloads.download({
    url,
    filename: opts.fileName
  }, downloadId => {
    // console.info(downloadId);
    opts.onload(downloadId);
    URL.revokeObjectURL(url);
  });
}

/***/ }),

/***/ "./src/background/utils/message.js":
/*!*****************************************!*\
  !*** ./src/background/utils/message.js ***!
  \*****************************************/
/*! exports provided: commands, notify, broadcast, sendMessageOrIgnore, forEachTab */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commands", function() { return commands; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notify", function() { return notify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "broadcast", function() { return broadcast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendMessageOrIgnore", function() { return sendMessageOrIgnore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachTab", function() { return forEachTab; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");

const commands = {};
function notify(options) {
  browser.notifications.create(options.id || 'ViolentMonkey', {
    type: 'basic',
    iconUrl: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["defaultImage"],
    title: `${options.title} - ${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('extName')}`,
    message: options.body,
    isClickable: options.isClickable
  });
}
function broadcast(data) {
  forEachTab(tab => {
    browser.tabs.sendMessage(tab.id, data).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]);
  });
}
function sendMessageOrIgnore(...args) {
  return browser.runtime.sendMessage(...args).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]);
}
async function forEachTab(callback) {
  const tabs = await browser.tabs.query({});
  let i = 0;

  for (const tab of tabs) {
    callback(tab);
    i += 1; // we'll run at most this many tabs in one event loop cycle
    // because hundreds of tabs would make our extension process unresponsive,
    // the same process used by our own pages like the background page, dashboard, or popups

    if (i % 20 === 0) await new Promise(setTimeout);
  }
}

/***/ }),

/***/ "./src/background/utils/notifications.js":
/*!***********************************************!*\
  !*** ./src/background/utils/notifications.js ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");


const openers = {};
Object.assign(_message__WEBPACK_IMPORTED_MODULE_1__["commands"], {
  /** @return {Promise<string>} */
  async Notification(data, src, bgExtras) {
    const notificationId = await browser.notifications.create({
      type: 'basic',
      title: data.title || (IS_FIREFOX ? Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('extName') : ''),
      // Chrome already shows the name
      message: data.text,
      iconUrl: data.image || _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["defaultImage"]
    });
    openers[notificationId] = (bgExtras == null ? void 0 : bgExtras.onClick) || src.tab.id;
    return notificationId;
  },

  RemoveNotification(notificationId) {
    return browser.notifications.clear(notificationId);
  }

});
browser.notifications.onClicked.addListener(id => {
  const openerId = openers[id];

  if (openerId >= 0) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(openerId, 'NotificationClick', id);
  }

  if (typeof openerId === 'function') {
    openerId();
  }
});
browser.notifications.onClosed.addListener(id => {
  const openerId = openers[id];
  delete openers[id];

  if (openerId >= 0) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(openerId, 'NotificationClose', id);
  }
});

/***/ }),

/***/ "./src/background/utils/options.js":
/*!*****************************************!*\
  !*** ./src/background/utils/options.js ***!
  \*****************************************/
/*! exports provided: getOption, getDefaultOption, setOption, hookOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOption", function() { return getOption; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultOption", function() { return getDefaultOption; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOption", function() { return setOption; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hookOptions", function() { return hookOptions; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/options-defaults */ "./src/common/options-defaults.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");





Object.assign(_message__WEBPACK_IMPORTED_MODULE_4__["commands"], {
  /** @return {Object} */
  GetAllOptions() {
    return _message__WEBPACK_IMPORTED_MODULE_4__["commands"].GetOptions(_Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__["default"]);
  },

  /** @return {Object} */
  GetOptions(data) {
    return safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["mapEntry"], data, ([key]) => getOption(key));
  },

  /** @return {void} */
  SetOptions(data) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["ensureArray"])(data).forEach(item => setOption(item.key, item.value));
  }

});
let changes = {};
const hooks = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["initHooks"])();
const callHooksLater = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["debounce"])(callHooks, 100);
let options = {};
let initPending = browser.storage.local.get('options').then(({
  options: data
}) => {
  if (data && typeof data === 'object') options = data;

  if (false) {}

  if (!Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(options, 'version')) {
    setOption('version', 1);
  }

  initPending = null;
});
_init__WEBPACK_IMPORTED_MODULE_3__["preInitialize"].push(initPending);

function fireChange(keys, value) {
  // Flattening key path so the subscribers can update nested values without overwriting the parent
  const key = keys.join('.'); // Ensuring the correct order when updates were mixed like this: foo.bar=1; foo={bar:2}; foo.bar=3

  delete changes[key];
  changes[key] = value;
  callHooksLater();
}

function callHooks() {
  hooks.fire(changes);
  changes = {};
}

function getOption(key, def) {
  const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
  const mainKey = keys[0];
  let value = options[mainKey];
  if (value == null) value = _Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__["default"][mainKey];
  if (value == null) value = def;
  return keys.length > 1 ? Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(value, keys.slice(1), def) : value;
}
function getDefaultOption(key) {
  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__["default"], key);
}
function setOption(key, value) {
  if (initPending) {
    initPending.then(() => {
      setOption(key, value);
    });
    return;
  }

  const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
  const optionKey = keys.join('.');
  let optionValue = value;
  const mainKey = keys[0];

  if (mainKey in _Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    if (keys.length > 1) {
      optionValue = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(getOption(mainKey), keys.slice(1), value);
    }

    options[mainKey] = optionValue;
    browser.storage.local.set({
      options
    });
    fireChange(keys, value);

    if (false) {}
  }
}
const hookOptions = hooks.hook;

/***/ }),

/***/ "./src/background/utils/patch-db.js":
/*!******************************************!*\
  !*** ./src/background/utils/patch-db.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./script */ "./src/background/utils/script.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/storage */ "./src/common/storage.js");


/* harmony default export */ __webpack_exports__["default"] = (() => new Promise((resolve, reject) => {
  console.info('Upgrade database...');
  init();

  function init() {
    const req = indexedDB.open('Violentmonkey', 1);

    req.onsuccess = () => {
      try {
        transform(req.result);
      } catch (err) {
        // This should not happen, but did happen in Firefox.
        reject(err);
      }
    };

    req.onerror = reject;

    req.onupgradeneeded = () => {
      // No available upgradation
      reject();
    };
  }

  function transform(db) {
    const tx = db.transaction(['scripts', 'require', 'cache', 'values']);
    const updates = {};
    let processing = 3;

    const done = () => {
      processing -= 1;
      if (!processing) resolve(browser.storage.local.set(updates));
    };

    const getAll = (storeName, callback) => {
      const req = tx.objectStore(storeName).getAll();

      req.onsuccess = () => callback(req.result);

      req.onerror = reject;
    };

    getAll('scripts', allScripts => {
      const uriMap = {};
      allScripts.forEach(script => {
        const {
          code,
          id,
          uri
        } = script;
        updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].script.prefix}${id}`] = transformScript(script);
        updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].code.prefix}${id}`] = code;
        uriMap[uri] = id;
      });
      getAll('values', allValues => {
        allValues.forEach(({
          uri,
          values
        }) => {
          const id = uriMap[uri];
          if (id) updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].value.prefix}${id}`] = values;
        });
        done();
      });
    });
    getAll('cache', allCache => {
      allCache.forEach(({
        uri,
        data
      }) => {
        updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].cache.prefix}${uri}`] = data;
      });
      done();
    });
    getAll('require', allRequire => {
      allRequire.forEach(({
        uri,
        code
      }) => {
        updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].require.prefix}${uri}`] = code;
      });
      done();
    });
  }

  function transformScript(script) {
    return {
      meta: Object(_script__WEBPACK_IMPORTED_MODULE_0__["parseMeta"])(script.code),
      custom: Object.assign({
        origInclude: true,
        origExclude: true,
        origMatch: true,
        origExcludeMatch: true
      }, script.custom),
      props: {
        id: script.id,
        uri: script.uri,
        position: script.position
      },
      config: {
        enabled: script.enabled,
        shouldUpdate: script.update
      }
    };
  }
}) // Ignore error
.catch(() => {}));

/***/ }),

/***/ "./src/background/utils/popup-tracker.js":
/*!***********************************************!*\
  !*** ./src/background/utils/popup-tracker.js ***!
  \***********************************************/
/*! exports provided: popupTabs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popupTabs", function() { return popupTabs; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "./src/background/utils/db.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");





const popupTabs = {}; // { tabId: 1 }

_init__WEBPACK_IMPORTED_MODULE_3__["postInitialize"].push(() => {
  browser.runtime.onConnect.addListener(onPopupOpened);
  browser.webRequest.onBeforeRequest.addListener(prefetchSetPopup, {
    urls: [browser.runtime.getURL(browser.runtime.getManifest().browser_action.default_popup)],
    types: ['main_frame']
  });
});

function onPopupOpened(port) {
  const tabId = +port.name;
  popupTabs[tabId] = 1;
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(tabId, 'PopupShown', true);
  port.onDisconnect.addListener(onPopupClosed);
  delete _message__WEBPACK_IMPORTED_MODULE_4__["commands"].SetPopup;
}

function onPopupClosed({
  name
}) {
  delete popupTabs[name];
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(+name, 'PopupShown', false);
}

async function prefetchSetPopup() {
  const tabId = (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getActiveTab"])()).id;
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(tabId, 'PopupShown', true);

  _message__WEBPACK_IMPORTED_MODULE_4__["commands"].SetPopup = async (data, src) => {
    Object.assign(data, (await Object(_db__WEBPACK_IMPORTED_MODULE_2__["getData"])(data.ids)));
    _cache__WEBPACK_IMPORTED_MODULE_1__["default"].put('SetPopup', Object.assign({
      [src.frameId]: [data, src]
    }, _cache__WEBPACK_IMPORTED_MODULE_1__["default"].get('SetPopup')));
  };
}

/***/ }),

/***/ "./src/background/utils/preinject.js":
/*!*******************************************!*\
  !*** ./src/background/utils/preinject.js ***!
  \*******************************************/
/*! exports provided: getInjectedScripts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInjectedScripts", function() { return getInjectedScripts; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/cache */ "./src/common/cache.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/common/storage */ "./src/common/storage.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/common/ua */ "./src/common/ua.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./db */ "./src/background/utils/db.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");










const API_CONFIG = {
  urls: ['*://*/*'],
  // `*` scheme matches only http and https
  types: ['main_frame', 'sub_frame']
};
const TIME_AFTER_SEND = 10e3; // longer as establishing connection to sites may take time

const TIME_AFTER_RECEIVE = 1e3; // shorter as response body will be coming very soon

const TIME_KEEP_DATA = 60e3; // 100ms should be enough but the tab may hang or get paused in debugger

const cacheCode = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_2__["default"])({
  lifetime: TIME_KEEP_DATA
});
const cache = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_2__["default"])({
  lifetime: TIME_KEEP_DATA,
  onDispose: async promise => {
    const data = await promise;
    const rcs = await (data == null ? void 0 : data.rcsPromise);
    rcs == null ? void 0 : rcs.unregister();
  }
});
const INJECT_INTO = 'injectInto'; // KEY_XXX for hooked options

const KEY_EXPOSE = 'expose';
const KEY_DEF_INJECT_INTO = 'defaultInjectInto';
const KEY_IS_APPLIED = 'isApplied';
const KEY_XHR_INJECT = 'xhrInject';
const expose = {};
let isApplied;
let injectInto;
let xhrInject;
Object(_options__WEBPACK_IMPORTED_MODULE_9__["hookOptions"])(onOptionChanged);
_init__WEBPACK_IMPORTED_MODULE_7__["postInitialize"].push(() => {
  for (const key of [KEY_EXPOSE, KEY_DEF_INJECT_INTO, KEY_IS_APPLIED, KEY_XHR_INJECT]) {
    onOptionChanged({
      [key]: Object(_options__WEBPACK_IMPORTED_MODULE_9__["getOption"])(key)
    });
  }
});
Object.assign(_message__WEBPACK_IMPORTED_MODULE_8__["commands"], {
  async InjectionFeedback({
    feedId,
    feedback,
    forceContent
  }, src) {
    feedback.forEach(processFeedback, src);

    if (feedId) {
      // cache cleanup when getDataFF outruns GetInjected
      cache.del(feedId.cacheKey); // envDelayed

      const env = await cache.pop(feedId.envKey);

      if (env) {
        env.forceContent = forceContent;
        env.scripts.map(prepareScript, env).filter(Boolean).forEach(processFeedback, src);
        return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["objectPick"])(env, ['cache', 'scripts']);
      }
    }
  }

});
/** @this {chrome.runtime.MessageSender} */

function processFeedback([key, needsInjection]) {
  const code = cacheCode.pop(key); // see TIME_KEEP_DATA comment

  if (needsInjection && code) {
    browser.tabs.executeScript(this.tab.id, {
      code,
      frameId: this.frameId,
      runAt: 'document_start'
    });
  }
}

const propsToClear = {
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].cache.prefix]: _db__WEBPACK_IMPORTED_MODULE_6__["ENV_CACHE_KEYS"],
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.prefix]: true,
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].require.prefix]: _db__WEBPACK_IMPORTED_MODULE_6__["ENV_REQ_KEYS"],
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.prefix]: true,
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.prefix]: _db__WEBPACK_IMPORTED_MODULE_6__["ENV_VALUE_IDS"]
};
browser.storage.onChanged.addListener(async changes => {
  const dbKeys = Object.keys(changes);
  const cacheValues = await Promise.all(cache.getValues());
  const dirty = cacheValues.some(data => data.inject && dbKeys.some(key => {
    var _data$prop;

    const prefix = key.slice(0, key.indexOf(':') + 1);
    const prop = propsToClear[prefix];
    key = key.slice(prefix.length);
    return prop === true || ((_data$prop = data[prop]) == null ? void 0 : _data$prop.includes(prefix === _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.prefix ? +key : key));
  }));

  if (dirty) {
    cache.destroy();
  }
});

function normalizeRealm(value) {
  return safeCall(hasOwnProperty, _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECT_MAPPING"], value) ? value : injectInto || _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECT_AUTO"];
}

function onOptionChanged(changes) {
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachEntry"], changes, ([key, value]) => {
    switch (key) {
      case KEY_DEF_INJECT_INTO:
        injectInto = normalizeRealm(value);
        cache.destroy();
        break;

      case KEY_XHR_INJECT:
        toggleXhrInject(value);
        cache.destroy();
        break;

      case KEY_IS_APPLIED:
        togglePreinject(value);
        break;

      case KEY_EXPOSE:
        safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachEntry"], value, ([site, isExposed]) => {
          expose[decodeURIComponent(site)] = isExposed;
        });
        break;

      default:
        if (key.includes('.')) {
          // used by `expose.url`
          onOptionChanged(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["objectSet"])({}, key, value));
        }

    }
  });
}
/** @return {Promise<Object>} */


function getInjectedScripts(url, tabId, frameId, forceContent) {
  const key = getKey(url, !frameId);
  return cache.pop(key) || prepare(key, url, tabId, frameId, forceContent);
}

function getKey(url, isTop) {
  return isTop ? url : `-${url}`;
}

function togglePreinject(enable) {
  isApplied = enable; // Using onSendHeaders because onHeadersReceived in Firefox fires *after* content scripts.
  // And even in Chrome a site may be so fast that preinject on onHeadersReceived won't be useful.

  const onOff = `${enable ? 'add' : 'remove'}Listener`;
  const config = enable ? API_CONFIG : undefined;
  browser.webRequest.onSendHeaders[onOff](onSendHeaders, config);

  if (!isApplied || !xhrInject) {
    // will be registered in toggleXhrInject
    browser.webRequest.onHeadersReceived[onOff](onHeadersReceived, config);
  }

  cache.destroy();
}

function toggleXhrInject(enable) {
  xhrInject = enable;
  browser.webRequest.onHeadersReceived.removeListener(onHeadersReceived);

  if (enable) {
    browser.webRequest.onHeadersReceived.addListener(onHeadersReceived, API_CONFIG, ['blocking', 'responseHeaders', browser.webRequest.OnHeadersReceivedOptions.EXTRA_HEADERS].filter(Boolean));
  }
}

function onSendHeaders({
  url,
  tabId,
  frameId
}) {
  if (!_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECTABLE_TAB_URL_RE"].test(url)) return;
  const isTop = !frameId;
  const key = getKey(url, isTop);

  if (!cache.has(key)) {
    // GetInjected message will be sent soon by the content script
    // and it may easily happen while getScriptsByURL is still waiting for browser.storage
    // so we'll let GetInjected await this pending data by storing Promise in the cache
    cache.put(key, prepare(key, url, tabId, frameId), TIME_AFTER_SEND);
  }
}
/** @param {chrome.webRequest.WebResponseHeadersDetails} info */


function onHeadersReceived(info) {
  const key = getKey(info.url, !info.frameId);
  const data = xhrInject && cache.get(key);
  cache.hit(key, TIME_AFTER_RECEIVE);
  return (data == null ? void 0 : data.inject) && prepareXhrBlob(info, data);
}
/**
 * @param {chrome.webRequest.WebResponseHeadersDetails} info
 * @param {VMGetInjectedDataContainer} data
 */


function prepareXhrBlob({
  url,
  responseHeaders
}, data) {
  if (url.startsWith('https:') && detectStrictCsp(responseHeaders)) {
    forceContentInjection(data);
  }

  const blobUrl = URL.createObjectURL(new Blob([JSON.stringify(data.inject)]));
  responseHeaders.push({
    name: 'Set-Cookie',
    value: `"${"Violentmonkey:BWVhWPP8nIg="}"=${blobUrl.split('/').pop()}; SameSite=Lax`
  });
  setTimeout(URL.revokeObjectURL, TIME_KEEP_DATA, blobUrl);
  return {
    responseHeaders
  };
}

function prepare(key, url, tabId, frameId, forceContent) {
  /** @namespace VMGetInjectedDataContainer */
  const res = {
    /** @namespace VMGetInjectedData */
    inject: {
      expose: !frameId && url.startsWith('https://') && expose[url.split('/', 3)[2]]
    }
  };
  return isApplied ? prepareScripts(res, key, url, tabId, frameId, forceContent) : res;
}

async function prepareScripts(res, cacheKey, url, tabId, frameId, forceContent) {
  const data = await Object(_db__WEBPACK_IMPORTED_MODULE_6__["getScriptsByURL"])(url, !frameId);
  const {
    envDelayed,
    scripts
  } = data;
  const isLate = forceContent != null;
  data.forceContent = forceContent;
  const feedback = scripts.map(prepareScript, data).filter(Boolean);
  const more = envDelayed.promise;
  const envKey = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getUniqId"])(`${tabId}:${frameId}:`);
  const {
    inject
  } = res;
  /** @namespace VMGetInjectedData */

  Object.assign(inject, {
    scripts,
    [INJECT_INTO]: injectInto,
    cache: data.cache,
    feedId: {
      cacheKey,
      // InjectionFeedback cache key for cleanup when getDataFF outruns GetInjected
      envKey // InjectionFeedback cache key for envDelayed

    },
    hasMore: !!more,
    // tells content bridge to expect envDelayed
    forceContent: forceContent || // Trying to skip page sandbox when xhrInject is on:
    feedback.length === scripts.length // ...when all `envStart` scripts are `content`,
    && envDelayed.scripts.every(scr => isContentRealm(scr, forceContent)) // and `envDelayed` too.
    ,
    ids: data.disabledIds,
    // content bridge adds the actually running ids and sends via SetPopup
    info: {
      ua: _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_5__["default"]
    }
  });
  /** @namespace VMGetInjectedDataContainer */

  Object.assign(res, {
    feedback,
    valOpIds: [...data[_db__WEBPACK_IMPORTED_MODULE_6__["ENV_VALUE_IDS"]], ...envDelayed[_db__WEBPACK_IMPORTED_MODULE_6__["ENV_VALUE_IDS"]]],
    rcsPromise: !isLate && !xhrInject && IS_FIREFOX ? registerScriptDataFF(inject, url, !!frameId) : null
  });
  if (more) cache.put(envKey, more);
  cache.put(cacheKey, res); // necessary for the synchronous onHeadersReceived

  return res;
}
/** @this {VMScriptByUrlData} */


function prepareScript(script) {
  var _meta$require;

  const {
    custom,
    meta,
    props
  } = script;
  const {
    id
  } = props;
  const {
    forceContent,
    require,
    value
  } = this;
  const code = this.code[id];
  const dataKey = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getUniqId"])('VMin');
  const displayName = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getScriptName"])(script);
  const name = encodeURIComponent(displayName.replace(/[#&',/:;?@=+]/g, replaceWithFullWidthForm));
  const isContent = isContentRealm(script, forceContent);
  const pathMap = custom.pathMap || {};
  const reqs = (_meta$require = meta.require) == null ? void 0 : _meta$require.map(key => require[pathMap[key] || key]).filter(Boolean); // trying to avoid progressive string concatenation of potentially huge code slices
  // adding `;` on a new line in case some required script ends with a line comment

  const reqsSlices = reqs ? [].concat(...reqs.map(req => [req, '\n;'])) : [];
  const hasReqs = reqsSlices.length;
  const injectedCode = [// hiding module interface from @require'd scripts so they don't mistakenly use it
  `window.${dataKey}=function(${dataKey}){try{with(this)((define,module,exports)=>{`, ...reqsSlices, // adding a nested IIFE to support 'use strict' in the code when there are @requires
  hasReqs ? '(()=>{' : '', code, // adding a new line in case the code ends with a line comment
  code.endsWith('\n') ? '' : '\n', hasReqs ? '})()' : '', // 0 at the end to suppress errors about non-cloneable result of executeScript in FF
  `})()}catch(e){${dataKey}(e)}};0`, // Firefox lists .user.js among our own content scripts so a space at start will group them
  `\n//# sourceURL=${_init__WEBPACK_IMPORTED_MODULE_7__["extensionRoot"]}${IS_FIREFOX ? '%20' : ''}${name}.user.js#${id}`].join('');
  cacheCode.put(dataKey, injectedCode, TIME_KEEP_DATA);
  /** @namespace VMInjectedScript */

  Object.assign(script, {
    dataKey,
    displayName,
    // code will be `true` if the desired realm is PAGE which is not injectable
    code: isContent ? '' : forceContent || injectedCode,
    metaStr: code.match(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["METABLOCK_RE"])[1] || '',
    values: value[id] || null
  });
  return isContent && [dataKey, true];
}

function replaceWithFullWidthForm(s) {
  // fullwidth range starts at 0xFF00, normal range starts at space char code 0x20
  return String.fromCharCode(s.charCodeAt(0) - 0x20 + 0xFF00);
}

const resolveDataCodeStr = `(${function _(data) {
  /* `function` is required to compile `this`, and `this` is required because our safe-globals
   * shadows `window` so its name is minified and hence inaccessible here */
  const {
    vmResolve
  } = this;

  if (vmResolve) {
    vmResolve(data);
  } else {
    // running earlier than the main content script for whatever reason
    this.vmData = data;
  }
}})`; // TODO: rework the whole thing to register scripts individually with real `matches`

function registerScriptDataFF(inject, url, allFrames) {
  var _browser$contentScrip;

  return (_browser$contentScrip = browser.contentScripts) == null ? void 0 : _browser$contentScrip.register({
    allFrames,
    js: [{
      code: `${resolveDataCodeStr}(${JSON.stringify(inject)})`
    }],
    matches: url.split('#', 1),
    runAt: 'document_start'
  });
}
/** @param {chrome.webRequest.HttpHeader[]} responseHeaders */


function detectStrictCsp(responseHeaders) {
  return responseHeaders.some(({
    name,
    value
  }) => /^content-security-policy$/i.test(name) && /^.(?!.*'unsafe-inline')/.test( // true if not empty and without 'unsafe-inline'
  value.match(/(?:^|;)\s*script-src-elem\s[^;]+/) || value.match(/(?:^|;)\s*script-src\s[^;]+/) || value.match(/(?:^|;)\s*default-src\s[^;]+/) || ''));
}
/** @param {VMGetInjectedDataContainer} data */


function forceContentInjection(data) {
  /** @type VMGetInjectedData */
  const inject = data.inject;
  inject.forceContent = true;
  inject.scripts.forEach(scr => {
    // When script wants `page`, the result below will be `true` so the script goes into `failedIds`
    scr.code = !isContentRealm(scr, true) || '';
    data.feedback.push([scr.dataKey, true]);
  });
}

function isContentRealm(scr, forceContent) {
  const realm = scr[INJECT_INTO] || (scr[INJECT_INTO] = normalizeRealm(scr.custom[INJECT_INTO] || scr.meta[INJECT_INTO]));
  return realm === _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECT_CONTENT"] || forceContent && realm === _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECT_AUTO"];
}

/***/ }),

/***/ "./src/background/utils/requests.js":
/*!******************************************!*\
  !*** ./src/background/utils/requests.js ***!
  \******************************************/
/*! exports provided: clearRequestsByTabId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearRequestsByTabId", function() { return clearRequestsByTabId; });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/ua */ "./src/common/ua.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./script */ "./src/background/utils/script.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _m3u8__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./m3u8 */ "./src/background/utils/m3u8.js");
/* harmony import */ var _merge_video__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge-video */ "./src/background/utils/merge-video.js");










const reqHandler = {
  m3u8: _m3u8__WEBPACK_IMPORTED_MODULE_8__["downloadM3u8"],
  merge: _merge_video__WEBPACK_IMPORTED_MODULE_9__["mergeVideo"]
};
const VM_VERIFY = 'VM-Verify';
const CONFIRM_URL_BASE = `${_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"]}confirm/index.html#`;
/** @type {Object<string,VMHttpRequest>} */

const requests = {};
const downloads = {};
const verify = {};
const tabRequests = {};
const {
  chrome
} = global;
let encoder;

if (chrome) {
  chrome.downloads.onChanged.addListener(evt => {
    var _evt$state, _evt$state2;

    // console.info('downloads onChanged', evt);
    if (!downloads[evt.id]) return;
    const {
      req,
      src
    } = downloads[evt.id];
    const {
      tab: {
        id: tabId
      },
      frameId
    } = src;

    if (((_evt$state = evt.state) == null ? void 0 : _evt$state.current) === 'complete') {
      Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
        type: 'load',
        id: req.id,
        downloadId: evt.id
      }, {
        frameId
      });
    } else if (((_evt$state2 = evt.state) == null ? void 0 : _evt$state2.current) === 'interrupted') {
      Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
        type: 'error',
        id: req.id,
        downloadId: evt.id
      }, {
        frameId
      });
    } else {
      return;
    }

    delete downloads[evt.id];
    delete requests[req.id];
  });
}

Object.assign(_message__WEBPACK_IMPORTED_MODULE_7__["commands"], {
  ConfirmInstall: confirmInstall,

  async CheckInstallerTab(tabId, src) {
    const tab = IS_FIREFOX && (src.url || '').startsWith('file:') && (await browser.tabs.get(tabId).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"]));
    return tab && (tab.pendingUrl || tab.url || '').startsWith(CONFIRM_URL_BASE);
  },

  /** @return {void} */
  HttpRequest(opts, src) {
    const {
      tab: {
        id: tabId
      },
      frameId
    } = src;
    const {
      id,
      eventsToNotify
    } = opts;
    console.info('req opts', opts);

    if (reqHandler[opts.type]) {
      const downloadId = id; // fake downloadId for inject.js

      opts.src = src;
      opts.requests = requests; // needed to append req in mergeVideo

      opts.onprogress = (loaded, total) => {
        if (eventsToNotify == null ? void 0 : eventsToNotify.includes('progress')) {
          // console.info('onprogress', {loaded, total});
          Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
            type: 'progress',
            id,
            downloadId,
            loaded,
            total
          }, {
            frameId
          });
        }
      };

      opts.onload = () => {
        Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
          type: 'load',
          downloadId,
          id
        }, {
          frameId
        });
      };

      opts.onerror = error => {
        Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
          type: 'error',
          downloadId,
          id,
          error
        }, {
          frameId
        });
      };

      return reqHandler[opts.type](opts, httpRequest);
    }

    requests[id] = {
      id,
      tabId,
      eventsToNotify,
      xhr: new XMLHttpRequest()
    };
    (tabRequests[tabId] || (tabRequests[tabId] = {}))[id] = 1;
    httpRequest(opts, src, res => {
      // console.info({ res, req: requests[id] });
      if (requests[id]) {
        Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', res, {
          frameId
        });
      }
    });
  },

  /** @return {void} */
  AbortRequest(id) {
    const req = requests[id];

    if (req) {
      // eslint-disable-next-line no-undef
      if (chrome) {
        // eslint-disable-next-line no-undef
        chrome.downloads.cancel(req.id);
        delete requests[req.id];
      } else {
        req.xhr.abort();
        clearRequest(req);
      }
    }
  },

  RevokeBlob(url) {
    const timer = _cache__WEBPACK_IMPORTED_MODULE_4__["default"].pop(`xhrBlob:${url}`);

    if (timer) {
      clearTimeout(timer);
      URL.revokeObjectURL(url);
    }
  }

});
const specialHeaders = ['user-agent', // https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name
// https://cs.chromium.org/?q=file:cc+symbol:IsForbiddenHeader%5Cb
'accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via']; // const tasks = {};

const HeaderInjector = (() => {
  /** @type chrome.webRequest.RequestFilter */
  const apiFilter = {
    urls: ['<all_urls>'],
    types: ['xmlhttprequest']
  };
  const EXTRA_HEADERS = [browser.webRequest.OnBeforeSendHeadersOptions.EXTRA_HEADERS].filter(Boolean);
  const headersToInject = {};
  /** @param {chrome.webRequest.HttpHeader} header */

  const isVmVerify = header => header.name === VM_VERIFY;

  const isNotCookie = header => !/^cookie2?$/i.test(header.name);

  const isSendable = header => header.name !== VM_VERIFY;

  const isSendableAnon = header => isSendable(header) && isNotCookie(header);

  const RE_SET_COOKIE = /^set-cookie2?$/i;
  const RE_SET_COOKIE_VALUE = /^\s*(?:__(Secure|Host)-)?([^=\s]+)\s*=\s*(")?([!#-+\--:<-[\]-~]*)\3(.*)/;
  const RE_SET_COOKIE_ATTR = /\s*;?\s*(\w+)(?:=(")?([!#-+\--:<-[\]-~]*)\2)?/y;
  const SAME_SITE_MAP = {
    strict: 'strict',
    lax: 'lax',
    none: 'no_restriction'
  };
  /**
   * @param {string} headerValue
   * @param {VMHttpRequest} req
   * @param {string} url
   */

  const setCookieInStore = (headerValue, req, url) => {
    let m = RE_SET_COOKIE_VALUE.exec(headerValue);

    if (m) {
      var _opt$sameSite;

      const [, prefix, name,, value, optStr] = m;
      const opt = {};
      const isHost = prefix === 'Host';
      RE_SET_COOKIE_ATTR.lastIndex = 0;

      while (m = RE_SET_COOKIE_ATTR.exec(optStr)) {
        opt[m[1].toLowerCase()] = m[3];
      }

      const sameSite = (_opt$sameSite = opt.sameSite) == null ? void 0 : _opt$sameSite.toLowerCase();
      browser.cookies.set({
        url,
        name,
        value,
        domain: isHost ? undefined : opt.domain,
        expirationDate: Math.max(0, +new Date(opt['max-age'] * 1000 || opt.expires)) || undefined,
        httpOnly: 'httponly' in opt,
        path: isHost ? '/' : opt.path,
        sameSite: SAME_SITE_MAP[sameSite],
        secure: url.startsWith('https:') && (!!prefix || sameSite === 'none' || 'secure' in opt),
        storeId: req.storeId
      });
    }
  };

  const apiEvents = {
    onBeforeSendHeaders: {
      options: ['requestHeaders', 'blocking', ...EXTRA_HEADERS],

      /** @param {chrome.webRequest.WebRequestHeadersDetails} details */
      listener({
        requestHeaders: headers,
        requestId
      }) {
        var _headers$find;

        // only the first call during a redirect/auth chain will have VM-Verify header
        const reqId = ((_headers$find = headers.find(isVmVerify)) == null ? void 0 : _headers$find.value) || verify[requestId];
        const req = reqId && requests[reqId];

        if (reqId && req) {
          verify[requestId] = reqId;
          req.coreId = requestId;
          headers = (req.noNativeCookie ? headers.filter(isNotCookie) : headers).concat(headersToInject[reqId] || []).filter(req.anonymous ? isSendableAnon : isSendable);
        }

        return {
          requestHeaders: headers
        };
      }

    },
    onHeadersReceived: {
      options: ['responseHeaders', 'blocking', ...EXTRA_HEADERS],

      /** @param {chrome.webRequest.WebRequestHeadersDetails} details */
      listener({
        responseHeaders: headers,
        requestId,
        url
      }) {
        const req = requests[verify[requestId]];

        if (req) {
          if (req.anonymous || req.storeId) {
            headers = headers.filter(h => !RE_SET_COOKIE.test(h.name) || !req.storeId || setCookieInStore(h.value, req, url));
          }

          req.responseHeaders = headers.map(encodeWebRequestHeader).join('');
          return {
            responseHeaders: headers
          };
        }
      }

    }
  }; // Chrome 74-91 needs an extraHeaders listener at tab load start, https://crbug.com/1074282
  // We're attaching a no-op in non-blocking mode so it's very lightweight and fast.

  if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].chrome >= 74 && _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].chrome <= 91) {
    browser.webRequest.onBeforeSendHeaders.addListener(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"], apiFilter, ['extraHeaders']);
  }

  return {
    add(reqId, headers) {
      // need to set the entry even if it's empty [] so that 'if' check in del() runs only once
      headersToInject[reqId] = headers; // need the listener to get the requestId

      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], apiEvents, ([name, {
        listener,
        options
      }]) => {
        browser.webRequest[name].addListener(listener, apiFilter, options);
      });
    },

    del(reqId) {
      if (reqId in headersToInject) {
        delete headersToInject[reqId];

        if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(headersToInject)) {
          safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], apiEvents, ([name, {
            listener
          }]) => {
            browser.webRequest[name].removeListener(listener);
          });
        }
      }
    }

  };
})();
/* 1MB takes ~20ms to encode/decode so it doesn't block the process of the extension and web page,
 * which lets us and them be responsive to other events or user input. */


const CHUNK_SIZE = 1e6;

async function blob2chunk(response, index) {
  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["blob2base64"])(response, index * CHUNK_SIZE, CHUNK_SIZE);
}

function blob2objectUrl(response) {
  const url = URL.createObjectURL(response);
  _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(`xhrBlob:${url}`, setTimeout(_message__WEBPACK_IMPORTED_MODULE_7__["commands"].RevokeBlob, 60e3, url), 61e3);
  return url;
}
/** @param {VMHttpRequest} req */


function xhrCallbackWrapper(req) {
  let lastPromise = Promise.resolve();
  let contentType;
  let dataSize;
  let numChunks;
  let response;
  let responseText;
  let responseHeaders; // let sent = false;

  const {
    id,
    blobbed,
    chunked,
    xhr
  } = req; // Chrome encodes messages to UTF8 so they can grow up to 4x but 64MB is the message size limit

  const getChunk = blobbed && blob2objectUrl || chunked && blob2chunk;

  const getResponseHeaders = () => {
    const headers = req.responseHeaders || xhr.getAllResponseHeaders();

    if (responseHeaders !== headers) {
      responseHeaders = headers;
      return {
        responseHeaders
      };
    }
  };

  return evt => {
    const type = evt.type;

    if (!contentType) {
      contentType = xhr.getResponseHeader('Content-Type') || 'application/octet-stream';
    }

    if (xhr.response !== response) {
      response = xhr.response; // sent = false;

      try {
        responseText = xhr.responseText;
        if (responseText === response) responseText = ['same'];
      } catch (e) {// ignore if responseText is unreachable
      }

      if ((blobbed || chunked) && response) {
        dataSize = response.size;
        numChunks = chunked && Math.ceil(dataSize / CHUNK_SIZE) || 1;
      }
    }

    const shouldNotify = req.eventsToNotify.includes(type); // only send response when XHR is complete

    const shouldSendResponse = xhr.readyState === 4 && shouldNotify;
    lastPromise = lastPromise.then(async () => {
      if (shouldSendResponse && blobbed && req.type === 'download') {
        if (req.fileName && chrome) {
          const blobUrl = URL.createObjectURL(response);
          return chrome.downloads.download({
            url: blobUrl,
            filename: req.fileName
          }, downloadId => {
            req.cb({
              blobbed,
              chunked,
              contentType,
              dataSize,
              id,
              type,
              data: {
                finalUrl: xhr.responseURL,
                response: '',
                responseText: downloadId
              }
            });
            URL.revokeObjectURL(blobUrl);
          });
        }

        return req.cb({
          blobbed,
          chunked,
          contentType,
          dataSize,
          id,
          type,
          data: response
        });
      } // console.info({ evt });


      await req.cb({
        blobbed,
        chunked,
        contentType,
        dataSize,
        id,
        numChunks,
        type,
        data: shouldNotify && _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
          finalUrl: xhr.responseURL
        }, getResponseHeaders(), {}, Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectPick"])(xhr, ['readyState', 'status', 'statusText']), {}, 'loaded' in evt && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectPick"])(evt, ['lengthComputable', 'loaded', 'total']), {
          response: shouldSendResponse ? numChunks && (await getChunk(response, 0)) || response : null,
          responseText: shouldSendResponse ? responseText : null
        })
      });

      if (shouldSendResponse) {
        for (let i = 1; i < numChunks; i += 1) {
          await req.cb({
            id,
            chunk: {
              pos: i * CHUNK_SIZE,
              data: await getChunk(response, i),
              last: i + 1 === numChunks
            }
          });
        }
      }

      if (type === 'loadend') {
        clearRequest(req);
      }
    });
  };
}

function isSpecialHeader(lowerHeader) {
  return specialHeaders.includes(lowerHeader) || lowerHeader.startsWith('proxy-') || lowerHeader.startsWith('sec-');
}
/**
 * @param {Object} opts
 * @param {chrome.runtime.MessageSender | browser.runtime.MessageSender} src
 * @param {function} cb
 */


async function httpRequest(opts, src, cb) {
  const {
    tab
  } = src;
  const {
    incognito
  } = tab;
  const {
    anonymous,
    id,
    overrideMimeType,
    xhrType,
    url
  } = opts;
  const req = requests[id];
  if (!req || req.cb) return;
  req.cb = cb;
  req.type = opts.type;
  req.fileName = opts.fileName;
  req.anonymous = anonymous;
  const {
    xhr
  } = req;
  const vmHeaders = []; // Firefox can send Blob/ArrayBuffer directly

  const chunked = !IS_FIREFOX && incognito;
  const blobbed = xhrType && !IS_FIREFOX && !incognito;
  const [body, contentType] = decodeBody(opts.data); // Chrome can't fetch Blob URL in incognito so we use chunks

  req.blobbed = blobbed;
  req.chunked = chunked; // Firefox doesn't send cookies, https://github.com/violentmonkey/violentmonkey/issues/606
  // Both Chrome & FF need explicit routing of cookies in containers or incognito

  let shouldSendCookies = !anonymous && (incognito || IS_FIREFOX);
  xhr.open(opts.method || 'GET', url, true, opts.user || '', opts.password || '');
  xhr.setRequestHeader(VM_VERIFY, id);
  if (contentType) xhr.setRequestHeader('Content-Type', contentType);
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], opts.headers, ([name, value]) => {
    const lowerName = name.toLowerCase();

    if (isSpecialHeader(lowerName)) {
      vmHeaders.push({
        name,
        value
      });
    } else if (!lowerName.startsWith('vm-')) {
      // `VM-` headers are reserved
      xhr.setRequestHeader(name, value);
    }

    if (lowerName === 'cookie') {
      shouldSendCookies = false;
    }
  });
  xhr.responseType = (chunked || blobbed) && 'blob' || xhrType || 'text';
  xhr.timeout = Math.max(0, Math.min(0x7FFFFFFF, opts.timeout)) || 0;
  if (overrideMimeType) xhr.overrideMimeType(overrideMimeType);

  if (shouldSendCookies) {
    req.noNativeCookie = true;

    for (const store of await browser.cookies.getAllCookieStores()) {
      if (store.tabIds.includes(tab.id)) {
        if (IS_FIREFOX ? store.id !== 'firefox-default' : store.id !== '0') {
          /* Cookie routing. For the main store we rely on the browser.
           * The ids are hard-coded as `stores` may omit the main store if no such tabs are open. */
          req.storeId = store.id;
        }

        break;
      }
    }

    const now = Date.now() / 1000;
    const cookies = (await browser.cookies.getAll(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
      url,
      storeId: req.storeId
    }, _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox >= 59 && {
      firstPartyDomain: null
    }))).filter(c => c.session || c.expirationDate > now); // FF reports expired cookies!

    if (cookies.length) {
      vmHeaders.push({
        name: 'cookie',
        value: cookies.map(c => `${c.name}=${c.value};`).join(' ')
      });
    }
  }

  HeaderInjector.add(id, vmHeaders);
  const callback = xhrCallbackWrapper(req);
  req.eventsToNotify.forEach(evt => {
    xhr[`on${evt}`] = callback;
  });
  xhr.onloadend = callback; // always send it for the internal cleanup

  xhr.send(body);
}
/** @param {VMHttpRequest} req */


function clearRequest(req) {
  if (req.coreId) delete verify[req.coreId];
  delete requests[req.id];
  delete (tabRequests[req.tabId] || {})[req.id];
  HeaderInjector.del(req.id);
}
/** Polyfill for Chrome's inability to send complex types over extension messaging */


function decodeBody([body, type, wasBlob]) {
  if (type === 'query') {
    type = 'application/x-www-form-urlencoded';
  } else if (type) {
    // 5x times faster than fetch() which wastes time on inter-process communication
    const res = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["string2uint8array"])(atob(body.slice(body.indexOf(',') + 1)));

    if (!wasBlob) {
      type = body.match(/^data:(.+?);base64/)[1].replace(/(boundary=)[^;]+/, // using a function so it runs only if "boundary" was found
      (_, p1) => p1 + String.fromCharCode(...res.slice(2, res.indexOf(13))));
    }

    body = res;
  }

  return [body, type];
} // Watch URL redirects
// browser.webRequest.onBeforeRedirect.addListener(details => {
//   const reqId = verify[details.requestId];
//   if (reqId) {
//     const req = requests[reqId];
//     if (req) req.finalUrl = details.redirectUrl;
//   }
// }, {
//   urls: ['<all_urls>'],
//   types: ['xmlhttprequest'],
// });
// tasks are not necessary now, turned off
// Stop redirects
// browser.webRequest.onHeadersReceived.addListener(details => {
//   const task = tasks[details.requestId];
//   if (task) {
//     delete tasks[details.requestId];
//     if (task === 'Get-Location' && [301, 302, 303].includes(details.statusCode)) {
//       const locationHeader = details.responseHeaders.find(
//         header => header.name.toLowerCase() === 'location');
//       const base64 = locationHeader && locationHeader.value;
//       return {
//         redirectUrl: `data:text/plain;charset=utf-8,${base64 || ''}`,
//       };
//     }
//   }
// }, {
//   urls: ['<all_urls>'],
//   types: ['xmlhttprequest'],
// }, ['blocking', 'responseHeaders']);
// browser.webRequest.onCompleted.addListener(details => {
//   delete tasks[details.requestId];
// }, {
//   urls: ['<all_urls>'],
//   types: ['xmlhttprequest'],
// });
// browser.webRequest.onErrorOccurred.addListener(details => {
//   delete tasks[details.requestId];
// }, {
//   urls: ['<all_urls>'],
//   types: ['xmlhttprequest'],
// });


async function confirmInstall({
  code,
  from,
  url
}, {
  tab = {}
}) {
  if (!code) code = (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["request"])(url)).data; // TODO: display the error in UI

  if (!Object(_script__WEBPACK_IMPORTED_MODULE_5__["isUserScript"])(code)) throw Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgInvalidScript');
  _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(url, code, 3000);
  const confirmKey = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getUniqId"])();
  const {
    active,
    id: tabId,
    incognito
  } = tab; // Not testing tab.pendingUrl because it will be always equal to `url`

  const canReplaceCurTab = (!incognito || IS_FIREFOX) && (url === from || _cache__WEBPACK_IMPORTED_MODULE_4__["default"].has(`autoclose:${tabId}`) || /^(chrome:\/\/(newtab|startpage)\/|about:(home|newtab))$/.test(from));
  /** @namespace VMConfirmCache */

  _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(`confirm-${confirmKey}`, {
    incognito,
    url,
    from,
    tabId,
    ff: _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox
  });
  const confirmUrl = CONFIRM_URL_BASE + confirmKey;
  const {
    windowId
  } = canReplaceCurTab ? await browser.tabs.update(tabId, {
    url: confirmUrl
  }) : await _message__WEBPACK_IMPORTED_MODULE_7__["commands"].TabOpen({
    url: confirmUrl,
    active: !!active
  }, {
    tab
  });

  if (active && windowId !== tab.windowId) {
    await browser.windows.update(windowId, {
      focused: true
    });
  }
}

const whitelistRe = new RegExp(`^https://(${['greasyfork\\.org/scripts/%/code/', 'openuserjs\\.org/install/%/', 'github\\.com/%/%/raw/%/', 'github\\.com/%/%/releases/%/download/', 'raw\\.githubusercontent\\.com(/%){3}/', 'gist\\.github\\.com/.*?/'].join('|')})%?\\.user\\.js([?#]|$)`.replace(/%/g, '[^/]*'));
const blacklistRe = new RegExp(`^https://(${['(gist\\.)?github\\.com', 'greasyfork\\.org', 'openuserjs\\.org'].join('|')})/`);

const resolveVirtualUrl = url => `${_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"]}options/index.html#scripts/${+url.split('#')[1]}`; // FF can't intercept virtual .user.js URL via webRequest, so we redirect it explicitly


const virtualUrlRe = IS_FIREFOX && new RegExp(`^(view-source:)?(${_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"].replace('://', '$&)?')}[^/]*\\.user\\.js#\\d+`);

const maybeRedirectVirtualUrlFF = virtualUrlRe && ((tabId, src) => {
  if (virtualUrlRe.test(src)) {
    browser.tabs.update(tabId, {
      url: resolveVirtualUrl(src)
    });
  }
});

if (virtualUrlRe) {
  const listener = (tabId, {
    url
  }) => url && maybeRedirectVirtualUrlFF(tabId, url);

  const apiEvent = browser.tabs.onUpdated;
  const addListener = apiEvent.addListener.bind(apiEvent, listener);

  try {
    addListener({
      properties: ['url']
    });
  } catch (e) {
    addListener();
  }
}

browser.tabs.onCreated.addListener(tab => {
  const {
    id,
    title,
    url
  } = tab;
  /* Determining if this tab can be auto-closed (replaced, actually).
     FF>=68 allows reading file: URL only in the tab's content script so the tab must stay open. */

  if ((!url.startsWith('file:') || _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox < 68) && /\.user\.js([?#]|$)/.test(tab.pendingUrl || url)) {
    _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(`autoclose:${id}`, true, 10e3);
  }

  if (virtualUrlRe && url === 'about:blank') {
    maybeRedirectVirtualUrlFF(id, title);
  }
});
browser.webRequest.onBeforeRequest.addListener(req => {
  const {
    method,
    tabId,
    url
  } = req;

  if (method !== 'GET') {
    return;
  } // open a real URL for simplified userscript URL listed in devtools of the web page


  if (url.startsWith(_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"])) {
    return {
      redirectUrl: resolveVirtualUrl(url)
    };
  }

  if (!_cache__WEBPACK_IMPORTED_MODULE_4__["default"].has(`bypass:${url}`) && (!blacklistRe.test(url) || whitelistRe.test(url))) {
    maybeInstallUserJs(tabId, url);
    return {
      redirectUrl: 'javascript:void 0'
    }; // eslint-disable-line no-script-url
  }
}, {
  urls: [// 1. *:// comprises only http/https
  // 2. the API ignores #hash part
  // 3. Firefox: onBeforeRequest does not work with file:// or moz-extension://
  '*://*/*.user.js', '*://*/*.user.js?*', 'file://*/*.user.js', 'file://*/*.user.js?*', `${_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"]}*.user.js`],
  types: ['main_frame']
}, ['blocking']);

async function maybeInstallUserJs(tabId, url) {
  const {
    data: code
  } = (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["request"])(url).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"])) || {};

  if (code && Object(_script__WEBPACK_IMPORTED_MODULE_5__["parseMeta"])(code).name) {
    const tab = tabId >= 0 && (await browser.tabs.get(tabId)) || {};
    confirmInstall({
      code,
      url,
      from: tab.url
    }, {
      tab
    });
  } else {
    _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(`bypass:${url}`, true, 10e3);
    if (tabId >= 0) browser.tabs.update(tabId, {
      url
    });
  }
} // In Firefox with production code of Violentmonkey, scripts can be injected before `tabs.onUpdated` is fired.
// Ref: https://github.com/violentmonkey/violentmonkey/issues/1255


browser.tabs.onRemoved.addListener(tabId => {
  clearRequestsByTabId(tabId);
});
function clearRequestsByTabId(tabId) {
  const set = tabRequests[tabId];

  if (set) {
    delete tabRequests[tabId];
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], set, ([id]) => _message__WEBPACK_IMPORTED_MODULE_7__["commands"].AbortRequest(id));
  }
}
/**
 * Imitating https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
 * Per the specification https://tools.ietf.org/html/rfc7230 the header name is within ASCII,
 * but we'll try encoding it, if necessary, to handle invalid server responses.
 */

function encodeWebRequestHeader({
  name,
  value,
  binaryValue
}) {
  return `${string2byteString(name)}: ${binaryValue ? Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["buffer2string"])(binaryValue) : string2byteString(value)}\r\n`;
}
/**
 * Returns a UTF8-encoded binary string i.e. one byte per character.
 * Returns the original string in case it was already within ASCII.
 */


function string2byteString(str) {
  if (!/[\u0080-\uFFFF]/.test(str)) return str;
  if (!encoder) encoder = new TextEncoder();
  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["buffer2string"])(encoder.encode(str));
}
/** @typedef {{
  anonymous: boolean
  blobbed: boolean
  cb: function(Object)
  chunked: boolean
  coreId: number
  eventsToNotify: string[]
  id: number
  noNativeCookie: boolean
  responseHeaders: string
  storeId: string
  tabId: number
  xhr: XMLHttpRequest
}} VMHttpRequest */

/***/ }),

/***/ "./src/background/utils/script.js":
/*!****************************************!*\
  !*** ./src/background/utils/script.js ***!
  \****************************************/
/*! exports provided: isUserScript, parseMeta, getDefaultCustom, newScript, getNameURI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUserScript", function() { return isUserScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseMeta", function() { return parseMeta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultCustom", function() { return getDefaultCustom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newScript", function() { return newScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNameURI", function() { return getNameURI; });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");







Object.assign(_message__WEBPACK_IMPORTED_MODULE_4__["commands"], {
  /** @return {string} */
  CacheNewScript(data) {
    const id = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getUniqId"])();
    _cache__WEBPACK_IMPORTED_MODULE_6__["default"].put(`new-${id}`, newScript(data));
    return id;
  },

  /** @return {VMScript} */
  NewScript(id) {
    return id && _cache__WEBPACK_IMPORTED_MODULE_6__["default"].get(`new-${id}`) || newScript();
  },

  ParseMeta: parseMeta
});
function isUserScript(text) {
  if (/^\s*</.test(text)) return false; // HTML

  if (text.indexOf('// ==UserScript==') < 0) return false; // Lack of meta block

  return true;
}
const arrayType = {
  default: () => [],
  transform: (res, val) => {
    res.push(val);
    return res;
  }
};
const defaultType = {
  default: () => null,
  transform: (res, val) => res == null ? val : res
};
const metaTypes = {
  include: arrayType,
  exclude: arrayType,
  match: arrayType,
  excludeMatch: arrayType,
  require: arrayType,
  resource: {
    default: () => ({}),
    transform: (res, val) => {
      const pair = val.match(/^(\w\S*)\s+(.*)/);
      if (pair) res[pair[1]] = pair[2];
      return res;
    }
  },
  grant: arrayType,
  noframes: {
    default: () => false,
    transform: () => true
  }
};
const metaOptionalTypes = {
  antifeature: arrayType,
  compatible: arrayType,
  connect: arrayType
};
function parseMeta(code) {
  // initialize meta
  const meta = safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["mapEntry"], metaTypes, ([, value]) => value.default());
  const metaBody = code.match(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["METABLOCK_RE"])[1] || '';
  metaBody.replace(/(?:^|\n)\s*\/\/\x20(@\S+)(.*)/g, (_match, rawKey, rawValue) => {
    const [keyName, locale] = rawKey.slice(1).split(':');
    const camelKey = keyName.replace(/[-_](\w)/g, (m, g) => g.toUpperCase());
    const key = locale ? `${camelKey}:${locale.toLowerCase()}` : camelKey;
    const val = rawValue.trim();
    const metaType = metaTypes[key] || metaOptionalTypes[key] || defaultType;
    let oldValue = meta[key];
    if (typeof oldValue === 'undefined') oldValue = metaType.default();
    meta[key] = metaType.transform(oldValue, val);
  });
  meta.resources = meta.resource;
  delete meta.resource; // @homepageURL: compatible with @homepage

  if (!meta.homepageURL && meta.homepage) meta.homepageURL = meta.homepage;
  return meta;
}
function getDefaultCustom() {
  return {
    origInclude: true,
    origExclude: true,
    origMatch: true,
    origExcludeMatch: true
  };
}
function newScript(data) {
  const state = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
    url: '*://*/*',
    name: '',
    date: new Date().toLocaleString()
  }, data);

  const code = Object(_options__WEBPACK_IMPORTED_MODULE_5__["getOption"])('scriptTemplate').replace(/{{(\w+)}}/g, (str, name) => {
    const value = state[name];
    return value == null ? str : value;
  });
  const script = {
    custom: getDefaultCustom(),
    config: {
      enabled: 1,
      shouldUpdate: 1
    },
    meta: parseMeta(code),
    props: {}
  };
  return {
    script,
    code
  };
}
function getNameURI(script) {
  const ns = script.meta.namespace || '';
  const name = script.meta.name || '';
  let nameURI = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["encodeFilename"])(`${ns}\n${name}\n`);
  if (!ns && !name) nameURI += script.props.id || '';
  return nameURI;
}

/***/ }),

/***/ "./src/background/utils/search.js":
/*!****************************************!*\
  !*** ./src/background/utils/search.js ***!
  \****************************************/
/*! exports provided: loadQuery, dumpQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadQuery", function() { return loadQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dumpQuery", function() { return dumpQuery; });
function loadQuery(string) {
  return string.split('&').reduce((data, piece) => {
    const [key, val] = piece.split('=').map(decodeURIComponent);
    data[key] = val;
    return data;
  }, {});
}
function dumpQuery(dict) {
  return Object.entries(dict).map(keyVal => keyVal.map(encodeURIComponent).join('=')).join('&');
}

/***/ }),

/***/ "./src/background/utils/storage-fetch.js":
/*!***********************************************!*\
  !*** ./src/background/utils/storage-fetch.js ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/storage */ "./src/common/storage.js");



/** @type { function(url, options, check): Promise<void> } or throws on error */

_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].cache.fetch = cacheOrFetch({
  init(options) {
    return _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, options, {
      responseType: 'blob'
    });
  },

  async transform(response, url, options, check) {
    const [type, body] = await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].cache.makeRaw(response, true);
    await (check == null ? void 0 : check(url, response.data, type));
    return `${type},${body}`;
  }

});
/** @type { function(url, options): Promise<void> } or throws on error */

_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].require.fetch = cacheOrFetch({
  transform: ({
    data
  }, url) => /^\s*</.test(data) ? Promise.reject(`NOT_JS: ${url} "${data.slice(0, 100).trim().replace(/\s{2,}/g, ' ')}"`) : data
});

function cacheOrFetch(handlers = {}) {
  const requests = {};
  const {
    init,
    transform
  } = handlers;
  /** @this VMStorageBase */

  return function cacheOrFetchHandler(...args) {
    const [url] = args;
    const promise = requests[url] || (requests[url] = safeCall(doFetch, this, ...args));
    return promise;
  };
  /** @this VMStorageBase */

  async function doFetch(...args) {
    const [url, options] = args;

    try {
      const res = await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["request"])(url, (init == null ? void 0 : init(options)) || options);

      if (await isModified(res, url)) {
        const result = transform ? await transform(res, ...args) : res.data;
        await this.set(url, result);
      }
    } catch (err) {
      if (false) {}
      throw err;
    } finally {
      delete requests[url];
    }
  }
}

async function isModified({
  headers
}, url) {
  const mod = headers.get('etag') || +new Date(headers.get('last-modified')) || +new Date(headers.get('date'));

  if (!mod || mod !== (await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].mod.getOne(url))) {
    if (mod) await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].mod.set(url, mod);
    return true;
  }
}

/***/ }),

/***/ "./src/background/utils/tabs.js":
/*!**************************************!*\
  !*** ./src/background/utils/tabs.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/ua */ "./src/common/ua.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");







const openers = {};
Object.assign(_message__WEBPACK_IMPORTED_MODULE_5__["commands"], {
  /**
   * @param {string} [pathId] - path or id to add to #scripts route in dashboard,
     if absent a new script will be created for active tab's URL
   * @returns {Promise<{id: number}>}
   */
  async OpenEditor(pathId) {
    if (!pathId) {
      const {
        tab,
        domain
      } = await _message__WEBPACK_IMPORTED_MODULE_5__["commands"].GetTabDomain();
      const id = domain && _message__WEBPACK_IMPORTED_MODULE_5__["commands"].CacheNewScript({
        url: (tab.pendingUrl || tab.url).split(/[#?]/)[0],
        name: `${Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])('scriptTemplateEdited') ? '' : '- '}${domain}`
      });
      pathId = `_new${id ? `/${id}` : ''}`;
    }

    const url = `${_init__WEBPACK_IMPORTED_MODULE_4__["extensionRoot"]}options/index.html#scripts/${pathId}`; // Firefox until v56 doesn't support moz-extension:// pattern in browser.tabs.query()

    for (const view of browser.extension.getViews()) {
      if (view.location.href === url) {
        // deep-copying to avoid dead objects
        const tab = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["deepCopy"])((await view.browser.tabs.getCurrent()));
        browser.tabs.update(tab.id, {
          active: true
        });
        browser.windows.update(tab.windowId, {
          focused: true
        });
        return tab;
      }
    }

    return _message__WEBPACK_IMPORTED_MODULE_5__["commands"].TabOpen({
      url,
      maybeInWindow: true
    });
  },

  /** @return {Promise<{ id: number } | chrome.tabs.Tab>} new tab is returned for internal calls */
  async TabOpen({
    url,
    active = true,
    container,
    insert = true,
    maybeInWindow = false,
    pinned
  }, src = {}) {
    // src.tab may be absent when invoked from popup (e.g. edit/create buttons)
    const srcTab = src.tab || (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getActiveTab"])()) || {}; // src.url may be absent when invoked directly as commands.TabOpen

    const srcUrl = src.url;
    const isInternal = !srcUrl || srcUrl.startsWith(_init__WEBPACK_IMPORTED_MODULE_4__["extensionRoot"]); // only incognito storeId may be specified when opening in an incognito window

    const {
      incognito,
      windowId
    } = srcTab; // Chrome can't open chrome-xxx: URLs in incognito windows

    let storeId = srcTab.cookieStoreId;

    if (storeId && !incognito) {
      storeId = getContainerId(isInternal ? 0 : container) || storeId;
    }

    if (storeId) storeId = {
      cookieStoreId: storeId
    }; // URL needs to be expanded for `canOpenIncognito` below

    if (!/^[-\w]+:/.test(url)) {
      url = isInternal ? browser.runtime.getURL(url) : Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getFullUrl"])(url, srcUrl);
    }

    const canOpenIncognito = !incognito || IS_FIREFOX || !/^(chrome[-\w]*):/.test(url);
    let newTab;

    if (maybeInWindow && browser.windows && Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])('editorWindow')
    /* cookieStoreId in windows.create() is supported since FF64 https://bugzil.la/1393570
     * and a workaround is too convoluted to add it for such an ancient version */
    && (!storeId || _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox >= 64)) {
      const wndOpts = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        url,
        incognito: canOpenIncognito && incognito
      }, Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])('editorWindowSimple') && {
        type: 'popup'
      }, {}, !IS_FIREFOX && {
        focused: !!active
      }, {}, storeId);

      const pos = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])('editorWindowPos');
      const hasPos = pos && 'top' in pos;
      const wnd = (await browser.windows.create(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, wndOpts, {}, pos)).catch(hasPos && _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"])) || hasPos && (await browser.windows.create(wndOpts));
      newTab = wnd.tabs[0];
    }

    if (!newTab) {
      newTab = await browser.tabs.create(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        url,
        // normalizing as boolean because the API requires strict types
        active: !!active,
        pinned: !!pinned
      }, storeId, {}, canOpenIncognito && _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        windowId
      }, insert && {
        index: srcTab.index + 1
      }, {}, _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].openerTabIdSupported && {
        openerTabId: srcTab.id
      })));
    }

    const {
      id
    } = newTab;

    if (active && newTab.windowId !== windowId) {
      await browser.windows.update(newTab.windowId, {
        focused: true
      });
    }

    openers[id] = srcTab.id;
    return isInternal ? newTab : {
      id
    };
  },

  /** @return {void} */
  TabClose({
    id
  } = {}, src) {
    var _src$tab;

    const tabId = id || (src == null ? void 0 : (_src$tab = src.tab) == null ? void 0 : _src$tab.id);
    if (tabId >= 0) browser.tabs.remove(tabId);
  },

  TabFocus(_, src) {
    browser.tabs.update(src.tab.id, {
      active: true
    }).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"]);
    browser.windows.update(src.tab.windowId, {
      focused: true
    }).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"]);
  }

}); // Firefox Android does not support `openerTabId` field, it fails if this field is passed
// XXX openerTabId seems buggy on Chrome, https://crbug.com/967150
// It seems to do nothing even set successfully with `browser.tabs.update`.

_Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].ready.then(() => {
  Object.defineProperties(_Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"], {
    openerTabIdSupported: {
      value: !IS_FIREFOX || _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox >= 57 && _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].os !== 'android'
    }
  });
});
browser.tabs.onRemoved.addListener(id => {
  const openerId = openers[id];

  if (openerId >= 0) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(openerId, 'TabClosed', id);
    delete openers[id];
  }
});

function getContainerId(index) {
  return index === 0 && 'firefox-default' || index > 0 && `firefox-container-${index}`;
}

/***/ }),

/***/ "./src/background/utils/template-hook.js":
/*!***********************************************!*\
  !*** ./src/background/utils/template-hook.js ***!
  \***********************************************/
/*! exports provided: SCRIPT_TEMPLATE, resetScriptTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCRIPT_TEMPLATE", function() { return SCRIPT_TEMPLATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetScriptTemplate", function() { return resetScriptTemplate; });
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");


const SCRIPT_TEMPLATE = 'scriptTemplate';
const SCRIPT_TEMPLATE_EDITED = `${SCRIPT_TEMPLATE}Edited`;
const INITIAL_TEMPLATE = `\
// ==UserScript==
// @name New Script
// @namespace Violentmonkey Scripts
// @match {{url}}
// @grant none
// ==/UserScript==
`;
_init__WEBPACK_IMPORTED_MODULE_0__["postInitialize"].push(() => {
  let edited = Object(_options__WEBPACK_IMPORTED_MODULE_1__["getOption"])(SCRIPT_TEMPLATE_EDITED); // Preserve an edited template

  if (edited) return;
  const template = Object(_options__WEBPACK_IMPORTED_MODULE_1__["getOption"])(SCRIPT_TEMPLATE); // When updating from an old version, set the edited flag retroactively

  if (edited == null) {
    edited = template !== INITIAL_TEMPLATE;
    if (edited) Object(_options__WEBPACK_IMPORTED_MODULE_1__["setOption"])(SCRIPT_TEMPLATE_EDITED, true);else resetScriptTemplate(); // When updating VM, update to the new default template
  } else if (template !== Object(_options__WEBPACK_IMPORTED_MODULE_1__["getDefaultOption"])(SCRIPT_TEMPLATE)) {
    resetScriptTemplate();
  }
});
function resetScriptTemplate(changes = {}) {
  const defaultTemplate = Object(_options__WEBPACK_IMPORTED_MODULE_1__["getDefaultOption"])(SCRIPT_TEMPLATE);
  let template = changes[SCRIPT_TEMPLATE];

  if (!template) {
    template = defaultTemplate;
    changes[SCRIPT_TEMPLATE] = template;
    Object(_options__WEBPACK_IMPORTED_MODULE_1__["setOption"])(SCRIPT_TEMPLATE, template);
  }

  const edited = template !== defaultTemplate;

  if (edited !== changes[SCRIPT_TEMPLATE_EDITED]) {
    changes[SCRIPT_TEMPLATE_EDITED] = edited;
    Object(_options__WEBPACK_IMPORTED_MODULE_1__["setOption"])(SCRIPT_TEMPLATE_EDITED, edited);
  }
}

/***/ }),

/***/ "./src/background/utils/tester.js":
/*!****************************************!*\
  !*** ./src/background/utils/tester.js ***!
  \****************************************/
/*! exports provided: testGlob, testMatch, testScript, testBlacklist, resetBlacklist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testGlob", function() { return testGlob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testMatch", function() { return testMatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testScript", function() { return testScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testBlacklist", function() { return testBlacklist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetBlacklist", function() { return resetBlacklist; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/tld */ "./src/common/tld.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");





Object.assign(_message__WEBPACK_IMPORTED_MODULE_3__["commands"], {
  TestBlacklist: testBlacklist
});
_init__WEBPACK_IMPORTED_MODULE_2__["postInitialize"].push(resetBlacklist);
_Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["initTLD"](true);
const RE_MATCH_PARTS = /(.*?):\/\/([^/]*)\/(.*)/;
let blacklistRules = [];
Object(_options__WEBPACK_IMPORTED_MODULE_4__["hookOptions"])(changes => {
  if ('blacklist' in changes) resetBlacklist(changes.blacklist || '');
});
const RE_HTTP_OR_HTTPS = /^https?$/i;
/*
 Simple FIFO queue for the results of testBlacklist, cached separately from the main |cache|
 because the blacklist is updated only once in a while so its entries would be crowding
 the main cache and reducing its performance (objects with lots of keys are slow to access).

 We also don't need to auto-expire the entries after a timeout.
 The only limit we're concerned with is the overall memory used.
 The limit is specified in the amount of unicode characters (string length) for simplicity.
 Disregarding deduplication due to interning, the actual memory used is approximately twice as big:
 2 * keyLength + objectStructureOverhead * objectCount
*/

const MAX_BL_CACHE_LENGTH = 100e3;
let blCache = {};
let blCacheSize = 0;

function testRules(url, rules, prefix, ruleBuilder) {
  return rules.some(rule => {
    const key = `${prefix}:${rule}`;
    const matcher = _cache__WEBPACK_IMPORTED_MODULE_1__["default"].get(key) || _cache__WEBPACK_IMPORTED_MODULE_1__["default"].put(key, ruleBuilder(rule));
    return matcher.test(url);
  });
}
/**
 * Test glob rules like `@include` and `@exclude`.
 */


function testGlob(url, rules) {
  return testRules(url, rules, 're', autoReg);
}
/**
 * Test match rules like `@match` and `@exclude_match`.
 */

function testMatch(url, rules) {
  return testRules(url, rules, 'match', matchTester);
}
function testScript(url, script) {
  _cache__WEBPACK_IMPORTED_MODULE_1__["default"].batch(true);
  const {
    custom,
    meta
  } = script;
  const mat = mergeLists(custom.origMatch && meta.match, custom.match);
  const inc = mergeLists(custom.origInclude && meta.include, custom.include);
  const exc = mergeLists(custom.origExclude && meta.exclude, custom.exclude);
  const excMat = mergeLists(custom.origExcludeMatch && meta.excludeMatch, custom.excludeMatch); // match all if no @match or @include rule

  let ok = !mat.length && !inc.length; // @match

  ok = ok || testMatch(url, mat); // @include

  ok = ok || testGlob(url, inc); // @exclude-match

  ok = ok && !testMatch(url, excMat); // @exclude

  ok = ok && !testGlob(url, exc);
  _cache__WEBPACK_IMPORTED_MODULE_1__["default"].batch(false);
  return ok;
}

function mergeLists(...args) {
  return args.reduce((res, item) => item ? res.concat(item) : res, []);
}

function str2RE(str) {
  const re = str.replace(/([.?+[\]{}()|^$])/g, '\\$1').replace(/\*/g, '.*?');
  return re;
}

function bindRE(re) {
  return re.test.bind(re);
}

function autoReg(str) {
  // regexp mode: case-insensitive per GM documentation
  if (str.length > 1 && str[0] === '/' && str[str.length - 1] === '/') {
    let re;

    try {
      re = new RegExp(str.slice(1, -1), 'i');
    } catch (e) {
      /* ignore */
    }

    return {
      test: re ? bindRE(re) : () => false
    };
  } // glob mode: case-insensitive to match GM4 & Tampermonkey bugged behavior


  const reStr = str2RE(str.toLowerCase());

  if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["isReady"]() && str.includes('.tld/')) {
    const reTldStr = reStr.replace('\\.tld/', '((?:\\.[-\\w]+)+)/');
    return {
      test: tstr => {
        const matches = tstr.toLowerCase().match(reTldStr);

        if (matches) {
          const suffix = matches[1].slice(1);
          if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["getPublicSuffix"](suffix) === suffix) return true;
        }

        return false;
      }
    };
  }

  const re = new RegExp(`^${reStr}$`, 'i'); // String with wildcards

  return {
    test: bindRE(re)
  };
}

function matchScheme(rule, data) {
  // exact match
  if (rule === data) return 1; // * = http | https
  // support http*

  if (['*', 'http*'].includes(rule) && RE_HTTP_OR_HTTPS.test(data)) return 1;
  return 0;
}

const RE_STR_ANY = '(?:|.*?\\.)';
const RE_STR_TLD = '((?:\\.[-\\w]+)+)';

function hostMatcher(rule) {
  // * matches all
  if (rule === '*') {
    return () => 1;
  } // *.example.com
  // www.google.*
  // www.google.tld


  const ruleLC = rule.toLowerCase(); // host matching is case-insensitive

  let prefix = '';
  let base = ruleLC;
  let suffix = '';

  if (rule.startsWith('*.')) {
    base = base.slice(2);
    prefix = RE_STR_ANY;
  }

  if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["isReady"]() && rule.endsWith('.tld')) {
    base = base.slice(0, -4);
    suffix = RE_STR_TLD;
  }

  const re = new RegExp(`^${prefix}${str2RE(base)}${suffix}$`);
  return data => {
    // exact match, case-insensitive
    data = data.toLowerCase();
    if (ruleLC === data) return 1; // full check

    const matches = data.match(re);

    if (matches) {
      const [, tldStr] = matches;
      if (!tldStr) return 1;
      const tldSuffix = tldStr.slice(1);
      return _Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["getPublicSuffix"](tldSuffix) === tldSuffix;
    }

    return 0;
  };
}

function pathMatcher(rule) {
  const iHash = rule.indexOf('#');
  let iQuery = rule.indexOf('?');
  let strRe = str2RE(rule);
  if (iQuery > iHash) iQuery = -1;

  if (iHash < 0) {
    if (iQuery < 0) strRe = `^${strRe}(?:[?#]|$)`;else strRe = `^${strRe}(?:#|$)`;
  }

  return bindRE(new RegExp(strRe));
}

function matchTester(rule) {
  let test;

  if (rule === '<all_urls>') {
    test = () => true;
  } else {
    const ruleParts = rule.match(RE_MATCH_PARTS);

    if (ruleParts) {
      const matchHost = hostMatcher(ruleParts[2]);
      const matchPath = pathMatcher(ruleParts[3]);

      test = url => {
        const parts = url.match(RE_MATCH_PARTS);
        return !!ruleParts && !!parts && matchScheme(ruleParts[1], parts[1]) && matchHost(parts[2]) && matchPath(parts[3]);
      };
    } else {
      // Ignore invalid match rules
      test = () => false;
    }
  }

  return {
    test
  };
}

function testBlacklist(url) {
  let res = blCache[url];

  if (res === undefined) {
    const rule = blacklistRules.find(({
      test
    }) => test(url));
    res = (rule == null ? void 0 : rule.reject) && rule.text;
    updateBlacklistCache(url, res || false);
  }

  return res;
}
function resetBlacklist(list) {
  _cache__WEBPACK_IMPORTED_MODULE_1__["default"].batch(true);
  const rules = list == null ? Object(_options__WEBPACK_IMPORTED_MODULE_4__["getOption"])('blacklist') : list;

  if (false) {} // XXX compatible with {Array} list in v2.6.1-


  blacklistRules = (Array.isArray(rules) ? rules : (rules || '').split('\n')).map(text => {
    text = text.trim();
    if (!text || text.startsWith('#')) return null;
    const mode = text.startsWith('@') && text.split(/\s/, 1)[0];
    const rule = mode ? text.slice(mode.length + 1).trim() : text;
    const reject = mode !== '@include' && mode !== '@match'; // @include and @match = whitelist

    const {
      test
    } = mode === '@include' || mode === '@exclude' && autoReg(rule) || !mode && !rule.includes('/') && matchTester(`*://${rule}/*`) // domain
    || matchTester(rule); // @match and @exclude-match

    return {
      reject,
      test,
      text
    };
  }).filter(Boolean);
  blCache = {};
  blCacheSize = 0;
  _cache__WEBPACK_IMPORTED_MODULE_1__["default"].batch(false);
}

function updateBlacklistCache(key, value) {
  blCache[key] = value;
  blCacheSize += key.length;

  if (blCacheSize > MAX_BL_CACHE_LENGTH) {
    Object.keys(blCache).some(k => {
      blCacheSize -= k.length;
      delete blCache[k]; // reduce the cache to 75% so that this function doesn't run too often.

      return blCacheSize < MAX_BL_CACHE_LENGTH * 3 / 4;
    });
  }
}

/***/ }),

/***/ "./src/background/utils/update.js":
/*!****************************************!*\
  !*** ./src/background/utils/update.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "./src/background/utils/db.js");
/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./script */ "./src/background/utils/script.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");






Object.assign(_message__WEBPACK_IMPORTED_MODULE_5__["commands"], {
  /** @return {Promise<true?>} */
  async CheckUpdate(id) {
    const script = Object(_db__WEBPACK_IMPORTED_MODULE_2__["getScriptById"])(id);
    const results = await checkAllAndNotify([script]);
    return results[0];
  },

  /** @return {Promise<boolean>} */
  async CheckUpdateAll() {
    Object(_options__WEBPACK_IMPORTED_MODULE_4__["setOption"])('lastUpdate', Date.now());
    const toUpdate = Object(_db__WEBPACK_IMPORTED_MODULE_2__["getScripts"])().filter(item => item.config.shouldUpdate);
    const results = await checkAllAndNotify(toUpdate);
    return results.includes(true);
  }

});

async function checkAllAndNotify(scripts) {
  const notes = [];
  const results = await Promise.all(scripts.map(item => checkUpdate(item, notes)));

  if (notes.length === 1) {
    notify(notes[0]);
  } else if (notes.length) {
    notify({
      // FF doesn't show notifications of type:'list' so we'll use `text` everywhere
      text: notes.map(n => n.text).join('\n'),
      onClick: browser.runtime.openOptionsPage
    });
  }

  return results;
}

const processes = {}; // resolves to true if successfully updated

function checkUpdate(script, notes) {
  const {
    id
  } = script.props;
  const promise = processes[id] || (processes[id] = doCheckUpdate(script, notes));
  return promise;
}

async function doCheckUpdate(script, notes) {
  const {
    id
  } = script.props;
  let msgOk;
  let msgErr;
  let resourceOpts;

  try {
    const {
      update
    } = await Object(_db__WEBPACK_IMPORTED_MODULE_2__["parseScript"])({
      id,
      code: await downloadUpdate(script),
      update: {
        checking: false
      }
    });
    msgOk = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgScriptUpdated', [Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getScriptName"])(update)]);
    resourceOpts = {
      cache: 'no-cache'
    };
    return true;
  } catch (update) {
    msgErr = update.error; // Either proceed with normal fetch on no-update or skip it altogether on error

    resourceOpts = !update.error && !update.checking && {};
    if (false) {}
  } finally {
    if (resourceOpts && !_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["IS_DEV"]) {
      // DEVresource
      msgErr = await Object(_db__WEBPACK_IMPORTED_MODULE_2__["fetchResources"])(script, null, resourceOpts);
      if (false) {}
    }

    if (canNotify(script) && (msgOk || msgErr)) {
      notes.push({
        script,
        text: safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["trueJoin"], [msgOk, msgErr], '\n')
      });
    }

    delete processes[id];
  }
}

async function downloadUpdate({
  props: {
    id
  },
  meta,
  custom
}) {
  const downloadURL = custom.downloadURL || meta.downloadURL || custom.lastInstallURL;
  let updateURL = custom.updateURL || meta.updateURL || downloadURL;

  if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["IS_DEV"] && updateURL) {
    if (meta.dev) {
      const urls = updateURL.split('/');
      updateURL = `http://127.0.0.1:${meta.dev}/${urls[urls.length - 1]}`;
    } else {
      updateURL = null;
    } // console.info('downloadUpdate', id, updateURL);

  }

  if (!updateURL) throw false;
  let errorMessage;
  const update = {};
  const result = {
    update,
    where: {
      id
    }
  };
  announce(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgCheckingForUpdate'));

  try {
    const {
      data
    } = await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["request"])(updateURL, {
      // TODO: do a HEAD request first to get ETag header and compare to storage.mod
      cache: 'no-cache',
      headers: {
        Accept: 'text/x-userscript-meta,*/*'
      }
    });
    const {
      version
    } = Object(_script__WEBPACK_IMPORTED_MODULE_3__["parseMeta"])(data);

    if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["IS_DEV"]) {
      if (meta.version === version) throw false;
      console.info('update', meta.name, version, Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["compareVersion"])(meta.version, version));
      return data;
    }

    if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["compareVersion"])(meta.version, version) >= 0) {
      announce(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgNoUpdate'), {
        checking: false
      });
    } else if (!downloadURL) {
      announce(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgNewVersion'), {
        checking: false
      });
    } else {
      announce(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgUpdating'));
      errorMessage = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgErrorFetchingScript');
      return (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["request"])(downloadURL, {
        cache: 'no-cache'
      })).data;
    }
  } catch (error) {
    if (false) {}
    announce(errorMessage || Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgErrorFetchingUpdateInfo'), {
      error
    });
  }

  throw update;

  function announce(message, {
    error,
    checking = !error
  } = {}) {
    Object.assign(update, {
      message,
      checking,
      error: error ? `${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('genericError')} ${error.status}, ${error.url}` : null // `null` is transferable in Chrome unlike `undefined`

    });
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendCmd"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["CMD_SCRIPT_UPDATE"], result);
  }
}

function canNotify(script) {
  var _script$config$notify;

  const allowed = Object(_options__WEBPACK_IMPORTED_MODULE_4__["getOption"])('notifyUpdates');
  return Object(_options__WEBPACK_IMPORTED_MODULE_4__["getOption"])('notifyUpdatesGlobal') ? allowed : (_script$config$notify = script.config.notifyUpdates) != null ? _script$config$notify : allowed;
}

function notify({
  script,
  text,
  onClick = () => _message__WEBPACK_IMPORTED_MODULE_5__["commands"].OpenEditor(script.props.id)
}) {
  _message__WEBPACK_IMPORTED_MODULE_5__["commands"].Notification({
    text,
    // FF doesn't show the name of the extension in the title of the notification
    title: IS_FIREFOX ? `${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('titleScriptUpdated')} - ${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('extName')}` : ''
  }, undefined, {
    onClick
  });
}

/***/ }),

/***/ "./src/background/utils/values.js":
/*!****************************************!*\
  !*** ./src/background/utils/values.js ***!
  \****************************************/
/*! exports provided: resetValueOpener, addValueOpener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetValueOpener", function() { return resetValueOpener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addValueOpener", function() { return addValueOpener; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "./src/background/utils/db.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");




const openers = {}; // { scriptId: { tabId: { frameId: 1, ... }, ... } }

let cache = {}; // { scriptId: { key: { last: value, tabId: { frameId: value } } } }

let updateScheduled;
Object.assign(_message__WEBPACK_IMPORTED_MODULE_3__["commands"], {
  /** @return {Promise<Object>} */
  async GetValueStore(id) {
    const stores = await Object(_db__WEBPACK_IMPORTED_MODULE_2__["getValueStoresByIds"])([id]);
    return stores[id] || {};
  },

  /** @param {{ where, store }[]} data
   * @return {Promise<void>} */
  async SetValueStores(data) {
    // Value store will be replaced soon.
    const stores = data.reduce((res, {
      where,
      store
    }) => {
      var _getScript;

      const id = where.id || ((_getScript = Object(_db__WEBPACK_IMPORTED_MODULE_2__["getScript"])(where)) == null ? void 0 : _getScript.props.id);
      if (id) res[id] = store;
      return res;
    }, {});
    await Promise.all([Object(_db__WEBPACK_IMPORTED_MODULE_2__["dumpValueStores"])(stores), broadcastValueStores(groupStoresByFrame(stores))]);
  },

  /** @return {void} */
  UpdateValue({
    id,
    key,
    value = null
  }, src) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(cache, [id, key, 'last'], value);
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(cache, [id, key, src.tab.id, src.frameId], value);
    updateLater();
  }

});
browser.tabs.onRemoved.addListener(resetValueOpener);
browser.tabs.onReplaced.addListener((addedId, removedId) => resetValueOpener(removedId));
function resetValueOpener(tabId) {
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], openers, ([id, openerTabs]) => {
    if (tabId in openerTabs) {
      delete openerTabs[tabId];
      if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(openerTabs)) delete openers[id];
    }
  });
}
function addValueOpener(tabId, frameId, scriptIds) {
  scriptIds.forEach(id => {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(openers, [id, tabId, frameId], 1);
  });
}

async function updateLater() {
  while (!updateScheduled) {
    updateScheduled = true;
    await 0;
    const currentCache = cache;
    cache = {};
    await doUpdate(currentCache);
    updateScheduled = false;
    if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(cache)) break;
  }
}

async function doUpdate(currentCache) {
  const ids = Object.keys(currentCache);
  const valueStores = await Object(_db__WEBPACK_IMPORTED_MODULE_2__["getValueStoresByIds"])(ids);
  ids.forEach(id => {
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], currentCache[id], ([key, {
      last
    }]) => {
      Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(valueStores, [id, key], last || undefined);
    });
  });
  await Promise.all([Object(_db__WEBPACK_IMPORTED_MODULE_2__["dumpValueStores"])(valueStores), broadcastValueStores(groupCacheByFrame(currentCache), {
    partial: true
  })]);
}

async function broadcastValueStores(tabFrameData, {
  partial
} = {}) {
  const tasks = [];

  for (const [tabId, frames] of Object.entries(tabFrameData)) {
    for (const [frameId, frameData] of Object.entries(frames)) {
      if (!Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(frameData)) {
        if (partial) frameData.partial = true;
        tasks.push(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(+tabId, 'UpdatedValues', frameData, {
          frameId: +frameId
        }));
        if (tasks.length === 20) await Promise.all(tasks.splice(0)); // throttling
      }
    }
  }

  await Promise.all(tasks);
} // Returns per tab/frame data with only the changed values


function groupCacheByFrame(cacheData) {
  const toSend = {};
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], cacheData, ([id, scriptData]) => {
    const dataEntries = Object.entries(scriptData);
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], openers[id], ([tabId, frames]) => {
      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachKey"], frames, frameId => {
        dataEntries.forEach(([key, history]) => {
          var _history$tabId;

          // Skipping this frame if its last recorded value is identical
          if (history.last !== ((_history$tabId = history[tabId]) == null ? void 0 : _history$tabId[frameId])) {
            Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(toSend, [tabId, frameId, id, key], history.last);
          }
        });
      });
    });
  });
  return toSend;
} // Returns per tab/frame data


function groupStoresByFrame(stores) {
  const toSend = {};
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], stores, ([id, store]) => {
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], openers[id], ([tabId, frames]) => {
      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachKey"], frames, frameId => {
        Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(toSend, [tabId, frameId, id], store);
      });
    });
  });
  return toSend;
}

/***/ }),

/***/ "./src/common/events.js":
/*!******************************!*\
  !*** ./src/common/events.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EventEmitter; });
class EventEmitter {
  constructor(allowed) {
    this.events = {};
    this.allowed = allowed;
  }

  checkType(type) {
    if (this.allowed && !this.allowed.includes(type)) {
      throw new Error(`Unknown event type: ${type}`);
    }
  }

  on(type, handle) {
    this.checkType(type);
    const {
      events
    } = this;
    let handlers = events[type];

    if (!handlers) {
      handlers = [];
      events[type] = handlers;
    }

    return () => this.off(type, handle);
  }

  off(type, handle) {
    this.checkType(type);
    const handlers = this.events[type];

    if (handlers) {
      const i = handlers.indexOf(handle);
      if (i >= 0) handlers.splice(i, 1);
    }
  }

  emit(type, data) {
    this.checkType(type);
    const handlers = this.events[type];

    if (handlers) {
      const evt = {
        type,
        data,
        defaultPrevented: false,

        preventDefault() {
          evt.defaultPrevented = true;
        }

      };
      handlers.some(handle => {
        handle(evt);
        return evt.defaultPrevented;
      });
    }
  }

}

/***/ }),

/***/ "./src/common/tld.js":
/*!***************************!*\
  !*** ./src/common/tld.js ***!
  \***************************/
/*! exports provided: initTLD, isReady, getDomain, getSubdomain, getPublicSuffix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initTLD", function() { return initTLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReady", function() { return isReady; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDomain", function() { return getDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSubdomain", function() { return getSubdomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPublicSuffix", function() { return getPublicSuffix; });
/* harmony import */ var tldjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tldjs */ "./node_modules/tldjs/index.js");
/* harmony import */ var tldjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tldjs__WEBPACK_IMPORTED_MODULE_0__);
 // import { fromUserSettings } from 'tldjs';
// import Trie from 'tldjs/lib/suffix-trie';
// import { request } from '#/common';
// let tldjs;
// export function initTLD(remote) {
//   // TLD rules are too large to be packed, download them at runtime.
//   const url = 'https://violentmonkey.top/static/tld-rules.json';
//   const key = 'dat:tldRules';
//   browser.storage.local.get(key)
//   .then(({ [key]: tldRules }) => {
//     if (tldRules) return tldRules;
//     if (!remote) return Promise.reject('ignore TLD');
//     return request(url, { responseType: 'json' })
//     .then(({ data: rules }) => {
//       console.info('Downloaded public suffix data');
//       return browser.storage.local.set({ [key]: rules })
//       .then(() => rules);
//     });
//   })
//   .then(tldRules => {
//     console.info('Initialized TLD');
//     tldjs = fromUserSettings({ rules: Trie.fromJson(tldRules) });
//   })
//   .catch(err => {
//     if (process.env.DEBUG) console.error(err);
//     console.info('Failed initializing TLD');
//   });
// }

function initTLD() {}

function exportMethod(key) {
  return (...args) => tldjs__WEBPACK_IMPORTED_MODULE_0___default.a && tldjs__WEBPACK_IMPORTED_MODULE_0___default.a[key](...args);
}

function isReady() {
  return !!tldjs__WEBPACK_IMPORTED_MODULE_0___default.a;
}
const getDomain = exportMethod('getDomain');
const getSubdomain = exportMethod('getSubdomain');
const getPublicSuffix = exportMethod('getPublicSuffix');

/***/ })

/******/ });}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy9icm93c2VyL2RlZmF1bHRPcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmZtcGVnL2ZmbXBlZy9zcmMvYnJvd3Nlci9mZXRjaEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy9icm93c2VyL2dldENyZWF0ZUZGbXBlZ0NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy9icm93c2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmZtcGVnL2ZmbXBlZy9zcmMvY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmZtcGVnL2ZmbXBlZy9zcmMvY3JlYXRlRkZtcGVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmZtcGVnL2ZmbXBlZy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy91dGlscy9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy91dGlscy9wYXJzZUFyZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy91dGlscy9wYXJzZVByb2dyZXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamJpbmFyeS9kaXN0L2Jyb3dzZXIvamJpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamRhdGF2aWV3L2Rpc3Qvbm9kZS9qZGF0YXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21wZWd0c190b19tcDQvbXBlZ3RzX3RvX21wNC9hZHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvaDI2NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXBlZ3RzX3RvX21wNC9tcGVndHNfdG9fbXA0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvbXA0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvbXBlZ3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvcGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXVybC9yZXNvbHZlLXVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wbHVnaW4vZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3BsdWdpbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9zeW5jL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvc3luYy9kcm9wYm94LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3N5bmMvZ29vZ2xlZHJpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvc3luYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9zeW5jL29uZWRyaXZlLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3N5bmMvd2ViZGF2LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL2Flcy1kZWNyeXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvY2xpcGJvYXJkLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL2RiLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy9ob3RrZXlzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL2ljb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvaW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy9tM3U4LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL21lcmdlLXZpZGVvLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL21lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvbm90aWZpY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy9vcHRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3BhdGNoLWRiLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3BvcHVwLXRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvcHJlaW5qZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3JlcXVlc3RzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3NjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy9zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvc3RvcmFnZS1mZXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy90YWJzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3RlbXBsYXRlLWhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvdGVzdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3VwZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi90bGQuanMiXSwibmFtZXMiOlsiaG9va09wdGlvbnMiLCJjaGFuZ2VzIiwiYXV0b1VwZGF0ZSIsIlNDUklQVF9URU1QTEFURSIsInJlc2V0U2NyaXB0VGVtcGxhdGUiLCJzZW5kQ21kIiwiT2JqZWN0IiwiYXNzaWduIiwiY29tbWFuZHMiLCJHZXREYXRhIiwiaWRzIiwiZGF0YSIsImdldERhdGEiLCJzeW5jIiwiR2V0SW5qZWN0ZWQiLCJ1cmwiLCJmb3JjZUNvbnRlbnQiLCJzcmMiLCJmcmFtZUlkIiwidGFiIiwidGFiSWQiLCJpZCIsInJlc2V0VmFsdWVPcGVuZXIiLCJjbGVhclJlcXVlc3RzQnlUYWJJZCIsInJlcyIsImdldEluamVjdGVkU2NyaXB0cyIsImZlZWRiYWNrIiwiaW5qZWN0IiwidmFsT3BJZHMiLCJpc1BvcHVwU2hvd24iLCJwb3B1cFRhYnMiLCJsZW5ndGgiLCJzZXRUaW1lb3V0IiwiSW5qZWN0aW9uRmVlZGJhY2siLCJhZGRWYWx1ZU9wZW5lciIsIkdldFRhYkRvbWFpbiIsImdldEFjdGl2ZVRhYiIsInBlbmRpbmdVcmwiLCJob3N0IiwibWF0Y2giLCJkb21haW4iLCJ0bGQiLCJTZXRUaW1lb3V0IiwibXMiLCJtYWtlUGF1c2UiLCJjb21tYW5kc1RvU3luYyIsImNvbW1hbmRzVG9TeW5jSWZUcnV0aHkiLCJoYW5kbGVDb21tYW5kTWVzc2FnZSIsInJlcSIsImNtZCIsImluY2x1ZGVzIiwiaW50ZXJ2YWwiLCJJU19ERVYiLCJnZXRPcHRpb24iLCJUSU1FT1VUXzI0SE9VUlMiLCJlbGFwc2VkIiwiRGF0ZSIsIm5vdyIsImNsZWFyVGltZW91dCIsInRpbWVyIiwiTWF0aCIsIm1pbiIsIlRJTUVPVVRfTUFYIiwiaW5pdEJ1aWxkaW4iLCJyZXF1ZXN0IiwiQlVJTERfSU5fU0NSSVBUX1NSQyIsImNhY2hlIiwiaGVhZGVycyIsIkFjY2VwdCIsIlBhcnNlU2NyaXB0IiwiY29kZSIsImN1c3RvbSIsImJ1aWxkSW4iLCJ3aGVyZSIsImluaXRpYWxpemUiLCJnbG9iYWwiLCJkZWVwQ29weSIsImJyb3dzZXIiLCJydW50aW1lIiwib25NZXNzYWdlIiwiYWRkTGlzdGVuZXIiLCJJU19GSVJFRk9YIiwiYXJncyIsImNhdGNoIiwiZSIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImNvbnNvbGUiLCJpbmZvIiwiY2hlY2tSZW1vdmUiLCJzZXRJbnRlcnZhbCIsImFwaSIsImNocm9tZSIsImRlY2xhcmF0aXZlQ29udGVudCIsIm9uUGFnZUNoYW5nZWQiLCJnZXRSdWxlcyIsInJ1bGUiLCJuZXdJZCIsInByb2Nlc3MiLCJyZW1vdmVSdWxlcyIsImFkZFJ1bGVzIiwiY29uZGl0aW9ucyIsIlBhZ2VTdGF0ZU1hdGNoZXIiLCJwYWdlVXJsIiwidXJsQ29udGFpbnMiLCJhY3Rpb25zIiwiUmVxdWVzdENvbnRlbnRTY3JpcHQiLCJqcyIsImdldE1hbmlmZXN0IiwiY29udGVudF9zY3JpcHRzIiwiRXZlbnRFbWl0dGVyIiwic2NyaXB0IiwidXBkYXRlIiwibGlzdCIsImdldFNjcmlwdHMiLCJnZXQiLCJHZXRTY3JpcHRDb2RlIiwicmVtb3ZlIiwiTWFya1JlbW92ZWQiLCJyZW1vdmVkIiwic2VydmljZU5hbWVzIiwic2VydmljZUNsYXNzZXMiLCJzZXJ2aWNlcyIsImF1dG9TeW5jIiwiZGVib3VuY2UiLCJUSU1FT1VUX0hPVVIiLCJ3b3JraW5nIiwicmVzb2x2ZSIsInN5bmNDb25maWciLCJnZXRJdGVtRmlsZW5hbWUiLCJuYW1lIiwidXJpIiwiaXNTY3JpcHRGaWxlIiwidGVzdCIsImdldFVSSSIsImkiLCJpbmRleE9mIiwidmVyc2lvbiIsInNsaWNlIiwic3BsaXQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlcnIiLCJpbml0Q29uZmlnIiwia2V5IiwiZGVmIiwia2V5cyIsIm5vcm1hbGl6ZUtleXMiLCJ1bnNoaWZ0Iiwic2V0IiwidmFsdWUiLCJzZXRPcHRpb24iLCJpbml0IiwiY29uZmlnIiwic2VydmljZUNvbmZpZyIsImdldEtleXMiLCJ2YWwiLCJmb3JFYWNoRW50cnkiLCJrIiwidiIsImNsZWFyIiwic2VydmljZVN0YXRlIiwidmFsaWRTdGF0ZXMiLCJpbml0aWFsU3RhdGUiLCJvbkNoYW5nZSIsInN0YXRlIiwibmV3U3RhdGUiLCJ3YXJuIiwiaXMiLCJzdGF0ZXMiLCJlbnN1cmVBcnJheSIsImdldFN0YXRlcyIsIm1hcCIsInNlcnZpY2UiLCJkaXNwbGF5TmFtZSIsImF1dGhTdGF0ZSIsInN5bmNTdGF0ZSIsImxhc3RTeW5jIiwicHJvZ3Jlc3MiLCJwcm9wZXJ0aWVzIiwidXNlckNvbmZpZyIsImdldFVzZXJDb25maWciLCJnZXRTY3JpcHREYXRhIiwic3luY1ZlcnNpb24iLCJleHRyYSIsInByb3BzIiwib2JqZWN0UGljayIsIm1vcmUiLCJlbmFibGVkIiwic2hvdWxkVXBkYXRlIiwibGFzdFVwZGF0ZWQiLCJwYXJzZVNjcmlwdERhdGEiLCJyYXciLCJvYmoiLCJKU09OIiwicGFyc2UiLCJvYmplY3RQdXJpZnkiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwic2VydmljZUZhY3RvcnkiLCJiYXNlIiwiU2VydmljZSIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiZXh0ZW5kIiwiZXh0ZW5kU2VydmljZSIsIm9wdGlvbnMiLCJjcmVhdGUiLCJvblN0YXRlQ2hhbmdlIiwiQmFzZVNlcnZpY2UiLCJkZWxheVRpbWUiLCJ1cmxQcmVmaXgiLCJtZXRhRmlsZSIsImF1dGhUeXBlIiwibm9vcCIsInNldFVzZXJDb25maWciLCJmaW5pc2hlZCIsInRvdGFsIiwibGFzdEZldGNoIiwic3RhcnRTeW5jIiwic3luY0ZhY3RvcnkiLCJldmVudHMiLCJnZXRFdmVudEVtaXR0ZXIiLCJsb2ciLCJwcm9taXNlIiwiZGVib3VuY2VkUmVzb2x2ZSIsInNob3VsZFN5bmMiLCJnZXRDdXJyZW50IiwiZ2V0UmVhZHkiLCJ0aGVuIiwiZXJyb3IiLCJwcmVwYXJlSGVhZGVycyIsInByZXBhcmUiLCJpbml0VG9rZW4iLCJ1c2VyIiwidHlwZSIsImNoZWNrU3luYyIsImFjcXVpcmVMb2NrIiwicmVsZWFzZUxvY2siLCJoYW5kbGVNZXRhRXJyb3IiLCJnZXRNZXRhIiwidG9rZW4iLCJBdXRob3JpemF0aW9uIiwibG9hZERhdGEiLCJkZWxheSIsInRzIiwic3RhcnRzV2l0aCIsInByZWZpeCIsImdldExvY2FsRGF0YSIsInBsdWdpblNjcmlwdCIsImdldFN5bmNEYXRhIiwicmVtb3RlTWV0YSIsImFsbCIsInJlbW90ZURhdGEiLCJsb2NhbERhdGEiLCJyZW1vdGVNZXRhRGF0YSIsInJlbW90ZU1ldGFJbmZvIiwicmVtb3RlVGltZXN0YW1wIiwidGltZXN0YW1wIiwicmVtb3RlQ2hhbmdlZCIsImdsb2JhbExhc3RNb2RpZmllZCIsInJlbW90ZUl0ZW1NYXAiLCJsb2NhbE1ldGEiLCJmaXJzdFN5bmMiLCJvdXRkYXRlZCIsInB1dExvY2FsIiwicHV0UmVtb3RlIiwiZGVsUmVtb3RlIiwiZGVsTG9jYWwiLCJ1cGRhdGVMb2NhbCIsInJlZHVjZSIsIml0ZW0iLCJpdGVtSW5mbyIsIm1vZGlmaWVkIiwicG9zaXRpb24iLCJsYXN0TW9kaWZpZWQiLCJyZW1vdGVJbmZvIiwicmVtb3RlSXRlbSIsInB1c2giLCJsb2NhbCIsInJlbW90ZSIsInByb21pc2VRdWV1ZSIsIm9iamVjdFNldCIsInB1dCIsInN0cmluZ2lmeSIsInVwZGF0ZXMiLCJ1cGRhdGVTY3JpcHRJbmZvIiwic29ydFNjcmlwdHMiLCJjaGFuZ2VkIiwic2NyaXB0cyIsInByb21pc2VzIiwiZXJyb3JzIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJlZ2lzdGVyIiwiRmFjdG9yeSIsImdldFNlcnZpY2UiLCJzeW5jT25lIiwiYXV0aG9yaXplIiwicmV2b2tlIiwic2V0Q29uZmlnIiwib3BlbkF1dGhQYWdlIiwicmVkaXJlY3RVcmkiLCJ1bnJlZ2lzdGVyV2ViUmVxdWVzdCIsIndlYlJlcXVlc3QiLCJvbkJlZm9yZVJlcXVlc3QiLCJ1cmxzIiwidHlwZXMiLCJ0YWJzIiwiY2hlY2tBdXRoIiwiY2FuY2VsIiwicmVtb3ZlTGlzdGVuZXIiLCJjbGllbnRfaWQiLCJyZWRpcmVjdF91cmkiLCJlc2NSRSIsImVzY0Z1bmMiLCJtIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwianNvblN0cmluZ2lmeVNhZmUiLCJzdHJpbmciLCJyZXBsYWNlIiwiRHJvcGJveCIsIm1ldGhvZCIsInN0YXR1cyIsImJvZHkiLCJwYXRoIiwicmVzcG9uc2VUeXBlIiwiZW50cmllcyIsIm5vcm1hbGl6ZSIsIm1vZGUiLCJwYXJhbXMiLCJyZXNwb25zZV90eXBlIiwiZHVtcFF1ZXJ5IiwiYXV0aG9yaXplZCIsImxvYWRRdWVyeSIsImFjY2Vzc190b2tlbiIsInVpZCIsInNpemUiLCJjbGllbnRfc2VjcmV0Iiwic2NvcGUiLCJVTkFVVEhPUklaRUQiLCJHb29nbGVEcml2ZSIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJncmFudF90eXBlIiwicmVxdWVzdFVzZXIiLCJhY2Nlc3NfdHlwZSIsIm5vdGlmeSIsInRpdGxlIiwib2JqZWN0R2V0Iiwic3BhY2VzIiwiZmllbGRzIiwiZmlsZXMiLCJtZXRhSXRlbSIsImdvdE1ldGEiLCJwcm9tcHQiLCJib3VuZGFyeSIsImdldFVuaXFJZCIsIm1ldGFkYXRhIiwicGFyZW50cyIsImpvaW4iLCJTeW5jQXV0aG9yaXplIiwiU3luY1Jldm9rZSIsIlN5bmNTdGFydCIsIlN5bmNTZXRDb25maWciLCJPbmVEcml2ZSIsImhlYWRlciIsImZpbGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ1c2VyX2lkIiwiS0VZX0NISUxEUkVOIiwiU3ltYm9sIiwiWE5vZGUiLCJub2RlIiwibnNNYXAiLCJwYXJzZUF0dHJzIiwicGFyc2VOYW1lIiwiZnJvbVhNTCIsInhtbCIsInBhcnNlciIsIkRPTVBhcnNlciIsImRvYyIsInBhcnNlRnJvbVN0cmluZyIsImF0dHJzIiwiYXR0cmlidXRlcyIsImF0dHIiLCIkIiwibm9kZVR5cGUiLCJ0YWdOYW1lIiwibnMiLCJ0ZXh0IiwidGV4dENvbnRlbnQiLCJ0cmltIiwiY2hpbGRyZW4iLCJjaGlsZCIsImNhbGxiYWNrIiwiZ2V0Q2FsbGJhY2siLCJmaW5kIiwiREVGQVVMVF9DT05GSUciLCJzZXJ2ZXJVcmwiLCJhbm9ueW1vdXMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiV2ViREFWIiwiZW5kc1dpdGgiLCJVUkwiLCJhdXRoIiwid2luZG93IiwiYnRvYSIsImNhbGwiLCJjcmVkZW50aWFscyIsIm1rZGlyIiwicmVhZGRpciIsImRlcHRoIiwiaXRlbXMiLCJwcm9wIiwiZGlzcGxheU5hbWVOb2RlIiwidW5kZWZpbmVkIiwiaHJlZiIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwibG9jayIsIklmIiwicmVtb3ZlUGFkZGluZyIsImJ1ZmZlciIsIm91dHB1dEJ5dGVzIiwiYnl0ZUxlbmd0aCIsInBhZGRpbmdCeXRlcyIsIkRhdGFWaWV3IiwiZ2V0VWludDgiLCJBRVNEZWNyeXB0b3IiLCJyY29uIiwic3ViTWl4IiwiVWludDMyQXJyYXkiLCJpbnZTdWJNaXgiLCJzQm94IiwiaW52U0JveCIsImluaXRUYWJsZSIsInVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyIsImFycmF5QnVmZmVyIiwidmlldyIsIm5ld0FycmF5IiwiZ2V0VWludDMyIiwic3ViTWl4MCIsInN1Yk1peDEiLCJzdWJNaXgyIiwic3ViTWl4MyIsImludlN1Yk1peDAiLCJpbnZTdWJNaXgxIiwiaW52U3ViTWl4MiIsImludlN1Yk1peDMiLCJkIiwieCIsInhpIiwic3giLCJ4MiIsIng0IiwieDgiLCJ0IiwiZXhwYW5kS2V5Iiwia2V5QnVmZmVyIiwic2FtZUtleSIsIm9mZnNldCIsImtleVNpemUiLCJrc1Jvd3MiLCJrc1JvdyIsImludktzUm93Iiwia2V5U2NoZWR1bGUiLCJpbnZLZXlTY2hlZHVsZSIsInNib3giLCJwcmV2IiwibmV0d29ya1RvSG9zdE9yZGVyU3dhcCIsIndvcmQiLCJkZWNyeXB0IiwiaW5wdXRBcnJheUJ1ZmZlciIsImFlc0lWIiwicmVtb3ZlUEtDUzdQYWRkaW5nIiwiblJvdW5kcyIsImludlNCT1giLCJpbml0VmVjdG9yIiwiaW5pdFZlY3RvcjAiLCJpbml0VmVjdG9yMSIsImluaXRWZWN0b3IyIiwiaW5pdFZlY3RvcjMiLCJpbnB1dEludDMyIiwiSW50MzJBcnJheSIsIm91dHB1dEludDMyIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzMCIsInMxIiwiczIiLCJzMyIsImlucHV0V29yZHMwIiwiaW5wdXRXb3JkczEiLCJpbnB1dFdvcmRzMiIsImlucHV0V29yZHMzIiwic3dhcFdvcmQiLCJkZXN0cm95IiwiaW5pdENhY2hlIiwibGlmZXRpbWUiLCJDYWNoZUxvYWQiLCJDYWNoZUhpdCIsImhpdCIsIkNhY2hlUG9wIiwicG9wIiwidGV4dGFyZWEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGlwYm9hcmREYXRhIiwiU2V0Q2xpcGJvYXJkIiwiZm9jdXMiLCJyZXQiLCJleGVjQ29tbWFuZCIsImFwcGVuZENoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInByZXZlbnREZWZhdWx0Iiwic2V0RGF0YSIsInN0b3JlIiwic3RvcmFnZSIsInNldERhdGFDYWNoZSIsImRhdGFDYWNoZSIsIm9uRHVtcCIsInNjcmlwdE1hcCIsIkNoZWNrUG9zaXRpb24iLCJDaGVja1JlbW92ZSIsIkdldFNjcmlwdCIsImdldFNjcmlwdCIsIkV4cG9ydFppcCIsInZhbHVlcyIsImdldFByb3BzSWQiLCJjb2RlTWFwIiwiZ2V0TXVsdGkiLCJnZXRPbmUiLCJHZXRTY3JpcHRWZXIiLCJvcHRzIiwibWV0YSIsIk1vdmUiLCJnZXRTY3JpcHRCeUlkIiwiaW5kZXgiLCJzcGxpY2UiLCJub3JtYWxpemVQb3NpdGlvbiIsIlJlbW92ZVNjcmlwdCIsIlBhcnNlTWV0YSIsInBhcnNlTWV0YSIsInBhcnNlU2NyaXB0IiwiVXBkYXRlU2NyaXB0SW5mbyIsIlZhY3V1bSIsInZhY3V1bSIsInByZUluaXRpYWxpemUiLCJsYXN0VmVyc2lvbiIsInBhdGNoREIiLCJzdG9yZUluZm8iLCJpZE1hcCIsInVyaU1hcCIsIm1vZHMiLCJyZXNVcmxzIiwicmVtZW1iZXJVcmwiLCJfIiwiZ2V0SW50IiwiZ2V0TmFtZVVSSSIsImdldERlZmF1bHRDdXN0b20iLCJtYXgiLCJwYXRoTWFwIiwiZ3JhbnQiLCJTZXQiLCJyZXF1aXJlIiwicmVzb3VyY2VzIiwiaWNvbiIsIm1vZCIsInJlbW92ZU11bHRpIiwiZGVmYXVsdEluamVjdEludG8iLCJJTkpFQ1RfUEFHRSIsImNvbXBhcmVWZXJzaW9uIiwiSU5KRUNUX0FVVE8iLCJ1cGRhdGVMYXN0TW9kaWZpZWQiLCJkdW1wIiwic29ydCIsImEiLCJiIiwiZ2V0VmFsdWVTdG9yZXNCeUlkcyIsImR1bXBWYWx1ZVN0b3JlcyIsInZhbHVlRGljdCIsIkVOVl9DQUNIRV9LRVlTIiwiRU5WX1JFUV9LRVlTIiwiRU5WX1ZBTFVFX0lEUyIsIkdNVkFMVUVTX1JFIiwiUlVOX0FUX1JFIiwiZ2V0U2NyaXB0c0J5VVJMIiwiaXNUb3AiLCJhbGxTY3JpcHRzIiwidGVzdEJsYWNrbGlzdCIsIm5vZnJhbWVzIiwidGVzdFNjcmlwdCIsImRpc2FibGVkSWRzIiwiZW52U3RhcnQiLCJlbnZEZWxheWVkIiwiYnVpbGRQYXRoTWFwIiwicnVuQXQiLCJlbnYiLCJzb21lIiwicmVhZEVudmlyb25tZW50RGF0YSIsIlNUT1JBR0VfUk9VVEVTIiwicmV0cmllZFN0b3JhZ2VLZXlzIiwiaXNSZXRyeSIsImFyZWEiLCJzcmNJZHMiLCJnZXRLZXkiLCJlcnIyIiwiZ2V0SWNvbkNhY2hlIiwiaWNvblVybHMiLCJpc1JlbW90ZSIsIm1ha2VEYXRhVXJpIiwiZm9yY2UiLCJ0b1JlbW92ZSIsIlRJTUVPVVRfV0VFSyIsImdldFVVSUQiLCJybmQiLCJVaW50MTZBcnJheSIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInNhdmVTY3JpcHQiLCJvbGRTY3JpcHQiLCJ1dWlkIiwicmFuZG9tVVVJRCIsImkxOG4iLCJDTURfU0NSSVBUX1VQREFURSIsInJlc3VsdCIsIm1lc3NhZ2UiLCJpc05ldyIsIm5ld1NjcmlwdCIsIkNNRF9TQ1JJUFRfQUREIiwiaG9tZXBhZ2VVUkwiLCJmcm9tIiwibGFzdEluc3RhbGxVUkwiLCJmZXRjaFJlc291cmNlcyIsInBsdWdpbkV2ZW50cyIsImVtaXQiLCJiYXNlVXJsIiwiZnVsbFVybCIsImdldEZ1bGxVcmwiLCJyZXNvdXJjZUNhY2hlIiwicmVxT3B0aW9ucyIsInNuYXRjaCIsInZhbGlkYXRvciIsImNvbnRlbnRzIiwiZmV0Y2giLCJ2YWxpZGF0ZUltYWdlIiwiaWdub3JlRGVwc0Vycm9ycyIsInRydWVKb2luIiwiZm9ybWF0SHR0cEVycm9yIiwiYnVmIiwiYmxvYlVybCIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJvbkRvbmUiLCJyZXZva2VPYmplY3RVUkwiLCJpbWFnZSIsIkltYWdlIiwib25sb2FkIiwib25lcnJvciIsIl92YWN1dW1pbmciLCJudW1GaXhlcyIsInJlc29sdmVTZWxmIiwiciIsInRvRmV0Y2giLCJrZXlzVG9SZW1vdmUiLCJ2YWx1ZUtleXMiLCJjYWNoZUtleXMiLCJyZXF1aXJlS2V5cyIsImNvZGVLZXlzIiwibWFwcGluZ3MiLCJmb3JFYWNoS2V5Iiwic3Vic3RvcmUiLCJ0b3VjaCIsInNjcmlwdElkIiwiZm9yRWFjaFZhbHVlIiwiZ2V0U2NyaXB0TmFtZSIsImZpeGVzIiwib24iLCJvZmYiLCJmaXJlIiwiZnVuYyIsInBvc3RJbml0aWFsaXplIiwib25Db21tYW5kIiwiT3BlbkVkaXRvciIsInJvdXRlIiwiVGFiT3BlbiIsIkNBQ0hFX0RVUkFUSU9OIiwiR2V0SW1hZ2VEYXRhIiwibG9hZEltYWdlRGF0YSIsImJhc2U2NCIsIlNldEJhZGdlIiwic2V0QmFkZ2UiLCJicm93c2VyQWN0aW9uIiwiaWdub3JlRXJyb3JzIiwibGFzdEVycm9yIiwibWFrZU1ldGhvZCIsImZuIiwiYmFkZ2VzIiwiS0VZX0lTX0FQUExJRUQiLCJLRVlfU0hPV19CQURHRSIsIktFWV9CQURHRV9DT0xPUiIsIktFWV9CQURHRV9DT0xPUl9CTE9DS0VEIiwiaXNBcHBsaWVkIiwic2hvd0JhZGdlIiwiYmFkZ2VDb2xvciIsImJhZGdlQ29sb3JCbG9ja2VkIiwidGl0bGVCbGFja2xpc3RlZCIsInRpdGxlTm9uaW5qZWN0YWJsZSIsImljb25DYWNoZSIsImpvYnMiLCJzZXRJY29uIiwidXBkYXRlQmFkZ2UiLCJ1cGRhdGVCYWRnZUNvbG9yIiwidXBkYXRlU3RhdGUiLCJmb3JFYWNoVGFiIiwib25SZW1vdmVkIiwib25VcGRhdGVkIiwiZmF2SWNvblVybCIsInVuaXF1ZSIsInNldEJhZGdlVGV4dCIsInNldEJhZGdlQmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJibG9ja2VkIiwiaW5qZWN0YWJsZSIsIklOSkVDVEFCTEVfVEFCX1VSTF9SRSIsImJsYWNrbGlzdGVkIiwic2V0VGl0bGUiLCJpY29uRGF0YSIsIm4iLCJpbWciLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJnZXRJbWFnZURhdGEiLCJleHRlbnNpb25Sb290IiwiZ2V0VVJMIiwibWFpbiIsInJ1biIsInRzTGlzdCIsInN0YXR1c0xpc3QiLCJtZWRpYUZpbGVMaXN0IiwiQUVTIiwiaXYiLCJkZWNyeXB0b3IiLCJzdHJpbmdUb0J1ZmZlciIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZG93bmxvYWRNM3U4IiwibTN1OCIsImxpbWl0IiwibGluZSIsInRvTG93ZXJDYXNlIiwidHNVcmwiLCJnZXRBRVMiLCJkb3dubG9hZFRTIiwiYWpheCIsInN1Y2Nlc3MiLCJmYWlsIiwidHNVcmkiLCJiYXNlVVJMIiwiZGVjcnlwdFRzIiwiVWludDhBcnJheSIsInJldHJ5IiwiZG93bmxvYWQiLCJwcm9jTGlzdCIsInMiLCJkZWFsVFMiLCJvbnByb2dyZXNzIiwiaWkiLCJtcDRCeUpiaW5hcnkiLCJkYXRhQ2h1bmtzIiwiYmxvYiIsImpCaW5hcnkiLCJsb2FkIiwiTVBFR1RTIiwibXBlZ3RzIiwic3RhcnQiLCJnZXRUaW1lIiwibXA0T2JqIiwibXBlZ3RzX3RvX21wNCIsImRvd25sb2FkTGluayIsInRvVVJJIiwicmF3RGF0YSIsImRvd25sb2FkcyIsImZpbGVuYW1lIiwiZmlsZU5hbWUiLCJkb3dubG9hZElkIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJvcGVuIiwic2VuZCIsImNyZWF0ZUZGbXBlZyIsImZldGNoRmlsZSIsImZmbXBlZyIsImNvcmVQYXRoIiwibWVyZ2UiLCJ2aWRlbyIsImF1ZGlvIiwiRlMiLCJodHRwUmVxdWVzdCIsInJlcXVlc3RzIiwiZXZlbnRzVG9Ob3RpZnkiLCJsb2FkZWQiLCJtZXJnZVZpZGVvIiwicHAiLCJfbG9hZGVkIiwiX3RvdGFsIiwicHJlbG9hZHMiLCJ2aWRlb09wdHMiLCJhdWRpb09wdHMiLCJ2YWxzIiwib3V0IiwiYmxvYkNvbmYiLCJub3RpZmljYXRpb25zIiwiaWNvblVybCIsImRlZmF1bHRJbWFnZSIsImlzQ2xpY2thYmxlIiwiYnJvYWRjYXN0Iiwic2VuZE1lc3NhZ2UiLCJzZW5kTWVzc2FnZU9ySWdub3JlIiwicXVlcnkiLCJvcGVuZXJzIiwiTm90aWZpY2F0aW9uIiwiYmdFeHRyYXMiLCJub3RpZmljYXRpb25JZCIsIm9uQ2xpY2siLCJSZW1vdmVOb3RpZmljYXRpb24iLCJvbkNsaWNrZWQiLCJvcGVuZXJJZCIsInNlbmRUYWJDbWQiLCJvbkNsb3NlZCIsIkdldEFsbE9wdGlvbnMiLCJHZXRPcHRpb25zIiwiZGVmYXVsdHMiLCJtYXBFbnRyeSIsIlNldE9wdGlvbnMiLCJob29rcyIsImluaXRIb29rcyIsImNhbGxIb29rc0xhdGVyIiwiY2FsbEhvb2tzIiwiaW5pdFBlbmRpbmciLCJmaXJlQ2hhbmdlIiwibWFpbktleSIsImdldERlZmF1bHRPcHRpb24iLCJvcHRpb25LZXkiLCJvcHRpb25WYWx1ZSIsImhvb2siLCJpbmRleGVkREIiLCJvbnN1Y2Nlc3MiLCJ0cmFuc2Zvcm0iLCJvbnVwZ3JhZGVuZWVkZWQiLCJkYiIsInR4IiwidHJhbnNhY3Rpb24iLCJwcm9jZXNzaW5nIiwiZG9uZSIsImdldEFsbCIsInN0b3JlTmFtZSIsIm9iamVjdFN0b3JlIiwidHJhbnNmb3JtU2NyaXB0IiwiYWxsVmFsdWVzIiwiYWxsQ2FjaGUiLCJhbGxSZXF1aXJlIiwib3JpZ0luY2x1ZGUiLCJvcmlnRXhjbHVkZSIsIm9yaWdNYXRjaCIsIm9yaWdFeGNsdWRlTWF0Y2giLCJvbkNvbm5lY3QiLCJvblBvcHVwT3BlbmVkIiwicHJlZmV0Y2hTZXRQb3B1cCIsImJyb3dzZXJfYWN0aW9uIiwiZGVmYXVsdF9wb3B1cCIsInBvcnQiLCJvbkRpc2Nvbm5lY3QiLCJvblBvcHVwQ2xvc2VkIiwiU2V0UG9wdXAiLCJBUElfQ09ORklHIiwiVElNRV9BRlRFUl9TRU5EIiwiVElNRV9BRlRFUl9SRUNFSVZFIiwiVElNRV9LRUVQX0RBVEEiLCJjYWNoZUNvZGUiLCJvbkRpc3Bvc2UiLCJyY3MiLCJyY3NQcm9taXNlIiwidW5yZWdpc3RlciIsIklOSkVDVF9JTlRPIiwiS0VZX0VYUE9TRSIsIktFWV9ERUZfSU5KRUNUX0lOVE8iLCJLRVlfWEhSX0lOSkVDVCIsImV4cG9zZSIsImluamVjdEludG8iLCJ4aHJJbmplY3QiLCJvbk9wdGlvbkNoYW5nZWQiLCJmZWVkSWQiLCJwcm9jZXNzRmVlZGJhY2siLCJkZWwiLCJjYWNoZUtleSIsImVudktleSIsInByZXBhcmVTY3JpcHQiLCJuZWVkc0luamVjdGlvbiIsImV4ZWN1dGVTY3JpcHQiLCJwcm9wc1RvQ2xlYXIiLCJvbkNoYW5nZWQiLCJkYktleXMiLCJjYWNoZVZhbHVlcyIsImdldFZhbHVlcyIsImRpcnR5Iiwibm9ybWFsaXplUmVhbG0iLCJoYXNPd25Qcm9wZXJ0eSIsIklOSkVDVF9NQVBQSU5HIiwidG9nZ2xlWGhySW5qZWN0IiwidG9nZ2xlUHJlaW5qZWN0Iiwic2l0ZSIsImlzRXhwb3NlZCIsImVuYWJsZSIsIm9uT2ZmIiwib25TZW5kSGVhZGVycyIsIm9uSGVhZGVyc1JlY2VpdmVkIiwiT25IZWFkZXJzUmVjZWl2ZWRPcHRpb25zIiwiRVhUUkFfSEVBREVSUyIsImhhcyIsInByZXBhcmVYaHJCbG9iIiwicmVzcG9uc2VIZWFkZXJzIiwiZGV0ZWN0U3RyaWN0Q3NwIiwiZm9yY2VDb250ZW50SW5qZWN0aW9uIiwicHJlcGFyZVNjcmlwdHMiLCJpc0xhdGUiLCJoYXNNb3JlIiwiZXZlcnkiLCJzY3IiLCJpc0NvbnRlbnRSZWFsbSIsInVhIiwicmVnaXN0ZXJTY3JpcHREYXRhRkYiLCJkYXRhS2V5IiwicmVwbGFjZVdpdGhGdWxsV2lkdGhGb3JtIiwiaXNDb250ZW50IiwicmVxcyIsInJlcXNTbGljZXMiLCJjb25jYXQiLCJoYXNSZXFzIiwiaW5qZWN0ZWRDb2RlIiwibWV0YVN0ciIsIk1FVEFCTE9DS19SRSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJlc29sdmVEYXRhQ29kZVN0ciIsInZtUmVzb2x2ZSIsInZtRGF0YSIsImFsbEZyYW1lcyIsImNvbnRlbnRTY3JpcHRzIiwibWF0Y2hlcyIsInJlYWxtIiwiSU5KRUNUX0NPTlRFTlQiLCJyZXFIYW5kbGVyIiwiVk1fVkVSSUZZIiwiQ09ORklSTV9VUkxfQkFTRSIsInZlcmlmeSIsInRhYlJlcXVlc3RzIiwiZW5jb2RlciIsImV2dCIsImN1cnJlbnQiLCJDb25maXJtSW5zdGFsbCIsImNvbmZpcm1JbnN0YWxsIiwiQ2hlY2tJbnN0YWxsZXJUYWIiLCJIdHRwUmVxdWVzdCIsIkFib3J0UmVxdWVzdCIsImFib3J0IiwiY2xlYXJSZXF1ZXN0IiwiUmV2b2tlQmxvYiIsInNwZWNpYWxIZWFkZXJzIiwiSGVhZGVySW5qZWN0b3IiLCJhcGlGaWx0ZXIiLCJPbkJlZm9yZVNlbmRIZWFkZXJzT3B0aW9ucyIsImhlYWRlcnNUb0luamVjdCIsImlzVm1WZXJpZnkiLCJpc05vdENvb2tpZSIsImlzU2VuZGFibGUiLCJpc1NlbmRhYmxlQW5vbiIsIlJFX1NFVF9DT09LSUUiLCJSRV9TRVRfQ09PS0lFX1ZBTFVFIiwiUkVfU0VUX0NPT0tJRV9BVFRSIiwiU0FNRV9TSVRFX01BUCIsInN0cmljdCIsImxheCIsIm5vbmUiLCJzZXRDb29raWVJblN0b3JlIiwiaGVhZGVyVmFsdWUiLCJleGVjIiwib3B0U3RyIiwib3B0IiwiaXNIb3N0IiwibGFzdEluZGV4Iiwic2FtZVNpdGUiLCJjb29raWVzIiwiZXhwaXJhdGlvbkRhdGUiLCJleHBpcmVzIiwiaHR0cE9ubHkiLCJzZWN1cmUiLCJzdG9yZUlkIiwiYXBpRXZlbnRzIiwib25CZWZvcmVTZW5kSGVhZGVycyIsImxpc3RlbmVyIiwicmVxdWVzdEhlYWRlcnMiLCJyZXF1ZXN0SWQiLCJyZXFJZCIsImNvcmVJZCIsIm5vTmF0aXZlQ29va2llIiwiaCIsImVuY29kZVdlYlJlcXVlc3RIZWFkZXIiLCJhZGQiLCJpc0VtcHR5IiwiQ0hVTktfU0laRSIsImJsb2IyY2h1bmsiLCJibG9iMmJhc2U2NCIsImJsb2Iyb2JqZWN0VXJsIiwieGhyQ2FsbGJhY2tXcmFwcGVyIiwibGFzdFByb21pc2UiLCJjb250ZW50VHlwZSIsImRhdGFTaXplIiwibnVtQ2h1bmtzIiwicmVzcG9uc2VUZXh0IiwiYmxvYmJlZCIsImNodW5rZWQiLCJnZXRDaHVuayIsImdldFJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsImdldFJlc3BvbnNlSGVhZGVyIiwiY2VpbCIsInNob3VsZE5vdGlmeSIsInNob3VsZFNlbmRSZXNwb25zZSIsImNiIiwiZmluYWxVcmwiLCJyZXNwb25zZVVSTCIsImNodW5rIiwicG9zIiwibGFzdCIsImlzU3BlY2lhbEhlYWRlciIsImxvd2VySGVhZGVyIiwiaW5jb2duaXRvIiwib3ZlcnJpZGVNaW1lVHlwZSIsInhoclR5cGUiLCJ2bUhlYWRlcnMiLCJkZWNvZGVCb2R5Iiwic2hvdWxkU2VuZENvb2tpZXMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwibG93ZXJOYW1lIiwidGltZW91dCIsImdldEFsbENvb2tpZVN0b3JlcyIsInRhYklkcyIsImZpcmVmb3giLCJmaXJzdFBhcnR5RG9tYWluIiwiYyIsInNlc3Npb24iLCJvbmxvYWRlbmQiLCJ3YXNCbG9iIiwic3RyaW5nMnVpbnQ4YXJyYXkiLCJhdG9iIiwicDEiLCJpc1VzZXJTY3JpcHQiLCJjb25maXJtS2V5IiwiYWN0aXZlIiwiY2FuUmVwbGFjZUN1clRhYiIsImZmIiwiY29uZmlybVVybCIsIndpbmRvd0lkIiwid2luZG93cyIsImZvY3VzZWQiLCJ3aGl0ZWxpc3RSZSIsIlJlZ0V4cCIsImJsYWNrbGlzdFJlIiwicmVzb2x2ZVZpcnR1YWxVcmwiLCJ2aXJ0dWFsVXJsUmUiLCJtYXliZVJlZGlyZWN0VmlydHVhbFVybEZGIiwiYXBpRXZlbnQiLCJiaW5kIiwib25DcmVhdGVkIiwicmVkaXJlY3RVcmwiLCJtYXliZUluc3RhbGxVc2VySnMiLCJiaW5hcnlWYWx1ZSIsInN0cmluZzJieXRlU3RyaW5nIiwiYnVmZmVyMnN0cmluZyIsIkNhY2hlTmV3U2NyaXB0IiwiTmV3U2NyaXB0IiwiYXJyYXlUeXBlIiwiZGVmYXVsdCIsImRlZmF1bHRUeXBlIiwibWV0YVR5cGVzIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJleGNsdWRlTWF0Y2giLCJyZXNvdXJjZSIsInBhaXIiLCJtZXRhT3B0aW9uYWxUeXBlcyIsImFudGlmZWF0dXJlIiwiY29tcGF0aWJsZSIsImNvbm5lY3QiLCJtZXRhQm9keSIsIl9tYXRjaCIsInJhd0tleSIsInJhd1ZhbHVlIiwia2V5TmFtZSIsImxvY2FsZSIsImNhbWVsS2V5IiwiZyIsInRvVXBwZXJDYXNlIiwibWV0YVR5cGUiLCJvbGRWYWx1ZSIsImhvbWVwYWdlIiwiZGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwibmFtZXNwYWNlIiwibmFtZVVSSSIsImVuY29kZUZpbGVuYW1lIiwicGllY2UiLCJkaWN0Iiwia2V5VmFsIiwiY2FjaGVPckZldGNoIiwiY2hlY2siLCJtYWtlUmF3IiwiaGFuZGxlcnMiLCJjYWNoZU9yRmV0Y2hIYW5kbGVyIiwiZG9GZXRjaCIsImlzTW9kaWZpZWQiLCJwYXRoSWQiLCJleHRlbnNpb24iLCJnZXRWaWV3cyIsImxvY2F0aW9uIiwibWF5YmVJbldpbmRvdyIsImNvbnRhaW5lciIsImluc2VydCIsInBpbm5lZCIsInNyY1RhYiIsInNyY1VybCIsImlzSW50ZXJuYWwiLCJjb29raWVTdG9yZUlkIiwiZ2V0Q29udGFpbmVySWQiLCJjYW5PcGVuSW5jb2duaXRvIiwibmV3VGFiIiwid25kT3B0cyIsImhhc1BvcyIsInduZCIsIm9wZW5lclRhYklkU3VwcG9ydGVkIiwib3BlbmVyVGFiSWQiLCJUYWJDbG9zZSIsIlRhYkZvY3VzIiwicmVhZHkiLCJkZWZpbmVQcm9wZXJ0aWVzIiwib3MiLCJTQ1JJUFRfVEVNUExBVEVfRURJVEVEIiwiSU5JVElBTF9URU1QTEFURSIsImVkaXRlZCIsInRlbXBsYXRlIiwiZGVmYXVsdFRlbXBsYXRlIiwiVGVzdEJsYWNrbGlzdCIsInJlc2V0QmxhY2tsaXN0IiwiUkVfTUFUQ0hfUEFSVFMiLCJibGFja2xpc3RSdWxlcyIsImJsYWNrbGlzdCIsIlJFX0hUVFBfT1JfSFRUUFMiLCJNQVhfQkxfQ0FDSEVfTEVOR1RIIiwiYmxDYWNoZSIsImJsQ2FjaGVTaXplIiwidGVzdFJ1bGVzIiwicnVsZXMiLCJydWxlQnVpbGRlciIsIm1hdGNoZXIiLCJ0ZXN0R2xvYiIsImF1dG9SZWciLCJ0ZXN0TWF0Y2giLCJtYXRjaFRlc3RlciIsImJhdGNoIiwibWF0IiwibWVyZ2VMaXN0cyIsImluYyIsImV4YyIsImV4Y01hdCIsIm9rIiwic3RyMlJFIiwicmUiLCJiaW5kUkUiLCJyZVN0ciIsInJlVGxkU3RyIiwidHN0ciIsInN1ZmZpeCIsIm1hdGNoU2NoZW1lIiwiUkVfU1RSX0FOWSIsIlJFX1NUUl9UTEQiLCJob3N0TWF0Y2hlciIsInJ1bGVMQyIsInRsZFN0ciIsInRsZFN1ZmZpeCIsInBhdGhNYXRjaGVyIiwiaUhhc2giLCJpUXVlcnkiLCJzdHJSZSIsInJ1bGVQYXJ0cyIsIm1hdGNoSG9zdCIsIm1hdGNoUGF0aCIsInBhcnRzIiwidXBkYXRlQmxhY2tsaXN0Q2FjaGUiLCJDaGVja1VwZGF0ZSIsInJlc3VsdHMiLCJjaGVja0FsbEFuZE5vdGlmeSIsIkNoZWNrVXBkYXRlQWxsIiwidG9VcGRhdGUiLCJub3RlcyIsImNoZWNrVXBkYXRlIiwib3Blbk9wdGlvbnNQYWdlIiwicHJvY2Vzc2VzIiwiZG9DaGVja1VwZGF0ZSIsIm1zZ09rIiwibXNnRXJyIiwicmVzb3VyY2VPcHRzIiwiZG93bmxvYWRVcGRhdGUiLCJjaGVja2luZyIsImNhbk5vdGlmeSIsImRvd25sb2FkVVJMIiwidXBkYXRlVVJMIiwiZGV2IiwiZXJyb3JNZXNzYWdlIiwiYW5ub3VuY2UiLCJhbGxvd2VkIiwibm90aWZ5VXBkYXRlcyIsInVwZGF0ZVNjaGVkdWxlZCIsIkdldFZhbHVlU3RvcmUiLCJzdG9yZXMiLCJTZXRWYWx1ZVN0b3JlcyIsImJyb2FkY2FzdFZhbHVlU3RvcmVzIiwiZ3JvdXBTdG9yZXNCeUZyYW1lIiwiVXBkYXRlVmFsdWUiLCJ1cGRhdGVMYXRlciIsIm9uUmVwbGFjZWQiLCJhZGRlZElkIiwicmVtb3ZlZElkIiwib3BlbmVyVGFicyIsInNjcmlwdElkcyIsImN1cnJlbnRDYWNoZSIsImRvVXBkYXRlIiwidmFsdWVTdG9yZXMiLCJncm91cENhY2hlQnlGcmFtZSIsInBhcnRpYWwiLCJ0YWJGcmFtZURhdGEiLCJ0YXNrcyIsImZyYW1lcyIsImZyYW1lRGF0YSIsImNhY2hlRGF0YSIsInRvU2VuZCIsInNjcmlwdERhdGEiLCJkYXRhRW50cmllcyIsImhpc3RvcnkiLCJjaGVja1R5cGUiLCJoYW5kbGUiLCJkZWZhdWx0UHJldmVudGVkIiwiaW5pdFRMRCIsImV4cG9ydE1ldGhvZCIsInRsZGpzIiwiaXNSZWFkeSIsImdldERvbWFpbiIsImdldFN1YmRvbWFpbiIsImdldFB1YmxpY1N1ZmZpeCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQUFBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsUUFBUSxvQkFBb0I7UUFDNUI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlLGtFQUFrRTtBQUNyRixHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FB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QVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzN0QmE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBQSxrRUFBVyxDQUFFQyxPQUFELElBQWE7QUFDdkIsTUFBSSxnQkFBZ0JBLE9BQXBCLEVBQTZCO0FBQzNCQyxjQUFVO0FBQ1g7O0FBQ0QsTUFBSUMscUVBQWUsSUFBSUYsT0FBdkIsRUFBZ0M7QUFDOUJHLHFGQUFtQixDQUFDSCxPQUFELENBQW5CO0FBQ0Q7O0FBQ0RJLGlHQUFPLENBQUMsZUFBRCxFQUFrQkosT0FBbEIsQ0FBUDtBQUNELENBUlUsQ0FBWDtBQVVBSyxNQUFNLENBQUNDLE1BQVAsQ0FBY0MsK0NBQWQsRUFBd0I7QUFDdEI7QUFDQSxRQUFNQyxPQUFOLENBQWNDLEdBQWQsRUFBbUI7QUFDakIsVUFBTUMsSUFBSSxHQUFHLE1BQU1DLHlEQUFPLENBQUNGLEdBQUQsQ0FBMUI7QUFDQUMsUUFBSSxDQUFDRSxJQUFMLEdBQVlBLCtDQUFBLEVBQVo7QUFDQSxXQUFPRixJQUFQO0FBQ0QsR0FOcUI7O0FBT3RCO0FBQ0EsUUFBTUcsV0FBTixDQUFrQjtBQUFFQyxPQUFGO0FBQU9DO0FBQVAsR0FBbEIsRUFBeUNDLEdBQXpDLEVBQThDO0FBQzVDLFVBQU07QUFBRUMsYUFBRjtBQUFXQztBQUFYLFFBQW1CRixHQUF6QjtBQUNBLFVBQU1HLEtBQUssR0FBR0QsR0FBRyxDQUFDRSxFQUFsQjtBQUNBLFFBQUksQ0FBQ04sR0FBTCxFQUFVQSxHQUFHLEdBQUdFLEdBQUcsQ0FBQ0YsR0FBSixJQUFXSSxHQUFHLENBQUNKLEdBQXJCOztBQUNWLFFBQUksQ0FBQ0csT0FBTCxFQUFjO0FBQ1pJLDZFQUFnQixDQUFDRixLQUFELENBQWhCO0FBQ0FHLG1GQUFvQixDQUFDSCxLQUFELENBQXBCO0FBQ0Q7O0FBQ0QsVUFBTUksR0FBRyxHQUFHLE1BQU1DLDRFQUFrQixDQUFDVixHQUFELEVBQU1LLEtBQU4sRUFBYUYsT0FBYixFQUFzQkYsWUFBdEIsQ0FBcEM7QUFDQSxVQUFNO0FBQUVVLGNBQUY7QUFBWUMsWUFBWjtBQUFvQkM7QUFBcEIsUUFBaUNKLEdBQXZDO0FBQ0FHLFVBQU0sQ0FBQ0UsWUFBUCxHQUFzQkMsK0RBQVMsQ0FBQ1YsS0FBRCxDQUEvQixDQVY0QyxDQVc1QztBQUNBOztBQUNBLFFBQUlNLFFBQVEsQ0FBQ0ssTUFBYixFQUFxQjtBQUNuQkMsZ0JBQVUsQ0FBQ3hCLCtDQUFRLENBQUN5QixpQkFBVixFQUE2QixDQUE3QixFQUFnQztBQUFFUDtBQUFGLE9BQWhDLEVBQThDVCxHQUE5QyxDQUFWO0FBQ0Q7O0FBQ0RpQix5RUFBYyxDQUFDZCxLQUFELEVBQVFGLE9BQVIsRUFBaUJVLFFBQWpCLENBQWQ7QUFDQSxXQUFPRCxNQUFQO0FBQ0QsR0ExQnFCOztBQTJCdEI7QUFDQSxRQUFNUSxZQUFOLEdBQXFCO0FBQ25CLFVBQU1oQixHQUFHLEdBQUcsT0FBTWlCLG9HQUFZLEVBQWxCLEtBQXdCLEVBQXBDO0FBQ0EsVUFBTXJCLEdBQUcsR0FBR0ksR0FBRyxDQUFDa0IsVUFBSixJQUFrQmxCLEdBQUcsQ0FBQ0osR0FBdEIsSUFBNkIsRUFBekM7QUFDQSxVQUFNdUIsSUFBSSxHQUFHdkIsR0FBRyxDQUFDd0IsS0FBSixDQUFVLHVCQUFWLEVBQW1DLENBQW5DLENBQWI7QUFDQSxXQUFPO0FBQ0xwQixTQURLO0FBRUxxQixZQUFNLEVBQUVGLElBQUksSUFBSUcsNkZBQUEsQ0FBY0gsSUFBZCxDQUFSLElBQStCQTtBQUZsQyxLQUFQO0FBSUQsR0FwQ3FCOztBQXFDdEI7Ozs7O0FBS0FJLFlBQVUsQ0FBQ0MsRUFBRCxFQUFLO0FBQ2IsV0FBT0EsRUFBRSxHQUFHLENBQUwsSUFBVUMsaUdBQVMsQ0FBQ0QsRUFBRCxDQUExQjtBQUNEOztBQTVDcUIsQ0FBeEIsRSxDQStDQTs7QUFDQSxNQUFNRSxjQUFjLEdBQUcsQ0FDckIsYUFEcUIsRUFFckIsTUFGcUIsRUFHckIsYUFIcUIsRUFJckIsY0FKcUIsRUFLckIsa0JBTHFCLENBQXZCLEMsQ0FPQTs7QUFDQSxNQUFNQyxzQkFBc0IsR0FBRyxDQUM3QixhQUQ2QixFQUU3QixhQUY2QixFQUc3QixnQkFINkIsQ0FBL0I7O0FBTUEsZUFBZUMsb0JBQWYsQ0FBb0NDLEdBQXBDLEVBQXlDL0IsR0FBekMsRUFBOEM7QUFBQTs7QUFDNUMsUUFBTTtBQUFFZ0M7QUFBRixNQUFVRCxHQUFoQjtBQUNBLFFBQU14QixHQUFHLEdBQUcsd0JBQU1oQiwrQ0FBUSxDQUFDeUMsR0FBRCxDQUFkLHFCQUFNLG1CQUFBekMsK0NBQVEsRUFBUXdDLEdBQUcsQ0FBQ3JDLElBQVosRUFBa0JNLEdBQWxCLENBQWQsQ0FBWjs7QUFDQSxNQUFJNEIsY0FBYyxDQUFDSyxRQUFmLENBQXdCRCxHQUF4QixLQUNEekIsR0FBRyxJQUFJc0Isc0JBQXNCLENBQUNJLFFBQXZCLENBQWdDRCxHQUFoQyxDQURWLEVBQ2dEO0FBQzlDcEMsOENBQUE7QUFDRCxHQU4yQyxDQU81Qzs7O0FBQ0EsU0FBT1csR0FBUCxXQUFPQSxHQUFQLEdBQWMsSUFBZDtBQUNEOztBQUVELFNBQVN0QixVQUFULEdBQXNCO0FBQ3BCLFFBQU1pRCxRQUFRLEdBQUdDLDZGQUFNLEdBQUcsSUFBSCxHQUFVLENBQUMsQ0FBQ0MsZ0VBQVMsQ0FBQyxZQUFELENBQVYsSUFBNEIsQ0FBN0IsSUFBa0NDLHNHQUFuRTtBQUNBLE1BQUksQ0FBQ0gsUUFBTCxFQUFlO0FBQ2YsTUFBSUksT0FBTyxHQUFHQyxJQUFJLENBQUNDLEdBQUwsS0FBYUosZ0VBQVMsQ0FBQyxZQUFELENBQXBDOztBQUNBLE1BQUlFLE9BQU8sSUFBSUosUUFBZixFQUF5QjtBQUN2Qkosd0JBQW9CLENBQUM7QUFBRUUsU0FBRyxFQUFFO0FBQVAsS0FBRCxDQUFwQjtBQUNBTSxXQUFPLEdBQUcsQ0FBVjtBQUNEOztBQUNERyxjQUFZLENBQUN4RCxVQUFVLENBQUN5RCxLQUFaLENBQVo7QUFDQXpELFlBQVUsQ0FBQ3lELEtBQVgsR0FBbUIzQixVQUFVLENBQUM5QixVQUFELEVBQWEwRCxJQUFJLENBQUNDLEdBQUwsQ0FBU0Msa0dBQVQsRUFBc0JYLFFBQVEsR0FBR0ksT0FBakMsQ0FBYixDQUE3QjtBQUNEOztBQUVELGVBQWVRLFdBQWYsR0FBNkI7QUFDM0IsUUFBTTtBQUFFcEQ7QUFBRixNQUFXLE1BQU1xRCwrRkFBTyxDQUFDQywwR0FBRCxFQUFzQjtBQUNsREMsU0FBSyxFQUFFLFVBRDJDO0FBRWxEQyxXQUFPLEVBQUU7QUFBRUMsWUFBTSxFQUFFO0FBQVY7QUFGeUMsR0FBdEIsQ0FBOUI7QUFLQSxRQUFNNUMsR0FBRyxHQUFHLE1BQU1oQiwrQ0FBUSxDQUFDNkQsV0FBVCxDQUFxQjtBQUNyQ3RELE9BQUcsRUFBRWtELDBHQURnQztBQUVyQ0ssUUFBSSxFQUFFM0QsSUFGK0I7QUFHckM0RCxVQUFNLEVBQUU7QUFBRUMsYUFBTyxFQUFFO0FBQVg7QUFINkIsR0FBckIsQ0FBbEI7QUFLQTNELDRDQUFBOztBQUVBLE1BQUlXLEdBQUcsQ0FBQ2lELEtBQUosQ0FBVXBELEVBQVYsS0FBaUIsQ0FBckIsRUFBd0I7QUFDdEIsVUFBTyxhQUFZRyxHQUFHLENBQUNpRCxLQUFKLENBQVVwRCxFQUFHLEVBQWhDO0FBQ0Q7QUFDRjs7QUFFRHFELDhEQUFVLENBQUMsTUFBTTtBQUNmQyxRQUFNLENBQUM1QixvQkFBUCxHQUE4QkEsb0JBQTlCO0FBQ0E0QixRQUFNLENBQUNDLFFBQVAsR0FBa0JBLCtGQUFsQjtBQUNBQyxTQUFPLENBQUNDLE9BQVIsQ0FBZ0JDLFNBQWhCLENBQTBCQyxXQUExQixDQUNFQyxVQUFVLENBQUM7QUFBRCxJQUNOLENBQUMsR0FBR0MsSUFBSixLQUFhbkMsb0JBQW9CLENBQUMsR0FBR21DLElBQUosQ0FBcEIsQ0FBOEJDLEtBQTlCLENBQW9DQyxDQUFDLElBQ2xEQyxPQUFPLENBQUNDLE1BQVIsQ0FBZUYsQ0FBQyxZQUFZRyxLQUFiLEdBQXFCSCxDQUFyQixHQUF5QixJQUFJRyxLQUFKLENBQVVILENBQVYsQ0FBeEMsQ0FEYSxDQURQLENBR0w7QUFISyxJQUlOckMsb0JBTE4sRUFIZSxDQVdmOztBQUNBZ0IsYUFBVztBQUNYeUIsU0FBTyxDQUFDQyxJQUFSLENBQWEsZ0JBQWI7QUFDQXpELFlBQVUsQ0FBQzlCLFVBQUQsRUFBYWtELDZGQUFNLEdBQUcsQ0FBSCxHQUFPLEdBQTFCLENBQVY7QUFDQXZDLGtEQUFBO0FBQ0E2RSwrREFBVztBQUNYQyxhQUFXLENBQUNELHFEQUFELEVBQWNwQyxzR0FBZCxDQUFYO0FBQ0EsUUFBTXNDLEdBQUcsR0FBR2pCLE1BQU0sQ0FBQ2tCLE1BQVAsQ0FBY0Msa0JBQTFCOztBQUNBLE1BQUlGLEdBQUosRUFBUztBQUNQO0FBQ0FBLE9BQUcsQ0FBQ0csYUFBSixDQUFrQkMsUUFBbEIsQ0FBMkIsT0FBTyxDQUFDQyxJQUFELENBQVAsS0FBa0I7QUFDM0MsWUFBTTVFLEVBQUUsR0FBRzRFLElBQUgsb0JBQUdBLElBQUksQ0FBRTVFLEVBQWpCO0FBQ0EsWUFBTTZFLEtBQUssR0FBR0MsNEJBQWQ7O0FBQ0EsVUFBSTlFLEVBQUUsS0FBSzZFLEtBQVgsRUFBa0I7QUFDaEI7QUFDRDs7QUFDRCxVQUFJN0UsRUFBSixFQUFRO0FBQ04sY0FBTXdELE9BQU8sQ0FBQ2lCLGtCQUFSLENBQTJCQyxhQUEzQixDQUF5Q0ssV0FBekMsQ0FBcUQsQ0FBQy9FLEVBQUQsQ0FBckQsQ0FBTjtBQUNEOztBQUNEdUUsU0FBRyxDQUFDRyxhQUFKLENBQWtCTSxRQUFsQixDQUEyQixDQUFDO0FBQzFCaEYsVUFBRSxFQUFFNkUsS0FEc0I7QUFFMUJJLGtCQUFVLEVBQUUsQ0FDVixJQUFJVixHQUFHLENBQUNXLGdCQUFSLENBQXlCO0FBQ3ZCQyxpQkFBTyxFQUFFO0FBQUVDLHVCQUFXLEVBQUU7QUFBZixXQURjLENBQ1U7O0FBRFYsU0FBekIsQ0FEVSxDQUZjO0FBTzFCQyxlQUFPLEVBQUUsQ0FDUCxJQUFJZCxHQUFHLENBQUNlLG9CQUFSLENBQTZCO0FBQzNCQyxZQUFFLEVBQUUvQixPQUFPLENBQUNDLE9BQVIsQ0FBZ0IrQixXQUFoQixHQUE4QkMsZUFBOUIsQ0FBOEMsQ0FBOUMsRUFBaURGLEVBRDFCLENBRTNCOztBQUYyQixTQUE3QixDQURPO0FBUGlCLE9BQUQsQ0FBM0I7QUFjRCxLQXZCRDtBQXdCRDtBQUNGLENBOUNTLENBQVYsQzs7Ozs7Ozs7Ozs7O0FDeklBO0FBQUE7QUFBQTtBQUVlLG1FQUFJRyw4RkFBSixDQUFpQixDQUM5QixZQUQ4QixFQUU5QixlQUY4QixDQUFqQixDQUFmLEU7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVPLE1BQU1DLE1BQU0sR0FBRztBQUNwQjs7Ozs7QUFLQUMsUUFBTSxFQUFFekcsdURBQVEsQ0FBQzZELFdBTkc7O0FBT3BCOzs7O0FBSUE2QyxNQUFJLEVBQUUsWUFBWUMsNERBQVUsRUFYUjs7QUFZcEI7Ozs7O0FBS0FDLEtBQUcsRUFBRTVHLHVEQUFRLENBQUM2RyxhQWpCTTs7QUFrQnBCOzs7OztBQUtBQyxRQUFNLEVBQUVqRyxFQUFFLElBQUliLHVEQUFRLENBQUMrRyxXQUFULENBQXFCO0FBQUVsRyxNQUFGO0FBQU1tRyxXQUFPLEVBQUU7QUFBZixHQUFyQjtBQXZCTSxDQUFmLEM7Ozs7Ozs7Ozs7OztBQ0hQO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBR0E7QUFHQTtBQUlBO0FBRUEsTUFBTUMsWUFBWSxHQUFHLEVBQXJCO0FBQ0EsTUFBTUMsY0FBYyxHQUFHLEVBQXZCO0FBQ0EsTUFBTUMsUUFBUSxHQUFHLEVBQWpCO0FBQ0EsTUFBTUMsUUFBUSxHQUFHQyxnR0FBUSxDQUFDaEgsSUFBRCxFQUFPaUgsbUdBQVAsQ0FBekI7QUFDQSxJQUFJQyxPQUFPLEdBQUcxQyxPQUFPLENBQUMyQyxPQUFSLEVBQWQ7QUFDQSxJQUFJQyxVQUFKO0FBRU8sU0FBU0MsZUFBVCxDQUF5QjtBQUFFQyxNQUFGO0FBQVFDO0FBQVIsQ0FBekIsRUFBd0M7QUFDN0M7QUFDQSxNQUFJRCxJQUFKLEVBQVUsT0FBT0EsSUFBUCxDQUZtQyxDQUc3QztBQUNBOztBQUNBLFNBQVEsUUFBT0MsR0FBSSxFQUFuQjtBQUNEO0FBQ00sU0FBU0MsWUFBVCxDQUFzQkYsSUFBdEIsRUFBNEI7QUFDakMsU0FBTyxnQkFBZ0JHLElBQWhCLENBQXFCSCxJQUFyQixDQUFQO0FBQ0Q7QUFDTSxTQUFTSSxNQUFULENBQWdCSixJQUFoQixFQUFzQjtBQUMzQixRQUFNSyxDQUFDLEdBQUdMLElBQUksQ0FBQ00sT0FBTCxDQUFhLEdBQWIsQ0FBVjtBQUNBLFFBQU0sR0FBR0MsT0FBSCxJQUFjUCxJQUFJLENBQUNRLEtBQUwsQ0FBVyxDQUFYLEVBQWNILENBQWQsRUFBaUJJLEtBQWpCLENBQXVCLEdBQXZCLENBQXBCOztBQUNBLE1BQUlGLE9BQU8sS0FBSyxHQUFoQixFQUFxQjtBQUNuQjtBQUNBLFdBQU9QLElBQUksQ0FBQ1EsS0FBTCxDQUFXSCxDQUFDLEdBQUcsQ0FBZixDQUFQO0FBQ0Q7O0FBQ0QsTUFBSTtBQUNGLFdBQU9LLGtCQUFrQixDQUFDVixJQUFJLENBQUNRLEtBQUwsQ0FBVyxDQUFYLENBQUQsQ0FBekI7QUFDRCxHQUZELENBRUUsT0FBT0csR0FBUCxFQUFZO0FBQ1osV0FBT1gsSUFBSSxDQUFDUSxLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTSSxVQUFULEdBQXNCO0FBQ3BCLFdBQVMzQixHQUFULENBQWE0QixHQUFiLEVBQWtCQyxHQUFsQixFQUF1QjtBQUNyQixVQUFNQyxJQUFJLEdBQUdDLHFHQUFhLENBQUNILEdBQUQsQ0FBMUI7QUFDQUUsUUFBSSxDQUFDRSxPQUFMLENBQWEsTUFBYjtBQUNBLFdBQU8vRix3REFBUyxDQUFDNkYsSUFBRCxFQUFPRCxHQUFQLENBQWhCO0FBQ0Q7O0FBQ0QsV0FBU0ksR0FBVCxDQUFhTCxHQUFiLEVBQWtCTSxLQUFsQixFQUF5QjtBQUN2QixVQUFNSixJQUFJLEdBQUdDLHFHQUFhLENBQUNILEdBQUQsQ0FBMUI7QUFDQUUsUUFBSSxDQUFDRSxPQUFMLENBQWEsTUFBYjtBQUNBRyw0REFBUyxDQUFDTCxJQUFELEVBQU9JLEtBQVAsQ0FBVDtBQUNEOztBQUNELFdBQVNFLElBQVQsR0FBZ0I7QUFDZCxRQUFJQyxNQUFNLEdBQUdwRyx3REFBUyxDQUFDLE1BQUQsQ0FBdEI7O0FBQ0EsUUFBSSxDQUFDb0csTUFBRCxJQUFXLENBQUNBLE1BQU0sQ0FBQzlCLFFBQXZCLEVBQWlDO0FBQy9COEIsWUFBTSxHQUFHO0FBQ1A5QixnQkFBUSxFQUFFO0FBREgsT0FBVDtBQUdBMEIsU0FBRyxDQUFDLEVBQUQsRUFBS0ksTUFBTCxDQUFIO0FBQ0Q7QUFDRjs7QUFDREQsTUFBSTtBQUNKLFNBQU87QUFBRXBDLE9BQUY7QUFBT2lDO0FBQVAsR0FBUDtBQUNEOztBQUNELFNBQVNLLGFBQVQsQ0FBdUJ2QixJQUF2QixFQUE2QjtBQUMzQixXQUFTd0IsT0FBVCxDQUFpQlgsR0FBakIsRUFBc0I7QUFDcEIsVUFBTUUsSUFBSSxHQUFHQyxxR0FBYSxDQUFDSCxHQUFELENBQTFCO0FBQ0FFLFFBQUksQ0FBQ0UsT0FBTCxDQUFhLFVBQWIsRUFBeUJqQixJQUF6QjtBQUNBLFdBQU9lLElBQVA7QUFDRDs7QUFDRCxXQUFTOUIsR0FBVCxDQUFhNEIsR0FBYixFQUFrQkMsR0FBbEIsRUFBdUI7QUFDckIsV0FBT2hCLFVBQVUsQ0FBQ2IsR0FBWCxDQUFldUMsT0FBTyxDQUFDWCxHQUFELENBQXRCLEVBQTZCQyxHQUE3QixDQUFQO0FBQ0Q7O0FBQ0QsV0FBU0ksR0FBVCxDQUFhTCxHQUFiLEVBQWtCWSxHQUFsQixFQUF1QjtBQUNyQixRQUFJLE9BQU9aLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixlQUFLYSxtR0FBTCxFQUFBYixHQUFHLEVBQWUsQ0FBQyxDQUFDYyxDQUFELEVBQUlDLENBQUosQ0FBRCxLQUFZO0FBQzVCOUIsa0JBQVUsQ0FBQ29CLEdBQVgsQ0FBZU0sT0FBTyxDQUFDRyxDQUFELENBQXRCLEVBQTJCQyxDQUEzQjtBQUNELE9BRkUsQ0FBSDtBQUdELEtBSkQsTUFJTztBQUNMOUIsZ0JBQVUsQ0FBQ29CLEdBQVgsQ0FBZU0sT0FBTyxDQUFDWCxHQUFELENBQXRCLEVBQTZCWSxHQUE3QjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBU0ksS0FBVCxHQUFpQjtBQUNmL0IsY0FBVSxDQUFDb0IsR0FBWCxDQUFlTSxPQUFPLEVBQXRCLEVBQTBCLEVBQTFCO0FBQ0Q7O0FBQ0QsU0FBTztBQUFFdkMsT0FBRjtBQUFPaUMsT0FBUDtBQUFZVztBQUFaLEdBQVA7QUFDRDs7QUFDRCxTQUFTQyxZQUFULENBQXNCQyxXQUF0QixFQUFtQ0MsWUFBbkMsRUFBaURDLFFBQWpELEVBQTJEO0FBQ3pELE1BQUlDLEtBQUssR0FBR0YsWUFBWSxJQUFJRCxXQUFXLENBQUMsQ0FBRCxDQUF2Qzs7QUFDQSxXQUFTOUMsR0FBVCxHQUFlO0FBQ2IsV0FBT2lELEtBQVA7QUFDRDs7QUFDRCxXQUFTaEIsR0FBVCxDQUFhaUIsUUFBYixFQUF1QjtBQUNyQixRQUFJSixXQUFXLENBQUNoSCxRQUFaLENBQXFCb0gsUUFBckIsQ0FBSixFQUFvQztBQUNsQ0QsV0FBSyxHQUFHQyxRQUFSO0FBQ0EsVUFBSUYsUUFBSixFQUFjQSxRQUFRO0FBQ3ZCLEtBSEQsTUFHTztBQUNMNUUsYUFBTyxDQUFDK0UsSUFBUixDQUFhLGdCQUFiLEVBQStCRCxRQUEvQjtBQUNEOztBQUNELFdBQU9sRCxHQUFHLEVBQVY7QUFDRDs7QUFDRCxXQUFTb0QsRUFBVCxDQUFZQyxNQUFaLEVBQW9CO0FBQ2xCLFdBQU9DLG1HQUFXLENBQUNELE1BQUQsQ0FBWCxDQUFvQnZILFFBQXBCLENBQTZCbUgsS0FBN0IsQ0FBUDtBQUNEOztBQUNELFNBQU87QUFBRWpELE9BQUY7QUFBT2lDLE9BQVA7QUFBWW1CO0FBQVosR0FBUDtBQUNEOztBQUNNLFNBQVNHLFNBQVQsR0FBcUI7QUFDMUIsU0FBT2xELFlBQVksQ0FBQ21ELEdBQWIsQ0FBa0J6QyxJQUFELElBQVU7QUFDaEMsVUFBTTBDLE9BQU8sR0FBR2xELFFBQVEsQ0FBQ1EsSUFBRCxDQUF4QjtBQUNBLFdBQU87QUFDTEEsVUFBSSxFQUFFMEMsT0FBTyxDQUFDMUMsSUFEVDtBQUVMMkMsaUJBQVcsRUFBRUQsT0FBTyxDQUFDQyxXQUZoQjtBQUdMQyxlQUFTLEVBQUVGLE9BQU8sQ0FBQ0UsU0FBUixDQUFrQjNELEdBQWxCLEVBSE47QUFJTDRELGVBQVMsRUFBRUgsT0FBTyxDQUFDRyxTQUFSLENBQWtCNUQsR0FBbEIsRUFKTjtBQUtMNkQsY0FBUSxFQUFFSixPQUFPLENBQUNwQixNQUFSLENBQWVyQyxHQUFmLENBQW1CLE1BQW5CLEVBQTJCLEVBQTNCLEVBQStCNkQsUUFMcEM7QUFNTEMsY0FBUSxFQUFFTCxPQUFPLENBQUNLLFFBTmI7QUFPTEMsZ0JBQVUsRUFBRU4sT0FBTyxDQUFDTSxVQVBmO0FBUUxDLGdCQUFVLEVBQUVQLE9BQU8sQ0FBQ1EsYUFBUjtBQVJQLEtBQVA7QUFVRCxHQVpNLENBQVA7QUFhRDs7QUFFRCxTQUFTQyxhQUFULENBQXVCdEUsTUFBdkIsRUFBK0J1RSxXQUEvQixFQUE0Q0MsS0FBNUMsRUFBbUQ7QUFDakQsTUFBSTdLLElBQUo7O0FBQ0EsTUFBSTRLLFdBQVcsS0FBSyxDQUFwQixFQUF1QjtBQUNyQjVLLFFBQUksR0FBRztBQUNMK0gsYUFBTyxFQUFFNkMsV0FESjtBQUVMaEgsWUFBTSxFQUFFeUMsTUFBTSxDQUFDekMsTUFGVjtBQUdMa0YsWUFBTSxFQUFFekMsTUFBTSxDQUFDeUMsTUFIVjtBQUlMZ0MsV0FBSyxFQUFFQyx5R0FBVSxDQUFDMUUsTUFBTSxDQUFDeUUsS0FBUixFQUFlLENBQUMsYUFBRCxDQUFmO0FBSlosS0FBUDtBQU1ELEdBUEQsTUFPTyxJQUFJRixXQUFXLEtBQUssQ0FBcEIsRUFBdUI7QUFDNUI1SyxRQUFJLEdBQUc7QUFDTCtILGFBQU8sRUFBRTZDLFdBREo7QUFFTEksVUFBSSxFQUFFO0FBQ0pwSCxjQUFNLEVBQUV5QyxNQUFNLENBQUN6QyxNQURYO0FBRUpxSCxlQUFPLEVBQUU1RSxNQUFNLENBQUN5QyxNQUFQLENBQWNtQyxPQUZuQjtBQUdKM0UsY0FBTSxFQUFFRCxNQUFNLENBQUN5QyxNQUFQLENBQWNvQyxZQUhsQjtBQUlKQyxtQkFBVyxFQUFFOUUsTUFBTSxDQUFDeUUsS0FBUCxDQUFhSztBQUp0QjtBQUZELEtBQVA7QUFTRDs7QUFDRCxTQUFPeEwsTUFBTSxDQUFDQyxNQUFQLENBQWNJLElBQWQsRUFBb0I2SyxLQUFwQixDQUFQO0FBQ0Q7O0FBQ0QsU0FBU08sZUFBVCxDQUF5QkMsR0FBekIsRUFBOEI7QUFDNUIsUUFBTXJMLElBQUksR0FBRyxFQUFiOztBQUNBLE1BQUk7QUFDRixVQUFNc0wsR0FBRyxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0gsR0FBWCxDQUFaO0FBQ0FyTCxRQUFJLENBQUMyRCxJQUFMLEdBQVkySCxHQUFHLENBQUMzSCxJQUFoQjs7QUFDQSxRQUFJMkgsR0FBRyxDQUFDdkQsT0FBSixLQUFnQixDQUFwQixFQUF1QjtBQUNyQi9ILFVBQUksQ0FBQzhJLE1BQUwsR0FBY3dDLEdBQUcsQ0FBQ3hDLE1BQWxCO0FBQ0E5SSxVQUFJLENBQUM0RCxNQUFMLEdBQWMwSCxHQUFHLENBQUMxSCxNQUFsQjtBQUNBNUQsVUFBSSxDQUFDOEssS0FBTCxHQUFhUSxHQUFHLENBQUNSLEtBQWpCO0FBQ0QsS0FKRCxNQUlPLElBQUlRLEdBQUcsQ0FBQ3ZELE9BQUosS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDNUIsVUFBSXVELEdBQUcsQ0FBQ04sSUFBUixFQUFjO0FBQ1poTCxZQUFJLENBQUM0RCxNQUFMLEdBQWMwSCxHQUFHLENBQUNOLElBQUosQ0FBU3BILE1BQXZCO0FBQ0E1RCxZQUFJLENBQUM4SSxNQUFMLEdBQWMyQyxZQUFZLENBQUM7QUFDekJSLGlCQUFPLEVBQUVLLEdBQUcsQ0FBQ04sSUFBSixDQUFTQyxPQURPO0FBRXpCQyxzQkFBWSxFQUFFSSxHQUFHLENBQUNOLElBQUosQ0FBUzFFO0FBRkUsU0FBRCxDQUExQjtBQUlBdEcsWUFBSSxDQUFDOEssS0FBTCxHQUFhVyxZQUFZLENBQUM7QUFDeEJOLHFCQUFXLEVBQUVHLEdBQUcsQ0FBQ04sSUFBSixDQUFTRztBQURFLFNBQUQsQ0FBekI7QUFHRDtBQUNGO0FBQ0YsR0FuQkQsQ0FtQkUsT0FBTzFHLENBQVAsRUFBVTtBQUNWekUsUUFBSSxDQUFDMkQsSUFBTCxHQUFZMEgsR0FBWjtBQUNEOztBQUNELFNBQU9yTCxJQUFQO0FBQ0Q7O0FBRUQsU0FBU3lMLFlBQVQsQ0FBc0JILEdBQXRCLEVBQTJCO0FBQ3pCO0FBQ0EsTUFBSUksS0FBSyxDQUFDQyxPQUFOLENBQWNMLEdBQWQsQ0FBSixFQUF3QjtBQUN0QkEsT0FBRyxDQUFDTSxPQUFKLENBQVlILFlBQVo7QUFDRCxHQUZELE1BRU8sSUFBSUgsR0FBRyxJQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUExQixFQUFvQztBQUN6QyxhQUFLcEMsbUdBQUwsRUFBQW9DLEdBQUcsRUFBZSxDQUFDLENBQUNqRCxHQUFELEVBQU1NLEtBQU4sQ0FBRCxLQUFrQjtBQUNsQyxVQUFJLE9BQU9BLEtBQVAsS0FBaUIsV0FBckIsRUFBa0MsT0FBTzJDLEdBQUcsQ0FBQ2pELEdBQUQsQ0FBVixDQUFsQyxLQUNLb0QsWUFBWSxDQUFDOUMsS0FBRCxDQUFaO0FBQ04sS0FIRSxDQUFIO0FBSUQ7O0FBQ0QsU0FBTzJDLEdBQVA7QUFDRDs7QUFFRCxTQUFTTyxjQUFULENBQXdCQyxJQUF4QixFQUE4QjtBQUM1QixRQUFNQyxPQUFPLEdBQUcsU0FBU0MsV0FBVCxHQUF1QjtBQUNyQyxTQUFLakksVUFBTDtBQUNELEdBRkQ7O0FBR0FnSSxTQUFPLENBQUNFLFNBQVIsR0FBb0JILElBQXBCO0FBQ0FDLFNBQU8sQ0FBQ0csTUFBUixHQUFpQkMsYUFBakI7QUFDQSxTQUFPSixPQUFQO0FBQ0Q7O0FBQ0QsU0FBU0ksYUFBVCxDQUF1QkMsT0FBdkIsRUFBZ0M7QUFDOUIsU0FBT1AsY0FBYyxDQUFDbE0sTUFBTSxDQUFDQyxNQUFQLENBQWNELE1BQU0sQ0FBQzBNLE1BQVAsQ0FBYyxLQUFLSixTQUFuQixDQUFkLEVBQTZDRyxPQUE3QyxDQUFELENBQXJCO0FBQ0Q7O0FBRUQsTUFBTUUsYUFBYSxHQUFHcEYsZ0dBQVEsQ0FBQyxNQUFNO0FBQ25DeEgsaUdBQU8sQ0FBQyxZQUFELEVBQWVzSyxTQUFTLEVBQXhCLENBQVA7QUFDRCxDQUY2QixDQUE5QjtBQUlPLE1BQU11QyxXQUFXLEdBQUdWLGNBQWMsQ0FBQztBQUN4Q3JFLE1BQUksRUFBRSxNQURrQztBQUV4QzJDLGFBQVcsRUFBRSxhQUYyQjtBQUd4Q3FDLFdBQVMsRUFBRSxJQUg2QjtBQUl4Q0MsV0FBUyxFQUFFLEVBSjZCO0FBS3hDQyxVQUFRLEVBQUUsZUFMOEI7QUFNeENsQyxZQUFVLEVBQUU7QUFDVm1DLFlBQVEsRUFBRTtBQURBLEdBTjRCO0FBU3hDakMsZUFBYSxFQUFFa0Msb0ZBVHlCO0FBVXhDQyxlQUFhLEVBQUVELG9GQVZ5Qjs7QUFXeEM3SSxZQUFVLEdBQUc7QUFDWCxTQUFLd0csUUFBTCxHQUFnQjtBQUNkdUMsY0FBUSxFQUFFLENBREk7QUFFZEMsV0FBSyxFQUFFO0FBRk8sS0FBaEI7QUFJQSxTQUFLakUsTUFBTCxHQUFjQyxhQUFhLENBQUMsS0FBS3ZCLElBQU4sQ0FBM0I7QUFDQSxTQUFLNEMsU0FBTCxHQUFpQmQsWUFBWSxDQUFDLENBQzVCLE1BRDRCLEVBRTVCLFNBRjRCLEVBRzVCLGNBSDRCLEVBSTVCLGFBSjRCLEVBSWI7QUFDZixnQkFMNEIsRUFNNUIsY0FONEIsRUFPNUIsT0FQNEIsQ0FBRCxFQVExQixJQVIwQixFQVFwQmdELGFBUm9CLENBQTdCO0FBU0EsU0FBS2pDLFNBQUwsR0FBaUJmLFlBQVksQ0FBQyxDQUM1QixNQUQ0QixFQUU1QixPQUY0QixFQUc1QixTQUg0QixFQUk1QixPQUo0QixDQUFELEVBSzFCLElBTDBCLEVBS3BCZ0QsYUFMb0IsQ0FBN0I7QUFNQSxTQUFLVSxTQUFMLEdBQWlCdEksT0FBTyxDQUFDMkMsT0FBUixFQUFqQjtBQUNBLFNBQUs0RixTQUFMLEdBQWlCLEtBQUtDLFdBQUwsRUFBakI7QUFDQSxVQUFNQyxNQUFNLEdBQUdDLDhEQUFlLEVBQTlCO0FBQ0EsS0FBQyxJQUFELEVBQU8sS0FBUCxFQUFjLE1BQWQsRUFDQ3hCLE9BREQsQ0FDVXZELEdBQUQsSUFBUztBQUNoQixXQUFLQSxHQUFMLElBQVksQ0FBQyxHQUFHOUQsSUFBSixLQUFhO0FBQUU0SSxjQUFNLENBQUM5RSxHQUFELENBQU4sQ0FBWSxHQUFHOUQsSUFBZjtBQUF1QixPQUFsRDtBQUNELEtBSEQ7QUFJRCxHQXZDdUM7O0FBd0N4QzhJLEtBQUcsQ0FBQyxHQUFHOUksSUFBSixFQUFVO0FBQ1hNLFdBQU8sQ0FBQ3dJLEdBQVIsQ0FBWSxHQUFHOUksSUFBZixFQURXLENBQ1c7QUFDdkIsR0ExQ3VDOztBQTJDeEMySSxhQUFXLEdBQUc7QUFDWixRQUFJSSxPQUFKO0FBQ0EsUUFBSUMsZ0JBQUo7O0FBQ0EsVUFBTUMsVUFBVSxHQUFHLE1BQU0sS0FBS3BELFNBQUwsQ0FBZVAsRUFBZixDQUFrQixZQUFsQixLQUFtQzRELFVBQVUsT0FBTyxLQUFLakcsSUFBbEY7O0FBQ0EsVUFBTWtHLFFBQVEsR0FBRyxNQUFNO0FBQ3JCLFVBQUksQ0FBQ0YsVUFBVSxFQUFmLEVBQW1CLE9BQU85SSxPQUFPLENBQUMyQyxPQUFSLEVBQVA7QUFDbkIsV0FBS2dHLEdBQUwsQ0FBUyxnQkFBVCxFQUEyQixLQUFLbEQsV0FBaEM7QUFDQSxXQUFLRSxTQUFMLENBQWUzQixHQUFmLENBQW1CLE9BQW5CO0FBQ0F0QixhQUFPLEdBQUdBLE9BQU8sQ0FBQ3VHLElBQVIsQ0FBYSxNQUFNLElBQUlqSixPQUFKLENBQWEyQyxPQUFELElBQWE7QUFDcERrRyx3QkFBZ0IsR0FBR3JHLGdHQUFRLENBQUNHLE9BQUQsRUFBVSxLQUFLLElBQWYsQ0FBM0I7QUFDQWtHLHdCQUFnQjtBQUNqQixPQUg0QixDQUFuQixFQUlUSSxJQUpTLENBSUosTUFBTTtBQUNWLFlBQUlILFVBQVUsRUFBZCxFQUFrQixPQUFPLEtBQUt0TixJQUFMLEVBQVA7QUFDbEIsYUFBS21LLFNBQUwsQ0FBZTNCLEdBQWYsQ0FBbUIsTUFBbkI7QUFDRCxPQVBTLEVBUVRsRSxLQVJTLENBUUYyRCxHQUFELElBQVM7QUFBRXRELGVBQU8sQ0FBQytJLEtBQVIsQ0FBY3pGLEdBQWQ7QUFBcUIsT0FSN0IsRUFTVHdGLElBVFMsQ0FTSixNQUFNO0FBQ1ZMLGVBQU8sR0FBRyxJQUFWO0FBQ0FDLHdCQUFnQixHQUFHLElBQW5CO0FBQ0QsT0FaUyxDQUFWO0FBYUFELGFBQU8sR0FBR2xHLE9BQVY7QUFDRCxLQWxCRDs7QUFtQkEsYUFBUzZGLFNBQVQsR0FBcUI7QUFDbkIsVUFBSSxDQUFDSyxPQUFMLEVBQWNJLFFBQVE7QUFDdEIsVUFBSUgsZ0JBQUosRUFBc0JBLGdCQUFnQjtBQUN0QyxhQUFPRCxPQUFQO0FBQ0Q7O0FBQ0QsV0FBT0wsU0FBUDtBQUNELEdBeEV1Qzs7QUF5RXhDWSxnQkFBYyxHQUFHO0FBQ2YsU0FBS3JLLE9BQUwsR0FBZSxFQUFmO0FBQ0QsR0EzRXVDOztBQTRFeENzSyxTQUFPLEdBQUc7QUFDUixTQUFLMUQsU0FBTCxDQUFlMUIsR0FBZixDQUFtQixjQUFuQjtBQUNBLFdBQU8sQ0FBQyxLQUFLcUYsU0FBTCxLQUFtQnJKLE9BQU8sQ0FBQzJDLE9BQVIsQ0FBZ0IsS0FBSzJHLElBQUwsRUFBaEIsQ0FBbkIsR0FBa0R0SixPQUFPLENBQUNDLE1BQVIsQ0FBZTtBQUN2RXNKLFVBQUksRUFBRTtBQURpRSxLQUFmLENBQW5ELEVBR05OLElBSE0sQ0FHRCxNQUFNO0FBQ1YsV0FBS3ZELFNBQUwsQ0FBZTFCLEdBQWYsQ0FBbUIsWUFBbkI7QUFDRCxLQUxNLEVBS0hQLEdBQUQsSUFBUztBQUNWLFVBQUksQ0FBQyxTQUFELEVBQVksY0FBWixFQUE0QjVGLFFBQTVCLENBQXFDNEYsR0FBckMsb0JBQXFDQSxHQUFHLENBQUU4RixJQUExQyxDQUFKLEVBQXFEO0FBQ25ELGFBQUs3RCxTQUFMLENBQWUxQixHQUFmLENBQW1CUCxHQUFHLENBQUM4RixJQUF2QjtBQUNELE9BRkQsTUFFTztBQUNMcEosZUFBTyxDQUFDK0ksS0FBUixDQUFjekYsR0FBZDtBQUNBLGFBQUtpQyxTQUFMLENBQWUxQixHQUFmLENBQW1CLE9BQW5CO0FBQ0Q7O0FBQ0QsV0FBSzJCLFNBQUwsQ0FBZTNCLEdBQWYsQ0FBbUIsTUFBbkI7QUFDQSxZQUFNUCxHQUFOO0FBQ0QsS0FkTSxDQUFQO0FBZUQsR0E3RnVDOztBQThGeEMrRixXQUFTLEdBQUc7QUFDVixXQUFPLEtBQUtKLE9BQUwsR0FDTkgsSUFETSxDQUNELE1BQU0sS0FBS1YsU0FBTCxFQURMLENBQVA7QUFFRCxHQWpHdUM7O0FBa0d4Q2UsTUFBSSxFQUFFcEIsb0ZBbEdrQztBQW1HeEN1QixhQUFXLEVBQUV2QixvRkFuRzJCO0FBb0d4Q3dCLGFBQVcsRUFBRXhCLG9GQXBHMkI7O0FBcUd4Q3lCLGlCQUFlLENBQUNsRyxHQUFELEVBQU07QUFDbkIsVUFBTUEsR0FBTjtBQUNELEdBdkd1Qzs7QUF3R3hDbUcsU0FBTyxHQUFHO0FBQ1IsV0FBTyxLQUFLN0gsR0FBTCxDQUFTO0FBQUVlLFVBQUksRUFBRSxLQUFLa0Y7QUFBYixLQUFULEVBQ05pQixJQURNLENBQ0QzTixJQUFJLElBQUl1TCxJQUFJLENBQUNDLEtBQUwsQ0FBV3hMLElBQVgsQ0FEUCxFQUVOd0UsS0FGTSxDQUVBMkQsR0FBRyxJQUFJLEtBQUtrRyxlQUFMLENBQXFCbEcsR0FBckIsQ0FGUCxFQUdOd0YsSUFITSxDQUdEM04sSUFBSSxLQUFLO0FBQ2J3SCxVQUFJLEVBQUUsS0FBS2tGLFFBREU7QUFFYjFNO0FBRmEsS0FBTCxDQUhILENBQVA7QUFPRCxHQWhIdUM7O0FBaUh4QytOLFdBQVMsR0FBRztBQUNWLFNBQUtGLGNBQUw7QUFDQSxVQUFNVSxLQUFLLEdBQUcsS0FBS3pGLE1BQUwsQ0FBWXJDLEdBQVosQ0FBZ0IsT0FBaEIsQ0FBZDtBQUNBLFNBQUtqRCxPQUFMLENBQWFnTCxhQUFiLEdBQTZCRCxLQUFLLEdBQUksVUFBU0EsS0FBTSxFQUFuQixHQUF1QixJQUF6RDtBQUNBLFdBQU8sQ0FBQyxDQUFDQSxLQUFUO0FBQ0QsR0F0SHVDOztBQXVIeENFLFVBQVEsQ0FBQ3JDLE9BQUQsRUFBVTtBQUNoQixVQUFNO0FBQUU3QjtBQUFGLFFBQWUsSUFBckI7QUFDQSxVQUFNO0FBQUVtRSxXQUFLLEdBQUcsS0FBS2xDO0FBQWYsUUFBNkJKLE9BQW5DO0FBQ0EsUUFBSVksU0FBUyxHQUFHdEksT0FBTyxDQUFDMkMsT0FBUixFQUFoQjs7QUFDQSxRQUFJcUgsS0FBSixFQUFXO0FBQ1QxQixlQUFTLEdBQUcsS0FBS0EsU0FBTCxDQUNYVyxJQURXLENBQ05nQixFQUFFLElBQUkxTSxpR0FBUyxDQUFDeU0sS0FBSyxJQUFJN0wsSUFBSSxDQUFDQyxHQUFMLEtBQWE2TCxFQUFqQixDQUFOLENBRFQsRUFFWGhCLElBRlcsQ0FFTixNQUFNOUssSUFBSSxDQUFDQyxHQUFMLEVBRkEsQ0FBWjtBQUdBLFdBQUtrSyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNEOztBQUNEekMsWUFBUSxDQUFDd0MsS0FBVCxJQUFrQixDQUFsQjtBQUNBVCxpQkFBYTtBQUNiLFdBQU9VLFNBQVMsQ0FBQ1csSUFBVixDQUFlLE1BQU07QUFBQTs7QUFDMUJ2QixhQUFPLEdBQUd6TSxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCd00sT0FBbEIsQ0FBVjtBQUNBQSxhQUFPLENBQUM1SSxPQUFSLEdBQWtCN0QsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLNEQsT0FBdkIsRUFBZ0M0SSxPQUFPLENBQUM1SSxPQUF4QyxDQUFsQjtBQUNBLFVBQUk7QUFBRXBEO0FBQUYsVUFBVWdNLE9BQWQ7QUFDQSxVQUFJaE0sR0FBRyxDQUFDd08sVUFBSixDQUFlLEdBQWYsQ0FBSixFQUF5QnhPLEdBQUcsR0FBRyxvQkFBQ2dNLE9BQU8sQ0FBQ3lDLE1BQVQsOEJBQW1CLEtBQUtwQyxTQUF4QixJQUFxQ3JNLEdBQTNDO0FBQ3pCLGFBQU9pRCwrRkFBTyxDQUFDakQsR0FBRCxFQUFNZ00sT0FBTixDQUFkO0FBQ0QsS0FOTSxFQU9OdUIsSUFQTSxDQU9ELENBQUM7QUFBRTNOO0FBQUYsS0FBRCxNQUFlO0FBQUVBO0FBQUYsS0FBZixDQVBDLEVBT3lCNE4sS0FBSyxLQUFLO0FBQUVBO0FBQUYsS0FBTCxDQVA5QixFQVFORCxJQVJNLENBUUQsQ0FBQztBQUFFM04sVUFBRjtBQUFRNE47QUFBUixLQUFELEtBQXFCO0FBQ3pCckQsY0FBUSxDQUFDdUMsUUFBVCxJQUFxQixDQUFyQjtBQUNBUixtQkFBYTtBQUNiLFVBQUlzQixLQUFKLEVBQVcsT0FBT2xKLE9BQU8sQ0FBQ0MsTUFBUixDQUFlaUosS0FBZixDQUFQO0FBQ1gsYUFBTzVOLElBQVA7QUFDRCxLQWJNLENBQVA7QUFjRCxHQWpKdUM7O0FBa0p4QzhPLGNBQVksR0FBRztBQUNiLFdBQU9DLDhDQUFZLENBQUN4SSxJQUFiLEVBQVA7QUFDRCxHQXBKdUM7O0FBcUp4Q3lJLGFBQVcsR0FBRztBQUNaLFdBQU8sS0FBS1YsT0FBTCxHQUNOWCxJQURNLENBQ0RzQixVQUFVLElBQUl2SyxPQUFPLENBQUN3SyxHQUFSLENBQVksQ0FDOUJELFVBRDhCLEVBRTlCLEtBQUsxSSxJQUFMLEVBRjhCLEVBRzlCLEtBQUt1SSxZQUFMLEVBSDhCLENBQVosQ0FEYixDQUFQO0FBTUQsR0E1SnVDOztBQTZKeEM1TyxNQUFJLEdBQUc7QUFDTCxTQUFLcUssUUFBTCxHQUFnQjtBQUNkdUMsY0FBUSxFQUFFLENBREk7QUFFZEMsV0FBSyxFQUFFO0FBRk8sS0FBaEI7QUFJQSxTQUFLMUMsU0FBTCxDQUFlM0IsR0FBZixDQUFtQixTQUFuQixFQUxLLENBTUw7O0FBQ0EsV0FBTyxLQUFLb0YsT0FBTCxHQUNOSCxJQURNLENBQ0QsTUFBTSxLQUFLcUIsV0FBTCxFQURMLEVBRU5yQixJQUZNLENBRUQzTixJQUFJLElBQUkwRSxPQUFPLENBQUMyQyxPQUFSLENBQWdCLEtBQUs4RyxXQUFMLEVBQWhCLEVBQW9DUixJQUFwQyxDQUF5QyxNQUFNM04sSUFBL0MsQ0FGUCxFQUdOMk4sSUFITSxDQUdELENBQUMsQ0FBQ3NCLFVBQUQsRUFBYUUsVUFBYixFQUF5QkMsU0FBekIsQ0FBRCxLQUF5QztBQUM3QyxZQUFNQyxjQUFjLEdBQUdKLFVBQVUsQ0FBQ2pQLElBQVgsSUFBbUIsRUFBMUM7QUFDQSxZQUFNc1AsY0FBYyxHQUFHRCxjQUFjLENBQUN2SyxJQUFmLElBQXVCLEVBQTlDO0FBQ0EsWUFBTXlLLGVBQWUsR0FBR0YsY0FBYyxDQUFDRyxTQUFmLElBQTRCLENBQXBEO0FBQ0EsVUFBSUMsYUFBYSxHQUFHLENBQUNGLGVBQUQsSUFDZjVQLE1BQU0sQ0FBQzRJLElBQVAsQ0FBWStHLGNBQVosRUFBNEJsTyxNQUE1QixLQUF1QytOLFVBQVUsQ0FBQy9OLE1BRHZEO0FBRUEsWUFBTTBCLEdBQUcsR0FBR0QsSUFBSSxDQUFDQyxHQUFMLEVBQVo7QUFDQSxZQUFNNE0sa0JBQWtCLEdBQUdoTix3REFBUyxDQUFDLGNBQUQsQ0FBcEM7QUFDQSxZQUFNaU4sYUFBYSxHQUFHLEVBQXRCO0FBQ0EsWUFBTUMsU0FBUyxHQUFHLEtBQUs5RyxNQUFMLENBQVlyQyxHQUFaLENBQWdCLE1BQWhCLEVBQXdCLEVBQXhCLENBQWxCO0FBQ0EsWUFBTW9KLFNBQVMsR0FBRyxDQUFDRCxTQUFTLENBQUNKLFNBQTdCO0FBQ0EsWUFBTU0sUUFBUSxHQUFHRCxTQUFTLElBQUlOLGVBQWUsR0FBR0ssU0FBUyxDQUFDSixTQUExRDtBQUNBLFdBQUtuQyxHQUFMLENBQVMsYUFBVCxFQUF3QndDLFNBQXhCO0FBQ0EsV0FBS3hDLEdBQUwsQ0FBUyxXQUFULEVBQXNCeUMsUUFBdEIsRUFBZ0MsR0FBaEMsRUFBcUMsUUFBckMsRUFBK0NGLFNBQVMsQ0FBQ0osU0FBekQsRUFBb0UsU0FBcEUsRUFBK0VELGVBQS9FLEVBQWdHLEdBQWhHO0FBQ0EsWUFBTVEsUUFBUSxHQUFHLEVBQWpCO0FBQ0EsWUFBTUMsU0FBUyxHQUFHLEVBQWxCO0FBQ0EsWUFBTUMsU0FBUyxHQUFHLEVBQWxCO0FBQ0EsWUFBTUMsUUFBUSxHQUFHLEVBQWpCO0FBQ0EsWUFBTUMsV0FBVyxHQUFHLEVBQXBCO0FBQ0FkLG9CQUFjLENBQUN2SyxJQUFmLEdBQXNCcUssVUFBVSxDQUFDaUIsTUFBWCxDQUFrQixDQUFDdEwsSUFBRCxFQUFPdUwsSUFBUCxLQUFnQjtBQUN0RFYscUJBQWEsQ0FBQ1UsSUFBSSxDQUFDNUksR0FBTixDQUFiLEdBQTBCNEksSUFBMUI7QUFDQSxZQUFJQyxRQUFRLEdBQUdoQixjQUFjLENBQUNlLElBQUksQ0FBQzVJLEdBQU4sQ0FBN0I7O0FBQ0EsWUFBSSxDQUFDNkksUUFBTCxFQUFlO0FBQ2JBLGtCQUFRLEdBQUcsRUFBWDtBQUNBYix1QkFBYSxHQUFHLElBQWhCO0FBQ0Q7O0FBQ0QzSyxZQUFJLENBQUN1TCxJQUFJLENBQUM1SSxHQUFOLENBQUosR0FBaUI2SSxRQUFqQjs7QUFDQSxZQUFJLENBQUNBLFFBQVEsQ0FBQ0MsUUFBZCxFQUF3QjtBQUN0QkQsa0JBQVEsQ0FBQ0MsUUFBVCxHQUFvQnpOLEdBQXBCO0FBQ0EyTSx1QkFBYSxHQUFHLElBQWhCO0FBQ0Q7O0FBQ0QsZUFBTzNLLElBQVA7QUFDRCxPQWJxQixFQWFuQixFQWJtQixDQUF0QjtBQWNBc0ssZUFBUyxDQUFDeEQsT0FBVixDQUFtQnlFLElBQUQsSUFBVTtBQUMxQixjQUFNO0FBQUV2RixlQUFLLEVBQUU7QUFBRXJELGVBQUY7QUFBTytJLG9CQUFQO0FBQWlCQztBQUFqQjtBQUFULFlBQTZDSixJQUFuRDtBQUNBLGNBQU1LLFVBQVUsR0FBR3JCLGNBQWMsQ0FBQ3ZLLElBQWYsQ0FBb0IyQyxHQUFwQixDQUFuQjtBQUNBLGNBQU1rSixVQUFVLEdBQUdoQixhQUFhLENBQUNsSSxHQUFELENBQWhDOztBQUNBLFlBQUlpSixVQUFVLElBQUlDLFVBQWxCLEVBQThCO0FBQzVCLGNBQUlkLFNBQVMsSUFBSSxDQUFDWSxZQUFkLElBQThCQyxVQUFVLENBQUNILFFBQVgsR0FBc0JFLFlBQXhELEVBQXNFO0FBQ3BFVixvQkFBUSxDQUFDYSxJQUFULENBQWM7QUFBRUMsbUJBQUssRUFBRVIsSUFBVDtBQUFlUyxvQkFBTSxFQUFFSCxVQUF2QjtBQUFtQzdMLGtCQUFJLEVBQUU0TDtBQUF6QyxhQUFkO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsZ0JBQUlBLFVBQVUsQ0FBQ0gsUUFBWCxHQUFzQkUsWUFBMUIsRUFBd0M7QUFDdENULHVCQUFTLENBQUNZLElBQVYsQ0FBZTtBQUFFQyxxQkFBSyxFQUFFUixJQUFUO0FBQWVTLHNCQUFNLEVBQUVIO0FBQXZCLGVBQWY7QUFDQUQsd0JBQVUsQ0FBQ0gsUUFBWCxHQUFzQkUsWUFBdEI7QUFDQWhCLDJCQUFhLEdBQUcsSUFBaEI7QUFDRDs7QUFDRCxnQkFBSWlCLFVBQVUsQ0FBQ0YsUUFBWCxLQUF3QkEsUUFBNUIsRUFBc0M7QUFDcEMsa0JBQUlFLFVBQVUsQ0FBQ0YsUUFBWCxJQUF1QmQsa0JBQWtCLElBQUlILGVBQWpELEVBQWtFO0FBQ2hFWSwyQkFBVyxDQUFDUyxJQUFaLENBQWlCO0FBQUVDLHVCQUFLLEVBQUVSLElBQVQ7QUFBZVMsd0JBQU0sRUFBRUgsVUFBdkI7QUFBbUM3TCxzQkFBSSxFQUFFNEw7QUFBekMsaUJBQWpCO0FBQ0QsZUFGRCxNQUVPO0FBQ0xBLDBCQUFVLENBQUNGLFFBQVgsR0FBc0JBLFFBQXRCO0FBQ0FmLDZCQUFhLEdBQUcsSUFBaEI7QUFDRDtBQUNGO0FBQ0Y7O0FBQ0QsaUJBQU9FLGFBQWEsQ0FBQ2xJLEdBQUQsQ0FBcEI7QUFDRCxTQW5CRCxNQW1CTyxJQUFJb0ksU0FBUyxJQUFJLENBQUNDLFFBQWQsSUFBMEJXLFlBQVksR0FBR2xCLGVBQTdDLEVBQThEO0FBQ25FUyxtQkFBUyxDQUFDWSxJQUFWLENBQWU7QUFBRUMsaUJBQUssRUFBRVI7QUFBVCxXQUFmO0FBQ0QsU0FGTSxNQUVBO0FBQ0xILGtCQUFRLENBQUNVLElBQVQsQ0FBYztBQUFFQyxpQkFBSyxFQUFFUjtBQUFULFdBQWQ7QUFDRDtBQUNGLE9BNUJEO0FBNkJBLGVBQWVuSCxtR0FBZixFQUFBeUcsYUFBYSxFQUFlLENBQUMsQ0FBQ2xJLEdBQUQsRUFBTTRJLElBQU4sQ0FBRCxLQUFpQjtBQUMzQyxjQUFNdkwsSUFBSSxHQUFHdUssY0FBYyxDQUFDdkssSUFBZixDQUFvQjJDLEdBQXBCLENBQWI7O0FBQ0EsWUFBSXFJLFFBQUosRUFBYztBQUNaQyxrQkFBUSxDQUFDYSxJQUFULENBQWM7QUFBRUUsa0JBQU0sRUFBRVQsSUFBVjtBQUFnQnZMO0FBQWhCLFdBQWQ7QUFDRCxTQUZELE1BRU87QUFDTG1MLG1CQUFTLENBQUNXLElBQVYsQ0FBZTtBQUFFRSxrQkFBTSxFQUFFVDtBQUFWLFdBQWY7QUFDRDtBQUNGLE9BUFksQ0FBYjtBQVFBLFlBQU1VLFlBQVksR0FBRyxDQUNuQixHQUFHaEIsUUFBUSxDQUFDOUYsR0FBVCxDQUFhLENBQUM7QUFBRTZHLGNBQUY7QUFBVWhNO0FBQVYsT0FBRCxLQUFzQjtBQUNwQyxhQUFLdUksR0FBTCxDQUFTLGtCQUFULEVBQTZCeUQsTUFBTSxDQUFDckosR0FBcEM7QUFDQSxlQUFPLEtBQUtoQixHQUFMLENBQVNxSyxNQUFULEVBQ05uRCxJQURNLENBQ0F0QyxHQUFELElBQVM7QUFDYixnQkFBTXJMLElBQUksR0FBR29MLGVBQWUsQ0FBQ0MsR0FBRCxDQUE1QixDQURhLENBRWI7O0FBQ0EsY0FBSSxDQUFDckwsSUFBSSxDQUFDMkQsSUFBVixFQUFnQjtBQUNoQixjQUFJbUIsSUFBSSxDQUFDeUwsUUFBVCxFQUFtQlMsd0dBQVMsQ0FBQ2hSLElBQUQsRUFBTyxvQkFBUCxFQUE2QjhFLElBQUksQ0FBQ3lMLFFBQWxDLENBQVQ7QUFDbkIsZ0JBQU1DLFFBQVEsR0FBRyxDQUFDMUwsSUFBSSxDQUFDMEwsUUFBdkI7QUFDQSxjQUFJQSxRQUFKLEVBQWN4USxJQUFJLENBQUN3USxRQUFMLEdBQWdCQSxRQUFoQjs7QUFDZCxjQUFJLENBQUM5Tix3REFBUyxDQUFDLGtCQUFELENBQVYsSUFBa0MxQyxJQUFJLENBQUM4SSxNQUEzQyxFQUFtRDtBQUNqRCxtQkFBTzlJLElBQUksQ0FBQzhJLE1BQUwsQ0FBWW1DLE9BQW5CO0FBQ0Q7O0FBQ0QsaUJBQU84RCw4Q0FBWSxDQUFDekksTUFBYixDQUFvQnRHLElBQXBCLENBQVA7QUFDRCxTQVpNLENBQVA7QUFhRCxPQWZFLENBRGdCLEVBaUJuQixHQUFHZ1EsU0FBUyxDQUFDL0YsR0FBVixDQUFjLENBQUM7QUFBRTRHLGFBQUY7QUFBU0M7QUFBVCxPQUFELEtBQXVCO0FBQ3RDLGFBQUt6RCxHQUFMLENBQVMsZ0JBQVQsRUFBMkJ3RCxLQUFLLENBQUMvRixLQUFOLENBQVlyRCxHQUF2QztBQUNBLGVBQU9zSCw4Q0FBWSxDQUFDdEksR0FBYixDQUFpQm9LLEtBQUssQ0FBQy9GLEtBQU4sQ0FBWXBLLEVBQTdCLEVBQ05pTixJQURNLENBQ0FoSyxJQUFELElBQVU7QUFDZDtBQUNBLGdCQUFNM0QsSUFBSSxHQUFHMkssYUFBYSxDQUFDa0csS0FBRCxFQUFRLENBQVIsRUFBVztBQUFFbE47QUFBRixXQUFYLENBQTFCO0FBQ0EwTCx3QkFBYyxDQUFDdkssSUFBZixDQUFvQitMLEtBQUssQ0FBQy9GLEtBQU4sQ0FBWXJELEdBQWhDLElBQXVDO0FBQ3JDOEksb0JBQVEsRUFBRU0sS0FBSyxDQUFDL0YsS0FBTixDQUFZMkYsWUFEZTtBQUVyQ0Qsb0JBQVEsRUFBRUssS0FBSyxDQUFDL0YsS0FBTixDQUFZMEY7QUFGZSxXQUF2QztBQUlBZix1QkFBYSxHQUFHLElBQWhCO0FBQ0EsaUJBQU8sS0FBS3dCLEdBQUwsQ0FDTHRSLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JrUixNQUFsQixFQUEwQjtBQUN4QnJKLGVBQUcsRUFBRW9KLEtBQUssQ0FBQy9GLEtBQU4sQ0FBWXJELEdBRE87QUFFeEJELGdCQUFJLEVBQUUsSUFGa0IsQ0FFWjs7QUFGWSxXQUExQixDQURLLEVBS0wrRCxJQUFJLENBQUMyRixTQUFMLENBQWVsUixJQUFmLENBTEssQ0FBUDtBQU9ELFNBaEJNLENBQVA7QUFpQkQsT0FuQkUsQ0FqQmdCLEVBcUNuQixHQUFHaVEsU0FBUyxDQUFDaEcsR0FBVixDQUFjLENBQUM7QUFBRTZHO0FBQUYsT0FBRCxLQUFnQjtBQUMvQixhQUFLekQsR0FBTCxDQUFTLHVCQUFULEVBQWtDeUQsTUFBTSxDQUFDckosR0FBekM7QUFDQSxlQUFPNEgsY0FBYyxDQUFDdkssSUFBZixDQUFvQmdNLE1BQU0sQ0FBQ3JKLEdBQTNCLENBQVA7QUFDQWdJLHFCQUFhLEdBQUcsSUFBaEI7QUFDQSxlQUFPLEtBQUs5SSxNQUFMLENBQVltSyxNQUFaLENBQVA7QUFDRCxPQUxFLENBckNnQixFQTJDbkIsR0FBR1osUUFBUSxDQUFDakcsR0FBVCxDQUFhLENBQUM7QUFBRTRHO0FBQUYsT0FBRCxLQUFlO0FBQzdCLGFBQUt4RCxHQUFMLENBQVMsc0JBQVQsRUFBaUN3RCxLQUFLLENBQUMvRixLQUFOLENBQVlyRCxHQUE3QztBQUNBLGVBQU9zSCw4Q0FBWSxDQUFDcEksTUFBYixDQUFvQmtLLEtBQUssQ0FBQy9GLEtBQU4sQ0FBWXBLLEVBQWhDLENBQVA7QUFDRCxPQUhFLENBM0NnQixFQStDbkIsR0FBR3lQLFdBQVcsQ0FBQ2xHLEdBQVosQ0FBZ0IsQ0FBQztBQUFFNEcsYUFBRjtBQUFTL0w7QUFBVCxPQUFELEtBQXFCO0FBQ3RDLGNBQU1xTSxPQUFPLEdBQUcsRUFBaEI7O0FBQ0EsWUFBSXJNLElBQUksQ0FBQzBMLFFBQVQsRUFBbUI7QUFDakJXLGlCQUFPLENBQUNyRyxLQUFSLEdBQWdCO0FBQUUwRixvQkFBUSxFQUFFMUwsSUFBSSxDQUFDMEw7QUFBakIsV0FBaEI7QUFDRDs7QUFDRCxlQUFPWSxrRUFBZ0IsQ0FBQ1AsS0FBSyxDQUFDL0YsS0FBTixDQUFZcEssRUFBYixFQUFpQnlRLE9BQWpCLENBQXZCO0FBQ0QsT0FORSxDQS9DZ0IsQ0FBckI7QUF1REFKLGtCQUFZLENBQUNILElBQWIsQ0FBa0JsTSxPQUFPLENBQUN3SyxHQUFSLENBQVk2QixZQUFaLEVBQTBCcEQsSUFBMUIsQ0FBK0IsTUFBTTBELDZEQUFXLEVBQWhELEVBQW9EMUQsSUFBcEQsQ0FBMEQyRCxPQUFELElBQWE7QUFDdEYsWUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDZDdCLHFCQUFhLEdBQUcsSUFBaEI7QUFDQSxlQUFPViw4Q0FBWSxDQUFDeEksSUFBYixHQUNOb0gsSUFETSxDQUNBNEQsT0FBRCxJQUFhO0FBQ2pCQSxpQkFBTyxDQUFDM0YsT0FBUixDQUFpQnZGLE1BQUQsSUFBWTtBQUMxQixrQkFBTXFLLFVBQVUsR0FBR3JCLGNBQWMsQ0FBQ3ZLLElBQWYsQ0FBb0J1QixNQUFNLENBQUN5RSxLQUFQLENBQWFyRCxHQUFqQyxDQUFuQjtBQUNBLGdCQUFJaUosVUFBSixFQUFnQkEsVUFBVSxDQUFDRixRQUFYLEdBQXNCbkssTUFBTSxDQUFDeUUsS0FBUCxDQUFhMEYsUUFBbkM7QUFDakIsV0FIRDtBQUlELFNBTk0sQ0FBUDtBQU9ELE9BVmlCLENBQWxCO0FBV0FPLGtCQUFZLENBQUNILElBQWIsQ0FBa0JsTSxPQUFPLENBQUN3SyxHQUFSLENBQVk2QixZQUFaLEVBQTBCcEQsSUFBMUIsQ0FBK0IsTUFBTTtBQUNyRCxjQUFNNkQsUUFBUSxHQUFHLEVBQWpCOztBQUNBLFlBQUkvQixhQUFKLEVBQW1CO0FBQ2pCSix3QkFBYyxDQUFDRyxTQUFmLEdBQTJCM00sSUFBSSxDQUFDQyxHQUFMLEVBQTNCO0FBQ0EwTyxrQkFBUSxDQUFDWixJQUFULENBQWMsS0FBS0ssR0FBTCxDQUFTaEMsVUFBVCxFQUFxQjFELElBQUksQ0FBQzJGLFNBQUwsQ0FBZTdCLGNBQWYsQ0FBckIsQ0FBZDtBQUNEOztBQUNETyxpQkFBUyxDQUFDSixTQUFWLEdBQXNCSCxjQUFjLENBQUNHLFNBQXJDO0FBQ0FJLGlCQUFTLENBQUN0RixRQUFWLEdBQXFCekgsSUFBSSxDQUFDQyxHQUFMLEVBQXJCO0FBQ0EsYUFBS2dHLE1BQUwsQ0FBWUosR0FBWixDQUFnQixNQUFoQixFQUF3QmtILFNBQXhCO0FBQ0EsZUFBT2xMLE9BQU8sQ0FBQ3dLLEdBQVIsQ0FBWXNDLFFBQVosQ0FBUDtBQUNELE9BVmlCLENBQWxCLEVBeEk2QyxDQW1KN0M7O0FBQ0EsYUFBTzlNLE9BQU8sQ0FBQ3dLLEdBQVIsQ0FBWTZCLFlBQVksQ0FBQzlHLEdBQWIsQ0FBaUJxRCxPQUFPLElBQUlBLE9BQU8sQ0FBQ0ssSUFBUixDQUFhZixvRkFBYixFQUFtQnpFLEdBQUcsSUFBSUEsR0FBRyxJQUFJLElBQWpDLENBQTVCLENBQVosRUFDTndGLElBRE0sQ0FDRDhELE1BQU0sSUFBSUEsTUFBTSxDQUFDQyxNQUFQLENBQWNDLE9BQWQsQ0FEVCxFQUVOaEUsSUFGTSxDQUVBOEQsTUFBRCxJQUFZO0FBQUUsWUFBSUEsTUFBTSxDQUFDclEsTUFBWCxFQUFtQixNQUFNcVEsTUFBTjtBQUFlLE9BRi9DLENBQVA7QUFHRCxLQTFKTSxFQTJKTjlELElBM0pNLENBMkpELE1BQU07QUFDVixXQUFLdEQsU0FBTCxDQUFlM0IsR0FBZixDQUFtQixNQUFuQjtBQUNBLFdBQUsyRSxHQUFMLENBQVMsZ0JBQVQsRUFBMkIsS0FBS2xELFdBQWhDO0FBQ0QsS0E5Sk0sRUE4SkhoQyxHQUFELElBQVM7QUFDVixXQUFLa0MsU0FBTCxDQUFlM0IsR0FBZixDQUFtQixPQUFuQjtBQUNBLFdBQUsyRSxHQUFMLENBQVMsaUJBQVQsRUFBNEIsS0FBS2xELFdBQWpDO0FBQ0EsV0FBS2tELEdBQUwsQ0FBU2xGLEdBQVQ7QUFDRCxLQWxLTSxFQW1LTndGLElBbktNLENBbUtELE1BQU1qSixPQUFPLENBQUMyQyxPQUFSLENBQWdCLEtBQUsrRyxXQUFMLEVBQWhCLEVBQW9DNUosS0FBcEMsQ0FBMENvSSxvRkFBMUMsQ0FuS0wsQ0FBUDtBQW9LRDs7QUF4VXVDLENBQUQsQ0FBbEM7QUEyVUEsU0FBU2dGLFFBQVQsQ0FBa0JDLE9BQWxCLEVBQTJCO0FBQ2hDOUssZ0JBQWMsQ0FBQzZKLElBQWYsQ0FBb0JpQixPQUFwQjtBQUNEOztBQUNELFNBQVNwRSxVQUFULEdBQXNCO0FBQ3BCLFNBQU9uRyxVQUFVLENBQUNiLEdBQVgsQ0FBZSxTQUFmLENBQVA7QUFDRDs7QUFDRCxTQUFTcUwsVUFBVCxDQUFvQnRLLElBQXBCLEVBQTBCO0FBQ3hCLFNBQU9SLFFBQVEsQ0FBQ1EsSUFBSSxJQUFJaUcsVUFBVSxFQUFuQixDQUFmO0FBQ0Q7O0FBQ00sU0FBUzFKLFVBQVQsR0FBc0I7QUFDM0IsTUFBSSxDQUFDdUQsVUFBTCxFQUFpQjtBQUNmQSxjQUFVLEdBQUdjLFVBQVUsRUFBdkI7QUFDQXJCLGtCQUFjLENBQUM2RSxPQUFmLENBQXdCaUcsT0FBRCxJQUFhO0FBQ2xDLFlBQU0zSCxPQUFPLEdBQUcsSUFBSTJILE9BQUosRUFBaEI7QUFDQSxZQUFNO0FBQUVySztBQUFGLFVBQVcwQyxPQUFqQjtBQUNBcEQsa0JBQVksQ0FBQzhKLElBQWIsQ0FBa0JwSixJQUFsQjtBQUNBUixjQUFRLENBQUNRLElBQUQsQ0FBUixHQUFpQjBDLE9BQWpCO0FBQ0QsS0FMRDtBQU1EOztBQUNEaEssTUFBSTtBQUNMOztBQUVELFNBQVM2UixPQUFULENBQWlCN0gsT0FBakIsRUFBMEI7QUFDeEIsTUFBSUEsT0FBTyxDQUFDRyxTQUFSLENBQWtCUixFQUFsQixDQUFxQixDQUFDLE9BQUQsRUFBVSxTQUFWLENBQXJCLENBQUosRUFBZ0Q7QUFDaEQsTUFBSUssT0FBTyxDQUFDRSxTQUFSLENBQWtCUCxFQUFsQixDQUFxQixDQUFDLE1BQUQsRUFBUyxPQUFULENBQXJCLENBQUosRUFBNkMsT0FBT0ssT0FBTyxDQUFDZ0UsU0FBUixFQUFQO0FBQzdDLE1BQUloRSxPQUFPLENBQUNFLFNBQVIsQ0FBa0JQLEVBQWxCLENBQXFCLFlBQXJCLENBQUosRUFBd0MsT0FBT0ssT0FBTyxDQUFDK0MsU0FBUixFQUFQO0FBQ3pDOztBQUVNLFNBQVMvTSxJQUFULEdBQWdCO0FBQ3JCLFFBQU1nSyxPQUFPLEdBQUc0SCxVQUFVLEVBQTFCO0FBQ0EsU0FBTzVILE9BQU8sSUFBSXhGLE9BQU8sQ0FBQzJDLE9BQVIsQ0FBZ0IwSyxPQUFPLENBQUM3SCxPQUFELENBQXZCLEVBQWtDeUQsSUFBbEMsQ0FBdUMxRyxRQUF2QyxDQUFsQjtBQUNEO0FBRU0sU0FBUytLLFNBQVQsR0FBcUI7QUFDMUIsUUFBTTlILE9BQU8sR0FBRzRILFVBQVUsRUFBMUI7QUFDQSxNQUFJNUgsT0FBSixFQUFhQSxPQUFPLENBQUM4SCxTQUFSO0FBQ2Q7QUFFTSxTQUFTQyxNQUFULEdBQWtCO0FBQ3ZCLFFBQU0vSCxPQUFPLEdBQUc0SCxVQUFVLEVBQTFCO0FBQ0EsTUFBSTVILE9BQUosRUFBYUEsT0FBTyxDQUFDK0gsTUFBUjtBQUNkO0FBRU0sU0FBU0MsU0FBVCxDQUFtQnBKLE1BQW5CLEVBQTJCO0FBQ2hDLFFBQU1vQixPQUFPLEdBQUc0SCxVQUFVLEVBQTFCOztBQUNBLE1BQUk1SCxPQUFKLEVBQWE7QUFDWEEsV0FBTyxDQUFDMkMsYUFBUixDQUFzQi9ELE1BQXRCO0FBQ0EsV0FBT29CLE9BQU8sQ0FBQ2dFLFNBQVIsRUFBUDtBQUNEO0FBQ0Y7QUFFTSxlQUFlaUUsWUFBZixDQUE0Qi9SLEdBQTVCLEVBQWlDZ1MsV0FBakMsRUFBOEM7QUFDbkRDLHNCQUFvQixHQUQrQixDQUMzQjs7QUFDeEJuTyxTQUFPLENBQUNvTyxVQUFSLENBQW1CQyxlQUFuQixDQUFtQ2xPLFdBQW5DLENBQStDa08sZUFBL0MsRUFBZ0U7QUFDOURDLFFBQUksRUFBRSxDQUFFLEdBQUVKLFdBQVksR0FBaEIsQ0FEd0Q7QUFFOURLLFNBQUssRUFBRSxDQUFDLFlBQUQsQ0FGdUQ7QUFHOURoUyxTQUFLLEVBQUUsQ0FBQyxNQUFNeUQsT0FBTyxDQUFDd08sSUFBUixDQUFhckcsTUFBYixDQUFvQjtBQUFFak07QUFBRixLQUFwQixDQUFQLEVBQXFDTTtBQUhrQixHQUFoRSxFQUlHLENBQUMsVUFBRCxDQUpIO0FBS0Q7QUFFRDs7Ozs7QUFJQSxTQUFTNlIsZUFBVCxDQUF5QnpOLElBQXpCLEVBQStCO0FBQUE7O0FBQzdCLCtCQUFJLGVBQUFnTixVQUFVLElBQUdhLFNBQWpCLHFCQUFJLHdDQUF5QjdOLElBQUksQ0FBQzFFLEdBQTlCLENBQUosRUFBd0M7QUFDdEM4RCxXQUFPLENBQUN3TyxJQUFSLENBQWEvTCxNQUFiLENBQW9CN0IsSUFBSSxDQUFDckUsS0FBekIsRUFEc0MsQ0FFdEM7O0FBQ0FZLGNBQVUsQ0FBQ2dSLG9CQUFELEVBQXVCLENBQXZCLENBQVY7QUFDQSxXQUFPO0FBQUVPLFlBQU0sRUFBRTtBQUFWLEtBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNQLG9CQUFULEdBQWdDO0FBQzlCbk8sU0FBTyxDQUFDb08sVUFBUixDQUFtQkMsZUFBbkIsQ0FBbUNNLGNBQW5DLENBQWtETixlQUFsRDtBQUNEOztBQUVEbFQsMERBQVcsQ0FBRVcsSUFBRCxJQUFVO0FBQ3BCLFFBQU0ySSxLQUFLLEdBQUczSSxJQUFILG9CQUFHQSxJQUFJLENBQUcsY0FBSCxDQUFsQjtBQUNBLE1BQUkySSxLQUFKLEVBQVc1RSxVQUFVO0FBQ3RCLENBSFUsQ0FBWCxDOzs7Ozs7Ozs7Ozs7QUN0bUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQSxNQUFNK0UsTUFBTSxHQUFHO0FBQ2JnSyxXQUFTLEVBQUUsaUJBREU7QUFFYkMsY0FBWSxFQUFFO0FBRkQsQ0FBZjtBQUtBLE1BQU1DLEtBQUssR0FBRyxrQkFBZCxDLENBQWtDOztBQUNsQyxNQUFNQyxPQUFPLEdBQUdDLENBQUMsSUFBSyxNQUFLLENBQUNBLENBQUMsQ0FBQ0MsVUFBRixDQUFhLENBQWIsSUFBa0IsT0FBbkIsRUFBNEJDLFFBQTVCLENBQXFDLEVBQXJDLEVBQXlDcEwsS0FBekMsQ0FBK0MsQ0FBL0MsQ0FBa0QsRUFBN0U7O0FBRUEsU0FBU3FMLGlCQUFULENBQTJCL0gsR0FBM0IsRUFBZ0M7QUFDOUIsUUFBTWdJLE1BQU0sR0FBRy9ILElBQUksQ0FBQzJGLFNBQUwsQ0FBZTVGLEdBQWYsQ0FBZjtBQUNBLFNBQU9nSSxNQUFNLENBQUNDLE9BQVAsQ0FBZVAsS0FBZixFQUFzQkMsT0FBdEIsQ0FBUDtBQUNEOztBQUVELE1BQU1PLE9BQU8sR0FBR2pILGlEQUFXLENBQUNMLE1BQVosQ0FBbUI7QUFDakMxRSxNQUFJLEVBQUUsU0FEMkI7QUFFakMyQyxhQUFXLEVBQUUsU0FGb0I7O0FBR2pDNkQsTUFBSSxHQUFHO0FBQ0wsV0FBTyxLQUFLUyxRQUFMLENBQWM7QUFDbkJnRixZQUFNLEVBQUUsTUFEVztBQUVuQnJULFNBQUcsRUFBRTtBQUZjLEtBQWQsRUFJTm9FLEtBSk0sQ0FJQzJELEdBQUQsSUFBUztBQUNkLFVBQUlBLEdBQUcsQ0FBQ3VMLE1BQUosS0FBZSxHQUFuQixFQUF3QjtBQUN0QixlQUFPaFAsT0FBTyxDQUFDQyxNQUFSLENBQWU7QUFDcEJzSixjQUFJLEVBQUU7QUFEYyxTQUFmLENBQVA7QUFHRDs7QUFDRCxhQUFPdkosT0FBTyxDQUFDQyxNQUFSLENBQWU7QUFDcEJzSixZQUFJLEVBQUUsT0FEYztBQUVwQmpPLFlBQUksRUFBRW1JO0FBRmMsT0FBZixDQUFQO0FBSUQsS0FkTSxDQUFQO0FBZUQsR0FuQmdDOztBQW9CakNrRyxpQkFBZSxDQUFDeE4sR0FBRCxFQUFNO0FBQ25CLFFBQUlBLEdBQUcsQ0FBQzZTLE1BQUosS0FBZSxHQUFuQixFQUF3QixNQUFNN1MsR0FBTjtBQUN6QixHQXRCZ0M7O0FBdUJqQzBGLE1BQUksR0FBRztBQUNMLFdBQU8sS0FBS2tJLFFBQUwsQ0FBYztBQUNuQmdGLFlBQU0sRUFBRSxNQURXO0FBRW5CclQsU0FBRyxFQUFFLGdEQUZjO0FBR25CdVQsVUFBSSxFQUFFO0FBQ0pDLFlBQUksRUFBRTtBQURGLE9BSGE7QUFNbkJDLGtCQUFZLEVBQUU7QUFOSyxLQUFkLEVBUU5sRyxJQVJNLENBUUQzTixJQUFJLElBQ1JBLElBQUksQ0FBQzhULE9BQUwsQ0FBYXBDLE1BQWIsQ0FBb0JyQixJQUFJLElBQUlBLElBQUksQ0FBQyxNQUFELENBQUosS0FBaUIsTUFBakIsSUFBMkIzSSwwREFBWSxDQUFDMkksSUFBSSxDQUFDN0ksSUFBTixDQUFuRSxFQUFnRnlDLEdBQWhGLENBQW9GOEosU0FBcEYsQ0FUSyxDQUFQO0FBV0QsR0FuQ2dDOztBQW9DakN0TixLQUFHLENBQUM0SixJQUFELEVBQU87QUFDUixVQUFNN0ksSUFBSSxHQUFHRCw2REFBZSxDQUFDOEksSUFBRCxDQUE1QjtBQUNBLFdBQU8sS0FBSzVCLFFBQUwsQ0FBYztBQUNuQmdGLFlBQU0sRUFBRSxNQURXO0FBRW5CclQsU0FBRyxFQUFFLGlEQUZjO0FBR25Cb0QsYUFBTyxFQUFFO0FBQ1AsMkJBQW1CNlAsaUJBQWlCLENBQUM7QUFDbkNPLGNBQUksRUFBRyxJQUFHcE0sSUFBSztBQURvQixTQUFEO0FBRDdCO0FBSFUsS0FBZCxDQUFQO0FBU0QsR0EvQ2dDOztBQWdEakN5SixLQUFHLENBQUNaLElBQUQsRUFBT3JRLElBQVAsRUFBYTtBQUNkLFVBQU13SCxJQUFJLEdBQUdELDZEQUFlLENBQUM4SSxJQUFELENBQTVCO0FBQ0EsV0FBTyxLQUFLNUIsUUFBTCxDQUFjO0FBQ25CZ0YsWUFBTSxFQUFFLE1BRFc7QUFFbkJyVCxTQUFHLEVBQUUsK0NBRmM7QUFHbkJvRCxhQUFPLEVBQUU7QUFDUCwyQkFBbUI2UCxpQkFBaUIsQ0FBQztBQUNuQ08sY0FBSSxFQUFHLElBQUdwTSxJQUFLLEVBRG9CO0FBRW5Dd00sY0FBSSxFQUFFO0FBRjZCLFNBQUQsQ0FEN0I7QUFLUCx3QkFBZ0I7QUFMVCxPQUhVO0FBVW5CTCxVQUFJLEVBQUUzVCxJQVZhO0FBV25CNlQsa0JBQVksRUFBRTtBQVhLLEtBQWQsRUFhTmxHLElBYk0sQ0FhRG9HLFNBYkMsQ0FBUDtBQWNELEdBaEVnQzs7QUFpRWpDcE4sUUFBTSxDQUFDMEosSUFBRCxFQUFPO0FBQ1gsVUFBTTdJLElBQUksR0FBR0QsNkRBQWUsQ0FBQzhJLElBQUQsQ0FBNUI7QUFDQSxXQUFPLEtBQUs1QixRQUFMLENBQWM7QUFDbkJnRixZQUFNLEVBQUUsTUFEVztBQUVuQnJULFNBQUcsRUFBRSwyQ0FGYztBQUduQnVULFVBQUksRUFBRTtBQUNKQyxZQUFJLEVBQUcsSUFBR3BNLElBQUs7QUFEWCxPQUhhO0FBTW5CcU0sa0JBQVksRUFBRTtBQU5LLEtBQWQsRUFRTmxHLElBUk0sQ0FRRG9HLFNBUkMsQ0FBUDtBQVNELEdBNUVnQzs7QUE2RWpDL0IsV0FBUyxHQUFHO0FBQ1YsVUFBTWlDLE1BQU0sR0FBRztBQUNiQyxtQkFBYSxFQUFFLE9BREY7QUFFYnBCLGVBQVMsRUFBRWhLLE1BQU0sQ0FBQ2dLLFNBRkw7QUFHYkMsa0JBQVksRUFBRWpLLE1BQU0sQ0FBQ2lLO0FBSFIsS0FBZjtBQUtBLFVBQU0zUyxHQUFHLEdBQUksNENBQTJDK1Qsd0RBQVMsQ0FBQ0YsTUFBRCxDQUFTLEVBQTFFO0FBQ0E5Qiw4REFBWSxDQUFDL1IsR0FBRCxFQUFNMEksTUFBTSxDQUFDaUssWUFBYixDQUFaO0FBQ0QsR0FyRmdDOztBQXNGakNxQixZQUFVLENBQUMvSSxHQUFELEVBQU07QUFDZCxVQUFNckwsSUFBSSxHQUFHcVUsd0RBQVMsQ0FBQ2hKLEdBQUQsQ0FBdEI7O0FBQ0EsUUFBSXJMLElBQUksQ0FBQ3NVLFlBQVQsRUFBdUI7QUFDckIsV0FBS3hMLE1BQUwsQ0FBWUosR0FBWixDQUFnQjtBQUNkNkwsV0FBRyxFQUFFdlUsSUFBSSxDQUFDdVUsR0FESTtBQUVkaEcsYUFBSyxFQUFFdk8sSUFBSSxDQUFDc1U7QUFGRSxPQUFoQjtBQUlEO0FBQ0YsR0E5RmdDOztBQStGakMzQixXQUFTLENBQUN2UyxHQUFELEVBQU07QUFDYixVQUFNZ1MsV0FBVyxHQUFJLEdBQUV0SixNQUFNLENBQUNpSyxZQUFhLEdBQTNDOztBQUNBLFFBQUkzUyxHQUFHLENBQUN3TyxVQUFKLENBQWV3RCxXQUFmLENBQUosRUFBaUM7QUFDL0IsV0FBS2dDLFVBQUwsQ0FBZ0JoVSxHQUFHLENBQUM0SCxLQUFKLENBQVVvSyxXQUFXLENBQUNoUixNQUF0QixDQUFoQjtBQUNBLFdBQUs4TSxTQUFMO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7QUFDRixHQXRHZ0M7O0FBdUdqQytELFFBQU0sR0FBRztBQUNQLFNBQUtuSixNQUFMLENBQVlKLEdBQVosQ0FBZ0I7QUFDZDZMLFNBQUcsRUFBRSxJQURTO0FBRWRoRyxXQUFLLEVBQUU7QUFGTyxLQUFoQjtBQUlBLFdBQU8sS0FBS1QsT0FBTCxFQUFQO0FBQ0Q7O0FBN0dnQyxDQUFuQixDQUFoQjtBQStHQThELHNEQUFRLENBQUM0QixPQUFELENBQVI7O0FBRUEsU0FBU08sU0FBVCxDQUFtQjFELElBQW5CLEVBQXlCO0FBQ3ZCLFNBQU87QUFDTDdJLFFBQUksRUFBRTZJLElBQUksQ0FBQzdJLElBRE47QUFFTGdOLFFBQUksRUFBRW5FLElBQUksQ0FBQ21FLElBRk47QUFHTC9NLE9BQUcsRUFBRUcsb0RBQU0sQ0FBQ3lJLElBQUksQ0FBQzdJLElBQU4sQ0FITixDQUlMO0FBQ0E7O0FBTEssR0FBUDtBQU9ELEM7Ozs7Ozs7Ozs7OztBQzVJRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQSxNQUFNc0IsTUFBTSxHQUFHO0FBQ2JnSyxXQUFTLEVBQUV0TixTQURFO0FBRWJpUCxlQUFhLEVBQUVqUCxTQUZGO0FBR2J1TixjQUFZLEVBQUUsdURBSEQ7QUFJYjJCLE9BQUssRUFBRTtBQUpNLENBQWY7QUFNQSxNQUFNQyxZQUFZLEdBQUc7QUFBRWpCLFFBQU0sRUFBRTtBQUFWLENBQXJCO0FBRUEsTUFBTWtCLFdBQVcsR0FBR3JJLGlEQUFXLENBQUNMLE1BQVosQ0FBbUI7QUFDckMxRSxNQUFJLEVBQUUsYUFEK0I7QUFFckMyQyxhQUFXLEVBQUUsY0FGd0I7QUFHckNzQyxXQUFTLEVBQUUscUNBSDBCOztBQUlyQ29JLGNBQVksR0FBRztBQUNiLFVBQU1BLFlBQVksR0FBRyxLQUFLL0wsTUFBTCxDQUFZckMsR0FBWixDQUFnQixlQUFoQixDQUFyQjtBQUNBLFFBQUksQ0FBQ29PLFlBQUwsRUFBbUIsT0FBT25RLE9BQU8sQ0FBQ0MsTUFBUixDQUFlO0FBQUVzSixVQUFJLEVBQUU7QUFBUixLQUFmLENBQVA7QUFDbkIsV0FBTyxLQUFLbUcsVUFBTCxDQUFnQjtBQUNyQlUsbUJBQWEsRUFBRUQsWUFETTtBQUVyQkUsZ0JBQVUsRUFBRTtBQUZTLEtBQWhCLEVBSU5wSCxJQUpNLENBSUQsTUFBTSxLQUFLRyxPQUFMLEVBSkwsQ0FBUDtBQUtELEdBWm9DOztBQWFyQ0UsTUFBSSxHQUFHO0FBQ0wsVUFBTWdILFdBQVcsR0FBRyxNQUFNLEtBQUt2RyxRQUFMLENBQWM7QUFDdENyTyxTQUFHLEVBQUcsa0RBQWlEK1Qsd0RBQVMsQ0FBQztBQUMvREcsb0JBQVksRUFBRSxLQUFLeEwsTUFBTCxDQUFZckMsR0FBWixDQUFnQixPQUFoQjtBQURpRCxPQUFELENBRTdELEVBSG1DO0FBSXRDb04sa0JBQVksRUFBRTtBQUp3QixLQUFkLENBQTFCOztBQU1BLFdBQU9tQixXQUFXLEdBQ2pCckgsSUFETSxDQUNBN0ksSUFBRCxJQUFVO0FBQ2Q7QUFDQSxVQUFJQSxJQUFJLENBQUNtUSxXQUFMLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDLGVBQU8sS0FBS3hHLFFBQUwsQ0FBYztBQUNuQmdGLGdCQUFNLEVBQUUsTUFEVztBQUVuQnJULGFBQUcsRUFBRyxxREFBb0QsS0FBSzBJLE1BQUwsQ0FBWXJDLEdBQVosQ0FBZ0IsT0FBaEIsQ0FBeUIsRUFGaEU7QUFHbkJvSSxnQkFBTSxFQUFFLEVBSFc7QUFJbkJyTCxpQkFBTyxFQUFFO0FBQ1AsNEJBQWdCO0FBRFQ7QUFKVSxTQUFkLEVBUU5tSyxJQVJNLENBUUQsTUFBTTtBQUNWdUgsK0RBQU0sQ0FBQztBQUNMQyxpQkFBSyxFQUFFLGVBREY7QUFFTHhCLGdCQUFJLEVBQUU7QUFGRCxXQUFELENBQU47QUFJQSxpQkFBT2pQLE9BQU8sQ0FBQ0MsTUFBUixDQUFlLHdCQUFmLENBQVA7QUFDRCxTQWRNLENBQVA7QUFlRDs7QUFDRCxVQUFJRyxJQUFJLENBQUM0UCxLQUFMLEtBQWU1TCxNQUFNLENBQUM0TCxLQUExQixFQUFpQyxPQUFPaFEsT0FBTyxDQUFDQyxNQUFSLENBQWVnUSxZQUFmLENBQVA7QUFDbEMsS0FyQk0sRUFzQk5uUSxLQXRCTSxDQXNCQzNELEdBQUQsSUFBUztBQUNkLFVBQUlBLEdBQUcsS0FBSzhULFlBQVIsSUFBd0I5VCxHQUFHLENBQUM2UyxNQUFKLEtBQWUsR0FBZixJQUFzQjBCLHdHQUFTLENBQUN2VSxHQUFELEVBQU0sd0JBQU4sQ0FBVCxLQUE2QyxlQUEvRixFQUFnSDtBQUM5RyxlQUFPLEtBQUtnVSxZQUFMLEdBQW9CbEgsSUFBcEIsQ0FBeUJxSCxXQUF6QixDQUFQO0FBQ0Q7O0FBQ0QsYUFBT3RRLE9BQU8sQ0FBQ0MsTUFBUixDQUFlO0FBQ3BCc0osWUFBSSxFQUFFLE9BRGM7QUFFcEJqTyxZQUFJLEVBQUVhO0FBRmMsT0FBZixDQUFQO0FBSUQsS0E5Qk0sQ0FBUDtBQStCRCxHQW5Eb0M7O0FBb0RyQ21PLGFBQVcsR0FBRztBQUNaLFVBQU1pRixNQUFNLEdBQUc7QUFDYm9CLFlBQU0sRUFBRSxlQURLO0FBRWJDLFlBQU0sRUFBRTtBQUZLLEtBQWY7QUFJQSxXQUFPLEtBQUs3RyxRQUFMLENBQWM7QUFDbkJyTyxTQUFHLEVBQUcsVUFBUytULHdEQUFTLENBQUNGLE1BQUQsQ0FBUyxFQURkO0FBRW5CSixrQkFBWSxFQUFFO0FBRkssS0FBZCxFQUlObEcsSUFKTSxDQUlELENBQUM7QUFBRTRIO0FBQUYsS0FBRCxLQUFlO0FBQ25CLFVBQUk3SSxRQUFKO0FBQ0EsWUFBTXlDLFVBQVUsR0FBR29HLEtBQUssQ0FBQzdELE1BQU4sQ0FBY3JCLElBQUQsSUFBVTtBQUN4QyxZQUFJM0ksMERBQVksQ0FBQzJJLElBQUksQ0FBQzdJLElBQU4sQ0FBaEIsRUFBNkIsT0FBTyxJQUFQOztBQUM3QixZQUFJLENBQUNrRixRQUFELElBQWEyRCxJQUFJLENBQUM3SSxJQUFMLEtBQWMsS0FBS2tGLFFBQXBDLEVBQThDO0FBQzVDQSxrQkFBUSxHQUFHMkQsSUFBWDtBQUNELFNBRkQsTUFFTztBQUNMLGVBQUsxSixNQUFMLENBQVkwSixJQUFaO0FBQ0Q7O0FBQ0QsZUFBTyxLQUFQO0FBQ0QsT0FSa0IsRUFTbEJwRyxHQVRrQixDQVNkOEosU0FUYyxFQVVsQnJDLE1BVmtCLENBVVZyQixJQUFELElBQVU7QUFDaEIsWUFBSSxDQUFDQSxJQUFJLENBQUNtRSxJQUFWLEVBQWdCO0FBQ2QsZUFBSzdOLE1BQUwsQ0FBWTBKLElBQVo7QUFDQSxpQkFBTyxLQUFQO0FBQ0Q7O0FBQ0QsZUFBTyxJQUFQO0FBQ0QsT0FoQmtCLENBQW5CO0FBaUJBLFlBQU1tRixRQUFRLEdBQUc5SSxRQUFRLEdBQUdxSCxTQUFTLENBQUNySCxRQUFELENBQVosR0FBeUIsRUFBbEQ7QUFDQSxZQUFNK0ksT0FBTyxHQUFHLEtBQUtoUCxHQUFMLENBQVMrTyxRQUFULEVBQ2Y3SCxJQURlLENBQ1YzTixJQUFJLElBQUl1TCxJQUFJLENBQUNDLEtBQUwsQ0FBV3hMLElBQVgsQ0FERSxFQUVmd0UsS0FGZSxDQUVUMkQsR0FBRyxJQUFJLEtBQUtrRyxlQUFMLENBQXFCbEcsR0FBckIsQ0FGRSxFQUdmd0YsSUFIZSxDQUdWM04sSUFBSSxJQUFJTCxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCNFYsUUFBbEIsRUFBNEI7QUFDeENoTyxZQUFJLEVBQUUsS0FBS2tGLFFBRDZCO0FBRXhDakYsV0FBRyxFQUFFLElBRm1DO0FBR3hDekg7QUFId0MsT0FBNUIsQ0FIRSxDQUFoQjtBQVFBLGFBQU8wRSxPQUFPLENBQUN3SyxHQUFSLENBQVksQ0FBQ3VHLE9BQUQsRUFBVXRHLFVBQVYsRUFBc0IsS0FBS0wsWUFBTCxFQUF0QixDQUFaLENBQVA7QUFDRCxLQWpDTSxDQUFQO0FBa0NELEdBM0ZvQzs7QUE0RnJDa0QsV0FBUyxHQUFHO0FBQ1YsVUFBTWlDLE1BQU0sR0FBRztBQUNiQyxtQkFBYSxFQUFFLE1BREY7QUFFYmUsaUJBQVcsRUFBRSxTQUZBO0FBR2JuQyxlQUFTLEVBQUVoSyxNQUFNLENBQUNnSyxTQUhMO0FBSWJDLGtCQUFZLEVBQUVqSyxNQUFNLENBQUNpSyxZQUpSO0FBS2IyQixXQUFLLEVBQUU1TCxNQUFNLENBQUM0TDtBQUxELEtBQWY7QUFPQSxRQUFJLENBQUMsS0FBSzVMLE1BQUwsQ0FBWXJDLEdBQVosQ0FBZ0IsZUFBaEIsQ0FBTCxFQUF1Q3dOLE1BQU0sQ0FBQ3lCLE1BQVAsR0FBZ0IsU0FBaEI7QUFDdkMsVUFBTXRWLEdBQUcsR0FBSSxnREFBK0MrVCx3REFBUyxDQUFDRixNQUFELENBQVMsRUFBOUU7QUFDQTlCLDhEQUFZLENBQUMvUixHQUFELEVBQU0wSSxNQUFNLENBQUNpSyxZQUFiLENBQVo7QUFDRCxHQXZHb0M7O0FBd0dyQ0osV0FBUyxDQUFDdlMsR0FBRCxFQUFNO0FBQ2IsVUFBTWdTLFdBQVcsR0FBSSxHQUFFdEosTUFBTSxDQUFDaUssWUFBYSxRQUEzQzs7QUFDQSxRQUFJM1MsR0FBRyxDQUFDd08sVUFBSixDQUFld0QsV0FBZixDQUFKLEVBQWlDO0FBQy9CLFdBQUtoSSxTQUFMLENBQWUxQixHQUFmLENBQW1CLGFBQW5CO0FBQ0EsV0FBSzBMLFVBQUwsQ0FBZ0I7QUFDZHpRLFlBQUksRUFBRXVFLGtCQUFrQixDQUFDOUgsR0FBRyxDQUFDNkgsS0FBSixDQUFVLEdBQVYsRUFBZSxDQUFmLEVBQWtCRCxLQUFsQixDQUF3Qm9LLFdBQVcsQ0FBQ2hSLE1BQXBDLENBQUQ7QUFEVixPQUFoQixFQUdDdU0sSUFIRCxDQUdNLE1BQU0sS0FBS08sU0FBTCxFQUhaO0FBSUEsYUFBTyxJQUFQO0FBQ0Q7QUFDRixHQWxIb0M7O0FBbUhyQytELFFBQU0sR0FBRztBQUNQLFNBQUtuSixNQUFMLENBQVlKLEdBQVosQ0FBZ0I7QUFDZDZGLFdBQUssRUFBRSxJQURPO0FBRWR1RyxtQkFBYSxFQUFFO0FBRkQsS0FBaEI7QUFJQSxXQUFPLEtBQUtoSCxPQUFMLEVBQVA7QUFDRCxHQXpIb0M7O0FBMEhyQ3NHLFlBQVUsQ0FBQ0gsTUFBRCxFQUFTO0FBQ2pCLFdBQU8sS0FBS3hGLFFBQUwsQ0FBYztBQUNuQmdGLFlBQU0sRUFBRSxNQURXO0FBRW5CclQsU0FBRyxFQUFFLDRDQUZjO0FBR25CeU8sWUFBTSxFQUFFLEVBSFc7QUFJbkJyTCxhQUFPLEVBQUU7QUFDUCx3QkFBZ0I7QUFEVCxPQUpVO0FBT25CbVEsVUFBSSxFQUFFUSx3REFBUyxDQUFDeFUsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQjtBQUNoQ2tULGlCQUFTLEVBQUVoSyxNQUFNLENBQUNnSyxTQURjO0FBRWhDMkIscUJBQWEsRUFBRTNMLE1BQU0sQ0FBQzJMLGFBRlU7QUFHaEMxQixvQkFBWSxFQUFFakssTUFBTSxDQUFDaUssWUFIVztBQUloQ2dDLGtCQUFVLEVBQUU7QUFKb0IsT0FBbEIsRUFLYmQsTUFMYSxDQUFELENBUEk7QUFhbkJKLGtCQUFZLEVBQUU7QUFiSyxLQUFkLEVBZU5sRyxJQWZNLENBZUEzTixJQUFELElBQVU7QUFDZCxVQUFJQSxJQUFJLENBQUNzVSxZQUFULEVBQXVCO0FBQ3JCLGNBQU1oTyxNQUFNLEdBQUc7QUFDYmlJLGVBQUssRUFBRXZPLElBQUksQ0FBQ3NVO0FBREMsU0FBZjs7QUFHQSxZQUFJdFUsSUFBSSxDQUFDOFUsYUFBVCxFQUF3QjtBQUN0QnhPLGdCQUFNLENBQUN3TyxhQUFQLEdBQXVCOVUsSUFBSSxDQUFDOFUsYUFBNUI7QUFDRDs7QUFDRCxhQUFLaE0sTUFBTCxDQUFZSixHQUFaLENBQWdCcEMsTUFBaEI7QUFDRCxPQVJELE1BUU87QUFDTCxjQUFNdEcsSUFBTjtBQUNEO0FBQ0YsS0EzQk0sQ0FBUDtBQTRCRCxHQXZKb0M7O0FBd0pyQ3FPLGlCQUFlLEVBQUV6QixvRkF4Sm9COztBQXlKckNyRyxNQUFJLEdBQUc7QUFDTCxVQUFNLElBQUkzQixLQUFKLENBQVUsZUFBVixDQUFOO0FBQ0QsR0EzSm9DOztBQTRKckM2QixLQUFHLENBQUM7QUFBRS9GO0FBQUYsR0FBRCxFQUFTO0FBQ1YsUUFBSSxDQUFDQSxFQUFMLEVBQVMsT0FBT2dFLE9BQU8sQ0FBQ0MsTUFBUixFQUFQO0FBQ1QsV0FBTyxLQUFLOEosUUFBTCxDQUFjO0FBQ25Cck8sU0FBRyxFQUFHLFVBQVNNLEVBQUc7QUFEQyxLQUFkLENBQVA7QUFHRCxHQWpLb0M7O0FBa0tyQ3VRLEtBQUcsQ0FBQ1osSUFBRCxFQUFPclEsSUFBUCxFQUFhO0FBQ2QsVUFBTXdILElBQUksR0FBR0QsNkRBQWUsQ0FBQzhJLElBQUQsQ0FBNUI7QUFDQSxVQUFNO0FBQUUzUDtBQUFGLFFBQVMyUCxJQUFmO0FBQ0EsVUFBTXNGLFFBQVEsR0FBR0MsaUdBQVMsQ0FBQyx5QkFBRCxDQUExQjtBQUNBLFVBQU1wUyxPQUFPLEdBQUc7QUFDZCxzQkFBaUIsK0JBQThCbVMsUUFBUztBQUQxQyxLQUFoQjtBQUdBLFVBQU1FLFFBQVEsR0FBR25WLEVBQUUsR0FBRztBQUNwQjhHO0FBRG9CLEtBQUgsR0FFZjtBQUNGQSxVQURFO0FBRUZzTyxhQUFPLEVBQUUsQ0FBQyxlQUFEO0FBRlAsS0FGSjtBQU1BLFVBQU1uQyxJQUFJLEdBQUcsQ0FDVixLQUFJZ0MsUUFBUyxFQURILEVBRVgsK0NBRlcsRUFHWCxFQUhXLEVBSVhwSyxJQUFJLENBQUMyRixTQUFMLENBQWUyRSxRQUFmLENBSlcsRUFLVixLQUFJRixRQUFTLEVBTEgsRUFNWCwwQkFOVyxFQU9YLEVBUFcsRUFRWDNWLElBUlcsRUFTVixLQUFJMlYsUUFBUyxJQVRILEVBVVgsRUFWVyxFQVdYSSxJQVhXLENBV04sTUFYTSxDQUFiO0FBWUEsVUFBTTNWLEdBQUcsR0FBR00sRUFBRSxHQUNULG9EQUFtREEsRUFBRyx1QkFEN0MsR0FFVix1RUFGSjtBQUdBLFdBQU8sS0FBSytOLFFBQUwsQ0FBYztBQUNuQnJPLFNBRG1CO0FBRW5CdVQsVUFGbUI7QUFHbkJuUSxhQUhtQjtBQUluQmlRLFlBQU0sRUFBRS9TLEVBQUUsR0FBRyxPQUFILEdBQWE7QUFKSixLQUFkLENBQVA7QUFNRCxHQXBNb0M7O0FBcU1yQ2lHLFFBQU0sQ0FBQztBQUFFakc7QUFBRixHQUFELEVBQVM7QUFDYixXQUFPLEtBQUsrTixRQUFMLENBQWM7QUFDbkJnRixZQUFNLEVBQUUsUUFEVztBQUVuQnJULFNBQUcsRUFBRyxVQUFTTSxFQUFHO0FBRkMsS0FBZCxDQUFQO0FBSUQ7O0FBMU1vQyxDQUFuQixDQUFwQjtBQTRNQWtSLHNEQUFRLENBQUNnRCxXQUFELENBQVI7O0FBRUEsU0FBU2IsU0FBVCxDQUFtQjFELElBQW5CLEVBQXlCO0FBQ3ZCLFNBQU87QUFDTDNQLE1BQUUsRUFBRTJQLElBQUksQ0FBQzNQLEVBREo7QUFFTDhHLFFBQUksRUFBRTZJLElBQUksQ0FBQzdJLElBRk47QUFHTGdOLFFBQUksRUFBRSxDQUFDbkUsSUFBSSxDQUFDbUUsSUFIUDtBQUlML00sT0FBRyxFQUFFRyxvREFBTSxDQUFDeUksSUFBSSxDQUFDN0ksSUFBTjtBQUpOLEdBQVA7QUFNRCxDOzs7Ozs7Ozs7Ozs7QUN4T0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBN0gsTUFBTSxDQUFDQyxNQUFQLENBQWNDLHVEQUFkLEVBQXdCO0FBQ3RCbVcsZUFBYSxFQUFFaEUsK0NBRE87QUFFdEJpRSxZQUFVLEVBQUVoRSw0Q0FGVTtBQUd0QmlFLFdBQVMsRUFBRWhXLDBDQUhXO0FBSXRCaVcsZUFBYSxFQUFFakUsK0NBQVNBO0FBSkYsQ0FBeEI7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBLE1BQU1wSixNQUFNLEdBQUc7QUFDYmdLLFdBQVMsRUFBRXROLFNBREU7QUFFYmlQLGVBQWEsRUFBRWpQLFNBRkY7QUFHYnVOLGNBQVksRUFBRTtBQUhELENBQWY7QUFNQSxNQUFNcUQsUUFBUSxHQUFHN0osaURBQVcsQ0FBQ0wsTUFBWixDQUFtQjtBQUNsQzFFLE1BQUksRUFBRSxVQUQ0QjtBQUVsQzJDLGFBQVcsRUFBRSxVQUZxQjtBQUdsQ3NDLFdBQVMsRUFBRSwrQkFIdUI7O0FBSWxDb0ksY0FBWSxHQUFHO0FBQ2IsVUFBTUEsWUFBWSxHQUFHLEtBQUsvTCxNQUFMLENBQVlyQyxHQUFaLENBQWdCLGVBQWhCLENBQXJCO0FBQ0EsV0FBTyxLQUFLMk4sVUFBTCxDQUFnQjtBQUNyQlUsbUJBQWEsRUFBRUQsWUFETTtBQUVyQkUsZ0JBQVUsRUFBRTtBQUZTLEtBQWhCLEVBSU5wSCxJQUpNLENBSUQsTUFBTSxLQUFLRyxPQUFMLEVBSkwsQ0FBUDtBQUtELEdBWGlDOztBQVlsQ0UsTUFBSSxHQUFHO0FBQ0wsVUFBTWdILFdBQVcsR0FBRyxNQUFNLEtBQUt2RyxRQUFMLENBQWM7QUFDdENyTyxTQUFHLEVBQUUsUUFEaUM7QUFFdEN5VCxrQkFBWSxFQUFFO0FBRndCLEtBQWQsQ0FBMUI7O0FBSUEsV0FBT21CLFdBQVcsR0FDakJ4USxLQURNLENBQ0MzRCxHQUFELElBQVM7QUFDZCxVQUFJQSxHQUFHLENBQUM2UyxNQUFKLEtBQWUsR0FBbkIsRUFBd0I7QUFDdEIsZUFBTyxLQUFLbUIsWUFBTCxHQUFvQmxILElBQXBCLENBQXlCcUgsV0FBekIsQ0FBUDtBQUNEOztBQUNELFlBQU1uVSxHQUFOO0FBQ0QsS0FOTSxFQU9OMkQsS0FQTSxDQU9DM0QsR0FBRCxJQUFTO0FBQ2QsVUFBSUEsR0FBRyxDQUFDNlMsTUFBSixLQUFlLEdBQWYsSUFBc0IwQix3R0FBUyxDQUFDdlUsR0FBRCxFQUFNLFlBQU4sQ0FBVCxLQUFpQyxlQUEzRCxFQUE0RTtBQUMxRSxlQUFPNkQsT0FBTyxDQUFDQyxNQUFSLENBQWU7QUFDcEJzSixjQUFJLEVBQUU7QUFEYyxTQUFmLENBQVA7QUFHRDs7QUFDRCxhQUFPdkosT0FBTyxDQUFDQyxNQUFSLENBQWU7QUFDcEJzSixZQUFJLEVBQUUsT0FEYztBQUVwQmpPLFlBQUksRUFBRWE7QUFGYyxPQUFmLENBQVA7QUFJRCxLQWpCTSxDQUFQO0FBa0JELEdBbkNpQzs7QUFvQ2xDd04saUJBQWUsQ0FBQ3hOLEdBQUQsRUFBTTtBQUNuQixRQUFJQSxHQUFHLENBQUM2UyxNQUFKLEtBQWUsR0FBbkIsRUFBd0I7QUFBQTs7QUFDdEIsWUFBTTJDLE1BQU0sR0FBRyxxQkFBQXhWLEdBQUcsQ0FBQzJDLE9BQUosQ0FBWWlELEdBQVosQ0FBZ0Isa0JBQWhCLHVDQUFzQyxDQUF0QyxNQUE0QyxFQUEzRDs7QUFDQSxVQUFJLDhCQUE4QmtCLElBQTlCLENBQW1DME8sTUFBbkMsQ0FBSixFQUFnRDtBQUM5QyxlQUFPLEtBQUt4QixZQUFMLEdBQW9CbEgsSUFBcEIsQ0FBeUIsTUFBTSxLQUFLVyxPQUFMLEVBQS9CLENBQVA7QUFDRDs7QUFDRDtBQUNEOztBQUNELFVBQU16TixHQUFOO0FBQ0QsR0E3Q2lDOztBQThDbEMwRixNQUFJLEdBQUc7QUFDTCxXQUFPLEtBQUtrSSxRQUFMLENBQWM7QUFDbkJyTyxTQUFHLEVBQUUsaUNBRGM7QUFFbkJ5VCxrQkFBWSxFQUFFO0FBRkssS0FBZCxFQUlObEcsSUFKTSxDQUlEM04sSUFBSSxJQUFJQSxJQUFJLENBQUMySSxLQUFMLENBQVcrSSxNQUFYLENBQWtCckIsSUFBSSxJQUFJQSxJQUFJLENBQUNpRyxJQUFMLElBQWE1TywwREFBWSxDQUFDMkksSUFBSSxDQUFDN0ksSUFBTixDQUFuRCxFQUFnRXlDLEdBQWhFLENBQW9FOEosU0FBcEUsQ0FKUCxDQUFQO0FBS0QsR0FwRGlDOztBQXFEbEN0TixLQUFHLENBQUM0SixJQUFELEVBQU87QUFDUixVQUFNN0ksSUFBSSxHQUFHRCw2REFBZSxDQUFDOEksSUFBRCxDQUE1QjtBQUNBLFdBQU8sS0FBSzVCLFFBQUwsQ0FBYztBQUNuQnJPLFNBQUcsRUFBRywyQkFBMEJtVyxrQkFBa0IsQ0FBQy9PLElBQUQsQ0FBTyxFQUR0QztBQUVuQnFNLGtCQUFZLEVBQUU7QUFGSyxLQUFkLEVBSU5sRyxJQUpNLENBSUQzTixJQUFJLElBQUksS0FBS3lPLFFBQUwsQ0FBYztBQUMxQnJPLFNBQUcsRUFBRUosSUFBSSxDQUFDLHNCQUFELENBRGlCO0FBRTFCME8sV0FBSyxFQUFFO0FBRm1CLEtBQWQsQ0FKUCxDQUFQO0FBUUQsR0EvRGlDOztBQWdFbEN1QyxLQUFHLENBQUNaLElBQUQsRUFBT3JRLElBQVAsRUFBYTtBQUNkLFVBQU13SCxJQUFJLEdBQUdELDZEQUFlLENBQUM4SSxJQUFELENBQTVCO0FBQ0EsV0FBTyxLQUFLNUIsUUFBTCxDQUFjO0FBQ25CZ0YsWUFBTSxFQUFFLEtBRFc7QUFFbkJyVCxTQUFHLEVBQUcsMkJBQTBCbVcsa0JBQWtCLENBQUMvTyxJQUFELENBQU8sV0FGdEM7QUFHbkJoRSxhQUFPLEVBQUU7QUFDUCx3QkFBZ0I7QUFEVCxPQUhVO0FBTW5CbVEsVUFBSSxFQUFFM1QsSUFOYTtBQU9uQjZULGtCQUFZLEVBQUU7QUFQSyxLQUFkLEVBU05sRyxJQVRNLENBU0RvRyxTQVRDLENBQVA7QUFVRCxHQTVFaUM7O0FBNkVsQ3BOLFFBQU0sQ0FBQzBKLElBQUQsRUFBTztBQUNYO0FBQ0EsVUFBTTdJLElBQUksR0FBR0QsNkRBQWUsQ0FBQzhJLElBQUQsQ0FBNUI7QUFDQSxXQUFPLEtBQUs1QixRQUFMLENBQWM7QUFDbkJnRixZQUFNLEVBQUUsUUFEVztBQUVuQnJULFNBQUcsRUFBRywyQkFBMEJtVyxrQkFBa0IsQ0FBQy9PLElBQUQsQ0FBTztBQUZ0QyxLQUFkLEVBSU5oRCxLQUpNLENBSUFvSSxvRkFKQSxDQUFQO0FBS0QsR0FyRmlDOztBQXNGbENvRixXQUFTLEdBQUc7QUFDVixVQUFNaUMsTUFBTSxHQUFHO0FBQ2JuQixlQUFTLEVBQUVoSyxNQUFNLENBQUNnSyxTQURMO0FBRWI0QixXQUFLLEVBQUUsc0NBRk07QUFHYlIsbUJBQWEsRUFBRSxNQUhGO0FBSWJuQixrQkFBWSxFQUFFakssTUFBTSxDQUFDaUs7QUFKUixLQUFmO0FBTUEsVUFBTTNTLEdBQUcsR0FBSSxnREFBK0MrVCx3REFBUyxDQUFDRixNQUFELENBQVMsRUFBOUU7QUFDQTlCLDhEQUFZLENBQUMvUixHQUFELEVBQU0wSSxNQUFNLENBQUNpSyxZQUFiLENBQVo7QUFDRCxHQS9GaUM7O0FBZ0dsQ0osV0FBUyxDQUFDdlMsR0FBRCxFQUFNO0FBQ2IsVUFBTWdTLFdBQVcsR0FBSSxHQUFFdEosTUFBTSxDQUFDaUssWUFBYSxRQUEzQzs7QUFDQSxRQUFJM1MsR0FBRyxDQUFDd08sVUFBSixDQUFld0QsV0FBZixDQUFKLEVBQWlDO0FBQy9CLFdBQUtoSSxTQUFMLENBQWUxQixHQUFmLENBQW1CLGFBQW5CO0FBQ0EsV0FBSzBMLFVBQUwsQ0FBZ0I7QUFDZHpRLFlBQUksRUFBRXZELEdBQUcsQ0FBQzRILEtBQUosQ0FBVW9LLFdBQVcsQ0FBQ2hSLE1BQXRCO0FBRFEsT0FBaEIsRUFHQ3VNLElBSEQsQ0FHTSxNQUFNLEtBQUtPLFNBQUwsRUFIWjtBQUlBLGFBQU8sSUFBUDtBQUNEO0FBQ0YsR0ExR2lDOztBQTJHbEMrRCxRQUFNLEdBQUc7QUFDUCxTQUFLbkosTUFBTCxDQUFZSixHQUFaLENBQWdCO0FBQ2Q2TCxTQUFHLEVBQUUsSUFEUztBQUVkaEcsV0FBSyxFQUFFLElBRk87QUFHZHVHLG1CQUFhLEVBQUU7QUFIRCxLQUFoQjtBQUtBLFdBQU8sS0FBS2hILE9BQUwsRUFBUDtBQUNELEdBbEhpQzs7QUFtSGxDc0csWUFBVSxDQUFDSCxNQUFELEVBQVM7QUFDakIsV0FBTyxLQUFLeEYsUUFBTCxDQUFjO0FBQ25CZ0YsWUFBTSxFQUFFLE1BRFc7QUFFbkJyVCxTQUFHLEVBQUUsMENBRmM7QUFHbkJ5TyxZQUFNLEVBQUUsRUFIVztBQUluQnJMLGFBQU8sRUFBRTtBQUNQLHdCQUFnQjtBQURULE9BSlU7QUFPbkJtUSxVQUFJLEVBQUVRLHdEQUFTLENBQUN4VSxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCO0FBQ2hDa1QsaUJBQVMsRUFBRWhLLE1BQU0sQ0FBQ2dLLFNBRGM7QUFFaEMyQixxQkFBYSxFQUFFM0wsTUFBTSxDQUFDMkwsYUFGVTtBQUdoQzFCLG9CQUFZLEVBQUVqSyxNQUFNLENBQUNpSyxZQUhXO0FBSWhDZ0Msa0JBQVUsRUFBRTtBQUpvQixPQUFsQixFQUtiZCxNQUxhLENBQUQsQ0FQSTtBQWFuQkosa0JBQVksRUFBRTtBQWJLLEtBQWQsRUFlTmxHLElBZk0sQ0FlQTNOLElBQUQsSUFBVTtBQUNkLFVBQUlBLElBQUksQ0FBQ3NVLFlBQVQsRUFBdUI7QUFDckIsYUFBS3hMLE1BQUwsQ0FBWUosR0FBWixDQUFnQjtBQUNkNkwsYUFBRyxFQUFFdlUsSUFBSSxDQUFDd1csT0FESTtBQUVkakksZUFBSyxFQUFFdk8sSUFBSSxDQUFDc1UsWUFGRTtBQUdkUSx1QkFBYSxFQUFFOVUsSUFBSSxDQUFDOFU7QUFITixTQUFoQjtBQUtELE9BTkQsTUFNTztBQUNMLGNBQU05VSxJQUFOO0FBQ0Q7QUFDRixLQXpCTSxDQUFQO0FBMEJEOztBQTlJaUMsQ0FBbkIsQ0FBakI7QUFnSkE0UixzREFBUSxDQUFDd0UsUUFBRCxDQUFSOztBQUVBLFNBQVNyQyxTQUFULENBQW1CMUQsSUFBbkIsRUFBeUI7QUFDdkIsU0FBTztBQUNMN0ksUUFBSSxFQUFFNkksSUFBSSxDQUFDN0ksSUFETjtBQUVMZ04sUUFBSSxFQUFFbkUsSUFBSSxDQUFDbUUsSUFGTjtBQUdML00sT0FBRyxFQUFFRyxvREFBTSxDQUFDeUksSUFBSSxDQUFDN0ksSUFBTixDQUhOLENBSUw7O0FBSkssR0FBUDtBQU1ELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEtEO0FBSUEsTUFBTWlQLFlBQVksR0FBR0MsTUFBTSxDQUFDLFVBQUQsQ0FBM0I7O0FBRUEsTUFBTUMsS0FBTixDQUFZO0FBQ1YzSyxhQUFXLENBQUM0SyxJQUFELEVBQU9DLEtBQVAsRUFBYztBQUN2QixTQUFLRCxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLQyxLQUFMLDZFQUFrQkEsS0FBbEI7QUFDQSxTQUFLQyxVQUFMO0FBQ0EsU0FBS0MsU0FBTDtBQUNEOztBQUVELFNBQU9DLE9BQVAsQ0FBZUMsR0FBZixFQUFvQjtBQUNsQixVQUFNQyxNQUFNLEdBQUcsSUFBSUMsU0FBSixFQUFmO0FBQ0EsVUFBTUMsR0FBRyxHQUFHRixNQUFNLENBQUNHLGVBQVAsQ0FBdUJKLEdBQXZCLEVBQTRCLGlCQUE1QixDQUFaO0FBQ0EsV0FBTyxJQUFJTixLQUFKLENBQVVTLEdBQVYsQ0FBUDtBQUNEOztBQUVETixZQUFVLEdBQUc7QUFDWCxVQUFNO0FBQUVGLFVBQUY7QUFBUUM7QUFBUixRQUFrQixJQUF4QjtBQUNBLFVBQU1TLEtBQUssR0FBRyxFQUFkO0FBQ0EsVUFBTTtBQUFFQztBQUFGLFFBQWlCWCxJQUF2Qjs7QUFDQSxRQUFJVyxVQUFKLEVBQWdCO0FBQ2QsV0FBSyxNQUFNQyxJQUFYLElBQW1CWixJQUFJLENBQUNXLFVBQXhCLEVBQW9DO0FBQ2xDLGNBQU07QUFBRS9QLGNBQUY7QUFBUW1CO0FBQVIsWUFBa0I2TyxJQUF4QjtBQUNBLFlBQUloUSxJQUFJLEtBQUssT0FBYixFQUFzQnFQLEtBQUssQ0FBQ1ksQ0FBTixHQUFVOU8sS0FBVixDQUF0QixLQUNLLElBQUluQixJQUFJLENBQUNvSCxVQUFMLENBQWdCLFFBQWhCLENBQUosRUFBK0JpSSxLQUFLLENBQUNyUCxJQUFJLENBQUNRLEtBQUwsQ0FBVyxDQUFYLENBQUQsQ0FBTCxHQUF1QlcsS0FBdkI7QUFDcEMyTyxhQUFLLENBQUM5UCxJQUFELENBQUwsR0FBY21CLEtBQWQ7QUFDRDtBQUNGOztBQUNELFNBQUsyTyxLQUFMLEdBQWFBLEtBQWI7QUFDRDs7QUFFRFAsV0FBUyxHQUFHO0FBQ1YsVUFBTTtBQUFFSCxVQUFGO0FBQVFDO0FBQVIsUUFBa0IsSUFBeEI7O0FBQ0EsUUFBSUQsSUFBSSxDQUFDYyxRQUFMLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCLFVBQUlsUSxJQUFJLEdBQUdvUCxJQUFJLENBQUNlLE9BQWhCO0FBQ0EsVUFBSUMsRUFBRSxHQUFHZixLQUFLLENBQUNZLENBQWY7O0FBQ0EsVUFBSWpRLElBQUksQ0FBQ2pGLFFBQUwsQ0FBYyxHQUFkLENBQUosRUFBd0I7QUFDdEIsWUFBSXNNLE1BQUo7QUFDQSxTQUFDQSxNQUFELEVBQVNySCxJQUFULElBQWlCQSxJQUFJLENBQUNTLEtBQUwsQ0FBVyxHQUFYLENBQWpCO0FBQ0EyUCxVQUFFLEdBQUdmLEtBQUssQ0FBQ2hJLE1BQUQsQ0FBVjtBQUNBLFlBQUksQ0FBQytJLEVBQUwsRUFBUyxNQUFNLElBQUloVCxLQUFKLENBQVcsc0JBQXFCaUssTUFBTyxFQUF2QyxDQUFOO0FBQ1Y7O0FBQ0QsV0FBS3JILElBQUwsR0FBWW9RLEVBQUUsR0FBR3BRLElBQWpCO0FBQ0Q7QUFDRjs7QUFFRHFRLE1BQUksR0FBRztBQUNMLFVBQU07QUFBRWpCO0FBQUYsUUFBVyxJQUFqQjtBQUNBLFFBQUlBLElBQUosRUFBVSxPQUFPLENBQUNBLElBQUksQ0FBQ2tCLFdBQUwsSUFBb0IsRUFBckIsRUFBeUJDLElBQXpCLEVBQVA7QUFDWDs7QUFFREMsVUFBUSxHQUFHO0FBQ1QsUUFBSSxDQUFDLEtBQUt2QixZQUFMLENBQUwsRUFBeUI7QUFDdkIsWUFBTTtBQUFFRyxZQUFGO0FBQVFDO0FBQVIsVUFBa0IsSUFBeEI7QUFDQSxXQUFLSixZQUFMLElBQXFCLENBQUMsR0FBR0csSUFBSSxDQUFDb0IsUUFBVCxFQUNwQi9OLEdBRG9CLENBQ2hCZ08sS0FBSyxJQUFJLElBQUl0QixLQUFKLENBQVVzQixLQUFWLEVBQWlCcEIsS0FBakIsQ0FETyxDQUFyQjtBQUVEOztBQUNELFdBQU8sS0FBS0osWUFBTCxDQUFQO0FBQ0Q7O0FBRUR4TSxLQUFHLENBQUNpTyxRQUFELEVBQVc7QUFDWixXQUFPLEtBQUtGLFFBQUwsR0FBZ0IvTixHQUFoQixDQUFvQmlPLFFBQXBCLENBQVA7QUFDRDs7QUFFREMsYUFBVyxDQUFDRCxRQUFELEVBQVc7QUFDcEIsUUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLGFBQU8sQ0FBQ1AsT0FBTyxJQUFJZixJQUFJLElBQUlBLElBQUksQ0FBQ3BQLElBQUwsS0FBY21RLE9BQWxDLEVBQTJDTyxRQUEzQyxDQUFQO0FBQ0Q7O0FBQ0QsV0FBT0EsUUFBUDtBQUNEOztBQUVEeEcsUUFBTSxDQUFDd0csUUFBRCxFQUFXO0FBQ2YsV0FBTyxLQUFLRixRQUFMLEdBQWdCdEcsTUFBaEIsQ0FBdUIsS0FBS3lHLFdBQUwsQ0FBaUJELFFBQWpCLENBQXZCLENBQVA7QUFDRDs7QUFFREUsTUFBSSxDQUFDRixRQUFELEVBQVc7QUFDYixXQUFPLEtBQUtGLFFBQUwsR0FBZ0JJLElBQWhCLENBQXFCLEtBQUtELFdBQUwsQ0FBaUJELFFBQWpCLENBQXJCLENBQVA7QUFDRDs7QUFFRFYsTUFBSSxDQUFDblAsR0FBRCxFQUFNO0FBQ1IsV0FBTyxLQUFLaVAsS0FBTCxDQUFXalAsR0FBWCxDQUFQO0FBQ0Q7O0FBL0VTOztBQWtGWixNQUFNZ1EsY0FBYyxHQUFHO0FBQ3JCQyxXQUFTLEVBQUUsRUFEVTtBQUVyQkMsV0FBUyxFQUFFLEtBRlU7QUFHckJDLFVBQVEsRUFBRSxFQUhXO0FBSXJCQyxVQUFRLEVBQUU7QUFKVyxDQUF2QjtBQU9BLE1BQU1DLE1BQU0sR0FBR25NLGlEQUFXLENBQUNMLE1BQVosQ0FBbUI7QUFDaEMxRSxNQUFJLEVBQUUsUUFEMEI7QUFFaEMyQyxhQUFXLEVBQUUsUUFGbUI7QUFHaENLLFlBQVUsRUFBRTtBQUNWbUMsWUFBUSxFQUFFLFVBREE7QUFFVjJMLGFBQVMsRUFBRTtBQUZELEdBSG9COztBQU9oQzVOLGVBQWEsR0FBRztBQUNkLFFBQUksQ0FBQyxLQUFLRCxVQUFWLEVBQXNCO0FBQ3BCLFdBQUtBLFVBQUwsNkVBQ0s0TixjQURMLE1BRUssS0FBS3ZQLE1BQUwsQ0FBWXJDLEdBQVosQ0FBZ0IsWUFBaEIsQ0FGTDtBQUlEOztBQUNELFdBQU8sS0FBS2dFLFVBQVo7QUFDRCxHQWYrQjs7QUFnQmhDb0MsZUFBYSxDQUFDL0QsTUFBRCxFQUFTO0FBQ3BCbkosVUFBTSxDQUFDQyxNQUFQLENBQWMsS0FBSzZLLFVBQW5CLEVBQStCM0IsTUFBL0I7QUFDQSxTQUFLQSxNQUFMLENBQVlKLEdBQVosQ0FBZ0IsWUFBaEIsRUFBOEIsS0FBSytCLFVBQW5DO0FBQ0QsR0FuQitCOztBQW9CaENzRCxXQUFTLEdBQUc7QUFBQTs7QUFDVixTQUFLRixjQUFMO0FBQ0EsVUFBTS9FLE1BQU0sR0FBRyxLQUFLNEIsYUFBTCxFQUFmO0FBQ0EsUUFBSXRLLEdBQUcsR0FBRyxzQkFBQTBJLE1BQU0sQ0FBQ3dQLFNBQVAsdUNBQWtCUCxJQUFsQixPQUE0QixFQUF0QztBQUNBLFFBQUksQ0FBQzNYLEdBQUcsQ0FBQ21DLFFBQUosQ0FBYSxLQUFiLENBQUwsRUFBMEJuQyxHQUFHLEdBQUksVUFBU0EsR0FBSSxFQUFwQjtBQUMxQixRQUFJLENBQUNBLEdBQUcsQ0FBQ3VZLFFBQUosQ0FBYSxHQUFiLENBQUwsRUFBd0J2WSxHQUFHLElBQUksR0FBUDs7QUFDeEIsUUFBSTtBQUNGLFVBQUl3WSxHQUFKLENBQVF4WSxHQUFSLEVBREUsQ0FDWTtBQUNmLEtBRkQsQ0FFRSxPQUFPcUUsQ0FBUCxFQUFVO0FBQ1YsV0FBSytGLFVBQUwsQ0FBZ0I4TixTQUFoQixHQUE0QixJQUE1QjtBQUNBLGFBQU8sS0FBUDtBQUNEOztBQUNELFNBQUs5TixVQUFMLENBQWdCOE4sU0FBaEIsR0FBNkIsR0FBRWxZLEdBQUksZ0JBQW5DO0FBQ0EsVUFBTTtBQUFFbVksZUFBRjtBQUFhQyxjQUFiO0FBQXVCQztBQUF2QixRQUFvQzNQLE1BQTFDO0FBQ0EsUUFBSXlQLFNBQUosRUFBZSxPQUFPLElBQVA7QUFDZixRQUFJLENBQUNDLFFBQUQsSUFBYSxDQUFDQyxRQUFsQixFQUE0QixPQUFPLEtBQVA7QUFDNUIsVUFBTUksSUFBSSxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBYSxHQUFFUCxRQUFTLElBQUdDLFFBQVMsRUFBcEMsQ0FBYjtBQUNBLFNBQUtqVixPQUFMLENBQWFnTCxhQUFiLEdBQThCLFNBQVFxSyxJQUFLLEVBQTNDO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0F2QytCOztBQXdDaENwSyxVQUFRLENBQUNyQyxPQUFELEVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsV0FBT0csaURBQVcsQ0FBQ04sU0FBWixDQUFzQndDLFFBQXRCLENBQStCdUssSUFBL0IsQ0FBb0MsSUFBcEMsRUFBMENyWixNQUFNLENBQUNDLE1BQVAsQ0FBYztBQUM3RHFaLGlCQUFXLEVBQUU7QUFEZ0QsS0FBZCxFQUU5QzdNLE9BRjhDLENBQTFDLENBQVA7QUFHRCxHQS9DK0I7O0FBZ0RoQ2lDLGlCQUFlLENBQUN4TixHQUFELEVBQU07QUFDbkIsUUFBSSxDQUFDLENBQ0gsR0FERyxFQUNFO0FBQ0wsT0FGRyxDQUVFO0FBRkYsTUFHSDBCLFFBSEcsQ0FHTTFCLEdBQUcsQ0FBQzZTLE1BSFYsQ0FBTCxFQUd3QixNQUFNN1MsR0FBTjtBQUN6QixHQXJEK0I7O0FBc0RoQzs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStFQTBGLE1BQUksR0FBRztBQUNMLFVBQU07QUFBRStSO0FBQUYsUUFBZ0IsS0FBSzlOLFVBQTNCOztBQUNBLFVBQU0wTyxLQUFLLEdBQUcsTUFBTSxLQUFLekssUUFBTCxDQUFjO0FBQ2hDZ0YsWUFBTSxFQUFFLE9BRHdCO0FBRWhDclQsU0FBRyxFQUFFa1k7QUFGMkIsS0FBZCxDQUFwQjs7QUFJQSxVQUFNYSxPQUFPLEdBQUcsTUFBTSxLQUFLMUssUUFBTCxDQUFjO0FBQ2xDZ0YsWUFBTSxFQUFFLFVBRDBCO0FBRWxDclQsU0FBRyxFQUFFa1ksU0FGNkI7QUFHbEM5VSxhQUFPLEVBQUU7QUFDUDRWLGFBQUssRUFBRTtBQURBO0FBSHlCLEtBQWQsRUFPckJ6TCxJQVBxQixDQU9mc0osR0FBRCxJQUFTO0FBQ2IsWUFBTUcsR0FBRyxHQUFHVCxLQUFLLENBQUNLLE9BQU4sQ0FBY0MsR0FBZCxDQUFaO0FBQ0EsWUFBTW9DLEtBQUssR0FBR2pDLEdBQUcsQ0FBQ1ksUUFBSixHQUFlLENBQWYsRUFDYi9OLEdBRGEsQ0FDUjJNLElBQUQsSUFBVTtBQUNiLGNBQU0wQyxJQUFJLEdBQUcxQyxJQUFJLENBQUN3QixJQUFMLENBQVUsY0FBVixFQUEwQkEsSUFBMUIsQ0FBK0IsVUFBL0IsQ0FBYjtBQUNBLGNBQU1uSyxJQUFJLEdBQUdxTCxJQUFJLENBQUNsQixJQUFMLENBQVUsa0JBQVYsRUFBOEJBLElBQTlCLENBQW1DLGdCQUFuQyxJQUF1RCxXQUF2RCxHQUFxRSxNQUFsRjs7QUFDQSxZQUFJbkssSUFBSSxLQUFLLE1BQWIsRUFBcUI7QUFDbkIsY0FBSTlELFdBQUo7QUFDQSxnQkFBTW9QLGVBQWUsR0FBR0QsSUFBSSxDQUFDbEIsSUFBTCxDQUFVLGlCQUFWLENBQXhCOztBQUVBLGNBQUltQixlQUFlLEtBQUtDLFNBQXhCLEVBQW1DO0FBQ2pDclAsdUJBQVcsR0FBR29QLGVBQWUsQ0FBQzFCLElBQWhCLEVBQWQ7QUFDRCxXQUZELE1BRU87QUFDTCxrQkFBTTRCLElBQUksR0FBRzdDLElBQUksQ0FBQ3dCLElBQUwsQ0FBVSxVQUFWLEVBQXNCUCxJQUF0QixFQUFiO0FBQ0ExTix1QkFBVyxHQUFHakMsa0JBQWtCLENBQUN1UixJQUFJLENBQUNDLFNBQUwsQ0FBZUQsSUFBSSxDQUFDRSxXQUFMLENBQWlCLEdBQWpCLElBQXdCLENBQXZDLENBQUQsQ0FBaEM7QUFDRDs7QUFFRCxjQUFJalMsMERBQVksQ0FBQ3lDLFdBQUQsQ0FBaEIsRUFBK0I7QUFDN0Isa0JBQU1xSyxJQUFJLEdBQUc4RSxJQUFJLENBQUNsQixJQUFMLENBQVUsc0JBQVYsQ0FBYjtBQUNBLG1CQUFPckUsU0FBUyxDQUFDO0FBQ2Z2TSxrQkFBSSxFQUFFMkMsV0FEUztBQUVmcUssa0JBQUksRUFBRUEsSUFBSSxHQUFHLENBQUNBLElBQUksQ0FBQ3FELElBQUwsRUFBSixHQUFrQjtBQUZiLGFBQUQsQ0FBaEI7QUFJRDtBQUNGOztBQUNELGVBQU8sSUFBUDtBQUNELE9BeEJhLEVBeUJibkcsTUF6QmEsQ0F5Qk5DLE9BekJNLENBQWQ7QUEwQkEsYUFBTzBILEtBQVA7QUFDRCxLQXBDcUIsQ0FBdEI7O0FBcUNBLFdBQU9GLE9BQU8sR0FDYjNVLEtBRE0sQ0FDQzJELEdBQUQsSUFBUztBQUNkLFVBQUlBLEdBQUcsQ0FBQ3VMLE1BQUosS0FBZSxHQUFuQixFQUF3QjtBQUN0QixlQUFPd0YsS0FBSyxHQUFHdkwsSUFBUixDQUFhd0wsT0FBYixDQUFQO0FBQ0Q7O0FBQ0QsWUFBTWhSLEdBQU47QUFDRCxLQU5NLENBQVA7QUFPRCxHQXhMK0I7O0FBeUxoQzFCLEtBQUcsQ0FBQzRKLElBQUQsRUFBTztBQUNSLFVBQU03SSxJQUFJLEdBQUdELDZEQUFlLENBQUM4SSxJQUFELENBQTVCO0FBQ0EsVUFBTTtBQUFFaUk7QUFBRixRQUFnQixLQUFLOU4sVUFBM0I7QUFDQSxXQUFPLEtBQUtpRSxRQUFMLENBQWM7QUFDbkJyTyxTQUFHLEVBQUVrWSxTQUFTLEdBQUc5UTtBQURFLEtBQWQsQ0FBUDtBQUdELEdBL0wrQjs7QUFnTWhDeUosS0FBRyxDQUFDWixJQUFELEVBQU9yUSxJQUFQLEVBQWE7QUFDZCxVQUFNd0gsSUFBSSxHQUFHRCw2REFBZSxDQUFDOEksSUFBRCxDQUE1QjtBQUNBLFVBQU03TSxPQUFPLEdBQUc7QUFDZCxzQkFBZ0I7QUFERixLQUFoQjtBQUdBLFVBQU1vVyxJQUFJLEdBQUcsS0FBSzlRLE1BQUwsQ0FBWXJDLEdBQVosQ0FBZ0IsTUFBaEIsQ0FBYjtBQUNBLFFBQUltVCxJQUFKLEVBQVVwVyxPQUFPLENBQUNxVyxFQUFSLEdBQWMsS0FBSUQsSUFBSyxJQUF2QjtBQUNWLFVBQU07QUFBRXRCO0FBQUYsUUFBZ0IsS0FBSzlOLFVBQTNCO0FBQ0EsV0FBTyxLQUFLaUUsUUFBTCxDQUFjO0FBQ25CZ0YsWUFBTSxFQUFFLEtBRFc7QUFFbkJyVCxTQUFHLEVBQUVrWSxTQUFTLEdBQUc5USxJQUZFO0FBR25CbU0sVUFBSSxFQUFFM1QsSUFIYTtBQUluQndEO0FBSm1CLEtBQWQsQ0FBUDtBQU1ELEdBOU0rQjs7QUErTWhDbUQsUUFBTSxDQUFDMEosSUFBRCxFQUFPO0FBQ1gsVUFBTTdJLElBQUksR0FBR0QsNkRBQWUsQ0FBQzhJLElBQUQsQ0FBNUI7QUFDQSxVQUFNN00sT0FBTyxHQUFHLEVBQWhCO0FBQ0EsVUFBTW9XLElBQUksR0FBRyxLQUFLOVEsTUFBTCxDQUFZckMsR0FBWixDQUFnQixNQUFoQixDQUFiO0FBQ0EsUUFBSW1ULElBQUosRUFBVXBXLE9BQU8sQ0FBQ3FXLEVBQVIsR0FBYyxLQUFJRCxJQUFLLElBQXZCO0FBQ1YsVUFBTTtBQUFFdEI7QUFBRixRQUFnQixLQUFLOU4sVUFBM0I7QUFDQSxXQUFPLEtBQUtpRSxRQUFMLENBQWM7QUFDbkJnRixZQUFNLEVBQUUsUUFEVztBQUVuQnJULFNBQUcsRUFBRWtZLFNBQVMsR0FBRzlRLElBRkU7QUFHbkJoRTtBQUhtQixLQUFkLENBQVA7QUFLRDs7QUExTitCLENBQW5CLENBQWY7QUE0TkFvTyxzREFBUSxDQUFDOEcsTUFBRCxDQUFSOztBQUVBLFNBQVMzRSxTQUFULENBQW1CMUQsSUFBbkIsRUFBeUI7QUFDdkIsU0FBTztBQUNMN0ksUUFBSSxFQUFFNkksSUFBSSxDQUFDN0ksSUFETjtBQUVMZ04sUUFBSSxFQUFFbkUsSUFBSSxDQUFDbUUsSUFGTjtBQUdML00sT0FBRyxFQUFFRyxvREFBTSxDQUFDeUksSUFBSSxDQUFDN0ksSUFBTjtBQUhOLEdBQVA7QUFLRCxDOzs7Ozs7Ozs7Ozs7QUNuVUQ7QUFBQTtBQUFBO0FBRUE7QUFFQSxTQUFTc1MsYUFBVCxDQUF1QkMsTUFBdkIsRUFBK0I7QUFDN0IsUUFBTUMsV0FBVyxHQUFHRCxNQUFNLENBQUNFLFVBQTNCO0FBQ0EsUUFBTUMsWUFBWSxHQUFHRixXQUFXLElBQUssSUFBSUcsUUFBSixDQUFhSixNQUFiLENBQUQsQ0FBdUJLLFFBQXZCLENBQWdDSixXQUFXLEdBQUcsQ0FBOUMsQ0FBcEM7O0FBQ0EsTUFBSUUsWUFBSixFQUFrQjtBQUNoQixXQUFPSCxNQUFNLENBQUMvUixLQUFQLENBQWEsQ0FBYixFQUFnQmdTLFdBQVcsR0FBR0UsWUFBOUIsQ0FBUDtBQUNEOztBQUNELFNBQU9ILE1BQVA7QUFDRDs7QUFFTSxNQUFNTSxZQUFZLEdBQUcsWUFBWTtBQUN0QyxTQUFPO0FBQ0xyTyxlQUFXLEdBQUc7QUFDWixXQUFLc08sSUFBTCxHQUFZLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCLElBQTFCLEVBQWdDLElBQWhDLEVBQXNDLElBQXRDLEVBQTRDLElBQTVDLEVBQWtELElBQWxELEVBQXdELElBQXhELENBQVo7QUFDQSxXQUFLQyxNQUFMLEdBQWMsQ0FBQyxJQUFJQyxXQUFKLENBQWdCLEdBQWhCLENBQUQsRUFBdUIsSUFBSUEsV0FBSixDQUFnQixHQUFoQixDQUF2QixFQUE2QyxJQUFJQSxXQUFKLENBQWdCLEdBQWhCLENBQTdDLEVBQW1FLElBQUlBLFdBQUosQ0FBZ0IsR0FBaEIsQ0FBbkUsQ0FBZDtBQUNBLFdBQUtDLFNBQUwsR0FBaUIsQ0FBQyxJQUFJRCxXQUFKLENBQWdCLEdBQWhCLENBQUQsRUFBdUIsSUFBSUEsV0FBSixDQUFnQixHQUFoQixDQUF2QixFQUE2QyxJQUFJQSxXQUFKLENBQWdCLEdBQWhCLENBQTdDLEVBQW1FLElBQUlBLFdBQUosQ0FBZ0IsR0FBaEIsQ0FBbkUsQ0FBakI7QUFDQSxXQUFLRSxJQUFMLEdBQVksSUFBSUYsV0FBSixDQUFnQixHQUFoQixDQUFaO0FBQ0EsV0FBS0csT0FBTCxHQUFlLElBQUlILFdBQUosQ0FBZ0IsR0FBaEIsQ0FBZixDQUxZLENBT1o7O0FBQ0EsV0FBS25TLEdBQUwsR0FBVyxJQUFJbVMsV0FBSixDQUFnQixDQUFoQixDQUFYO0FBRUEsV0FBS0ksU0FBTDtBQUNELEtBWkk7O0FBY0w7QUFDQUMsNEJBQXdCLENBQUNDLFdBQUQsRUFBYztBQUNwQyxVQUFJQyxJQUFJLEdBQUcsSUFBSVosUUFBSixDQUFhVyxXQUFiLENBQVg7QUFDQSxVQUFJRSxRQUFRLEdBQUcsSUFBSVIsV0FBSixDQUFnQixDQUFoQixDQUFmOztBQUNBLFdBQUssSUFBSTNTLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsQ0FBcEIsRUFBdUJBLENBQUMsRUFBeEIsRUFBNEI7QUFDMUJtVCxnQkFBUSxDQUFDblQsQ0FBRCxDQUFSLEdBQWNrVCxJQUFJLENBQUNFLFNBQUwsQ0FBZXBULENBQUMsR0FBRyxDQUFuQixDQUFkO0FBQ0Q7O0FBRUQsYUFBT21ULFFBQVA7QUFDRCxLQXZCSTs7QUF5QkxKLGFBQVMsR0FBRztBQUNWLFVBQUlGLElBQUksR0FBRyxLQUFLQSxJQUFoQjtBQUNBLFVBQUlDLE9BQU8sR0FBRyxLQUFLQSxPQUFuQjtBQUNBLFVBQUlKLE1BQU0sR0FBRyxLQUFLQSxNQUFsQjtBQUNBLFVBQUlXLE9BQU8sR0FBR1gsTUFBTSxDQUFDLENBQUQsQ0FBcEI7QUFDQSxVQUFJWSxPQUFPLEdBQUdaLE1BQU0sQ0FBQyxDQUFELENBQXBCO0FBQ0EsVUFBSWEsT0FBTyxHQUFHYixNQUFNLENBQUMsQ0FBRCxDQUFwQjtBQUNBLFVBQUljLE9BQU8sR0FBR2QsTUFBTSxDQUFDLENBQUQsQ0FBcEI7QUFDQSxVQUFJRSxTQUFTLEdBQUcsS0FBS0EsU0FBckI7QUFDQSxVQUFJYSxVQUFVLEdBQUdiLFNBQVMsQ0FBQyxDQUFELENBQTFCO0FBQ0EsVUFBSWMsVUFBVSxHQUFHZCxTQUFTLENBQUMsQ0FBRCxDQUExQjtBQUNBLFVBQUllLFVBQVUsR0FBR2YsU0FBUyxDQUFDLENBQUQsQ0FBMUI7QUFDQSxVQUFJZ0IsVUFBVSxHQUFHaEIsU0FBUyxDQUFDLENBQUQsQ0FBMUI7QUFFQSxVQUFJaUIsQ0FBQyxHQUFHLElBQUlsQixXQUFKLENBQWdCLEdBQWhCLENBQVI7QUFDQSxVQUFJbUIsQ0FBQyxHQUFHLENBQVI7QUFDQSxVQUFJQyxFQUFFLEdBQUcsQ0FBVDtBQUNBLFVBQUkvVCxDQUFDLEdBQUcsQ0FBUjs7QUFDQSxXQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUcsR0FBaEIsRUFBcUJBLENBQUMsRUFBdEIsRUFBMEI7QUFDeEIsWUFBSUEsQ0FBQyxHQUFHLEdBQVIsRUFBYTtBQUNYNlQsV0FBQyxDQUFDN1QsQ0FBRCxDQUFELEdBQU9BLENBQUMsSUFBSSxDQUFaO0FBQ0QsU0FGRCxNQUVPO0FBQ0w2VCxXQUFDLENBQUM3VCxDQUFELENBQUQsR0FBUUEsQ0FBQyxJQUFJLENBQU4sR0FBVyxLQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHLEdBQWhCLEVBQXFCQSxDQUFDLEVBQXRCLEVBQTBCO0FBQ3hCLFlBQUlnVSxFQUFFLEdBQUdELEVBQUUsR0FBSUEsRUFBRSxJQUFJLENBQVosR0FBa0JBLEVBQUUsSUFBSSxDQUF4QixHQUE4QkEsRUFBRSxJQUFJLENBQXBDLEdBQTBDQSxFQUFFLElBQUksQ0FBekQ7QUFDQUMsVUFBRSxHQUFJQSxFQUFFLEtBQUssQ0FBUixHQUFjQSxFQUFFLEdBQUcsSUFBbkIsR0FBMkIsSUFBaEM7QUFDQW5CLFlBQUksQ0FBQ2lCLENBQUQsQ0FBSixHQUFVRSxFQUFWO0FBQ0FsQixlQUFPLENBQUNrQixFQUFELENBQVAsR0FBY0YsQ0FBZCxDQUp3QixDQU14Qjs7QUFDQSxZQUFJRyxFQUFFLEdBQUdKLENBQUMsQ0FBQ0MsQ0FBRCxDQUFWO0FBQ0EsWUFBSUksRUFBRSxHQUFHTCxDQUFDLENBQUNJLEVBQUQsQ0FBVjtBQUNBLFlBQUlFLEVBQUUsR0FBR04sQ0FBQyxDQUFDSyxFQUFELENBQVYsQ0FUd0IsQ0FXeEI7O0FBQ0EsWUFBSUUsQ0FBQyxHQUFJUCxDQUFDLENBQUNHLEVBQUQsQ0FBRCxHQUFRLEtBQVQsR0FBbUJBLEVBQUUsR0FBRyxTQUFoQztBQUNBWCxlQUFPLENBQUNTLENBQUQsQ0FBUCxHQUFjTSxDQUFDLElBQUksRUFBTixHQUFhQSxDQUFDLEtBQUssQ0FBaEM7QUFDQWQsZUFBTyxDQUFDUSxDQUFELENBQVAsR0FBY00sQ0FBQyxJQUFJLEVBQU4sR0FBYUEsQ0FBQyxLQUFLLEVBQWhDO0FBQ0FiLGVBQU8sQ0FBQ08sQ0FBRCxDQUFQLEdBQWNNLENBQUMsSUFBSSxDQUFOLEdBQVlBLENBQUMsS0FBSyxFQUEvQjtBQUNBWixlQUFPLENBQUNNLENBQUQsQ0FBUCxHQUFhTSxDQUFiLENBaEJ3QixDQWtCeEI7O0FBQ0FBLFNBQUMsR0FBSUQsRUFBRSxHQUFHLFNBQU4sR0FBb0JELEVBQUUsR0FBRyxPQUF6QixHQUFxQ0QsRUFBRSxHQUFHLEtBQTFDLEdBQW9ESCxDQUFDLEdBQUcsU0FBNUQ7QUFDQUwsa0JBQVUsQ0FBQ08sRUFBRCxDQUFWLEdBQWtCSSxDQUFDLElBQUksRUFBTixHQUFhQSxDQUFDLEtBQUssQ0FBcEM7QUFDQVYsa0JBQVUsQ0FBQ00sRUFBRCxDQUFWLEdBQWtCSSxDQUFDLElBQUksRUFBTixHQUFhQSxDQUFDLEtBQUssRUFBcEM7QUFDQVQsa0JBQVUsQ0FBQ0ssRUFBRCxDQUFWLEdBQWtCSSxDQUFDLElBQUksQ0FBTixHQUFZQSxDQUFDLEtBQUssRUFBbkM7QUFDQVIsa0JBQVUsQ0FBQ0ksRUFBRCxDQUFWLEdBQWlCSSxDQUFqQixDQXZCd0IsQ0F5QnhCOztBQUNBLFlBQUksQ0FBQ04sQ0FBTCxFQUFRO0FBQ05BLFdBQUMsR0FBR0MsRUFBRSxHQUFHLENBQVQ7QUFDRCxTQUZELE1BRU87QUFDTEQsV0FBQyxHQUFHRyxFQUFFLEdBQUdKLENBQUMsQ0FBQ0EsQ0FBQyxDQUFDQSxDQUFDLENBQUNNLEVBQUUsR0FBR0YsRUFBTixDQUFGLENBQUYsQ0FBVjtBQUNBRixZQUFFLElBQUlGLENBQUMsQ0FBQ0EsQ0FBQyxDQUFDRSxFQUFELENBQUYsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixLQXBGSTs7QUFzRkxNLGFBQVMsQ0FBQ0MsU0FBRCxFQUFZO0FBQ25CO0FBQ0EsVUFBSTlULEdBQUcsR0FBRyxLQUFLd1Msd0JBQUwsQ0FBOEJzQixTQUE5QixDQUFWO0FBQ0EsVUFBSUMsT0FBTyxHQUFHLElBQWQ7QUFDQSxVQUFJQyxNQUFNLEdBQUcsQ0FBYjs7QUFFQSxhQUFPQSxNQUFNLEdBQUdoVSxHQUFHLENBQUNqSCxNQUFiLElBQXVCZ2IsT0FBOUIsRUFBdUM7QUFDckNBLGVBQU8sR0FBSS9ULEdBQUcsQ0FBQ2dVLE1BQUQsQ0FBSCxLQUFnQixLQUFLaFUsR0FBTCxDQUFTZ1UsTUFBVCxDQUEzQjtBQUNBQSxjQUFNO0FBQ1A7O0FBRUQsVUFBSUQsT0FBSixFQUFhO0FBQ1g7QUFDRDs7QUFFRCxXQUFLL1QsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsVUFBSWlVLE9BQU8sR0FBRyxLQUFLQSxPQUFMLEdBQWVqVSxHQUFHLENBQUNqSCxNQUFqQzs7QUFFQSxVQUFJa2IsT0FBTyxLQUFLLENBQVosSUFBaUJBLE9BQU8sS0FBSyxDQUE3QixJQUFrQ0EsT0FBTyxLQUFLLENBQWxELEVBQXFEO0FBQ25ELGNBQU0sSUFBSTFYLEtBQUosQ0FBVSwwQkFBMEIwWCxPQUFwQyxDQUFOO0FBQ0Q7O0FBRUQsVUFBSUMsTUFBTSxHQUFHLEtBQUtBLE1BQUwsR0FBYyxDQUFDRCxPQUFPLEdBQUcsQ0FBVixHQUFjLENBQWYsSUFBb0IsQ0FBL0M7QUFDQSxVQUFJRSxLQUFKO0FBQ0EsVUFBSUMsUUFBSjtBQUVBLFVBQUlDLFdBQVcsR0FBRyxLQUFLQSxXQUFMLEdBQW1CLElBQUlsQyxXQUFKLENBQWdCK0IsTUFBaEIsQ0FBckM7QUFDQSxVQUFJSSxjQUFjLEdBQUcsS0FBS0EsY0FBTCxHQUFzQixJQUFJbkMsV0FBSixDQUFnQitCLE1BQWhCLENBQTNDO0FBQ0EsVUFBSUssSUFBSSxHQUFHLEtBQUtsQyxJQUFoQjtBQUNBLFVBQUlKLElBQUksR0FBRyxLQUFLQSxJQUFoQjtBQUVBLFVBQUlHLFNBQVMsR0FBRyxLQUFLQSxTQUFyQjtBQUNBLFVBQUlhLFVBQVUsR0FBR2IsU0FBUyxDQUFDLENBQUQsQ0FBMUI7QUFDQSxVQUFJYyxVQUFVLEdBQUdkLFNBQVMsQ0FBQyxDQUFELENBQTFCO0FBQ0EsVUFBSWUsVUFBVSxHQUFHZixTQUFTLENBQUMsQ0FBRCxDQUExQjtBQUNBLFVBQUlnQixVQUFVLEdBQUdoQixTQUFTLENBQUMsQ0FBRCxDQUExQjtBQUVBLFVBQUlvQyxJQUFKO0FBQ0EsVUFBSVosQ0FBSjs7QUFFQSxXQUFLTyxLQUFLLEdBQUcsQ0FBYixFQUFnQkEsS0FBSyxHQUFHRCxNQUF4QixFQUFnQ0MsS0FBSyxFQUFyQyxFQUF5QztBQUN2QyxZQUFJQSxLQUFLLEdBQUdGLE9BQVosRUFBcUI7QUFDbkJPLGNBQUksR0FBR0gsV0FBVyxDQUFDRixLQUFELENBQVgsR0FBcUJuVSxHQUFHLENBQUNtVSxLQUFELENBQS9CO0FBQ0E7QUFDRDs7QUFDRFAsU0FBQyxHQUFHWSxJQUFKOztBQUVBLFlBQUlMLEtBQUssR0FBR0YsT0FBUixLQUFvQixDQUF4QixFQUEyQjtBQUN6QjtBQUNBTCxXQUFDLEdBQUlBLENBQUMsSUFBSSxDQUFOLEdBQVlBLENBQUMsS0FBSyxFQUF0QixDQUZ5QixDQUl6Qjs7QUFDQUEsV0FBQyxHQUFJVyxJQUFJLENBQUNYLENBQUMsS0FBSyxFQUFQLENBQUosSUFBa0IsRUFBbkIsR0FBMEJXLElBQUksQ0FBRVgsQ0FBQyxLQUFLLEVBQVAsR0FBYSxJQUFkLENBQUosSUFBMkIsRUFBckQsR0FBNERXLElBQUksQ0FBRVgsQ0FBQyxLQUFLLENBQVAsR0FBWSxJQUFiLENBQUosSUFBMEIsQ0FBdEYsR0FBMkZXLElBQUksQ0FBQ1gsQ0FBQyxHQUFHLElBQUwsQ0FBbkcsQ0FMeUIsQ0FPekI7O0FBQ0FBLFdBQUMsSUFBSTNCLElBQUksQ0FBRWtDLEtBQUssR0FBR0YsT0FBVCxHQUFvQixDQUFyQixDQUFKLElBQStCLEVBQXBDO0FBQ0QsU0FURCxNQVNPLElBQUlBLE9BQU8sR0FBRyxDQUFWLElBQWVFLEtBQUssR0FBR0YsT0FBUixLQUFvQixDQUF2QyxFQUEwQztBQUMvQztBQUNBTCxXQUFDLEdBQUlXLElBQUksQ0FBQ1gsQ0FBQyxLQUFLLEVBQVAsQ0FBSixJQUFrQixFQUFuQixHQUEwQlcsSUFBSSxDQUFFWCxDQUFDLEtBQUssRUFBUCxHQUFhLElBQWQsQ0FBSixJQUEyQixFQUFyRCxHQUE0RFcsSUFBSSxDQUFFWCxDQUFDLEtBQUssQ0FBUCxHQUFZLElBQWIsQ0FBSixJQUEwQixDQUF0RixHQUEyRlcsSUFBSSxDQUFDWCxDQUFDLEdBQUcsSUFBTCxDQUFuRztBQUNEOztBQUVEUyxtQkFBVyxDQUFDRixLQUFELENBQVgsR0FBcUJLLElBQUksR0FBRyxDQUFDSCxXQUFXLENBQUNGLEtBQUssR0FBR0YsT0FBVCxDQUFYLEdBQStCTCxDQUFoQyxNQUF1QyxDQUFuRTtBQUNEOztBQUVELFdBQUtRLFFBQVEsR0FBRyxDQUFoQixFQUFtQkEsUUFBUSxHQUFHRixNQUE5QixFQUFzQ0UsUUFBUSxFQUE5QyxFQUFrRDtBQUNoREQsYUFBSyxHQUFHRCxNQUFNLEdBQUdFLFFBQWpCOztBQUNBLFlBQUlBLFFBQVEsR0FBRyxDQUFmLEVBQWtCO0FBQ2hCUixXQUFDLEdBQUdTLFdBQVcsQ0FBQ0YsS0FBRCxDQUFmO0FBQ0QsU0FGRCxNQUVPO0FBQ0xQLFdBQUMsR0FBR1MsV0FBVyxDQUFDRixLQUFLLEdBQUcsQ0FBVCxDQUFmO0FBQ0Q7O0FBRUQsWUFBSUMsUUFBUSxHQUFHLENBQVgsSUFBZ0JELEtBQUssSUFBSSxDQUE3QixFQUFnQztBQUM5Qkcsd0JBQWMsQ0FBQ0YsUUFBRCxDQUFkLEdBQTJCUixDQUEzQjtBQUNELFNBRkQsTUFFTztBQUNMVSx3QkFBYyxDQUFDRixRQUFELENBQWQsR0FBMkJuQixVQUFVLENBQUNzQixJQUFJLENBQUNYLENBQUMsS0FBSyxFQUFQLENBQUwsQ0FBVixHQUE2QlYsVUFBVSxDQUFDcUIsSUFBSSxDQUFFWCxDQUFDLEtBQUssRUFBUCxHQUFhLElBQWQsQ0FBTCxDQUF2QyxHQUFtRVQsVUFBVSxDQUFDb0IsSUFBSSxDQUFFWCxDQUFDLEtBQUssQ0FBUCxHQUFZLElBQWIsQ0FBTCxDQUE3RSxHQUF3R1IsVUFBVSxDQUFDbUIsSUFBSSxDQUFDWCxDQUFDLEdBQUcsSUFBTCxDQUFMLENBQTdJO0FBQ0Q7O0FBRURVLHNCQUFjLENBQUNGLFFBQUQsQ0FBZCxHQUEyQkUsY0FBYyxDQUFDRixRQUFELENBQWQsS0FBNkIsQ0FBeEQ7QUFDRDtBQUNGLEtBdEtJOztBQXdLTDtBQUNBSywwQkFBc0IsQ0FBQ0MsSUFBRCxFQUFPO0FBQzNCLGFBQVFBLElBQUksSUFBSSxFQUFULEdBQWdCLENBQUNBLElBQUksR0FBRyxNQUFSLEtBQW1CLENBQW5DLEdBQXlDLENBQUNBLElBQUksR0FBRyxRQUFSLEtBQXFCLENBQTlELEdBQW9FQSxJQUFJLEtBQUssRUFBcEY7QUFDRCxLQTNLSTs7QUE2S0xDLFdBQU8sQ0FBQ0MsZ0JBQUQsRUFBbUJaLE1BQW5CLEVBQTJCYSxLQUEzQixFQUFrQ0Msa0JBQWxDLEVBQXNEO0FBQzNELFVBQUlDLE9BQU8sR0FBRyxLQUFLZCxPQUFMLEdBQWUsQ0FBN0I7QUFDQSxVQUFJSyxjQUFjLEdBQUcsS0FBS0EsY0FBMUI7QUFDQSxVQUFJVSxPQUFPLEdBQUcsS0FBSzFDLE9BQW5CO0FBRUEsVUFBSUYsU0FBUyxHQUFHLEtBQUtBLFNBQXJCO0FBQ0EsVUFBSWEsVUFBVSxHQUFHYixTQUFTLENBQUMsQ0FBRCxDQUExQjtBQUNBLFVBQUljLFVBQVUsR0FBR2QsU0FBUyxDQUFDLENBQUQsQ0FBMUI7QUFDQSxVQUFJZSxVQUFVLEdBQUdmLFNBQVMsQ0FBQyxDQUFELENBQTFCO0FBQ0EsVUFBSWdCLFVBQVUsR0FBR2hCLFNBQVMsQ0FBQyxDQUFELENBQTFCO0FBRUEsVUFBSTZDLFVBQVUsR0FBRyxLQUFLekMsd0JBQUwsQ0FBOEJxQyxLQUE5QixDQUFqQjtBQUNBLFVBQUlLLFdBQVcsR0FBR0QsVUFBVSxDQUFDLENBQUQsQ0FBNUI7QUFDQSxVQUFJRSxXQUFXLEdBQUdGLFVBQVUsQ0FBQyxDQUFELENBQTVCO0FBQ0EsVUFBSUcsV0FBVyxHQUFHSCxVQUFVLENBQUMsQ0FBRCxDQUE1QjtBQUNBLFVBQUlJLFdBQVcsR0FBR0osVUFBVSxDQUFDLENBQUQsQ0FBNUI7QUFFQSxVQUFJSyxVQUFVLEdBQUcsSUFBSUMsVUFBSixDQUFlWCxnQkFBZixDQUFqQjtBQUNBLFVBQUlZLFdBQVcsR0FBRyxJQUFJRCxVQUFKLENBQWVELFVBQVUsQ0FBQ3ZjLE1BQTFCLENBQWxCO0FBRUEsVUFBSTBjLEVBQUosRUFBUUMsRUFBUixFQUFZQyxFQUFaLEVBQWdCQyxFQUFoQjtBQUNBLFVBQUlDLEVBQUosRUFBUUMsRUFBUixFQUFZQyxFQUFaLEVBQWdCQyxFQUFoQjtBQUNBLFVBQUlDLFdBQUosRUFBaUJDLFdBQWpCLEVBQThCQyxXQUE5QixFQUEyQ0MsV0FBM0M7QUFFQSxVQUFJakMsS0FBSixFQUFXM1UsQ0FBWDtBQUNBLFVBQUk2VyxRQUFRLEdBQUcsS0FBSzVCLHNCQUFwQjs7QUFFQSxhQUFPVCxNQUFNLEdBQUdzQixVQUFVLENBQUN2YyxNQUEzQixFQUFtQztBQUNqQ2tkLG1CQUFXLEdBQUdJLFFBQVEsQ0FBQ2YsVUFBVSxDQUFDdEIsTUFBRCxDQUFYLENBQXRCO0FBQ0FrQyxtQkFBVyxHQUFHRyxRQUFRLENBQUNmLFVBQVUsQ0FBQ3RCLE1BQU0sR0FBRyxDQUFWLENBQVgsQ0FBdEI7QUFDQW1DLG1CQUFXLEdBQUdFLFFBQVEsQ0FBQ2YsVUFBVSxDQUFDdEIsTUFBTSxHQUFHLENBQVYsQ0FBWCxDQUF0QjtBQUNBb0MsbUJBQVcsR0FBR0MsUUFBUSxDQUFDZixVQUFVLENBQUN0QixNQUFNLEdBQUcsQ0FBVixDQUFYLENBQXRCO0FBRUE2QixVQUFFLEdBQUdJLFdBQVcsR0FBRzNCLGNBQWMsQ0FBQyxDQUFELENBQWpDO0FBQ0F3QixVQUFFLEdBQUdNLFdBQVcsR0FBRzlCLGNBQWMsQ0FBQyxDQUFELENBQWpDO0FBQ0F5QixVQUFFLEdBQUdJLFdBQVcsR0FBRzdCLGNBQWMsQ0FBQyxDQUFELENBQWpDO0FBQ0EwQixVQUFFLEdBQUdFLFdBQVcsR0FBRzVCLGNBQWMsQ0FBQyxDQUFELENBQWpDO0FBRUFILGFBQUssR0FBRyxDQUFSLENBWGlDLENBYWpDOztBQUNBLGFBQUszVSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUd1VixPQUFoQixFQUF5QnZWLENBQUMsRUFBMUIsRUFBOEI7QUFDNUJpVyxZQUFFLEdBQUd4QyxVQUFVLENBQUM0QyxFQUFFLEtBQUssRUFBUixDQUFWLEdBQXdCM0MsVUFBVSxDQUFFNEMsRUFBRSxJQUFJLEVBQVAsR0FBYSxJQUFkLENBQWxDLEdBQXdEM0MsVUFBVSxDQUFFNEMsRUFBRSxJQUFJLENBQVAsR0FBWSxJQUFiLENBQWxFLEdBQXVGM0MsVUFBVSxDQUFDNEMsRUFBRSxHQUFHLElBQU4sQ0FBakcsR0FBK0cxQixjQUFjLENBQUNILEtBQUQsQ0FBbEk7QUFDQXVCLFlBQUUsR0FBR3pDLFVBQVUsQ0FBQzZDLEVBQUUsS0FBSyxFQUFSLENBQVYsR0FBd0I1QyxVQUFVLENBQUU2QyxFQUFFLElBQUksRUFBUCxHQUFhLElBQWQsQ0FBbEMsR0FBd0Q1QyxVQUFVLENBQUU2QyxFQUFFLElBQUksQ0FBUCxHQUFZLElBQWIsQ0FBbEUsR0FBdUY1QyxVQUFVLENBQUN5QyxFQUFFLEdBQUcsSUFBTixDQUFqRyxHQUErR3ZCLGNBQWMsQ0FBQ0gsS0FBSyxHQUFHLENBQVQsQ0FBbEk7QUFDQXdCLFlBQUUsR0FBRzFDLFVBQVUsQ0FBQzhDLEVBQUUsS0FBSyxFQUFSLENBQVYsR0FBd0I3QyxVQUFVLENBQUU4QyxFQUFFLElBQUksRUFBUCxHQUFhLElBQWQsQ0FBbEMsR0FBd0Q3QyxVQUFVLENBQUUwQyxFQUFFLElBQUksQ0FBUCxHQUFZLElBQWIsQ0FBbEUsR0FBdUZ6QyxVQUFVLENBQUMwQyxFQUFFLEdBQUcsSUFBTixDQUFqRyxHQUErR3hCLGNBQWMsQ0FBQ0gsS0FBSyxHQUFHLENBQVQsQ0FBbEk7QUFDQXlCLFlBQUUsR0FBRzNDLFVBQVUsQ0FBQytDLEVBQUUsS0FBSyxFQUFSLENBQVYsR0FBd0I5QyxVQUFVLENBQUUyQyxFQUFFLElBQUksRUFBUCxHQUFhLElBQWQsQ0FBbEMsR0FBd0QxQyxVQUFVLENBQUUyQyxFQUFFLElBQUksQ0FBUCxHQUFZLElBQWIsQ0FBbEUsR0FBdUYxQyxVQUFVLENBQUMyQyxFQUFFLEdBQUcsSUFBTixDQUFqRyxHQUErR3pCLGNBQWMsQ0FBQ0gsS0FBSyxHQUFHLENBQVQsQ0FBbEksQ0FKNEIsQ0FLNUI7O0FBQ0EwQixZQUFFLEdBQUdKLEVBQUw7QUFDQUssWUFBRSxHQUFHSixFQUFMO0FBQ0FLLFlBQUUsR0FBR0osRUFBTDtBQUNBSyxZQUFFLEdBQUdKLEVBQUw7QUFFQXpCLGVBQUssR0FBR0EsS0FBSyxHQUFHLENBQWhCO0FBQ0QsU0ExQmdDLENBNEJqQzs7O0FBQ0FzQixVQUFFLEdBQUtULE9BQU8sQ0FBQ2EsRUFBRSxLQUFLLEVBQVIsQ0FBUCxJQUFzQixFQUF2QixHQUE4QmIsT0FBTyxDQUFFYyxFQUFFLElBQUksRUFBUCxHQUFhLElBQWQsQ0FBUCxJQUE4QixFQUE1RCxHQUFtRWQsT0FBTyxDQUFFZSxFQUFFLElBQUksQ0FBUCxHQUFZLElBQWIsQ0FBUCxJQUE2QixDQUFoRyxHQUFxR2YsT0FBTyxDQUFDZ0IsRUFBRSxHQUFHLElBQU4sQ0FBN0csR0FBNEgxQixjQUFjLENBQUNILEtBQUQsQ0FBL0k7QUFDQXVCLFVBQUUsR0FBS1YsT0FBTyxDQUFDYyxFQUFFLEtBQUssRUFBUixDQUFQLElBQXNCLEVBQXZCLEdBQThCZCxPQUFPLENBQUVlLEVBQUUsSUFBSSxFQUFQLEdBQWEsSUFBZCxDQUFQLElBQThCLEVBQTVELEdBQW1FZixPQUFPLENBQUVnQixFQUFFLElBQUksQ0FBUCxHQUFZLElBQWIsQ0FBUCxJQUE2QixDQUFoRyxHQUFxR2hCLE9BQU8sQ0FBQ2EsRUFBRSxHQUFHLElBQU4sQ0FBN0csR0FBNEh2QixjQUFjLENBQUNILEtBQUssR0FBRyxDQUFULENBQS9JO0FBQ0F3QixVQUFFLEdBQUtYLE9BQU8sQ0FBQ2UsRUFBRSxLQUFLLEVBQVIsQ0FBUCxJQUFzQixFQUF2QixHQUE4QmYsT0FBTyxDQUFFZ0IsRUFBRSxJQUFJLEVBQVAsR0FBYSxJQUFkLENBQVAsSUFBOEIsRUFBNUQsR0FBbUVoQixPQUFPLENBQUVhLEVBQUUsSUFBSSxDQUFQLEdBQVksSUFBYixDQUFQLElBQTZCLENBQWhHLEdBQXFHYixPQUFPLENBQUNjLEVBQUUsR0FBRyxJQUFOLENBQTdHLEdBQTRIeEIsY0FBYyxDQUFDSCxLQUFLLEdBQUcsQ0FBVCxDQUEvSTtBQUNBeUIsVUFBRSxHQUFLWixPQUFPLENBQUNnQixFQUFFLEtBQUssRUFBUixDQUFQLElBQXNCLEVBQXZCLEdBQThCaEIsT0FBTyxDQUFFYSxFQUFFLElBQUksRUFBUCxHQUFhLElBQWQsQ0FBUCxJQUE4QixFQUE1RCxHQUFtRWIsT0FBTyxDQUFFYyxFQUFFLElBQUksQ0FBUCxHQUFZLElBQWIsQ0FBUCxJQUE2QixDQUFoRyxHQUFxR2QsT0FBTyxDQUFDZSxFQUFFLEdBQUcsSUFBTixDQUE3RyxHQUE0SHpCLGNBQWMsQ0FBQ0gsS0FBSyxHQUFHLENBQVQsQ0FBL0k7QUFDQUEsYUFBSyxHQUFHQSxLQUFLLEdBQUcsQ0FBaEIsQ0FqQ2lDLENBbUNqQzs7QUFDQXFCLG1CQUFXLENBQUN4QixNQUFELENBQVgsR0FBc0JxQyxRQUFRLENBQUNaLEVBQUUsR0FBR1AsV0FBTixDQUE5QjtBQUNBTSxtQkFBVyxDQUFDeEIsTUFBTSxHQUFHLENBQVYsQ0FBWCxHQUEwQnFDLFFBQVEsQ0FBQ1QsRUFBRSxHQUFHVCxXQUFOLENBQWxDO0FBQ0FLLG1CQUFXLENBQUN4QixNQUFNLEdBQUcsQ0FBVixDQUFYLEdBQTBCcUMsUUFBUSxDQUFDVixFQUFFLEdBQUdQLFdBQU4sQ0FBbEM7QUFDQUksbUJBQVcsQ0FBQ3hCLE1BQU0sR0FBRyxDQUFWLENBQVgsR0FBMEJxQyxRQUFRLENBQUNYLEVBQUUsR0FBR0wsV0FBTixDQUFsQyxDQXZDaUMsQ0F5Q2pDOztBQUNBSCxtQkFBVyxHQUFHZSxXQUFkO0FBQ0FkLG1CQUFXLEdBQUdlLFdBQWQ7QUFDQWQsbUJBQVcsR0FBR2UsV0FBZDtBQUNBZCxtQkFBVyxHQUFHZSxXQUFkO0FBRUFwQyxjQUFNLEdBQUdBLE1BQU0sR0FBRyxDQUFsQjtBQUNEOztBQUVELGFBQU9jLGtCQUFrQixHQUFHckQsYUFBYSxDQUFDK0QsV0FBVyxDQUFDOUQsTUFBYixDQUFoQixHQUF1QzhELFdBQVcsQ0FBQzlELE1BQTVFO0FBQ0QsS0EzUEk7O0FBNlBMNEUsV0FBTyxHQUFHO0FBQ1IsV0FBS3RXLEdBQUwsR0FBV21SLFNBQVg7QUFDQSxXQUFLOEMsT0FBTCxHQUFlOUMsU0FBZjtBQUNBLFdBQUsrQyxNQUFMLEdBQWMvQyxTQUFkO0FBRUEsV0FBS2tCLElBQUwsR0FBWWxCLFNBQVo7QUFDQSxXQUFLbUIsT0FBTCxHQUFlbkIsU0FBZjtBQUNBLFdBQUtlLE1BQUwsR0FBY2YsU0FBZDtBQUNBLFdBQUtpQixTQUFMLEdBQWlCakIsU0FBakI7QUFDQSxXQUFLa0QsV0FBTCxHQUFtQmxELFNBQW5CO0FBQ0EsV0FBS21ELGNBQUwsR0FBc0JuRCxTQUF0QjtBQUVBLFdBQUtjLElBQUwsR0FBWWQsU0FBWjtBQUNEOztBQTFRSSxHQUFQO0FBNFFELENBN1FNLEM7Ozs7Ozs7Ozs7OztBQ2JQO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQSxNQUFNalcsS0FBSyxHQUFHcWIscUdBQVMsQ0FBQztBQUN0Qjs7O0FBR0FDLFVBQVEsRUFBRSxLQUFLLEVBQUwsR0FBVTtBQUpFLENBQUQsQ0FBdkI7QUFPQWxmLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjQyxpREFBZCxFQUF3QjtBQUN0QmlmLFdBQVMsQ0FBQzllLElBQUQsRUFBTztBQUNkLFdBQU91RCxLQUFLLENBQUNrRCxHQUFOLENBQVV6RyxJQUFWLEtBQW1CLElBQTFCO0FBQ0QsR0FIcUI7O0FBSXRCK2UsVUFBUSxDQUFDL2UsSUFBRCxFQUFPO0FBQ2J1RCxTQUFLLENBQUN5YixHQUFOLENBQVVoZixJQUFJLENBQUNxSSxHQUFmLEVBQW9CckksSUFBSSxDQUFDNmUsUUFBekI7QUFDRCxHQU5xQjs7QUFPdEJJLFVBQVEsQ0FBQzVXLEdBQUQsRUFBTTtBQUNaLFdBQU85RSxLQUFLLENBQUMyYixHQUFOLENBQVU3VyxHQUFWLEtBQWtCLElBQXpCO0FBQ0Q7O0FBVHFCLENBQXhCO0FBWWU5RSxvRUFBZixFOzs7Ozs7Ozs7Ozs7QUN0QkE7QUFBQTtBQUFBO0FBRUEsTUFBTTRiLFFBQVEsR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLFVBQXZCLENBQWpCO0FBQ0EsSUFBSUMsYUFBSjtBQUVBM2YsTUFBTSxDQUFDQyxNQUFQLENBQWNDLGlEQUFkLEVBQXdCO0FBQ3RCMGYsY0FBWSxDQUFDdmYsSUFBRCxFQUFPO0FBQ2pCc2YsaUJBQWEsR0FBR3RmLElBQWhCO0FBQ0FtZixZQUFRLENBQUNLLEtBQVQ7QUFDQSxVQUFNQyxHQUFHLEdBQUdMLFFBQVEsQ0FBQ00sV0FBVCxDQUFxQixNQUFyQixFQUE2QixLQUE3QixFQUFvQyxJQUFwQyxDQUFaOztBQUNBLFFBQUksQ0FBQ0QsR0FBRCxJQUFRamEsS0FBWixFQUErQjtBQUM3QlgsYUFBTyxDQUFDK0UsSUFBUixDQUFhLGNBQWI7QUFDRDtBQUNGOztBQVJxQixDQUF4QjtBQVdBd1YsUUFBUSxDQUFDekwsSUFBVCxDQUFjZ00sV0FBZCxDQUEwQlIsUUFBMUI7QUFFQUMsUUFBUSxDQUFDUSxnQkFBVCxDQUEwQixNQUExQixFQUFrQ25iLENBQUMsSUFBSTtBQUNyQ0EsR0FBQyxDQUFDb2IsY0FBRjtBQUNBLFFBQU07QUFBRTVSLFFBQUY7QUFBUWpPO0FBQVIsTUFBaUJzZixhQUF2QjtBQUNBN2EsR0FBQyxDQUFDNmEsYUFBRixDQUFnQlEsT0FBaEIsQ0FBd0I3UixJQUFJLElBQUksWUFBaEMsRUFBOENqTyxJQUE5QztBQUNELENBSkQsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU0rZixLQUFLLEdBQUcsRUFBZDtBQUNBQywrRkFBTyxDQUFDbFUsSUFBUixDQUFhbVUsWUFBYixDQUEwQkMsK0NBQTFCOztBQUNBRiwrRkFBTyxDQUFDM1osTUFBUixDQUFlOFosTUFBZixHQUF5QjlQLElBQUQsSUFBVTtBQUNoQzBQLE9BQUssQ0FBQ0ssU0FBTixDQUFnQi9QLElBQUksQ0FBQ3ZGLEtBQUwsQ0FBV3BLLEVBQTNCLElBQWlDMlAsSUFBakM7QUFDRCxDQUZEOztBQUlBMVEsTUFBTSxDQUFDQyxNQUFQLENBQWNDLGlEQUFkLEVBQXdCO0FBQ3RCd2dCLGVBQWEsRUFBRWhQLFdBRE87QUFFdEJpUCxhQUFXLEVBQUV2YixXQUZTOztBQUd0QjtBQUNBd2IsV0FBUyxFQUFFQyxTQUpXOztBQUt0QjtBQUNBLFFBQU1DLFNBQU4sQ0FBZ0I7QUFBRUM7QUFBRixHQUFoQixFQUE0QjtBQUMxQixVQUFNblAsT0FBTyxHQUFHL0ssVUFBVSxFQUExQjtBQUNBLFVBQU16RyxHQUFHLEdBQUd3UixPQUFPLENBQUN0SCxHQUFSLENBQVkwVyxVQUFaLENBQVo7QUFDQSxVQUFNQyxPQUFPLEdBQUcsTUFBTVosK0ZBQU8sQ0FBQ3JjLElBQVIsQ0FBYWtkLFFBQWIsQ0FBc0I5Z0IsR0FBdEIsQ0FBdEI7QUFDQSxXQUFPO0FBQ0xzWixXQUFLLEVBQUU5SCxPQUFPLENBQUN0SCxHQUFSLENBQVk1RCxNQUFNLEtBQUs7QUFBRUEsY0FBRjtBQUFVMUMsWUFBSSxFQUFFaWQsT0FBTyxDQUFDdmEsTUFBTSxDQUFDeUUsS0FBUCxDQUFhcEssRUFBZDtBQUF2QixPQUFMLENBQWxCLENBREY7QUFFTGdnQixZQUFNLEVBQUVBLE1BQU0sR0FBRyxNQUFNViwrRkFBTyxDQUFDclgsS0FBUixDQUFja1ksUUFBZCxDQUF1QjlnQixHQUF2QixDQUFULEdBQXVDeVo7QUFGaEQsS0FBUDtBQUlELEdBZHFCOztBQWV0QjtBQUNBOVMsZUFBYSxDQUFDaEcsRUFBRCxFQUFLO0FBQ2hCLFdBQU9zZiwrRkFBTyxDQUFDcmMsSUFBUixDQUFhbWQsTUFBYixDQUFvQnBnQixFQUFwQixDQUFQO0FBQ0QsR0FsQnFCOztBQW1CdEJxZ0IsY0FBWSxDQUFDQyxJQUFELEVBQU87QUFDakIsVUFBTTNhLE1BQU0sR0FBR21hLFNBQVMsQ0FBQ1EsSUFBRCxDQUF4QjtBQUNBLFdBQU8zYSxNQUFNLElBQUksQ0FBQ0EsTUFBTSxDQUFDeUMsTUFBUCxDQUFjakMsT0FBekIsR0FDSFIsTUFBTSxDQUFDNGEsSUFBUCxDQUFZbFosT0FEVCxHQUVILElBRko7QUFHRCxHQXhCcUI7O0FBeUJ0QjtBQUNBbkIsYUFBVyxDQUFDO0FBQUVsRyxNQUFGO0FBQU1tRztBQUFOLEdBQUQsRUFBa0I7QUFDM0IsV0FBT3VLLGdCQUFnQixDQUFDMVEsRUFBRCxFQUFLO0FBQzFCb0ksWUFBTSxFQUFFO0FBQUVqQyxlQUFPLEVBQUVBLE9BQU8sR0FBRyxDQUFILEdBQU87QUFBekIsT0FEa0I7QUFFMUJpRSxXQUFLLEVBQUU7QUFBRTJGLG9CQUFZLEVBQUU1TixJQUFJLENBQUNDLEdBQUw7QUFBaEI7QUFGbUIsS0FBTCxDQUF2QjtBQUlELEdBL0JxQjs7QUFnQ3RCO0FBQ0FvZSxNQUFJLENBQUM7QUFBRXhnQixNQUFGO0FBQU0yYjtBQUFOLEdBQUQsRUFBaUI7QUFDbkIsVUFBTWhXLE1BQU0sR0FBRzhhLGFBQWEsQ0FBQ3pnQixFQUFELENBQTVCO0FBQ0EsVUFBTTBnQixLQUFLLEdBQUdyQixLQUFLLENBQUN4TyxPQUFOLENBQWN6SixPQUFkLENBQXNCekIsTUFBdEIsQ0FBZDtBQUNBMFosU0FBSyxDQUFDeE8sT0FBTixDQUFjOFAsTUFBZCxDQUFxQkQsS0FBckIsRUFBNEIsQ0FBNUI7QUFDQXJCLFNBQUssQ0FBQ3hPLE9BQU4sQ0FBYzhQLE1BQWQsQ0FBcUJELEtBQUssR0FBRy9FLE1BQTdCLEVBQXFDLENBQXJDLEVBQXdDaFcsTUFBeEM7QUFDQSxXQUFPaWIsaUJBQWlCLEVBQXhCO0FBQ0QsR0F2Q3FCOztBQXdDdEI7QUFDQSxRQUFNQyxZQUFOLENBQW1CN2dCLEVBQW5CLEVBQXVCO0FBQ3JCLFVBQU1tSCxDQUFDLEdBQUdrWSxLQUFLLENBQUN4TyxPQUFOLENBQWN6SixPQUFkLENBQXNCcVosYUFBYSxDQUFDemdCLEVBQUQsQ0FBbkMsQ0FBVjs7QUFDQSxRQUFJbUgsQ0FBQyxJQUFJLENBQVQsRUFBWTtBQUNWa1ksV0FBSyxDQUFDeE8sT0FBTixDQUFjOFAsTUFBZCxDQUFxQnhaLENBQXJCLEVBQXdCLENBQXhCO0FBQ0EsWUFBTW5ELE9BQU8sQ0FBQ3dLLEdBQVIsQ0FBWSxDQUNoQjhRLCtGQUFPLENBQUMzWixNQUFSLENBQWVNLE1BQWYsQ0FBc0JqRyxFQUF0QixDQURnQixFQUVoQnNmLCtGQUFPLENBQUNyYyxJQUFSLENBQWFnRCxNQUFiLENBQW9CakcsRUFBcEIsQ0FGZ0IsRUFHaEJzZiwrRkFBTyxDQUFDclgsS0FBUixDQUFjaEMsTUFBZCxDQUFxQmpHLEVBQXJCLENBSGdCLENBQVosQ0FBTjtBQUtEOztBQUNELFdBQU9oQiwrRkFBTyxDQUFDLGNBQUQsRUFBaUJnQixFQUFqQixDQUFkO0FBQ0QsR0FwRHFCOztBQXFEdEI4Z0IsV0FBUyxFQUFFQyxpREFyRFc7QUFzRHRCL2QsYUFBVyxFQUFFZ2UsV0F0RFM7O0FBdUR0QjtBQUNBQyxrQkFBZ0IsQ0FBQztBQUFFamhCLE1BQUY7QUFBTW9JLFVBQU47QUFBY2xGO0FBQWQsR0FBRCxFQUF5QjtBQUN2QyxXQUFPd04sZ0JBQWdCLENBQUMxUSxFQUFELEVBQUs7QUFDMUJvSSxZQUQwQjtBQUUxQmxGLFlBRjBCO0FBRzFCa0gsV0FBSyxFQUFFO0FBQUUyRixvQkFBWSxFQUFFNU4sSUFBSSxDQUFDQyxHQUFMO0FBQWhCO0FBSG1CLEtBQUwsQ0FBdkI7QUFLRCxHQTlEcUI7O0FBK0R0QjtBQUNBOGUsUUFBTSxFQUFFQztBQWhFYyxDQUF4QjtBQW1FQUMsbURBQWEsQ0FBQ2xSLElBQWQsQ0FBbUIsWUFBWTtBQUFBOztBQUM3QixRQUFNO0FBQUU3SSxXQUFPLEVBQUVnYTtBQUFYLE1BQTJCLE1BQU03ZCxPQUFPLENBQUM4YixPQUFSLENBQWdCblAsS0FBaEIsQ0FBc0JwSyxHQUF0QixDQUEwQixTQUExQixDQUF2QztBQUNBLFFBQU1zQixPQUFPLEdBQUd2QyxXQUFoQjtBQUNBLE1BQUksQ0FBQ3VjLFdBQUwsRUFBa0IsTUFBTUMsMERBQU8sRUFBYjtBQUNsQixNQUFJamEsT0FBTyxLQUFLZ2EsV0FBaEIsRUFBNkI3ZCxPQUFPLENBQUM4YixPQUFSLENBQWdCblAsS0FBaEIsQ0FBc0JuSSxHQUF0QixDQUEwQjtBQUFFWDtBQUFGLEdBQTFCO0FBQzdCLFFBQU0vSCxJQUFJLEdBQUcsTUFBTWtFLE9BQU8sQ0FBQzhiLE9BQVIsQ0FBZ0JuUCxLQUFoQixDQUFzQnBLLEdBQXRCLEVBQW5CO0FBQ0EsUUFBTThLLE9BQU8sR0FBRyxFQUFoQjtBQUNBLFFBQU0wUSxTQUFTLEdBQUc7QUFDaEJ2aEIsTUFBRSxFQUFFLENBRFk7QUFFaEI4UCxZQUFRLEVBQUU7QUFGTSxHQUFsQjtBQUlBLFFBQU0wUixLQUFLLEdBQUcsRUFBZDtBQUNBLFFBQU1DLE1BQU0sR0FBRyxFQUFmO0FBQ0EsUUFBTUMsSUFBSSxHQUFHLEVBQWI7QUFDQSxRQUFNQyxPQUFPLEdBQUcsRUFBaEI7QUFDQTs7QUFDQSxRQUFNQyxXQUFXLEdBQUcsU0FBU0MsQ0FBVCxDQUFXbmlCLEdBQVgsRUFBZ0I7QUFBRWlpQixXQUFPLENBQUN6UixJQUFSLENBQWEsS0FBS3hRLEdBQUwsS0FBYUEsR0FBMUI7QUFBaUMsR0FBdkU7O0FBQ0EsV0FBTThJLG1HQUFOLEVBQUFsSixJQUFJLEVBQWUsQ0FBQyxDQUFDcUksR0FBRCxFQUFNaEMsTUFBTixDQUFELEtBQW1CO0FBQ3BDNlosbURBQVMsQ0FBQ2pQLEdBQVYsQ0FBYzVJLEdBQWQsRUFBbUJoQyxNQUFuQjs7QUFDQSxRQUFJZ0MsR0FBRyxDQUFDdUcsVUFBSixDQUFlb1IsK0ZBQU8sQ0FBQzNaLE1BQVIsQ0FBZXdJLE1BQTlCLENBQUosRUFBMkM7QUFBQTs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBTW5PLEVBQUUsR0FBRzhoQixNQUFNLENBQUNuYSxHQUFHLENBQUNMLEtBQUosQ0FBVWdZLCtGQUFPLENBQUMzWixNQUFSLENBQWV3SSxNQUFmLENBQXNCek4sTUFBaEMsQ0FBRCxDQUFqQjs7QUFDQSxVQUFJLENBQUNWLEVBQUQsSUFBT3doQixLQUFLLENBQUN4aEIsRUFBRCxDQUFoQixFQUFzQjtBQUNwQjtBQUNBO0FBQ0E7QUFDRDs7QUFDRHdoQixXQUFLLENBQUN4aEIsRUFBRCxDQUFMLEdBQVkyRixNQUFaO0FBQ0EsWUFBTW9CLEdBQUcsR0FBR2diLDBEQUFVLENBQUNwYyxNQUFELENBQXRCOztBQUNBLFVBQUk4YixNQUFNLENBQUMxYSxHQUFELENBQVYsRUFBaUI7QUFDZjtBQUNBO0FBQ0E7QUFDRDs7QUFDRDBhLFlBQU0sQ0FBQzFhLEdBQUQsQ0FBTixHQUFjcEIsTUFBZDtBQUNBQSxZQUFNLENBQUN5RSxLQUFQLDZFQUNLekUsTUFBTSxDQUFDeUUsS0FEWjtBQUVFcEssVUFGRjtBQUdFK0c7QUFIRjtBQUtBcEIsWUFBTSxDQUFDekMsTUFBUCw2RUFDSzhlLGdFQUFnQixFQURyQixNQUVLcmMsTUFBTSxDQUFDekMsTUFGWjtBQUlBcWUsZUFBUyxDQUFDdmhCLEVBQVYsR0FBZXVDLElBQUksQ0FBQzBmLEdBQUwsQ0FBU1YsU0FBUyxDQUFDdmhCLEVBQW5CLEVBQXVCQSxFQUF2QixDQUFmO0FBQ0F1aEIsZUFBUyxDQUFDelIsUUFBVixHQUFxQnZOLElBQUksQ0FBQzBmLEdBQUwsQ0FBU1YsU0FBUyxDQUFDelIsUUFBbkIsRUFBNkJnUyxNQUFNLENBQUNuYyxNQUFNLENBQUN5RSxLQUFQLENBQWEwRixRQUFkLENBQW5DLENBQXJCO0FBQ0FlLGFBQU8sQ0FBQ1gsSUFBUixDQUFhdkssTUFBYixFQWhDeUMsQ0FpQ3pDOztBQUNBLFlBQU07QUFDSnpDLGNBQU0sRUFBRTtBQUFFZ2YsaUJBQU8sR0FBRztBQUFaLFlBQW1CLEVBRHZCO0FBRUozQixZQUFJLEdBQUc1YSxNQUFNLENBQUM0YSxJQUFQLEdBQWM7QUFGakIsVUFHRjVhLE1BSEo7QUFJQTRhLFVBQUksQ0FBQzRCLEtBQUwsR0FBYSxDQUFDLEdBQUcsSUFBSUMsR0FBSixDQUFRN0IsSUFBSSxDQUFDNEIsS0FBTCxJQUFjLEVBQXRCLENBQUosQ0FBYixDQXRDeUMsQ0FzQ0k7O0FBQzdDLHVCQUFBNUIsSUFBSSxDQUFDOEIsT0FBTCxtQ0FBY25YLE9BQWQsQ0FBc0IwVyxXQUF0QixFQUFtQ00sT0FBbkM7QUFDQWpqQixZQUFNLENBQUMrZ0IsTUFBUCxDQUFjTyxJQUFJLENBQUMrQixTQUFMLElBQWtCLEVBQWhDLEVBQW9DcFgsT0FBcEMsQ0FBNEMwVyxXQUE1QyxFQUF5RE0sT0FBekQ7QUFDQSxlQUFTTixXQUFULEVBQUFNLE9BQU8sRUFBYzNCLElBQUksQ0FBQ2dDLElBQW5CLENBQVA7QUFDRCxLQTFDRCxNQTBDTyxJQUFJNWEsR0FBRyxDQUFDdUcsVUFBSixDQUFlb1IsK0ZBQU8sQ0FBQ2tELEdBQVIsQ0FBWXJVLE1BQTNCLENBQUosRUFBd0M7QUFDN0N1VCxVQUFJLENBQUN4UixJQUFMLENBQVV2SSxHQUFHLENBQUNMLEtBQUosQ0FBVWdZLCtGQUFPLENBQUNrRCxHQUFSLENBQVlyVSxNQUFaLENBQW1Cek4sTUFBN0IsQ0FBVjtBQUNEO0FBQ0YsR0EvQ0csQ0FBSjtBQWdEQTRlLGlHQUFPLENBQUNrRCxHQUFSLENBQVlDLFdBQVosQ0FBd0JmLElBQUksQ0FBQzFRLE1BQUwsQ0FBWXRSLEdBQUcsSUFBSSxDQUFDaWlCLE9BQU8sQ0FBQzlmLFFBQVIsQ0FBaUJuQyxHQUFqQixDQUFwQixDQUF4QjtBQUNBVCxRQUFNLENBQUNDLE1BQVAsQ0FBY21nQixLQUFkLEVBQXFCO0FBQ25CeE8sV0FEbUI7QUFFbkIwUSxhQUZtQjtBQUduQjdCLGFBQVMsRUFBRTdPLE9BQU8sQ0FBQ25CLE1BQVIsQ0FBZSxDQUFDbkcsR0FBRCxFQUFNb0csSUFBTixLQUFlO0FBQ3ZDcEcsU0FBRyxDQUFDb0csSUFBSSxDQUFDdkYsS0FBTCxDQUFXcEssRUFBWixDQUFILEdBQXFCMlAsSUFBckI7QUFDQSxhQUFPcEcsR0FBUDtBQUNELEtBSFUsRUFHUixFQUhRO0FBSFEsR0FBckIsRUFsRTZCLENBMEU3Qjs7QUFDQSxNQUFJbEMsT0FBTyxLQUFLZ2EsV0FBWixJQUNEemQsVUFEQyxJQUVELGtCQUFBdEUsSUFBSSxDQUFDb00sT0FBTCxtQ0FBY2dYLGlCQUFkLE1BQW9DQyxrR0FGbkMsSUFHREMsc0dBQWMsQ0FBQ3ZCLFdBQUQsRUFBYyxRQUFkLENBQWQsSUFBeUMsQ0FINUMsRUFHK0M7QUFDN0NuWiwrREFBUyxDQUFDLG1CQUFELEVBQXNCMmEsa0dBQXRCLENBQVQ7QUFDRDs7QUFDRCxNQUFJL2QsS0FBSixFQUF1QixFQUV0Qjs7QUFDRHFjLFFBQU0sQ0FBQzdoQixJQUFELENBQU47QUFDQSxTQUFPcVIsV0FBVyxFQUFsQjtBQUNELENBdEZEO0FBd0ZBOztBQUNBLFNBQVNtUixNQUFULENBQWdCdlosR0FBaEIsRUFBcUI7QUFDbkIsU0FBTyxDQUFDQSxHQUFELElBQVEsQ0FBZjtBQUNEO0FBRUQ7OztBQUNBLFNBQVMwWCxVQUFULENBQW9CdGEsTUFBcEIsRUFBNEI7QUFDMUIsU0FBT0EsTUFBUCxvQkFBT0EsTUFBTSxDQUFFeUUsS0FBUixDQUFjcEssRUFBckI7QUFDRDtBQUVEOzs7QUFDQSxTQUFTOGlCLGtCQUFULEdBQThCO0FBQzVCNWEsNkRBQVMsQ0FBQyxjQUFELEVBQWlCL0YsSUFBSSxDQUFDQyxHQUFMLEVBQWpCLENBQVQ7QUFDRDtBQUVEOzs7QUFDTyxlQUFld2UsaUJBQWYsR0FBbUM7QUFDeEMsUUFBTW5RLE9BQU8sR0FBRzRPLEtBQUssQ0FBQ3hPLE9BQU4sQ0FBY0csTUFBZCxDQUFxQixDQUFDO0FBQUU1RztBQUFGLEdBQUQsRUFBWXNXLEtBQVosS0FBc0I7QUFDekQsVUFBTTVRLFFBQVEsR0FBRzRRLEtBQUssR0FBRyxDQUF6QjtBQUNBLFVBQU12Z0IsR0FBRyxHQUFHaUssS0FBSyxDQUFDMEYsUUFBTixLQUFtQkEsUUFBL0I7QUFDQSxRQUFJM1AsR0FBSixFQUFTaUssS0FBSyxDQUFDMEYsUUFBTixHQUFpQkEsUUFBakI7QUFDVCxXQUFPM1AsR0FBUDtBQUNELEdBTGUsQ0FBaEI7QUFNQWtmLE9BQUssQ0FBQ2tDLFNBQU4sQ0FBZ0J6UixRQUFoQixHQUEyQnVQLEtBQUssQ0FBQ3hPLE9BQU4sQ0FBY25RLE1BQXpDOztBQUNBLE1BQUkrUCxPQUFPLENBQUMvUCxNQUFaLEVBQW9CO0FBQ2xCLFVBQU00ZSwrRkFBTyxDQUFDM1osTUFBUixDQUFlb2QsSUFBZixDQUFvQnRTLE9BQXBCLENBQU47QUFDQXFTLHNCQUFrQjtBQUNuQjs7QUFDRCxTQUFPclMsT0FBTyxDQUFDL1AsTUFBZjtBQUNEO0FBRUQ7O0FBQ08sZUFBZWlRLFdBQWYsR0FBNkI7QUFDbEMwTyxPQUFLLENBQUN4TyxPQUFOLENBQWNtUyxJQUFkLENBQW1CLENBQUNDLENBQUQsRUFBSUMsQ0FBSixLQUFVcEIsTUFBTSxDQUFDbUIsQ0FBQyxDQUFDN1ksS0FBRixDQUFRMEYsUUFBVCxDQUFOLEdBQTJCZ1MsTUFBTSxDQUFDb0IsQ0FBQyxDQUFDOVksS0FBRixDQUFRMEYsUUFBVCxDQUE5RDtBQUNBLFFBQU1jLE9BQU8sR0FBRyxNQUFNZ1EsaUJBQWlCLEVBQXZDO0FBQ0E1aEIsaUdBQU8sQ0FBQyxnQkFBRCxFQUFtQixJQUFuQixDQUFQO0FBQ0EsU0FBTzRSLE9BQVA7QUFDRDtBQUVEOztBQUNPLFNBQVM2UCxhQUFULENBQXVCemdCLEVBQXZCLEVBQTJCO0FBQ2hDLFNBQU9xZixLQUFLLENBQUNLLFNBQU4sQ0FBZ0IxZixFQUFoQixDQUFQO0FBQ0Q7QUFFRDs7QUFDTyxTQUFTOGYsU0FBVCxDQUFtQjtBQUFFOWYsSUFBRjtBQUFNK0csS0FBTjtBQUFXd1o7QUFBWCxDQUFuQixFQUFzQztBQUMzQyxNQUFJNWEsTUFBSjs7QUFDQSxNQUFJM0YsRUFBSixFQUFRO0FBQ04yRixVQUFNLEdBQUc4YSxhQUFhLENBQUN6Z0IsRUFBRCxDQUF0QjtBQUNELEdBRkQsTUFFTztBQUNMLFFBQUksQ0FBQytHLEdBQUwsRUFBVUEsR0FBRyxHQUFHZ2IsMERBQVUsQ0FBQztBQUFFeEIsVUFBRjtBQUFRdmdCLFFBQUUsRUFBRTtBQUFaLEtBQUQsQ0FBaEI7QUFDVjJGLFVBQU0sR0FBRzBaLEtBQUssQ0FBQ3hPLE9BQU4sQ0FBYzZHLElBQWQsQ0FBbUIsQ0FBQztBQUFFdE47QUFBRixLQUFELEtBQWVyRCxHQUFHLEtBQUtxRCxLQUFLLENBQUNyRCxHQUFoRCxDQUFUO0FBQ0Q7O0FBQ0QsU0FBT3BCLE1BQVA7QUFDRDtBQUVEOztBQUNPLFNBQVNHLFVBQVQsR0FBc0I7QUFDM0IsU0FBT3VaLEtBQUssQ0FBQ3hPLE9BQU4sQ0FBY0csTUFBZCxDQUFxQnJMLE1BQU0sSUFBSSxDQUFDQSxNQUFNLENBQUN5QyxNQUFQLENBQWNqQyxPQUE5QyxDQUFQO0FBQ0Q7QUFFRDs7Ozs7O0FBS08sU0FBU2dkLG1CQUFULENBQTZCOWpCLEdBQTdCLEVBQWtDO0FBQ3ZDLFNBQU9pZ0IsK0ZBQU8sQ0FBQ3JYLEtBQVIsQ0FBY2tZLFFBQWQsQ0FBdUI5Z0IsR0FBdkIsQ0FBUDtBQUNEO0FBRUQ7Ozs7OztBQUtPLGVBQWUrakIsZUFBZixDQUErQkMsU0FBL0IsRUFBMEM7QUFDL0MsTUFBSXZlLEtBQUosRUFBdUJYLEVBQUE7QUFDdkIsUUFBTW1iLCtGQUFPLENBQUNyWCxLQUFSLENBQWM4YSxJQUFkLENBQW1CTSxTQUFuQixDQUFOO0FBQ0EsU0FBT0EsU0FBUDtBQUNEO0FBRU0sTUFBTUMsY0FBYyxHQUFHLFdBQXZCO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLFNBQXJCO0FBQ0EsTUFBTUMsYUFBYSxHQUFHLFVBQXRCO0FBQ1AsTUFBTUMsV0FBVyxHQUFHLDJDQUFwQjtBQUNBLE1BQU1DLFNBQVMsR0FBRyxrQ0FBbEI7QUFDQTs7OztBQUdPLGVBQWVDLGVBQWYsQ0FBK0Jqa0IsR0FBL0IsRUFBb0Nra0IsS0FBcEMsRUFBMkM7QUFDaEQsUUFBTUMsVUFBVSxHQUFHQyw2REFBYSxDQUFDcGtCLEdBQUQsQ0FBYixHQUNmLEVBRGUsR0FFZjJmLEtBQUssQ0FBQ3hPLE9BQU4sQ0FBY0csTUFBZCxDQUFxQnJMLE1BQU07QUFBQTs7QUFBQSxXQUMzQixDQUFDQSxNQUFNLENBQUN5QyxNQUFQLENBQWNqQyxPQUFmLEtBQ0l5ZCxLQUFLLElBQUksMkJBQUVqZSxNQUFNLENBQUN6QyxNQUFQLENBQWM2Z0IsUUFBaEIsb0NBQTRCcGUsTUFBTSxDQUFDNGEsSUFBUCxDQUFZd0QsUUFBeEMsQ0FEYixLQUVHQywwREFBVSxDQUFDdGtCLEdBQUQsRUFBTWlHLE1BQU4sQ0FIYztBQUFBLEdBQTNCLENBRko7QUFPQSxRQUFNc2UsV0FBVyxHQUFHLEVBQXBCO0FBQ0E7O0FBQ0EsUUFBTSxDQUFDQyxRQUFELEVBQVdDLFVBQVgsSUFBeUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPNWEsR0FBUCxDQUFXLE9BQU87QUFDL0NsSyxPQUFHLEVBQUUsRUFEMEM7O0FBRS9DO0FBQ0F3UixXQUFPLEVBQUUsRUFIc0M7QUFJL0MsS0FBQ3lTLGNBQUQsR0FBa0IsRUFKNkI7QUFLL0MsS0FBQ0MsWUFBRCxHQUFnQixFQUwrQjtBQU0vQyxLQUFDQyxhQUFELEdBQWlCO0FBTjhCLEdBQVAsQ0FBWCxDQUEvQjtBQVFBSyxZQUFVLENBQUMzWSxPQUFYLENBQW9CdkYsTUFBRCxJQUFZO0FBQUE7O0FBQzdCLFVBQU07QUFBRTNGO0FBQUYsUUFBUzJGLE1BQU0sQ0FBQ3lFLEtBQXRCOztBQUNBLFFBQUksQ0FBQ3pFLE1BQU0sQ0FBQ3lDLE1BQVAsQ0FBY21DLE9BQW5CLEVBQTRCO0FBQzFCMFosaUJBQVcsQ0FBQy9ULElBQVosQ0FBaUJsUSxFQUFqQjtBQUNBO0FBQ0Q7O0FBQ0QsVUFBTTtBQUFFdWdCLFVBQUY7QUFBUXJkO0FBQVIsUUFBbUJ5QyxNQUF6QjtBQUNBLFVBQU07QUFBRXVjLGFBQU8sR0FBR2tDLFlBQVksQ0FBQ3plLE1BQUQ7QUFBeEIsUUFBcUN6QyxNQUEzQztBQUNBLFVBQU1taEIsS0FBSyxHQUFHLFlBQUMsR0FBRW5oQixNQUFNLENBQUNtaEIsS0FBUCxJQUFnQjlELElBQUksQ0FBQzhELEtBQXJCLElBQThCLEVBQUcsRUFBcEMsQ0FBc0NuakIsS0FBdEMsQ0FBNEN3aUIsU0FBNUMsOEJBQXlELENBQXpELE1BQStELEtBQTdFO0FBQ0EsVUFBTVksR0FBRyxHQUFHRCxLQUFLLEtBQUssT0FBVixJQUFxQkEsS0FBSyxLQUFLLE1BQS9CLEdBQXdDSCxRQUF4QyxHQUFtREMsVUFBL0Q7QUFDQUcsT0FBRyxDQUFDamxCLEdBQUosQ0FBUTZRLElBQVIsQ0FBYWxRLEVBQWI7O0FBQ0EsUUFBSXVnQixJQUFJLENBQUM0QixLQUFMLENBQVdvQyxJQUFYLENBQWdCZCxXQUFXLENBQUN4YyxJQUE1QixFQUFrQ3djLFdBQWxDLENBQUosRUFBb0Q7QUFDbERhLFNBQUcsQ0FBQ2QsYUFBRCxDQUFILENBQW1CdFQsSUFBbkIsQ0FBd0JsUSxFQUF4QjtBQUNEOztBQUNELFNBQUssTUFBTSxDQUFDNkYsSUFBRCxFQUFPaUIsSUFBUCxDQUFYLElBQTJCLENBQ3pCLENBQUN5WixJQUFJLENBQUM4QixPQUFOLEVBQWVrQixZQUFmLENBRHlCLEVBRXpCLENBQUN0a0IsTUFBTSxDQUFDK2dCLE1BQVAsQ0FBY08sSUFBSSxDQUFDK0IsU0FBbkIsQ0FBRCxFQUFnQ2dCLGNBQWhDLENBRnlCLENBQTNCLEVBR0c7QUFDRHpkLFVBQUksQ0FBQ3FGLE9BQUwsQ0FBYXZELEdBQUcsSUFBSTtBQUNsQkEsV0FBRyxHQUFHdWEsT0FBTyxDQUFDdmEsR0FBRCxDQUFQLElBQWdCQSxHQUF0Qjs7QUFDQSxZQUFJLENBQUN1YyxRQUFRLENBQUNwZCxJQUFELENBQVIsQ0FBZWpGLFFBQWYsQ0FBd0I4RixHQUF4QixDQUFMLEVBQW1DO0FBQ2pDMmMsYUFBRyxDQUFDeGQsSUFBRCxDQUFILENBQVVvSixJQUFWLENBQWV2SSxHQUFmO0FBQ0Q7QUFDRixPQUxEO0FBTUQ7QUFDRDs7O0FBQ0EyYyxPQUFHLENBQUN6VCxPQUFKLENBQVlYLElBQVosMkVBQXNCdkssTUFBdEI7QUFBOEIwZTtBQUE5QjtBQUNELEdBM0JEOztBQTRCQSxNQUFJRixVQUFVLENBQUM5a0IsR0FBWCxDQUFlcUIsTUFBbkIsRUFBMkI7QUFDekJ5akIsY0FBVSxDQUFDdlgsT0FBWCxHQUFxQjRYLG1CQUFtQixDQUFDTCxVQUFELENBQXhDO0FBQ0Q7QUFDRDs7O0FBQ0EsbUZBQ0tELFFBREwsT0FFSyxNQUFNTSxtQkFBbUIsQ0FBQ04sUUFBRCxDQUY5QjtBQUdFRCxlQUhGO0FBSUVFO0FBSkY7QUFNRDtBQUVEOzs7OztBQUlBLE1BQU1NLGNBQWMsR0FBR3hsQixNQUFNLENBQUNtVSxPQUFQLENBQWU7QUFDcEN2USxPQUFLLEVBQUV5Z0IsY0FENkI7QUFFcENyZ0IsTUFBSSxFQUFFLEtBRjhCO0FBR3BDb2YsU0FBTyxFQUFFa0IsWUFIMkI7QUFJcEN0YixPQUFLLEVBQUV1YjtBQUo2QixDQUFmLENBQXZCO0FBTUEsTUFBTWtCLGtCQUFrQixHQUFHLEVBQTNCOztBQUVBLGVBQWVGLG1CQUFmLENBQW1DRixHQUFuQyxFQUF3Q0ssT0FBeEMsRUFBaUQ7QUFDL0MsUUFBTTljLElBQUksR0FBRyxFQUFiO0FBQ0E0YyxnQkFBYyxDQUFDdlosT0FBZixDQUF1QixDQUFDLENBQUMwWixJQUFELEVBQU9DLE1BQVAsQ0FBRCxLQUFvQjtBQUN6Q1AsT0FBRyxDQUFDTyxNQUFELENBQUgsQ0FBWTNaLE9BQVosQ0FBb0JsTCxFQUFFLElBQUk7QUFDeEI2SCxVQUFJLENBQUNxSSxJQUFMLENBQVVvUCwrRkFBTyxDQUFDc0YsSUFBRCxDQUFQLENBQWNFLE1BQWQsQ0FBcUI5a0IsRUFBckIsQ0FBVjtBQUNELEtBRkQ7QUFHRCxHQUpEO0FBS0EsUUFBTVYsSUFBSSxHQUFHLE1BQU1nZ0IsK0ZBQU8sQ0FBQ2xVLElBQVIsQ0FBYStVLFFBQWIsQ0FBc0J0WSxJQUF0QixDQUFuQjs7QUFDQSxPQUFLLE1BQU0sQ0FBQytjLElBQUQsRUFBT0MsTUFBUCxDQUFYLElBQTZCSixjQUE3QixFQUE2QztBQUMzQ0gsT0FBRyxDQUFDTSxJQUFELENBQUgsR0FBWSxFQUFaOztBQUNBLFNBQUssTUFBTTVrQixFQUFYLElBQWlCc2tCLEdBQUcsQ0FBQ08sTUFBRCxDQUFwQixFQUE4QjtBQUM1QixZQUFNdGMsR0FBRyxHQUFHakosSUFBSSxDQUFDZ2dCLCtGQUFPLENBQUNzRixJQUFELENBQVAsQ0FBY0UsTUFBZCxDQUFxQjlrQixFQUFyQixDQUFELENBQWhCO0FBQ0Fza0IsU0FBRyxDQUFDTSxJQUFELENBQUgsQ0FBVTVrQixFQUFWLElBQWdCdUksR0FBaEI7O0FBQ0EsVUFBSUEsR0FBRyxJQUFJLElBQVAsSUFBZXFjLElBQUksS0FBSyxPQUF4QixJQUFtQ0Ysa0JBQWtCLENBQUNFLElBQUksR0FBRzVrQixFQUFSLENBQWxCLEtBQWtDLENBQXpFLEVBQTRFO0FBQzFFLGNBQU15SCxHQUFHLEdBQUksUUFBT21kLElBQUsseUJBQXdCNWtCLEVBQUcsSUFBcEQ7QUFDQSxjQUFNK2tCLElBQUksR0FBRyxnRUFBYjtBQUNBTCwwQkFBa0IsQ0FBQ0UsSUFBSSxHQUFHNWtCLEVBQVIsQ0FBbEIsR0FBZ0Mya0IsT0FBTyxHQUFHLENBQUgsR0FBTyxDQUE5Qzs7QUFDQSxZQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaeGdCLGlCQUFPLENBQUMrRSxJQUFSLENBQWF6QixHQUFiLEVBQWtCLGNBQWxCOztBQUNBLGNBQUksTUFBTTBaLE1BQU0sRUFBaEIsRUFBb0I7QUFDbEIsbUJBQU9xRCxtQkFBbUIsQ0FBQ0YsR0FBRCxFQUFNLElBQU4sQ0FBMUI7QUFDRDtBQUNGOztBQUNEbmdCLGVBQU8sQ0FBQytJLEtBQVIsQ0FBY3pGLEdBQWQsRUFBbUJzZCxJQUFuQjtBQUNBdlEsK0RBQU0sQ0FBQztBQUFFQyxlQUFLLEVBQUVoTixHQUFUO0FBQWN3TCxjQUFJLEVBQUU4UjtBQUFwQixTQUFELENBQU47QUFDRDtBQUNGO0FBQ0Y7O0FBQ0QsU0FBT1QsR0FBUDtBQUNEO0FBRUQ7Ozs7OztBQUlPLGVBQWUva0IsT0FBZixDQUF1QkYsR0FBdkIsRUFBNEI7QUFDakMsUUFBTXdSLE9BQU8sR0FBR3hSLEdBQUcsR0FBR0EsR0FBRyxDQUFDa0ssR0FBSixDQUFRa1gsYUFBUixDQUFILEdBQTRCcEIsS0FBSyxDQUFDeE8sT0FBckQ7QUFDQSxTQUFPO0FBQ0xBLFdBREs7QUFFTGhPLFNBQUssRUFBRSxNQUFNbWlCLFlBQVksQ0FBQ25VLE9BQUQ7QUFGcEIsR0FBUDtBQUlEOztBQUVELFNBQVNtVSxZQUFULENBQXNCblUsT0FBdEIsRUFBK0I7QUFDN0IsUUFBTW9VLFFBQVEsR0FBRyxFQUFqQjtBQUNBcFUsU0FBTyxDQUFDM0YsT0FBUixDQUFpQnZGLE1BQUQsSUFBWTtBQUMxQixVQUFNO0FBQUU0YztBQUFGLFFBQVc1YyxNQUFNLENBQUM0YSxJQUF4Qjs7QUFDQSxRQUFJMkUsZ0dBQVEsQ0FBQzNDLElBQUQsQ0FBWixFQUFvQjtBQUFBOztBQUNsQjBDLGNBQVEsQ0FBQy9VLElBQVQsQ0FBYywwQkFBQXZLLE1BQU0sQ0FBQ3pDLE1BQVAsQ0FBY2dmLE9BQWQsMkNBQXdCSyxJQUF4QixNQUFpQ0EsSUFBL0M7QUFDRDtBQUNGLEdBTEQ7QUFNQSxTQUFPMEMsUUFBUSxDQUFDdmtCLE1BQVQsR0FDSDRlLCtGQUFPLENBQUN6YyxLQUFSLENBQWNzZCxRQUFkLENBQXVCOEUsUUFBdkIsRUFBaUNuTSxTQUFqQyxFQUE0Q3dHLCtGQUFPLENBQUN6YyxLQUFSLENBQWNzaUIsV0FBMUQsQ0FERyxHQUVILEVBRko7QUFHRDtBQUVEOzs7QUFDTyxTQUFTOWdCLFdBQVQsQ0FBcUI7QUFBRStnQjtBQUFGLElBQVksRUFBakMsRUFBcUM7QUFDMUMsUUFBTWhqQixHQUFHLEdBQUdELElBQUksQ0FBQ0MsR0FBTCxFQUFaO0FBQ0EsUUFBTWlqQixRQUFRLEdBQUdoRyxLQUFLLENBQUN4TyxPQUFOLENBQWNHLE1BQWQsQ0FBcUJyTCxNQUFNLElBQUlBLE1BQU0sQ0FBQ3lDLE1BQVAsQ0FBY2pDLE9BQWQsS0FDOUNpZixLQUFLLElBQUloakIsR0FBRyxHQUFHMGYsTUFBTSxDQUFDbmMsTUFBTSxDQUFDeUUsS0FBUCxDQUFhMkYsWUFBZCxDQUFaLEdBQTBDdVYsbUdBREwsQ0FBL0IsQ0FBakI7O0FBR0EsTUFBSUQsUUFBUSxDQUFDM2tCLE1BQWIsRUFBcUI7QUFDbkIyZSxTQUFLLENBQUN4TyxPQUFOLEdBQWdCd08sS0FBSyxDQUFDeE8sT0FBTixDQUFjRyxNQUFkLENBQXFCckwsTUFBTSxJQUFJLENBQUNBLE1BQU0sQ0FBQ3lDLE1BQVAsQ0FBY2pDLE9BQTlDLENBQWhCO0FBQ0EsVUFBTTlHLEdBQUcsR0FBR2dtQixRQUFRLENBQUM5YixHQUFULENBQWEwVyxVQUFiLENBQVo7QUFDQVgsbUdBQU8sQ0FBQzNaLE1BQVIsQ0FBZThjLFdBQWYsQ0FBMkJwakIsR0FBM0I7QUFDQWlnQixtR0FBTyxDQUFDcmMsSUFBUixDQUFhd2YsV0FBYixDQUF5QnBqQixHQUF6QjtBQUNBaWdCLG1HQUFPLENBQUNyWCxLQUFSLENBQWN3YSxXQUFkLENBQTBCcGpCLEdBQTFCO0FBQ0Q7O0FBQ0QsU0FBT2dtQixRQUFRLENBQUMza0IsTUFBaEI7QUFDRDtBQUVEOztBQUNBLFNBQVM2a0IsT0FBVCxHQUFtQjtBQUNqQixRQUFNQyxHQUFHLEdBQUcsSUFBSUMsV0FBSixDQUFnQixDQUFoQixDQUFaO0FBQ0FyTixRQUFNLENBQUNzTixNQUFQLENBQWNDLGVBQWQsQ0FBOEJILEdBQTlCLEVBRmlCLENBR2pCO0FBQ0E7QUFDQTs7QUFDQUEsS0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTQSxHQUFHLENBQUMsQ0FBRCxDQUFILEdBQVMsTUFBVCxHQUFrQixNQUEzQixDQU5pQixDQU1rQjs7QUFDbkNBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBU0EsR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTLE1BQVQsR0FBa0IsTUFBM0IsQ0FQaUIsQ0FPa0I7O0FBQ25DLFNBQU8sZUFBZTNTLE9BQWYsQ0FBdUIsS0FBdkIsRUFBOEIxTCxDQUFDLElBQUksQ0FBQ3FlLEdBQUcsQ0FBQ3JlLENBQUQsQ0FBSCxHQUFTLE9BQVYsRUFBb0J1TCxRQUFwQixDQUE2QixFQUE3QixFQUFpQ3BMLEtBQWpDLENBQXVDLENBQUMsQ0FBeEMsQ0FBbkMsQ0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7QUFLQSxlQUFlc2UsVUFBZixDQUEwQmpnQixNQUExQixFQUFrQzFDLElBQWxDLEVBQXdDO0FBQ3RDLFFBQU1tRixNQUFNLEdBQUd6QyxNQUFNLENBQUN5QyxNQUFQLElBQWlCLEVBQWhDO0FBQ0FBLFFBQU0sQ0FBQ21DLE9BQVAsR0FBaUJ1WCxNQUFNLENBQUMxWixNQUFNLENBQUNtQyxPQUFSLENBQXZCO0FBQ0FuQyxRQUFNLENBQUNvQyxZQUFQLEdBQXNCc1gsTUFBTSxDQUFDMVosTUFBTSxDQUFDb0MsWUFBUixDQUE1QjtBQUNBLFFBQU1KLEtBQUssR0FBR3pFLE1BQU0sQ0FBQ3lFLEtBQVAsSUFBZ0IsRUFBOUI7QUFDQSxNQUFJeWIsU0FBSjs7QUFDQSxNQUFJLENBQUN6YixLQUFLLENBQUNwSyxFQUFYLEVBQWU7QUFDYnFmLFNBQUssQ0FBQ2tDLFNBQU4sQ0FBZ0J2aEIsRUFBaEIsSUFBc0IsQ0FBdEI7QUFDQW9LLFNBQUssQ0FBQ3BLLEVBQU4sR0FBV3FmLEtBQUssQ0FBQ2tDLFNBQU4sQ0FBZ0J2aEIsRUFBM0I7QUFDRCxHQUhELE1BR087QUFDTDZsQixhQUFTLEdBQUd4RyxLQUFLLENBQUNLLFNBQU4sQ0FBZ0J0VixLQUFLLENBQUNwSyxFQUF0QixDQUFaO0FBQ0Q7O0FBQ0RvSyxPQUFLLENBQUNyRCxHQUFOLEdBQVlnYiwwREFBVSxDQUFDcGMsTUFBRCxDQUF0QjtBQUNBeUUsT0FBSyxDQUFDMGIsSUFBTixHQUFhMWIsS0FBSyxDQUFDMGIsSUFBTixLQUFjSixNQUFNLENBQUNLLFVBQXJCLG9CQUFjTCxNQUFNLENBQUNLLFVBQVAsRUFBZCxLQUF1Q1IsT0FBTyxFQUEzRCxDQWJzQyxDQWN0Qzs7QUFDQSxNQUFJbEcsS0FBSyxDQUFDeE8sT0FBTixDQUFjMFQsSUFBZCxDQUFtQixDQUFDO0FBQUVuYSxTQUFLLEVBQUU7QUFBRXBLLFFBQUY7QUFBTStHO0FBQU4sUUFBYztBQUF2QixHQUFELEtBQWlDcUQsS0FBSyxDQUFDcEssRUFBTixLQUFhQSxFQUFiLElBQW1Cb0ssS0FBSyxDQUFDckQsR0FBTixLQUFjQSxHQUFyRixDQUFKLEVBQStGO0FBQzdGLFVBQU1pZiw0RkFBSSxDQUFDLHNCQUFELENBQVY7QUFDRDs7QUFDRCxNQUFJSCxTQUFKLEVBQWU7QUFDYmxnQixVQUFNLENBQUN5QyxNQUFQLDZFQUFxQnlkLFNBQVMsQ0FBQ3pkLE1BQS9CLE1BQTBDQSxNQUExQztBQUNBekMsVUFBTSxDQUFDeUUsS0FBUCw2RUFBb0J5YixTQUFTLENBQUN6YixLQUE5QixNQUF3Q0EsS0FBeEM7QUFDQSxVQUFNc1csS0FBSyxHQUFHckIsS0FBSyxDQUFDeE8sT0FBTixDQUFjekosT0FBZCxDQUFzQnllLFNBQXRCLENBQWQ7QUFDQXhHLFNBQUssQ0FBQ3hPLE9BQU4sQ0FBYzZQLEtBQWQsSUFBdUIvYSxNQUF2QjtBQUNELEdBTEQsTUFLTztBQUNMLFFBQUksQ0FBQ3lFLEtBQUssQ0FBQzBGLFFBQVgsRUFBcUI7QUFDbkJ1UCxXQUFLLENBQUNrQyxTQUFOLENBQWdCelIsUUFBaEIsSUFBNEIsQ0FBNUI7QUFDQTFGLFdBQUssQ0FBQzBGLFFBQU4sR0FBaUJ1UCxLQUFLLENBQUNrQyxTQUFOLENBQWdCelIsUUFBakM7QUFDRCxLQUhELE1BR08sSUFBSXVQLEtBQUssQ0FBQ2tDLFNBQU4sQ0FBZ0J6UixRQUFoQixHQUEyQjFGLEtBQUssQ0FBQzBGLFFBQXJDLEVBQStDO0FBQ3BEdVAsV0FBSyxDQUFDa0MsU0FBTixDQUFnQnpSLFFBQWhCLEdBQTJCMUYsS0FBSyxDQUFDMEYsUUFBakM7QUFDRDs7QUFDRG5LLFVBQU0sQ0FBQ3lDLE1BQVAsR0FBZ0JBLE1BQWhCO0FBQ0F6QyxVQUFNLENBQUN5RSxLQUFQLEdBQWVBLEtBQWY7QUFDQWlWLFNBQUssQ0FBQ3hPLE9BQU4sQ0FBY1gsSUFBZCxDQUFtQnZLLE1BQW5CO0FBQ0Q7O0FBQ0QsU0FBTzNCLE9BQU8sQ0FBQ3dLLEdBQVIsQ0FBWSxDQUNqQjhRLCtGQUFPLENBQUMzWixNQUFSLENBQWVvZCxJQUFmLENBQW9CcGQsTUFBcEIsQ0FEaUIsRUFFakIyWiwrRkFBTyxDQUFDcmMsSUFBUixDQUFhK0UsR0FBYixDQUFpQm9DLEtBQUssQ0FBQ3BLLEVBQXZCLEVBQTJCaUQsSUFBM0IsQ0FGaUIsQ0FBWixDQUFQO0FBSUQ7QUFFRDs7O0FBQ08sZUFBZXlOLGdCQUFmLENBQWdDMVEsRUFBaEMsRUFBb0NWLElBQXBDLEVBQTBDO0FBQy9DLFFBQU1xRyxNQUFNLEdBQUcwWixLQUFLLENBQUNLLFNBQU4sQ0FBZ0IxZixFQUFoQixDQUFmO0FBQ0EsTUFBSSxDQUFDMkYsTUFBTCxFQUFhLE1BQU0sSUFBTjtBQUNiQSxRQUFNLENBQUN5RSxLQUFQLDZFQUFvQnpFLE1BQU0sQ0FBQ3lFLEtBQTNCLE1BQXFDOUssSUFBSSxDQUFDOEssS0FBMUM7QUFDQXpFLFFBQU0sQ0FBQ3lDLE1BQVAsNkVBQXFCekMsTUFBTSxDQUFDeUMsTUFBNUIsTUFBdUM5SSxJQUFJLENBQUM4SSxNQUE1QztBQUNBekMsUUFBTSxDQUFDekMsTUFBUCw2RUFBcUJ5QyxNQUFNLENBQUN6QyxNQUE1QixNQUF1QzVELElBQUksQ0FBQzRELE1BQTVDO0FBQ0EsUUFBTW9jLCtGQUFPLENBQUMzWixNQUFSLENBQWVvZCxJQUFmLENBQW9CcGQsTUFBcEIsQ0FBTjtBQUNBLFNBQU8zRywrRkFBTyxDQUFDaW5CLHdHQUFELEVBQW9CO0FBQUU3aUIsU0FBSyxFQUFFO0FBQUVwRDtBQUFGLEtBQVQ7QUFBaUI0RixVQUFNLEVBQUVEO0FBQXpCLEdBQXBCLENBQWQ7QUFDRDtBQUVEOztBQUNPLGVBQWVxYixXQUFmLENBQTJCcGhCLEdBQTNCLEVBQWdDO0FBQ3JDLFFBQU0yZ0IsSUFBSSxHQUFHUSx5REFBUyxDQUFDbmhCLEdBQUcsQ0FBQ3FELElBQUwsQ0FBdEI7QUFDQSxNQUFJLENBQUNzZCxJQUFJLENBQUN6WixJQUFWLEVBQWdCLE1BQU8sR0FBRWtmLDRGQUFJLENBQUMsa0JBQUQsQ0FBcUIsS0FBSUEsNEZBQUksQ0FBQyxhQUFELENBQWdCLEVBQTFEO0FBQ2hCLFFBQU1FLE1BQU0sR0FBRztBQUNidGdCLFVBQU0sRUFBRTtBQUNOdWdCLGFBQU8sRUFBRXZtQixHQUFHLENBQUN1bUIsT0FBSixJQUFlLElBQWYsR0FBc0JILDRGQUFJLENBQUMsWUFBRCxDQUExQixHQUEyQ3BtQixHQUFHLENBQUN1bUIsT0FBSixJQUFlO0FBRDdEO0FBREssR0FBZjtBQUtBLE1BQUl2a0IsR0FBRyxHQUFHcWtCLHdHQUFWO0FBQ0EsTUFBSXRnQixNQUFKO0FBQ0EsUUFBTWtnQixTQUFTLEdBQUcsTUFBTS9GLFNBQVMsQ0FBQztBQUFFOWYsTUFBRSxFQUFFSixHQUFHLENBQUNJLEVBQVY7QUFBY3VnQjtBQUFkLEdBQUQsQ0FBakM7O0FBQ0EsTUFBSXNGLFNBQUosRUFBZTtBQUNiLFFBQUlqbUIsR0FBRyxDQUFDd21CLEtBQVIsRUFBZSxNQUFNSiw0RkFBSSxDQUFDLHNCQUFELENBQVY7QUFDZnJnQixVQUFNLEdBQUcsMEVBQUtrZ0IsU0FBUixDQUFOO0FBQ0QsR0FIRCxNQUdPO0FBQ0wsS0FBQztBQUFFbGdCO0FBQUYsUUFBYTBnQix5REFBUyxFQUF2QjtBQUNBemtCLE9BQUcsR0FBRzBrQixxR0FBTjtBQUNBSixVQUFNLENBQUNFLEtBQVAsR0FBZSxJQUFmO0FBQ0FGLFVBQU0sQ0FBQ3RnQixNQUFQLENBQWN1Z0IsT0FBZCxHQUF3QkgsNEZBQUksQ0FBQyxjQUFELENBQTVCO0FBQ0Q7O0FBQ0RyZ0IsUUFBTSxDQUFDeUMsTUFBUCw2RUFDS3pDLE1BQU0sQ0FBQ3lDLE1BRFosTUFFS3hJLEdBQUcsQ0FBQ3dJLE1BRlQ7QUFHRWpDLFdBQU8sRUFBRSxDQUhYLENBR2M7O0FBSGQ7QUFLQVIsUUFBTSxDQUFDekMsTUFBUCw2RUFDS3lDLE1BQU0sQ0FBQ3pDLE1BRFosTUFFS3RELEdBQUcsQ0FBQ3NELE1BRlQ7QUFJQXlDLFFBQU0sQ0FBQ3lFLEtBQVAsNkVBQ0t6RSxNQUFNLENBQUN5RSxLQURaO0FBRUUyRixnQkFBWSxFQUFFNU4sSUFBSSxDQUFDQyxHQUFMLEVBRmhCO0FBR0VxSSxlQUFXLEVBQUV0SSxJQUFJLENBQUNDLEdBQUw7QUFIZixLQUlLeEMsR0FBRyxDQUFDd0ssS0FKVDtBQU1BekUsUUFBTSxDQUFDNGEsSUFBUCxHQUFjQSxJQUFkOztBQUNBLE1BQUksQ0FBQ0EsSUFBSSxDQUFDZ0csV0FBTixJQUFxQixDQUFDNWdCLE1BQU0sQ0FBQ3pDLE1BQVAsQ0FBY3FqQixXQUFwQyxJQUFtRHJCLGdHQUFRLENBQUN0bEIsR0FBRyxDQUFDNG1CLElBQUwsQ0FBL0QsRUFBMkU7QUFDekU3Z0IsVUFBTSxDQUFDekMsTUFBUCxDQUFjcWpCLFdBQWQsR0FBNEIzbUIsR0FBRyxDQUFDNG1CLElBQWhDO0FBQ0Q7O0FBQ0QsTUFBSXRCLGdHQUFRLENBQUN0bEIsR0FBRyxDQUFDRixHQUFMLENBQVosRUFBdUJpRyxNQUFNLENBQUN6QyxNQUFQLENBQWN1akIsY0FBZCxHQUErQjdtQixHQUFHLENBQUNGLEdBQW5DO0FBQ3ZCLE1BQUlFLEdBQUcsQ0FBQ2tRLFFBQVIsRUFBa0JuSyxNQUFNLENBQUN5RSxLQUFQLENBQWEwRixRQUFiLEdBQXdCLENBQUNsUSxHQUFHLENBQUNrUSxRQUE3QjtBQUNsQnNVLGNBQVksQ0FBQ3plLE1BQUQsRUFBUy9GLEdBQUcsQ0FBQ0YsR0FBYixDQUFaO0FBQ0EsUUFBTWttQixVQUFVLENBQUNqZ0IsTUFBRCxFQUFTL0YsR0FBRyxDQUFDcUQsSUFBYixDQUFoQjtBQUNBeWpCLGdCQUFjLENBQUMvZ0IsTUFBRCxFQUFTL0YsR0FBVCxDQUFkO0FBQ0FYLFFBQU0sQ0FBQ0MsTUFBUCxDQUFjZ25CLE1BQU0sQ0FBQ3RnQixNQUFyQixFQUE2QkQsTUFBN0IsRUFBcUMvRixHQUFHLENBQUNnRyxNQUF6QztBQUNBc2dCLFFBQU0sQ0FBQzlpQixLQUFQLEdBQWU7QUFBRXBELE1BQUUsRUFBRTJGLE1BQU0sQ0FBQ3lFLEtBQVAsQ0FBYXBLO0FBQW5CLEdBQWY7QUFDQWhCLGlHQUFPLENBQUM0QyxHQUFELEVBQU1za0IsTUFBTixDQUFQO0FBQ0FTLHdEQUFZLENBQUNDLElBQWIsQ0FBa0IsZUFBbEIsRUFBbUNWLE1BQW5DO0FBQ0EsU0FBT0EsTUFBUDtBQUNEO0FBRUQ7O0FBQ0EsU0FBUzlCLFlBQVQsQ0FBc0J6ZSxNQUF0QixFQUE4QnlGLElBQTlCLEVBQW9DO0FBQ2xDLFFBQU07QUFBRW1WO0FBQUYsTUFBVzVhLE1BQWpCO0FBQ0EsUUFBTWtoQixPQUFPLEdBQUd6YixJQUFJLElBQUl6RixNQUFNLENBQUN6QyxNQUFQLENBQWN1akIsY0FBdEM7QUFDQSxRQUFNdkUsT0FBTyxHQUFHMkUsT0FBTyxHQUFHLENBQ3hCLEdBQUd0RyxJQUFJLENBQUM4QixPQURnQixFQUV4QixHQUFHcGpCLE1BQU0sQ0FBQytnQixNQUFQLENBQWNPLElBQUksQ0FBQytCLFNBQW5CLENBRnFCLEVBR3hCL0IsSUFBSSxDQUFDZ0MsSUFIbUIsRUFJeEI3UyxNQUp3QixDQUlqQixDQUFDbkcsR0FBRCxFQUFNNUIsR0FBTixLQUFjO0FBQ3JCLFFBQUlBLEdBQUosRUFBUztBQUNQLFlBQU1tZixPQUFPLEdBQUdDLGtHQUFVLENBQUNwZixHQUFELEVBQU1rZixPQUFOLENBQTFCO0FBQ0EsVUFBSUMsT0FBTyxLQUFLbmYsR0FBaEIsRUFBcUI0QixHQUFHLENBQUM1QixHQUFELENBQUgsR0FBV21mLE9BQVg7QUFDdEI7O0FBQ0QsV0FBT3ZkLEdBQVA7QUFDRCxHQVZ5QixFQVV2QixFQVZ1QixDQUFILEdBVWQsRUFWVDtBQVdBNUQsUUFBTSxDQUFDekMsTUFBUCxDQUFjZ2YsT0FBZCxHQUF3QkEsT0FBeEI7QUFDQSxTQUFPQSxPQUFQO0FBQ0Q7QUFFRDs7O0FBQ08sZUFBZXdFLGNBQWYsQ0FBOEIvZ0IsTUFBOUIsRUFBc0NxaEIsYUFBdEMsRUFBcURDLFVBQXJELEVBQWlFO0FBQ3RFLFFBQU07QUFBRS9qQixVQUFNLEVBQUU7QUFBRWdmO0FBQUYsS0FBVjtBQUF1QjNCO0FBQXZCLE1BQWdDNWEsTUFBdEM7O0FBQ0EsUUFBTXVoQixNQUFNLEdBQUcsQ0FBQ3huQixHQUFELEVBQU02TixJQUFOLEVBQVk0WixTQUFaLEtBQTBCO0FBQUE7O0FBQ3ZDem5CLE9BQUcsR0FBR3dpQixPQUFPLENBQUN4aUIsR0FBRCxDQUFQLElBQWdCQSxHQUF0QjtBQUNBLFVBQU0wbkIsUUFBUSxHQUFHSixhQUFILDJDQUFHQSxhQUFhLENBQUd6WixJQUFILENBQWhCLHFCQUFHLG9CQUF3QjdOLEdBQXhCLENBQWpCO0FBQ0EsV0FBTzBuQixRQUFRLElBQUksSUFBWixJQUFvQixDQUFDRCxTQUFyQixHQUNIN0gsK0ZBQU8sQ0FBQy9SLElBQUQsQ0FBUCxDQUFjdkYsR0FBZCxDQUFrQnRJLEdBQWxCLEVBQXVCMG5CLFFBQXZCLEtBQW9DLElBRGpDLEdBRUg5SCwrRkFBTyxDQUFDL1IsSUFBRCxDQUFQLENBQWM4WixLQUFkLENBQW9CM25CLEdBQXBCLEVBQXlCdW5CLFVBQXpCLEVBQXFDRSxTQUFyQyxFQUFnRHJqQixLQUFoRCxDQUFzRDJELEdBQUcsSUFBSUEsR0FBN0QsQ0FGSjtBQUdELEdBTkQ7O0FBT0EsUUFBTXNKLE1BQU0sR0FBRyxNQUFNL00sT0FBTyxDQUFDd0ssR0FBUixDQUFZLENBQy9CLEdBQUcrUixJQUFJLENBQUM4QixPQUFMLENBQWE5WSxHQUFiLENBQWlCN0osR0FBRyxJQUFJd25CLE1BQU0sQ0FBQ3huQixHQUFELEVBQU0sU0FBTixDQUE5QixDQUQ0QixFQUUvQixHQUFHVCxNQUFNLENBQUMrZ0IsTUFBUCxDQUFjTyxJQUFJLENBQUMrQixTQUFuQixFQUE4Qi9ZLEdBQTlCLENBQWtDN0osR0FBRyxJQUFJd25CLE1BQU0sQ0FBQ3huQixHQUFELEVBQU0sT0FBTixDQUEvQyxDQUY0QixFQUcvQndsQixnR0FBUSxDQUFDM0UsSUFBSSxDQUFDZ0MsSUFBTixDQUFSLElBQXVCMkUsTUFBTSxDQUFDM0csSUFBSSxDQUFDZ0MsSUFBTixFQUFZLE9BQVosRUFBcUIrRSxhQUFyQixDQUhFLENBQVosQ0FBckI7O0FBS0EsTUFBSSxFQUFDTixhQUFELG9CQUFDQSxhQUFhLENBQUVPLGdCQUFoQixDQUFKLEVBQXNDO0FBQ3BDLFVBQU1yYSxLQUFLLEdBQUcsU0FBNkJzYSx3RkFBN0IsRUFBQXpXLE1BQU0sQ0FBQ3hILEdBQVAsQ0FBV2tlLGVBQVgsR0FBc0MsSUFBdEMsQ0FBZDs7QUFDQSxRQUFJdmEsS0FBSixFQUFXO0FBQ1QsWUFBTWlaLE9BQU8sR0FBR0gsNEZBQUksQ0FBQywwQkFBRCxDQUFwQjtBQUNBaG5CLHFHQUFPLENBQUNpbkIsd0dBQUQsRUFBb0I7QUFDekJyZ0IsY0FBTSxFQUFFO0FBQUVzSCxlQUFGO0FBQVNpWjtBQUFULFNBRGlCO0FBRXpCL2lCLGFBQUssRUFBRTtBQUFFcEQsWUFBRSxFQUFFMkYsTUFBTSxDQUFDeUUsS0FBUCxDQUFhcEs7QUFBbkI7QUFGa0IsT0FBcEIsQ0FBUDtBQUlBLGFBQVEsR0FBRW1tQixPQUFRLEtBQUlqWixLQUFNLEVBQTVCO0FBQ0Q7QUFDRjtBQUNGO0FBRUQ7O0FBQ0EsU0FBU29hLGFBQVQsQ0FBdUI1bkIsR0FBdkIsRUFBNEJnb0IsR0FBNUIsRUFBaUNuYSxJQUFqQyxFQUF1QztBQUNyQyxTQUFPLElBQUl2SixPQUFKLENBQVksQ0FBQzJDLE9BQUQsRUFBVTFDLE1BQVYsS0FBcUI7QUFDdEMsVUFBTTBqQixPQUFPLEdBQUd6UCxHQUFHLENBQUMwUCxlQUFKLENBQW9CLElBQUlDLElBQUosQ0FBUyxDQUFDSCxHQUFELENBQVQsRUFBZ0I7QUFBRW5hO0FBQUYsS0FBaEIsQ0FBcEIsQ0FBaEI7O0FBQ0EsVUFBTXVhLE1BQU0sR0FBSS9qQixDQUFELElBQU87QUFDcEJtVSxTQUFHLENBQUM2UCxlQUFKLENBQW9CSixPQUFwQjtBQUNBLFVBQUk1akIsQ0FBQyxDQUFDd0osSUFBRixLQUFXLE1BQWYsRUFBdUI1RyxPQUFPLEdBQTlCLEtBQ0sxQyxNQUFNLENBQUUsZ0JBQWV2RSxHQUFJLEVBQXJCLENBQU47QUFDTixLQUpEOztBQUtBLFVBQU1zb0IsS0FBSyxHQUFHLElBQUlDLEtBQUosRUFBZDtBQUNBRCxTQUFLLENBQUNFLE1BQU4sR0FBZUosTUFBZjtBQUNBRSxTQUFLLENBQUNHLE9BQU4sR0FBZ0JMLE1BQWhCO0FBQ0FFLFNBQUssQ0FBQ3BvQixHQUFOLEdBQVkrbkIsT0FBWjtBQUNELEdBWE0sQ0FBUDtBQVlEOztBQUVELFNBQVNGLGVBQVQsQ0FBeUIxakIsQ0FBekIsRUFBNEI7QUFDMUIsU0FBT0EsQ0FBQyxJQUFJLFNBQXdDeWpCLHdGQUF4QyxHQUFDempCLENBQUMsQ0FBQ2lQLE1BQUYsSUFBYSxPQUFNalAsQ0FBQyxDQUFDaVAsTUFBTyxFQUE3QixFQUFnQ2pQLENBQUMsQ0FBQ3JFLEdBQWxDLEdBQWlELEdBQWpELENBQUwsSUFBOERxRSxDQUFyRTtBQUNEOztBQUVELElBQUlxa0IsVUFBSjtBQUNBOzs7Ozs7QUFJTyxlQUFlakgsTUFBZixDQUFzQjdoQixJQUF0QixFQUE0QjtBQUNqQyxNQUFJOG9CLFVBQUosRUFBZ0IsT0FBT0EsVUFBUDtBQUNoQixNQUFJQyxRQUFRLEdBQUcsQ0FBZjtBQUNBLE1BQUlDLFdBQUo7QUFDQUYsWUFBVSxHQUFHLElBQUlwa0IsT0FBSixDQUFZdWtCLENBQUMsSUFBSTtBQUFFRCxlQUFXLEdBQUdDLENBQWQ7QUFBa0IsR0FBckMsQ0FBYjtBQUNBLFFBQU1yQyxNQUFNLEdBQUcsRUFBZjtBQUNBLFFBQU1zQyxPQUFPLEdBQUcsRUFBaEI7QUFDQSxRQUFNQyxZQUFZLEdBQUcsRUFBckI7QUFDQSxRQUFNQyxTQUFTLEdBQUcsRUFBbEI7QUFDQSxRQUFNQyxTQUFTLEdBQUcsRUFBbEI7QUFDQSxRQUFNQyxXQUFXLEdBQUcsRUFBcEI7QUFDQSxRQUFNQyxRQUFRLEdBQUcsRUFBakI7QUFDQSxRQUFNQyxRQUFRLEdBQUcsQ0FDZixDQUFDeEosK0ZBQU8sQ0FBQ3JYLEtBQVQsRUFBZ0J5Z0IsU0FBaEIsQ0FEZSxFQUVmLENBQUNwSiwrRkFBTyxDQUFDemMsS0FBVCxFQUFnQjhsQixTQUFoQixDQUZlLEVBR2YsQ0FBQ3JKLCtGQUFPLENBQUMrQyxPQUFULEVBQWtCdUcsV0FBbEIsQ0FIZSxFQUlmLENBQUN0SiwrRkFBTyxDQUFDcmMsSUFBVCxFQUFlNGxCLFFBQWYsQ0FKZSxDQUFqQjtBQU1BLE1BQUksQ0FBQ3ZwQixJQUFMLEVBQVdBLElBQUksR0FBRyxNQUFNa0UsT0FBTyxDQUFDOGIsT0FBUixDQUFnQm5QLEtBQWhCLENBQXNCcEssR0FBdEIsRUFBYjtBQUNYLFdBQU1nakIsaUdBQU4sRUFBQXpwQixJQUFJLEVBQWNxSSxHQUFELElBQVM7QUFDeEJtaEIsWUFBUSxDQUFDdkUsSUFBVCxDQUFjLENBQUMsQ0FBQ3lFLFFBQUQsRUFBV3pmLEdBQVgsQ0FBRCxLQUFxQjtBQUNqQyxZQUFNO0FBQUU0RTtBQUFGLFVBQWE2YSxRQUFuQjs7QUFDQSxVQUFJcmhCLEdBQUcsQ0FBQ3VHLFVBQUosQ0FBZUMsTUFBZixDQUFKLEVBQTRCO0FBQzFCO0FBQ0E1RSxXQUFHLENBQUM1QixHQUFHLENBQUNMLEtBQUosQ0FBVTZHLE1BQU0sQ0FBQ3pOLE1BQWpCLENBQUQsQ0FBSCxHQUFnQyxDQUFDLENBQWpDO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsYUFBTyxLQUFQO0FBQ0QsS0FSRDtBQVNELEdBVkcsQ0FBSjs7QUFXQSxRQUFNdW9CLEtBQUssR0FBRyxDQUFDcmUsR0FBRCxFQUFNakQsR0FBTixFQUFXdWhCLFFBQVgsS0FBd0I7QUFDcEMsUUFBSXRlLEdBQUcsQ0FBQ2pELEdBQUQsQ0FBSCxHQUFXLENBQWYsRUFBa0I7QUFDaEJpRCxTQUFHLENBQUNqRCxHQUFELENBQUgsR0FBVyxDQUFYO0FBQ0QsS0FGRCxNQUVPLElBQUksQ0FBQ2lELEdBQUcsQ0FBQ2pELEdBQUQsQ0FBUixFQUFlO0FBQ3BCaUQsU0FBRyxDQUFDakQsR0FBRCxDQUFILEdBQVcsSUFBSXVoQixRQUFmO0FBQ0Q7QUFDRixHQU5EOztBQU9BN0osT0FBSyxDQUFDeE8sT0FBTixDQUFjM0YsT0FBZCxDQUF1QnZGLE1BQUQsSUFBWTtBQUNoQyxVQUFNO0FBQUUzRjtBQUFGLFFBQVMyRixNQUFNLENBQUN5RSxLQUF0QjtBQUNBNmUsU0FBSyxDQUFDSixRQUFELEVBQVc3b0IsRUFBWCxFQUFlQSxFQUFmLENBQUw7QUFDQWlwQixTQUFLLENBQUNQLFNBQUQsRUFBWTFvQixFQUFaLEVBQWdCQSxFQUFoQixDQUFMO0FBQ0EsUUFBSSxDQUFDMkYsTUFBTSxDQUFDekMsTUFBUCxDQUFjZ2YsT0FBbkIsRUFBNEJrQyxZQUFZLENBQUN6ZSxNQUFELENBQVo7QUFDNUIsVUFBTTtBQUFFdWM7QUFBRixRQUFjdmMsTUFBTSxDQUFDekMsTUFBM0I7O0FBQ0F5QyxVQUFNLENBQUM0YSxJQUFQLENBQVk4QixPQUFaLENBQW9CblgsT0FBcEIsQ0FBNkJ4TCxHQUFELElBQVM7QUFDbkN1cEIsV0FBSyxDQUFDTCxXQUFELEVBQWMxRyxPQUFPLENBQUN4aUIsR0FBRCxDQUFQLElBQWdCQSxHQUE5QixFQUFtQ00sRUFBbkMsQ0FBTDtBQUNELEtBRkQ7O0FBR0EsYUFBdUJtcEIsbUdBQXZCLEVBQUF4akIsTUFBTSxDQUFDNGEsSUFBUCxDQUFZK0IsU0FBWixFQUFxQzVpQixHQUFELElBQVM7QUFDM0N1cEIsV0FBSyxDQUFDTixTQUFELEVBQVl6RyxPQUFPLENBQUN4aUIsR0FBRCxDQUFQLElBQWdCQSxHQUE1QixFQUFpQ00sRUFBakMsQ0FBTDtBQUNELEtBRkQ7QUFHQSxVQUFNO0FBQUV1aUI7QUFBRixRQUFXNWMsTUFBTSxDQUFDNGEsSUFBeEI7O0FBQ0EsUUFBSTJFLGdHQUFRLENBQUMzQyxJQUFELENBQVosRUFBb0I7QUFDbEIsWUFBTXVFLE9BQU8sR0FBRzVFLE9BQU8sQ0FBQ0ssSUFBRCxDQUFQLElBQWlCQSxJQUFqQztBQUNBMEcsV0FBSyxDQUFDTixTQUFELEVBQVk3QixPQUFaLEVBQXFCOW1CLEVBQXJCLENBQUw7QUFDRDtBQUNGLEdBakJEO0FBa0JBOG9CLFVBQVEsQ0FBQzVkLE9BQVQsQ0FBaUIsQ0FBQyxDQUFDOGQsUUFBRCxFQUFXemYsR0FBWCxDQUFELEtBQXFCO0FBQ3BDLGFBQUtmLG1HQUFMLEVBQUFlLEdBQUcsRUFBZSxDQUFDLENBQUM1QixHQUFELEVBQU1NLEtBQU4sQ0FBRCxLQUFrQjtBQUNsQyxVQUFJQSxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ2I7QUFDQXdnQixvQkFBWSxDQUFDdlksSUFBYixDQUFrQjhZLFFBQVEsQ0FBQ2xFLE1BQVQsQ0FBZ0JuZCxHQUFoQixDQUFsQjtBQUNBMGdCLGdCQUFRLElBQUksQ0FBWjtBQUNELE9BSkQsTUFJTyxJQUFJcGdCLEtBQUssSUFBSSxDQUFULElBQWMrZ0IsUUFBUSxDQUFDM0IsS0FBM0IsRUFBa0M7QUFDdkM7QUFDQW9CLG9CQUFZLENBQUN2WSxJQUFiLENBQWtCb1AsK0ZBQU8sQ0FBQ2tELEdBQVIsQ0FBWXNDLE1BQVosQ0FBbUJuZCxHQUFuQixDQUFsQjtBQUNBNmdCLGVBQU8sQ0FBQ3RZLElBQVIsQ0FBYThZLFFBQVEsQ0FBQzNCLEtBQVQsQ0FBZTFmLEdBQWYsRUFBb0I3RCxLQUFwQixDQUEwQjJELEdBQUcsSUFBSyxHQUM3QzJoQixxR0FBYSxDQUFDM0ksYUFBYSxDQUFDeFksS0FBSyxHQUFHLENBQVQsQ0FBZCxDQUNkLEtBQ0N3ZixlQUFlLENBQUNoZ0IsR0FBRCxDQUNoQixFQUpZLENBQWI7QUFLQTRnQixnQkFBUSxJQUFJLENBQVo7QUFDRDtBQUNGLEtBZkUsQ0FBSDtBQWdCRCxHQWpCRDs7QUFrQkEsTUFBSUEsUUFBSixFQUFjO0FBQ1osVUFBTS9JLCtGQUFPLENBQUNsVSxJQUFSLENBQWFxWCxXQUFiLENBQXlCZ0csWUFBekIsQ0FBTixDQURZLENBQ2tDOztBQUM5Q3ZDLFVBQU0sQ0FBQ25WLE1BQVAsR0FBZ0IsQ0FBQyxNQUFNL00sT0FBTyxDQUFDd0ssR0FBUixDQUFZZ2EsT0FBWixDQUFQLEVBQTZCeFgsTUFBN0IsQ0FBb0NDLE9BQXBDLENBQWhCO0FBQ0Q7O0FBQ0RtWCxZQUFVLEdBQUcsSUFBYjtBQUNBbEMsUUFBTSxDQUFDbUQsS0FBUCxHQUFlaEIsUUFBZjtBQUNBQyxhQUFXLENBQUNwQyxNQUFELENBQVg7QUFDQSxTQUFPQSxNQUFQO0FBQ0Q7QUFFRDs7Ozs7OztBQU1BOzs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7O0FDeHVCQTtBQUFBO0FBQWUsU0FBU3haLGVBQVQsR0FBMkI7QUFDeEMsUUFBTUQsTUFBTSxHQUFHLEVBQWY7QUFDQSxTQUFPO0FBQUU2YyxNQUFGO0FBQU1DLE9BQU47QUFBV0M7QUFBWCxHQUFQOztBQUVBLFdBQVNGLEVBQVQsQ0FBWS9iLElBQVosRUFBa0JrYyxJQUFsQixFQUF3QjtBQUN0QixRQUFJNWpCLElBQUksR0FBRzRHLE1BQU0sQ0FBQ2MsSUFBRCxDQUFqQjs7QUFDQSxRQUFJLENBQUMxSCxJQUFMLEVBQVc7QUFDVEEsVUFBSSxHQUFHLEVBQVA7QUFDQTRHLFlBQU0sQ0FBQ2MsSUFBRCxDQUFOLEdBQWUxSCxJQUFmO0FBQ0Q7O0FBQ0RBLFFBQUksQ0FBQ3FLLElBQUwsQ0FBVXVaLElBQVY7QUFDRDs7QUFDRCxXQUFTRixHQUFULENBQWFoYyxJQUFiLEVBQW1Ca2MsSUFBbkIsRUFBeUI7QUFDdkIsVUFBTTVqQixJQUFJLEdBQUc0RyxNQUFNLENBQUNjLElBQUQsQ0FBbkI7O0FBQ0EsUUFBSTFILElBQUosRUFBVTtBQUNSLFlBQU1zQixDQUFDLEdBQUd0QixJQUFJLENBQUN1QixPQUFMLENBQWFxaUIsSUFBYixDQUFWO0FBQ0EsVUFBSXRpQixDQUFDLElBQUksQ0FBVCxFQUFZdEIsSUFBSSxDQUFDOGEsTUFBTCxDQUFZeFosQ0FBWixFQUFlLENBQWY7QUFDYjtBQUNGOztBQUNELFdBQVNxaUIsSUFBVCxDQUFjamMsSUFBZCxFQUFvQmpPLElBQXBCLEVBQTBCO0FBQ3hCLFVBQU11RyxJQUFJLEdBQUc0RyxNQUFNLENBQUNjLElBQUQsQ0FBbkI7O0FBQ0EsUUFBSTFILElBQUosRUFBVTtBQUNSQSxVQUFJLENBQUNxRixPQUFMLENBQWN1ZSxJQUFELElBQVU7QUFDckJBLFlBQUksQ0FBQ25xQixJQUFELEVBQU9pTyxJQUFQLENBQUo7QUFDRCxPQUZEO0FBR0Q7QUFDRjtBQUNGLEM7Ozs7Ozs7Ozs7OztBQzNCRDtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUFtYyxvREFBYyxDQUFDeFosSUFBZixDQUFvQixNQUFNO0FBQ3hCMU0sU0FBTyxDQUFDckUsUUFBUixDQUFpQndxQixTQUFqQixDQUEyQmhtQixXQUEzQixDQUF3Qy9CLEdBQUQsSUFBUztBQUM5QyxRQUFJQSxHQUFHLEtBQUssV0FBWixFQUF5QjtBQUN2QnpDLHVEQUFRLENBQUN5cUIsVUFBVDtBQUNELEtBRkQsTUFFTztBQUNMLFlBQU1DLEtBQUssR0FBR2pvQixHQUFHLEtBQUssVUFBUixHQUFzQixJQUFHQSxHQUFJLEVBQTdCLEdBQWlDLEVBQS9DO0FBQ0F6Qyx1REFBUSxDQUFDMnFCLE9BQVQsQ0FBaUI7QUFBRXBxQixXQUFHLEVBQUcsc0JBQXFCbXFCLEtBQU07QUFBbkMsT0FBakI7QUFDRDtBQUNGLEdBUEQ7QUFRRCxDQVRELEU7Ozs7Ozs7Ozs7OztBQ0hBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0NBR0E7O0FBQ0EsTUFBTUUsY0FBYyxHQUFHLElBQXZCO0FBRUE5cUIsTUFBTSxDQUFDQyxNQUFQLENBQWNDLGlEQUFkLEVBQXdCO0FBQ3RCLFFBQU02cUIsWUFBTixDQUFtQnRxQixHQUFuQixFQUF3QjtBQUN0QixVQUFNaUksR0FBRyxHQUFJLGdCQUFlakksR0FBSSxFQUFoQztBQUNBLFdBQU9tRCw4Q0FBSyxDQUFDa0QsR0FBTixDQUFVNEIsR0FBVixLQUNGOUUsOENBQUssQ0FBQzBOLEdBQU4sQ0FBVTVJLEdBQVYsRUFBZXNpQixhQUFhLENBQUN2cUIsR0FBRCxFQUFNO0FBQUV3cUIsWUFBTSxFQUFFO0FBQVYsS0FBTixDQUFiLENBQXFDcG1CLEtBQXJDLENBQTJDb0ksb0ZBQTNDLENBQWYsRUFBaUU2ZCxjQUFqRSxDQURMO0FBRUQsR0FMcUI7O0FBTXRCSSxVQUFRLEVBQUVDO0FBTlksQ0FBeEIsRSxDQVNBOztBQUVBLE1BQU1DLGFBQWEsR0FBRyxDQUFDLE1BQU07QUFDM0IsUUFBTTtBQUFFN2xCO0FBQUYsTUFBYWxCLE1BQW5CLENBRDJCLENBRTNCOztBQUNBLFFBQU1pQixHQUFHLEdBQUdDLE1BQU0sQ0FBQzZsQixhQUFuQixDQUgyQixDQUkzQjs7QUFDQSxRQUFNQyxZQUFZLEdBQUcsTUFBTTlsQixNQUFNLENBQUNmLE9BQVAsQ0FBZThtQixTQUExQyxDQUwyQixDQU0zQjs7O0FBQ0EsUUFBTUMsVUFBVSxHQUFHQyxFQUFFLElBQUksQ0FBQyxHQUFHNW1CLElBQUosS0FBYTtBQUNwQyxRQUFJO0FBQ0YsZUFBSzRtQixFQUFMLEVBQUFsbUIsR0FBRyxFQUFLLEdBQUdWLElBQVIsRUFBY3ltQixZQUFkLENBQUg7QUFDRCxLQUZELENBRUUsT0FBT3ZtQixDQUFQLEVBQVU7QUFDVixlQUFLMG1CLEVBQUwsRUFBQWxtQixHQUFHLEVBQUssR0FBR1YsSUFBUixDQUFIO0FBQ0Q7QUFDRixHQU5EOztBQU9BLFNBQU93Ryx5R0FBVSxDQUFDOUYsR0FBRCxFQUFNLENBQ3JCLFNBRHFCLEVBRXJCLGNBRnFCLEVBR3JCLHlCQUhxQixFQUlyQixVQUpxQixDQUFOLEVBS2RrbUIsRUFBRSxJQUFLQSxFQUFFLEdBQUdELFVBQVUsQ0FBQ0MsRUFBRCxDQUFiLEdBQW9CdmUsb0ZBTGYsQ0FBakI7QUFNRCxDQXBCcUIsR0FBdEI7O0FBc0JBLE1BQU13ZSxNQUFNLEdBQUcsRUFBZjtBQUNBLE1BQU1DLGNBQWMsR0FBRyxXQUF2QjtBQUNBLE1BQU1DLGNBQWMsR0FBRyxXQUF2QjtBQUNBLE1BQU1DLGVBQWUsR0FBRyxZQUF4QjtBQUNBLE1BQU1DLHVCQUF1QixHQUFHLG1CQUFoQztBQUNBOztBQUNBLElBQUlDLFNBQUo7QUFDQTs7QUFDQSxJQUFJQyxTQUFKO0FBQ0E7O0FBQ0EsSUFBSUMsVUFBSjtBQUNBOztBQUNBLElBQUlDLGlCQUFKO0FBQ0E7O0FBQ0EsSUFBSUMsZ0JBQUo7QUFDQTs7QUFDQSxJQUFJQyxrQkFBSixDLENBRUE7QUFDQTs7QUFDQSxNQUFNQyxTQUFTLEdBQUcsQ0FBQ3puQixVQUFELElBQWUsRUFBakM7QUFFQWpGLDREQUFXLENBQUVDLE9BQUQsSUFBYTtBQUN2QixNQUFJOEosQ0FBSjtBQUNBLFFBQU00aUIsSUFBSSxHQUFHLEVBQWI7O0FBQ0EsTUFBSSxDQUFDNWlCLENBQUMsR0FBRzlKLE9BQU8sQ0FBQytyQixjQUFELENBQVosS0FBaUMsSUFBckMsRUFBMkM7QUFDekNJLGFBQVMsR0FBR3JpQixDQUFaO0FBQ0E2aUIsV0FBTyxHQUZrQyxDQUU5Qjs7QUFDWEQsUUFBSSxDQUFDcGIsSUFBTCxDQUFVcWIsT0FBVixFQUh5QyxDQUdyQjtBQUNyQjs7QUFDRCxNQUFJLENBQUM3aUIsQ0FBQyxHQUFHOUosT0FBTyxDQUFDZ3NCLGNBQUQsQ0FBWixLQUFpQyxJQUFyQyxFQUEyQztBQUN6Q0ksYUFBUyxHQUFHdGlCLENBQVo7QUFDQTRpQixRQUFJLENBQUNwYixJQUFMLENBQVVzYixXQUFWO0FBQ0Q7O0FBQ0QsTUFBSSxDQUFDOWlCLENBQUMsR0FBRzlKLE9BQU8sQ0FBQ2lzQixlQUFELENBQVosTUFBbUNJLFVBQVUsR0FBR3ZpQixDQUFoRCxLQUNELENBQUNBLENBQUMsR0FBRzlKLE9BQU8sQ0FBQ2tzQix1QkFBRCxDQUFaLE1BQTJDSSxpQkFBaUIsR0FBR3hpQixDQUEvRCxDQURILEVBQ3NFO0FBQ3BFNGlCLFFBQUksQ0FBQ3BiLElBQUwsQ0FBVXViLGdCQUFWO0FBQ0Q7O0FBQ0QsTUFBSSxlQUFlN3NCLE9BQW5CLEVBQTRCO0FBQzFCMHNCLFFBQUksQ0FBQ3BiLElBQUwsQ0FBVXdiLFdBQVY7QUFDRDs7QUFDRCxNQUFJSixJQUFJLENBQUM1cUIsTUFBVCxFQUFpQjtBQUNmaXJCLCtEQUFVLENBQUM3ckIsR0FBRyxJQUFJd3JCLElBQUksQ0FBQ3BnQixPQUFMLENBQWF1ZixFQUFFLElBQUlBLEVBQUUsQ0FBQzNxQixHQUFELENBQXJCLENBQVIsQ0FBVjtBQUNEO0FBQ0YsQ0F0QlUsQ0FBWDtBQXdCQTRwQixvREFBYyxDQUFDeFosSUFBZixDQUFvQixNQUFNO0FBQ3hCNmEsV0FBUyxHQUFHL29CLDBEQUFTLENBQUMyb0IsY0FBRCxDQUFyQjtBQUNBSyxXQUFTLEdBQUdocEIsMERBQVMsQ0FBQzRvQixjQUFELENBQXJCO0FBQ0FLLFlBQVUsR0FBR2pwQiwwREFBUyxDQUFDNm9CLGVBQUQsQ0FBdEI7QUFDQUssbUJBQWlCLEdBQUdscEIsMERBQVMsQ0FBQzhvQix1QkFBRCxDQUE3QjtBQUNBSyxrQkFBZ0IsR0FBR25GLDRGQUFJLENBQUMsMEJBQUQsQ0FBdkI7QUFDQW9GLG9CQUFrQixHQUFHcEYsNEZBQUksQ0FBQyw0QkFBRCxDQUF6QjtBQUNBMkYsNkRBQVUsQ0FBQ0QsV0FBRCxDQUFWO0FBQ0EsTUFBSSxDQUFDWCxTQUFMLEVBQWdCUSxPQUFPLEdBUkMsQ0FRRztBQUM1QixDQVREO0FBV0EvbkIsT0FBTyxDQUFDd08sSUFBUixDQUFhNFosU0FBYixDQUF1QmpvQixXQUF2QixDQUFvQzNELEVBQUQsSUFBUTtBQUN6QyxTQUFPMHFCLE1BQU0sQ0FBQzFxQixFQUFELENBQWI7QUFDRCxDQUZEO0FBSUF3RCxPQUFPLENBQUN3TyxJQUFSLENBQWE2WixTQUFiLENBQXVCbG9CLFdBQXZCLENBQW1DLENBQUM1RCxLQUFELEVBQVFxRSxJQUFSLEVBQWN0RSxHQUFkLEtBQXNCO0FBQ3ZELFFBQU07QUFBRUo7QUFBRixNQUFVMEUsSUFBaEI7O0FBQ0EsTUFBSUEsSUFBSSxDQUFDNE8sTUFBTCxLQUFnQixTQUFoQixDQUNBO0FBREEsS0FFRzVPLElBQUksQ0FBQzBuQixVQUFMLElBQW1CaHNCLEdBQUcsQ0FBQ0osR0FBSixDQUFRd08sVUFBUixDQUFtQixRQUFuQixDQUYxQixFQUV3RDtBQUN0RHdkLGVBQVcsQ0FBQzVyQixHQUFELEVBQU1KLEdBQU4sQ0FBWDtBQUNEO0FBQ0YsQ0FQRDs7QUFTQSxTQUFTMHFCLFFBQVQsQ0FBa0IvcUIsR0FBbEIsRUFBdUI7QUFBRVMsS0FBRjtBQUFPRDtBQUFQLENBQXZCLEVBQXlDO0FBQ3ZDLFFBQU1FLEtBQUssR0FBR0QsR0FBRyxDQUFDRSxFQUFsQjtBQUNBLFFBQU1WLElBQUksR0FBR29yQixNQUFNLENBQUMzcUIsS0FBRCxDQUFOLElBQWlCLEVBQTlCOztBQUNBLE1BQUksQ0FBQ1QsSUFBSSxDQUFDa2lCLEtBQU4sSUFBZTNoQixPQUFPLEtBQUssQ0FBL0IsRUFBa0M7QUFDaEM7QUFDQTtBQUNBUCxRQUFJLENBQUMrTSxLQUFMLEdBQWEsQ0FBYjtBQUNBL00sUUFBSSxDQUFDeXNCLE1BQUwsR0FBYyxDQUFkO0FBQ0F6c0IsUUFBSSxDQUFDa2lCLEtBQUwsR0FBYSxFQUFiO0FBQ0FrSixVQUFNLENBQUMzcUIsS0FBRCxDQUFOLEdBQWdCVCxJQUFoQjtBQUNEOztBQUNEQSxNQUFJLENBQUMrTSxLQUFMLElBQWNoTixHQUFHLENBQUNxQixNQUFsQjs7QUFDQSxNQUFJckIsR0FBSixFQUFTO0FBQ1BBLE9BQUcsQ0FBQzZMLE9BQUosQ0FBYWxMLEVBQUQsSUFBUTtBQUNsQlYsVUFBSSxDQUFDa2lCLEtBQUwsQ0FBV3hoQixFQUFYLElBQWlCLENBQWpCO0FBQ0QsS0FGRDtBQUdBVixRQUFJLENBQUN5c0IsTUFBTCxHQUFjOXNCLE1BQU0sQ0FBQzRJLElBQVAsQ0FBWXZJLElBQUksQ0FBQ2tpQixLQUFqQixFQUF3QjlnQixNQUF0QztBQUNEOztBQUNEK3FCLGtCQUFnQixDQUFDM3JCLEdBQUQsRUFBTVIsSUFBTixDQUFoQjtBQUNBa3NCLGFBQVcsQ0FBQzFyQixHQUFELEVBQU1SLElBQU4sQ0FBWDtBQUNEOztBQUVELFNBQVNrc0IsV0FBVCxDQUFxQjFyQixHQUFyQixFQUEwQlIsSUFBSSxHQUFHb3JCLE1BQU0sQ0FBQzVxQixHQUFHLENBQUNFLEVBQUwsQ0FBdkMsRUFBaUQ7QUFDL0MsTUFBSVYsSUFBSixFQUFVO0FBQ1IrcUIsaUJBQWEsQ0FBQzJCLFlBQWQsQ0FBMkI7QUFDekI3VSxVQUFJLEVBQUcsR0FBRTdYLElBQUksQ0FBQzByQixTQUFELENBQUosSUFBbUIsRUFBRyxFQUROO0FBRXpCanJCLFdBQUssRUFBRUQsR0FBRyxDQUFDRTtBQUZjLEtBQTNCO0FBSUQ7QUFDRjs7QUFFRCxTQUFTeXJCLGdCQUFULENBQTBCM3JCLEdBQTFCLEVBQStCUixJQUFJLEdBQUdvckIsTUFBTSxDQUFDNXFCLEdBQUcsQ0FBQ0UsRUFBTCxDQUE1QyxFQUFzRDtBQUNwRCxNQUFJVixJQUFKLEVBQVU7QUFDUitxQixpQkFBYSxDQUFDNEIsdUJBQWQsQ0FBc0M7QUFDcENDLFdBQUssRUFBRTVzQixJQUFJLENBQUM2c0IsT0FBTCxHQUFlakIsaUJBQWYsR0FBbUNELFVBRE47QUFFcENsckIsV0FBSyxFQUFFRCxHQUFHLENBQUNFO0FBRnlCLEtBQXRDO0FBSUQ7QUFDRixDLENBRUQ7QUFDQTs7O0FBQ0EsU0FBUzByQixXQUFULENBQXFCNXJCLEdBQXJCLEVBQTBCSixHQUFHLEdBQUdJLEdBQUcsQ0FBQ2tCLFVBQUosSUFBa0JsQixHQUFHLENBQUNKLEdBQXRELEVBQTJEO0FBQ3pELFFBQU1LLEtBQUssR0FBR0QsR0FBRyxDQUFDRSxFQUFsQjtBQUNBLFFBQU1vc0IsVUFBVSxHQUFHQyw0R0FBcUIsQ0FBQ3BsQixJQUF0QixDQUEyQnZILEdBQTNCLENBQW5CO0FBQ0EsUUFBTTRzQixXQUFXLEdBQUdGLFVBQVUsR0FBR3RJLDZEQUFhLENBQUNwa0IsR0FBRCxDQUFoQixHQUF3Qm9aLFNBQXREO0FBQ0EsUUFBTXJFLEtBQUssR0FBRzZYLFdBQVcsSUFBSW5CLGdCQUFmLElBQW1DLENBQUNpQixVQUFELElBQWVoQixrQkFBbEQsSUFBd0UsRUFBdEYsQ0FKeUQsQ0FLekQ7QUFDQTs7QUFDQSxNQUFJM1csS0FBSyxJQUFJLENBQUNpVyxNQUFNLENBQUMzcUIsS0FBRCxDQUFOLElBQWlCLEVBQWxCLEVBQXNCb3NCLE9BQW5DLEVBQTRDO0FBQzFDOUIsaUJBQWEsQ0FBQ2tDLFFBQWQsQ0FBdUI7QUFBRTlYLFdBQUY7QUFBUzFVO0FBQVQsS0FBdkI7QUFDQSxVQUFNVCxJQUFJLEdBQUdtVixLQUFLLEdBQUc7QUFBRTBYLGFBQU8sRUFBRTtBQUFYLEtBQUgsR0FBdUIsRUFBekM7QUFDQXpCLFVBQU0sQ0FBQzNxQixLQUFELENBQU4sR0FBZ0JULElBQWhCO0FBQ0Fpc0IsV0FBTyxDQUFDenJCLEdBQUQsRUFBTVIsSUFBTixDQUFQO0FBQ0Frc0IsZUFBVyxDQUFDMXJCLEdBQUQsRUFBTVIsSUFBTixDQUFYO0FBQ0Q7QUFDRjs7QUFFRCxlQUFlaXNCLE9BQWYsQ0FBdUJ6ckIsR0FBRyxHQUFHLEVBQTdCLEVBQWlDUixJQUFJLEdBQUcsRUFBeEMsRUFBNEM7QUFDMUM7QUFDQSxRQUFNa2pCLEdBQUcsR0FBR2xqQixJQUFJLENBQUM2c0IsT0FBTCxJQUFnQixHQUFoQixJQUF1QixDQUFDcEIsU0FBRCxJQUFjLEdBQXJDLElBQTRDLEVBQXhEO0FBQ0EsUUFBTXlCLFFBQVEsR0FBRyxFQUFqQjs7QUFDQSxPQUFLLE1BQU1DLENBQVgsSUFBZ0IsQ0FBQyxFQUFELEVBQUssRUFBTCxFQUFTLEVBQVQsRUFBYSxFQUFiLENBQWhCLEVBQWtDO0FBQ2hDLFVBQU12WixJQUFJLEdBQUksc0JBQXFCdVosQ0FBRSxHQUFFakssR0FBSSxNQUEzQztBQUNBLFFBQUlELElBQUksR0FBRzhJLFNBQVMsR0FBR0EsU0FBUyxDQUFDblksSUFBRCxDQUFaLEdBQXFCQSxJQUF6Qzs7QUFDQSxRQUFJLENBQUNxUCxJQUFMLEVBQVc7QUFDVEEsVUFBSSxHQUFHLE1BQU0wSCxhQUFhLENBQUMvVyxJQUFELENBQTFCO0FBQ0FtWSxlQUFTLENBQUNuWSxJQUFELENBQVQsR0FBa0JxUCxJQUFsQjtBQUNEOztBQUNEaUssWUFBUSxDQUFDQyxDQUFELENBQVIsR0FBY2xLLElBQWQ7QUFDRDs7QUFDRDhILGVBQWEsQ0FBQ2tCLE9BQWQsQ0FBc0I7QUFDcEJ4ckIsU0FBSyxFQUFFRCxHQUFHLENBQUNFLEVBRFM7QUFFcEIsS0FBQ3FyQixTQUFTLEdBQUcsV0FBSCxHQUFpQixNQUEzQixHQUFvQ21CO0FBRmhCLEdBQXRCO0FBSUQ7O0FBRUQsU0FBU3ZDLGFBQVQsQ0FBdUIvVyxJQUF2QixFQUE2QjtBQUFFZ1g7QUFBRixJQUFhLEVBQTFDLEVBQThDO0FBQzVDLFNBQU8sSUFBSWxtQixPQUFKLENBQVksQ0FBQzJDLE9BQUQsRUFBVTFDLE1BQVYsS0FBcUI7QUFDdEMsVUFBTXlvQixHQUFHLEdBQUcsSUFBSXpFLEtBQUosRUFBWjtBQUNBeUUsT0FBRyxDQUFDOXNCLEdBQUosR0FBVXNULElBQVY7O0FBQ0F3WixPQUFHLENBQUN4RSxNQUFKLEdBQWEsTUFBTTtBQUNqQixZQUFNO0FBQUV5RSxhQUFGO0FBQVNDO0FBQVQsVUFBb0JGLEdBQTFCOztBQUNBLFVBQUksQ0FBQ0MsS0FBTCxFQUFZO0FBQUU7QUFDWmhtQixlQUFPLENBQUN1TSxJQUFELENBQVA7QUFDQTtBQUNEOztBQUNELFlBQU0yWixNQUFNLEdBQUduTyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBLFlBQU1tTyxHQUFHLEdBQUdELE1BQU0sQ0FBQ0UsVUFBUCxDQUFrQixJQUFsQixDQUFaO0FBQ0FGLFlBQU0sQ0FBQ0YsS0FBUCxHQUFlQSxLQUFmO0FBQ0FFLFlBQU0sQ0FBQ0QsTUFBUCxHQUFnQkEsTUFBaEI7QUFDQUUsU0FBRyxDQUFDRSxTQUFKLENBQWNOLEdBQWQsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUJDLEtBQXpCLEVBQWdDQyxNQUFoQztBQUNBam1CLGFBQU8sQ0FBQ3VqQixNQUFNLEdBQUcyQyxNQUFNLENBQUNJLFNBQVAsRUFBSCxHQUF3QkgsR0FBRyxDQUFDSSxZQUFKLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCUCxLQUF2QixFQUE4QkMsTUFBOUIsQ0FBL0IsQ0FBUDtBQUNELEtBWkQ7O0FBYUFGLE9BQUcsQ0FBQ3ZFLE9BQUosR0FBY2xrQixNQUFkO0FBQ0QsR0FqQk0sQ0FBUDtBQWtCRCxDOzs7Ozs7Ozs7Ozs7QUNuTkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFPLE1BQU1rcEIsYUFBYSxHQUFHM3BCLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQjJwQixNQUFoQixDQUF1QixHQUF2QixDQUF0QjtBQUVBLE1BQU1oTSxhQUFhLEdBQUcsRUFBdEI7QUFDQSxNQUFNc0ksY0FBYyxHQUFHLEVBQXZCO0FBRUEsZUFBZXJtQixVQUFmLENBQTBCZ3FCLElBQTFCLEVBQWdDO0FBQ3JDLFFBQU1DLEdBQUcsR0FBR25sQixJQUFJLElBQUssT0FBT0EsSUFBUCxLQUFnQixVQUFoQixHQUE2QkEsSUFBSSxFQUFqQyxHQUFzQ0EsSUFBM0Q7O0FBQ0EsUUFBTW5FLE9BQU8sQ0FBQ3dLLEdBQVIsQ0FBWTRTLGFBQWEsQ0FBQzdYLEdBQWQsQ0FBa0IrakIsR0FBbEIsQ0FBWixDQUFOO0FBQ0EsUUFBTUEsR0FBRyxDQUFDRCxJQUFELENBQVQ7QUFDQSxRQUFNcnBCLE9BQU8sQ0FBQ3dLLEdBQVIsQ0FBWWtiLGNBQWMsQ0FBQ25nQixHQUFmLENBQW1CK2pCLEdBQW5CLENBQVosQ0FBTjtBQUNBbE0sZUFBYSxDQUFDMWdCLE1BQWQsR0FBdUIsQ0FBdkI7QUFDQWdwQixnQkFBYyxDQUFDaHBCLE1BQWYsR0FBd0IsQ0FBeEI7QUFDRCxDOzs7Ozs7Ozs7Ozs7QUNaRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTs7Ozs7QUFNQTtBQUNBO0NBQytEOztBQUMvRDtBQUVBLElBQUk2c0IsTUFBTSxHQUFHLEVBQWI7QUFDQSxJQUFJQyxVQUFVLEdBQUcsRUFBakI7QUFDQSxJQUFJQyxhQUFhLEdBQUcsRUFBcEIsQyxDQUVBOztBQUNBLE1BQU1DLEdBQUcsR0FBRztBQUNWM2EsUUFBTSxFQUFFLEVBREU7QUFDRTtBQUNaaE0sS0FBRyxFQUFFLEVBRks7QUFFRDtBQUNUNG1CLElBQUUsRUFBRSxFQUhNO0FBR0Y7QUFDUmhtQixLQUFHLEVBQUUsRUFKSztBQUlEO0FBQ1RpbUIsV0FBUyxFQUFFLElBTEQ7QUFLTztBQUNqQkMsZ0JBQWMsRUFBRSxVQUFVQyxHQUFWLEVBQWU7QUFDN0IsV0FBTyxJQUFJQyxXQUFKLEdBQWtCQyxNQUFsQixDQUF5QkYsR0FBekIsQ0FBUDtBQUNEO0FBUlMsQ0FBWjtBQVdPLE1BQU1HLFlBQVksR0FBRyxVQUFVM04sSUFBVixFQUFnQjtBQUMxQztBQUNBaU4sUUFBTSxHQUFHLEVBQVQ7QUFDQUMsWUFBVSxHQUFHLEVBQWI7QUFDQUMsZUFBYSxHQUFHLEVBQWhCO0FBRUEsUUFBTVMsSUFBSSxHQUFHNU4sSUFBSSxDQUFDaGhCLElBQUwsQ0FBVSxDQUFWLENBQWI7QUFDQSxRQUFNdW5CLE9BQU8sR0FBR3ZHLElBQUksQ0FBQzVnQixHQUFyQjtBQUNBLE1BQUl5dUIsS0FBSyxHQUFHLENBQVo7QUFDQUQsTUFBSSxDQUFDM21CLEtBQUwsQ0FBVyxJQUFYLEVBQWlCMkQsT0FBakIsQ0FBMEJrakIsSUFBRCxJQUFVO0FBQ2pDLFFBQUlELEtBQUssR0FBRyxDQUFSLElBQWFaLE1BQU0sQ0FBQzdzQixNQUFQLElBQWlCeXRCLEtBQWxDLEVBQXlDOztBQUN6QyxRQUFJQyxJQUFJLENBQUNDLFdBQUwsR0FBbUJqbkIsT0FBbkIsQ0FBMkIsS0FBM0IsSUFBb0MsQ0FBQyxDQUF6QyxFQUE0QztBQUMxQ21tQixZQUFNLENBQUNyZCxJQUFQLENBQVlvZSxLQUFLLENBQUNGLElBQUQsRUFBT3ZILE9BQVAsQ0FBakI7QUFDQTJHLGdCQUFVLENBQUN0ZCxJQUFYLENBQWdCO0FBQ2R1RSxhQUFLLEVBQUUyWixJQURPO0FBRWRwYixjQUFNLEVBQUU7QUFGTSxPQUFoQjtBQUlEO0FBQ0YsR0FURCxFQVQwQyxDQW9CMUM7O0FBRUEsTUFBSWtiLElBQUksQ0FBQzltQixPQUFMLENBQWEsWUFBYixJQUE2QixDQUFDLENBQWxDLEVBQXFDO0FBQ25DO0FBQ0FzbUIsT0FBRyxDQUFDM2EsTUFBSixHQUFhLENBQUNtYixJQUFJLENBQUNodEIsS0FBTCxDQUFXLHNCQUFYLEtBQXNDLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxFQUFULENBQXZDLEVBQXFELENBQXJELENBQWI7QUFDQXdzQixPQUFHLENBQUMzbUIsR0FBSixHQUFVLENBQUNtbkIsSUFBSSxDQUFDaHRCLEtBQUwsQ0FBVyxtQkFBWCxLQUFtQyxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxDQUFwQyxFQUFrRCxDQUFsRCxDQUFWO0FBQ0F3c0IsT0FBRyxDQUFDM21CLEdBQUosR0FBVXVuQixLQUFLLENBQUNaLEdBQUcsQ0FBQzNtQixHQUFMLEVBQVU4ZixPQUFWLENBQWY7QUFDQTZHLE9BQUcsQ0FBQ0MsRUFBSixHQUFTLENBQUNPLElBQUksQ0FBQ2h0QixLQUFMLENBQVcsa0JBQVgsS0FBa0MsQ0FBQyxFQUFELEVBQUssRUFBTCxFQUFTLEVBQVQsQ0FBbkMsRUFBaUQsQ0FBakQsQ0FBVDtBQUNBd3NCLE9BQUcsQ0FBQ0MsRUFBSixHQUFTRCxHQUFHLENBQUNDLEVBQUosR0FBU0QsR0FBRyxDQUFDRyxjQUFKLENBQW1CSCxHQUFHLENBQUNDLEVBQXZCLENBQVQsR0FBc0MsRUFBL0MsQ0FObUMsQ0FRbkM7O0FBQ0FZLFVBQU0sQ0FBQyxNQUFNO0FBQ1hDLGdCQUFVLENBQUNsTyxJQUFELENBQVY7QUFDRCxLQUZLLENBQU47QUFHRCxHQVpELE1BWU8sSUFBSWlOLE1BQU0sQ0FBQzdzQixNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQzVCO0FBQ0E4dEIsY0FBVSxDQUFDbE8sSUFBRCxDQUFWO0FBQ0QsR0FITSxNQUdBO0FBQ0xuYyxXQUFPLENBQUNDLElBQVIsQ0FBYSxhQUFiO0FBQ0Q7QUFDRixDQXhDTTs7QUEwQ1AsTUFBTW1xQixNQUFNLEdBQUcsVUFBVS9XLFFBQVYsRUFBb0I7QUFDakNpWCxNQUFJLENBQUM7QUFDSC91QixPQUFHLEVBQUVndUIsR0FBRyxDQUFDM21CLEdBRE47QUFFSDJuQixXQUFPLEVBQUcvbUIsR0FBRCxJQUFTO0FBQ2hCK2xCLFNBQUcsQ0FBQy9sQixHQUFKLEdBQVVBLEdBQVY7QUFDQStsQixTQUFHLENBQUNFLFNBQUosR0FBZ0IsSUFBSWpVLDJEQUFKLEVBQWhCO0FBQ0ErVCxTQUFHLENBQUNFLFNBQUosQ0FBY3RpQixXQUFkO0FBQ0FvaUIsU0FBRyxDQUFDRSxTQUFKLENBQWNwUyxTQUFkLENBQXdCa1MsR0FBRyxDQUFDL2xCLEdBQTVCO0FBQ0E2UCxjQUFRO0FBQ1QsS0FSRTtBQVNIbVgsUUFBSSxFQUFFLE1BQU07QUFDVnhxQixhQUFPLENBQUNDLElBQVIsQ0FBYSxZQUFiO0FBQ0Q7QUFYRSxHQUFELENBQUo7QUFhRCxDQWREOztBQWdCQSxNQUFNa3FCLEtBQUssR0FBRyxVQUFVTSxLQUFWLEVBQWlCQyxPQUFqQixFQUEwQjtBQUN0QyxNQUFJRCxLQUFLLENBQUMxZ0IsVUFBTixDQUFpQixNQUFqQixDQUFKLEVBQThCO0FBQzVCLFdBQU8wZ0IsS0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWEsR0FBakIsRUFBc0I7QUFDM0IsUUFBSXp0QixNQUFNLEdBQUcwdEIsT0FBTyxDQUFDdG5CLEtBQVIsQ0FBYyxHQUFkLENBQWI7QUFDQSxXQUFPcEcsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZLElBQVosR0FBbUJBLE1BQU0sQ0FBQyxDQUFELENBQXpCLEdBQStCeXRCLEtBQXRDO0FBQ0QsR0FITSxNQUdBO0FBQ0wsUUFBSXp0QixNQUFNLEdBQUcwdEIsT0FBTyxDQUFDdG5CLEtBQVIsQ0FBYyxHQUFkLENBQWI7QUFDQXBHLFVBQU0sQ0FBQ3FkLEdBQVA7QUFDQSxXQUFPcmQsTUFBTSxDQUFDa1UsSUFBUCxDQUFZLEdBQVosSUFBbUIsR0FBbkIsR0FBeUJ1WixLQUFoQztBQUNEO0FBQ0YsQ0FYRCxDLENBYUE7OztBQUNBLE1BQU1FLFNBQVMsR0FBRyxVQUFVeHZCLElBQVYsRUFBZ0JvaEIsS0FBaEIsRUFBdUI7QUFDdkMsTUFBSWlOLEVBQUUsR0FBR0QsR0FBRyxDQUFDQyxFQUFKLElBQVUsSUFBSW9CLFVBQUosQ0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDck8sS0FBOUMsQ0FBZixDQUFuQjtBQUNBLFNBQU9nTixHQUFHLENBQUNFLFNBQUosQ0FBY3RSLE9BQWQsQ0FBc0JoZCxJQUF0QixFQUE0QixDQUE1QixFQUErQnF1QixFQUFFLENBQUN0VSxNQUFILElBQWFzVSxFQUE1QyxFQUFnRCxJQUFoRCxDQUFQO0FBQ0QsQ0FIRCxDLENBS0E7OztBQUNBLE1BQU1hLFVBQVUsR0FBRyxVQUFVbE8sSUFBVixFQUFnQjtBQUNqQyxNQUFJSSxLQUFLLEdBQUcsQ0FBWjtBQUNBLE1BQUlzTyxLQUFLLEdBQUcsQ0FBWjs7QUFDQSxNQUFJQyxRQUFRLEdBQUcsTUFBTTtBQUNuQixVQUFNOW5CLENBQUMsR0FBR3VaLEtBQVY7QUFDQUEsU0FBSzs7QUFDTCxRQUFJdlosQ0FBQyxJQUFJb21CLE1BQU0sQ0FBQzdzQixNQUFoQixFQUF3QjtBQUN0QjtBQUNBLFlBQU13dUIsUUFBUSxHQUFHMUIsVUFBVSxDQUFDeGMsTUFBWCxDQUFrQm1lLENBQUMsSUFBSSxDQUFDLE1BQUQsRUFBUyxTQUFULEVBQW9CdHRCLFFBQXBCLENBQTZCc3RCLENBQUMsQ0FBQ25jLE1BQS9CLENBQXZCLENBQWpCOztBQUNBLFVBQUlrYyxRQUFRLENBQUN4dUIsTUFBVCxLQUFvQjZzQixNQUFNLENBQUM3c0IsTUFBL0IsRUFBdUM7QUFDckM7QUFDRDs7QUFFRCxVQUFJc3VCLEtBQUssR0FBRyxDQUFaLEVBQWU7QUFDYjtBQUNBQSxhQUFLO0FBQ0x0TyxhQUFLLEdBQUcsQ0FBUjtBQUNBL2Ysa0JBQVUsQ0FBQyxNQUFNc3VCLFFBQVEsRUFBZixFQUFtQixJQUFuQixDQUFWO0FBQ0E5cUIsZUFBTyxDQUFDd0ksR0FBUixDQUFZLE9BQVosRUFBcUJxaUIsS0FBckIsRUFBNEJFLFFBQVEsQ0FBQ3h1QixNQUFyQztBQUNBO0FBQ0Q7QUFDRjs7QUFFRHlELFdBQU8sQ0FBQ3dJLEdBQVIsQ0FBWSxVQUFaLEVBQXdCeEYsQ0FBeEI7O0FBQ0EsUUFBSXFtQixVQUFVLENBQUNybUIsQ0FBRCxDQUFWLElBQWlCLENBQUMsT0FBRCxFQUFVLE1BQVYsRUFBa0J0RixRQUFsQixDQUEyQjJyQixVQUFVLENBQUNybUIsQ0FBRCxDQUFWLENBQWM2TCxNQUF6QyxDQUFyQixFQUF1RTtBQUNyRXdhLGdCQUFVLENBQUNybUIsQ0FBRCxDQUFWLENBQWM2TCxNQUFkLEdBQXVCLFNBQXZCO0FBQ0F5YixVQUFJLENBQUM7QUFDSC91QixXQUFHLEVBQUU2dEIsTUFBTSxDQUFDcG1CLENBQUQsQ0FEUjtBQUVIdW5CLGVBQU8sRUFBR3B2QixJQUFELElBQVU7QUFDakJrdUIsb0JBQVUsQ0FBQ3JtQixDQUFELENBQVYsQ0FBYzZMLE1BQWQsR0FBdUIsTUFBdkI7QUFDQW9jLGdCQUFNLENBQUM5dkIsSUFBRCxFQUFPNkgsQ0FBUCxFQUFVbVosSUFBVixFQUFnQixNQUFNO0FBQzFCQSxnQkFBSSxDQUFDK08sVUFBTCxDQUFnQjVCLGFBQWEsQ0FBQy9zQixNQUE5QixFQUFzQzZzQixNQUFNLENBQUM3c0IsTUFBUCxHQUFnQixDQUF0RDtBQUNBdXVCLG9CQUFRO0FBQ1QsV0FISyxDQUFOO0FBSUQsU0FSRTtBQVNITixZQUFJLEVBQUc1cUIsQ0FBRCxJQUFPO0FBQ1g7QUFDQUksaUJBQU8sQ0FBQ3dJLEdBQVIsQ0FBWTtBQUFFNUksYUFBRjtBQUFLb0Q7QUFBTCxXQUFaLEVBRlcsQ0FHWDs7QUFDQXFtQixvQkFBVSxDQUFDcm1CLENBQUQsQ0FBVixDQUFjNkwsTUFBZCxHQUF1QixPQUF2QjtBQUNBaWMsa0JBQVE7QUFDVDtBQWZFLE9BQUQsQ0FBSjtBQWlCRCxLQW5CRCxNQW1CTztBQUFFO0FBQ1BBLGNBQVE7QUFDVDtBQUNGLEdBM0NELENBSGlDLENBZ0RqQzs7O0FBQ0EsT0FBSyxJQUFJSyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHLENBQXRCLEVBQXlCQSxFQUFFLEVBQTNCLEVBQStCO0FBQzdCTCxZQUFRO0FBQ1Q7QUFDRixDQXBERDs7QUFzREEsTUFBTU0sWUFBWSxHQUFHLENBQUNDLFVBQUQsRUFBYWhZLFFBQWIsS0FBMEI7QUFDN0MsUUFBTWlZLElBQUksR0FBRyxJQUFJNUgsSUFBSixDQUFTMkgsVUFBVSxDQUFDam1CLEdBQVgsQ0FBZWpLLElBQUksSUFBSSxJQUFJeXZCLFVBQUosQ0FBZXp2QixJQUFmLENBQXZCLENBQVQsRUFBdUQ7QUFBRWlPLFFBQUksRUFBRTtBQUFSLEdBQXZELENBQWI7QUFDQW1pQixnREFBTyxDQUFDQyxJQUFSLENBQWFGLElBQWIsRUFBbUJHLHlFQUFuQixFQUEyQixDQUFDbm9CLEdBQUQsRUFBTW9vQixNQUFOLEtBQWlCO0FBQzFDLFFBQUlwb0IsR0FBSixFQUFTdEQsT0FBTyxDQUFDd0ksR0FBUixDQUFZO0FBQUVsRjtBQUFGLEtBQVo7QUFDVCxVQUFNcW9CLEtBQUssR0FBRyxJQUFJM3RCLElBQUosR0FBVzR0QixPQUFYLEVBQWQ7QUFDQSxVQUFNQyxNQUFNLEdBQUdDLHdFQUFhLENBQUNKLE1BQUQsQ0FBNUI7QUFDQTFyQixXQUFPLENBQUN3SSxHQUFSLENBQWEscUNBQW9DLElBQUl4SyxJQUFKLEdBQVc0dEIsT0FBWCxLQUF1QkQsS0FBTSxJQUE5RTtBQUNBLFVBQU14d0IsSUFBSSxHQUFHO0FBQUU0d0Isa0JBQVksRUFBRUYsTUFBTSxDQUFDRyxLQUFQLENBQWEsV0FBYjtBQUFoQixLQUFiO0FBQ0EzWSxZQUFRLENBQUNsWSxJQUFELENBQVI7QUFDRCxHQVBEO0FBUUQsQ0FWRCxDLENBWUE7OztBQUNBLE1BQU04dkIsTUFBTSxHQUFHLFVBQVVnQixPQUFWLEVBQW1CMVAsS0FBbkIsRUFBMEJKLElBQTFCLEVBQWdDOUksUUFBaEMsRUFBMEM7QUFDdkQsUUFBTWxZLElBQUksR0FBR291QixHQUFHLENBQUMzbUIsR0FBSixHQUFVK25CLFNBQVMsQ0FBQ3NCLE9BQUQsRUFBVTFQLEtBQVYsQ0FBbkIsR0FBc0MwUCxPQUFuRDtBQUNBM0MsZUFBYSxDQUFDL00sS0FBRCxDQUFiLEdBQXVCcGhCLElBQXZCOztBQUNBLE1BQUltdUIsYUFBYSxDQUFDemMsTUFBZCxDQUFxQndCLENBQUMsSUFBSUEsQ0FBQyxJQUFJLEtBQS9CLEVBQXNDOVIsTUFBdEMsS0FBaUQ2c0IsTUFBTSxDQUFDN3NCLE1BQTVELEVBQW9FO0FBQ2xFNnVCLGdCQUFZLENBQUM5QixhQUFELEVBQWdCdHRCLEdBQUcsSUFBSTtBQUNqQ3FFLFlBQU0sQ0FBQzZyQixTQUFQLENBQWlCcEIsUUFBakIsQ0FBMEI7QUFDeEJ2dkIsV0FBRyxFQUFFUyxHQUFHLENBQUMrdkIsWUFEZTtBQUV4QkksZ0JBQVEsRUFBRWhRLElBQUksQ0FBQ2lRO0FBRlMsT0FBMUIsRUFHR0MsVUFBVSxJQUFJO0FBQ2ZsUSxZQUFJLENBQUM0SCxNQUFMO0FBQ0FoUSxXQUFHLENBQUM2UCxlQUFKLENBQW9CNW5CLEdBQUcsQ0FBQyt2QixZQUF4QjtBQUNELE9BTkQ7QUFPRCxLQVJXLENBQVo7QUFTRDs7QUFDRDFZLFVBQVEsSUFBSUEsUUFBUSxFQUFwQjtBQUNELENBZkQ7O0FBaUJBLE1BQU1pWCxJQUFJLEdBQUcsVUFBVS9pQixPQUFWLEVBQW1CO0FBQzlCQSxTQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFyQjtBQUNBLE1BQUkra0IsR0FBRyxHQUFHLElBQUlDLGNBQUosRUFBVjtBQUNBRCxLQUFHLENBQUN0ZCxZQUFKLEdBQW1CLGFBQW5COztBQUVBc2QsS0FBRyxDQUFDRSxrQkFBSixHQUF5QixZQUFZO0FBQ25DLFFBQUlGLEdBQUcsQ0FBQ0csVUFBSixLQUFtQixDQUF2QixFQUEwQjtBQUN4QixVQUFJNWQsTUFBTSxHQUFHeWQsR0FBRyxDQUFDemQsTUFBakI7O0FBQ0EsVUFBSUEsTUFBTSxJQUFJLEdBQVYsSUFBaUJBLE1BQU0sR0FBRyxHQUE5QixFQUFtQztBQUNqQ3RILGVBQU8sQ0FBQ2dqQixPQUFSLElBQW1CaGpCLE9BQU8sQ0FBQ2dqQixPQUFSLENBQWdCK0IsR0FBRyxDQUFDSSxRQUFwQixDQUFuQjtBQUNELE9BRkQsTUFFTztBQUNMbmxCLGVBQU8sQ0FBQ2lqQixJQUFSLElBQWdCampCLE9BQU8sQ0FBQ2lqQixJQUFSLENBQWEzYixNQUFiLENBQWhCO0FBQ0Q7QUFDRjtBQUNGLEdBVEQ7O0FBV0F5ZCxLQUFHLENBQUNLLElBQUosQ0FBUyxLQUFULEVBQWdCcGxCLE9BQU8sQ0FBQ2hNLEdBQXhCLEVBQTZCLElBQTdCO0FBQ0Erd0IsS0FBRyxDQUFDTSxJQUFKLENBQVMsSUFBVDtBQUNELENBbEJELEM7Ozs7Ozs7Ozs7OztBQzlMQTtBQUFBO0FBQUE7QUFBQTs7QUFDQSxNQUFNO0FBQUVDLGNBQUY7QUFBZ0JDO0FBQWhCLElBQThCNU8sbUJBQU8sQ0FBQyxrRUFBRCxDQUEzQzs7QUFDQSxNQUFNO0FBQUU3ZDtBQUFGLElBQWFsQixNQUFuQjtBQUVBLElBQUk0dEIsTUFBSjs7QUFDQSxlQUFldkIsSUFBZixHQUFzQjtBQUNwQixNQUFJdUIsTUFBSixFQUFZLE9BQU9BLE1BQVA7QUFDWkEsUUFBTSxHQUFHRixZQUFZLENBQUM7QUFDcEJHLFlBQVEsRUFBRSw0QkFEVTtBQUVwQnhrQixPQUFHLEVBQUU7QUFGZSxHQUFELENBQXJCO0FBSUEsUUFBTXVrQixNQUFNLENBQUN2QixJQUFQLEVBQU47QUFDQXhyQixTQUFPLENBQUNDLElBQVIsQ0FBYSxXQUFiLEVBQTBCO0FBQUU4c0I7QUFBRixHQUExQjtBQUNBLFNBQU9BLE1BQVA7QUFDRDs7QUFFRCxNQUFNRSxLQUFLLEdBQUcsT0FBT0MsS0FBUCxFQUFjQyxLQUFkLEtBQXdCO0FBQ3BDO0FBQ0FKLFFBQU0sQ0FBQ0ssRUFBUCxDQUFVLFdBQVYsRUFBdUIsV0FBdkIsR0FBb0MsTUFBTU4sU0FBUyxDQUFDSSxLQUFELENBQW5EO0FBQ0FILFFBQU0sQ0FBQ0ssRUFBUCxDQUFVLFdBQVYsRUFBdUIsV0FBdkIsR0FBb0MsTUFBTU4sU0FBUyxDQUFDSyxLQUFELENBQW5EO0FBQ0EsUUFBTUosTUFBTSxDQUFDNUQsR0FBUCxDQUFXLElBQVgsRUFBaUIsV0FBakIsRUFBOEIsSUFBOUIsRUFBb0MsV0FBcEMsRUFBaUQsSUFBakQsRUFBdUQsTUFBdkQsRUFBK0QsU0FBL0QsQ0FBTjtBQUNBLFNBQU80RCxNQUFNLENBQUNLLEVBQVAsQ0FBVSxVQUFWLEVBQXNCLFNBQXRCLENBQVA7QUFDRCxDQU5EOztBQVFBLGVBQWV4ckIsR0FBZixDQUFtQnVhLElBQW5CLEVBQXlCa1IsV0FBekIsRUFBc0MzbkIsUUFBdEMsRUFBZ0Q7QUFDOUMsU0FBTyxJQUFJN0YsT0FBSixDQUFZLENBQUMyQyxPQUFELEVBQVUxQyxNQUFWLEtBQXFCO0FBQ3RDcWMsUUFBSSxDQUFDbVIsUUFBTCxDQUFjblIsSUFBSSxDQUFDdGdCLEVBQW5CLElBQXlCO0FBQ3ZCQSxRQUFFLEVBQUVzZ0IsSUFBSSxDQUFDdGdCLEVBRGM7QUFFdkJELFdBQUssRUFBRXVnQixJQUFJLENBQUMxZ0IsR0FBTCxDQUFTRSxHQUFULENBQWFFLEVBRkc7QUFHdkIweEIsb0JBQWMsRUFBRSxDQUFDLE9BQUQsRUFBVSxNQUFWLEVBQWtCLFVBQWxCLENBSE87QUFJdkJqQixTQUFHLEVBQUUsSUFBSUMsY0FBSjtBQUprQixLQUF6QjtBQU1BcFEsUUFBSSxDQUFDL1MsSUFBTCxHQUFZLFVBQVo7QUFDQStTLFFBQUksQ0FBQ2lRLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQWpRLFFBQUksQ0FBQ2hoQixJQUFMLEdBQVksRUFBWjtBQUNBa3lCLGVBQVcsQ0FBQ2xSLElBQUQsRUFBT0EsSUFBSSxDQUFDMWdCLEdBQVosRUFBaUJPLEdBQUcsSUFBSTtBQUNqQztBQUNBLFVBQUlBLEdBQUcsQ0FBQ29OLElBQUosS0FBYSxVQUFqQixFQUE2QjtBQUFBOztBQUMzQjtBQUNBMUQsZ0JBQVEsY0FBQzFKLEdBQUcsQ0FBQ2IsSUFBTCxxQkFBQyxVQUFVcXlCLE1BQVgsZ0JBQW1CeHhCLEdBQUcsQ0FBQ2IsSUFBdkIscUJBQW1CLFdBQVUrTSxLQUE3QixDQUFSO0FBQ0QsT0FIRCxNQUdPLElBQUlsTSxHQUFHLENBQUNvTixJQUFKLEtBQWEsTUFBakIsRUFBeUI7QUFDOUI1RyxlQUFPLENBQUN4RyxHQUFHLENBQUNiLElBQUwsQ0FBUDtBQUNELE9BRk0sTUFFQSxJQUFJYSxHQUFHLENBQUNvTixJQUFKLEtBQWEsU0FBakIsRUFBNEI7QUFDakN0SixjQUFNO0FBQ1A7QUFDRixLQVZVLENBQVg7QUFXRCxHQXJCTSxDQUFQO0FBc0JEOztBQUVNLGVBQWUydEIsVUFBZixDQUEwQnRSLElBQTFCLEVBQWdDa1IsV0FBaEMsRUFBNkM7QUFDbEQ7QUFDQSxRQUFNM25CLFFBQVEsR0FBRztBQUNmd25CLFNBQUssRUFBRTtBQUFFTSxZQUFNLEVBQUUsQ0FBVjtBQUFhdGxCLFdBQUssRUFBRTtBQUFwQixLQURRO0FBRWZpbEIsU0FBSyxFQUFFO0FBQUVLLFlBQU0sRUFBRSxDQUFWO0FBQWF0bEIsV0FBSyxFQUFFO0FBQXBCO0FBRlEsR0FBakI7O0FBS0EsUUFBTWdqQixVQUFVLEdBQUcsQ0FBQ3dDLEVBQUQsRUFBS0YsTUFBTCxFQUFhdGxCLEtBQWIsS0FBdUI7QUFDeEMsUUFBSXNsQixNQUFNLElBQUl0bEIsS0FBZCxFQUFxQnBOLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjMnlCLEVBQWQsRUFBa0I7QUFBRUYsWUFBRjtBQUFVdGxCO0FBQVYsS0FBbEI7O0FBQ3JCLFVBQU15bEIsT0FBTyxHQUFHam9CLFFBQVEsQ0FBQ3duQixLQUFULENBQWVNLE1BQWYsR0FBd0I5bkIsUUFBUSxDQUFDeW5CLEtBQVQsQ0FBZUssTUFBdkQ7O0FBQ0EsVUFBTUksTUFBTSxHQUFHbG9CLFFBQVEsQ0FBQ3duQixLQUFULENBQWVobEIsS0FBZixHQUF1QnhDLFFBQVEsQ0FBQ3luQixLQUFULENBQWVqbEIsS0FBckQ7O0FBQ0EsUUFBSXlsQixPQUFPLElBQUlDLE1BQWYsRUFBdUJ6UixJQUFJLENBQUMrTyxVQUFMLENBQWdCeUMsT0FBaEIsRUFBeUJDLE1BQU0sR0FBRyxDQUFsQztBQUN4QixHQUxEOztBQU9BLFFBQU1DLFFBQVEsR0FBRyxFQUFqQjtBQUNBQSxVQUFRLENBQUM5aEIsSUFBVCxDQUFjeWYsSUFBSSxFQUFsQjtBQUVBLFFBQU1zQyxTQUFTLEdBQUcxdUIsdUdBQVEsQ0FBQytjLElBQUQsQ0FBMUI7QUFDQTJSLFdBQVMsQ0FBQ1IsUUFBVixHQUFxQm5SLElBQUksQ0FBQ21SLFFBQTFCO0FBQ0FRLFdBQVMsQ0FBQ2p5QixFQUFWLEdBQWdCLEdBQUVzZ0IsSUFBSSxDQUFDdGdCLEVBQUcsUUFBMUI7QUFDQWd5QixVQUFRLENBQUM5aEIsSUFBVCxDQUFjbkssR0FBRyxDQUFDa3NCLFNBQUQsRUFBWVQsV0FBWixFQUF5QixDQUFDRyxNQUFELEVBQVN0bEIsS0FBVCxLQUFtQjtBQUMzRGdqQixjQUFVLENBQUN4bEIsUUFBUSxDQUFDd25CLEtBQVYsRUFBaUJNLE1BQWpCLEVBQXlCdGxCLEtBQXpCLENBQVY7QUFDRCxHQUZnQixDQUFqQjtBQUlBLFFBQU02bEIsU0FBUyxHQUFHM3VCLHVHQUFRLENBQUMrYyxJQUFELENBQTFCO0FBQ0E0UixXQUFTLENBQUNULFFBQVYsR0FBcUJuUixJQUFJLENBQUNtUixRQUExQjtBQUNBUyxXQUFTLENBQUN4eUIsR0FBVixHQUFnQjRnQixJQUFJLENBQUNoaEIsSUFBTCxDQUFVLENBQVYsQ0FBaEI7QUFDQTR5QixXQUFTLENBQUNseUIsRUFBVixHQUFnQixHQUFFc2dCLElBQUksQ0FBQ3RnQixFQUFHLFFBQTFCO0FBQ0FneUIsVUFBUSxDQUFDOWhCLElBQVQsQ0FBY25LLEdBQUcsQ0FBQ21zQixTQUFELEVBQVlWLFdBQVosRUFBeUIsQ0FBQ0csTUFBRCxFQUFTdGxCLEtBQVQsS0FBbUI7QUFDM0RnakIsY0FBVSxDQUFDeGxCLFFBQVEsQ0FBQ3luQixLQUFWLEVBQWlCSyxNQUFqQixFQUF5QnRsQixLQUF6QixDQUFWO0FBQ0QsR0FGZ0IsQ0FBakI7QUFJQSxRQUFNOGxCLElBQUksR0FBRyxNQUFNbnVCLE9BQU8sQ0FBQ3dLLEdBQVIsQ0FBWXdqQixRQUFaLENBQW5COztBQUNBLE1BQUksQ0FBQ0csSUFBSSxDQUFDLENBQUQsQ0FBTCxJQUFZLENBQUNBLElBQUksQ0FBQyxDQUFELENBQXJCLEVBQTBCO0FBQ3hCO0FBQ0E3UixRQUFJLENBQUM2SCxPQUFMO0FBQ0E7QUFDRCxHQXJDaUQsQ0F1Q2xEOzs7QUFDQSxRQUFNaUssR0FBRyxHQUFHLE1BQU1oQixLQUFLLENBQUNlLElBQUksQ0FBQyxDQUFELENBQUwsRUFBVUEsSUFBSSxDQUFDLENBQUQsQ0FBZCxDQUF2QixDQXhDa0QsQ0F5Q2xEOztBQUNBLFFBQU1FLFFBQVEsR0FBRyxFQUFqQjtBQUNBQSxVQUFRLENBQUM5a0IsSUFBVCxHQUFnQixXQUFoQjtBQUNBLFFBQU03TixHQUFHLEdBQUd3WSxHQUFHLENBQUMwUCxlQUFKLENBQW9CLElBQUlDLElBQUosQ0FBUyxDQUFDdUssR0FBRCxDQUFULEVBQWdCQyxRQUFoQixDQUFwQixDQUFaLENBNUNrRCxDQTZDbEQ7O0FBQ0E3dEIsUUFBTSxDQUFDNnJCLFNBQVAsQ0FBaUJwQixRQUFqQixDQUEwQjtBQUN4QnZ2QixPQUR3QjtBQUV4QjR3QixZQUFRLEVBQUVoUSxJQUFJLENBQUNpUTtBQUZTLEdBQTFCLEVBR0dDLFVBQVUsSUFBSTtBQUNmO0FBQ0FsUSxRQUFJLENBQUM0SCxNQUFMLENBQVlzSSxVQUFaO0FBQ0F0WSxPQUFHLENBQUM2UCxlQUFKLENBQW9Ccm9CLEdBQXBCO0FBQ0QsR0FQRDtBQVFELEM7Ozs7Ozs7Ozs7OztBQ3ZHRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRU8sTUFBTVAsUUFBUSxHQUFHLEVBQWpCO0FBRUEsU0FBU3FWLE1BQVQsQ0FBZ0I5SSxPQUFoQixFQUF5QjtBQUM5QmxJLFNBQU8sQ0FBQzh1QixhQUFSLENBQXNCM21CLE1BQXRCLENBQTZCRCxPQUFPLENBQUMxTCxFQUFSLElBQWMsZUFBM0MsRUFBNEQ7QUFDMUR1TixRQUFJLEVBQUUsT0FEb0Q7QUFFMURnbEIsV0FBTyxFQUFFQyw0RkFGaUQ7QUFHMUQvZCxTQUFLLEVBQUcsR0FBRS9JLE9BQU8sQ0FBQytJLEtBQU0sTUFBS3VSLDRGQUFJLENBQUMsU0FBRCxDQUFZLEVBSGE7QUFJMURHLFdBQU8sRUFBRXphLE9BQU8sQ0FBQ3VILElBSnlDO0FBSzFEd2YsZUFBVyxFQUFFL21CLE9BQU8sQ0FBQyttQjtBQUxxQyxHQUE1RDtBQU9EO0FBRU0sU0FBU0MsU0FBVCxDQUFtQnB6QixJQUFuQixFQUF5QjtBQUM5QnFzQixZQUFVLENBQUU3ckIsR0FBRCxJQUFTO0FBQ2xCMEQsV0FBTyxDQUFDd08sSUFBUixDQUFhMmdCLFdBQWIsQ0FBeUI3eUIsR0FBRyxDQUFDRSxFQUE3QixFQUFpQ1YsSUFBakMsRUFDQ3dFLEtBREQsQ0FDT29JLG9GQURQO0FBRUQsR0FIUyxDQUFWO0FBSUQ7QUFFTSxTQUFTMG1CLG1CQUFULENBQTZCLEdBQUcvdUIsSUFBaEMsRUFBc0M7QUFDM0MsU0FBT0wsT0FBTyxDQUFDQyxPQUFSLENBQWdCa3ZCLFdBQWhCLENBQTRCLEdBQUc5dUIsSUFBL0IsRUFBcUNDLEtBQXJDLENBQTJDb0ksb0ZBQTNDLENBQVA7QUFDRDtBQUVNLGVBQWV5ZixVQUFmLENBQTBCblUsUUFBMUIsRUFBb0M7QUFDekMsUUFBTXhGLElBQUksR0FBRyxNQUFNeE8sT0FBTyxDQUFDd08sSUFBUixDQUFhNmdCLEtBQWIsQ0FBbUIsRUFBbkIsQ0FBbkI7QUFDQSxNQUFJMXJCLENBQUMsR0FBRyxDQUFSOztBQUNBLE9BQUssTUFBTXJILEdBQVgsSUFBa0JrUyxJQUFsQixFQUF3QjtBQUN0QndGLFlBQVEsQ0FBQzFYLEdBQUQsQ0FBUjtBQUNBcUgsS0FBQyxJQUFJLENBQUwsQ0FGc0IsQ0FHdEI7QUFDQTtBQUNBOztBQUNBLFFBQUlBLENBQUMsR0FBRyxFQUFKLEtBQVcsQ0FBZixFQUFrQixNQUFNLElBQUluRCxPQUFKLENBQVlyRCxVQUFaLENBQU47QUFDbkI7QUFDRixDOzs7Ozs7Ozs7Ozs7QUNwQ0Q7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBLE1BQU1teUIsT0FBTyxHQUFHLEVBQWhCO0FBRUE3ekIsTUFBTSxDQUFDQyxNQUFQLENBQWNDLGlEQUFkLEVBQXdCO0FBQ3RCO0FBQ0EsUUFBTTR6QixZQUFOLENBQW1CenpCLElBQW5CLEVBQXlCTSxHQUF6QixFQUE4Qm96QixRQUE5QixFQUF3QztBQUN0QyxVQUFNQyxjQUFjLEdBQUcsTUFBTXp2QixPQUFPLENBQUM4dUIsYUFBUixDQUFzQjNtQixNQUF0QixDQUE2QjtBQUN4RDRCLFVBQUksRUFBRSxPQURrRDtBQUV4RGtILFdBQUssRUFBRW5WLElBQUksQ0FBQ21WLEtBQUwsS0FBZTdRLFVBQVUsR0FBR29pQiw0RkFBSSxDQUFDLFNBQUQsQ0FBUCxHQUFxQixFQUE5QyxDQUZpRDtBQUVFO0FBQzFERyxhQUFPLEVBQUU3bUIsSUFBSSxDQUFDNlgsSUFIMEM7QUFJeERvYixhQUFPLEVBQUVqekIsSUFBSSxDQUFDMG9CLEtBQUwsSUFBY3dLLDRGQUFZQTtBQUpxQixLQUE3QixDQUE3QjtBQU1BTSxXQUFPLENBQUNHLGNBQUQsQ0FBUCxHQUEwQixDQUFBRCxRQUFRLFFBQVIsWUFBQUEsUUFBUSxDQUFFRSxPQUFWLEtBQXFCdHpCLEdBQUcsQ0FBQ0UsR0FBSixDQUFRRSxFQUF2RDtBQUNBLFdBQU9pekIsY0FBUDtBQUNELEdBWHFCOztBQVl0QkUsb0JBQWtCLENBQUNGLGNBQUQsRUFBaUI7QUFDakMsV0FBT3p2QixPQUFPLENBQUM4dUIsYUFBUixDQUFzQjNwQixLQUF0QixDQUE0QnNxQixjQUE1QixDQUFQO0FBQ0Q7O0FBZHFCLENBQXhCO0FBaUJBenZCLE9BQU8sQ0FBQzh1QixhQUFSLENBQXNCYyxTQUF0QixDQUFnQ3p2QixXQUFoQyxDQUE2QzNELEVBQUQsSUFBUTtBQUNsRCxRQUFNcXpCLFFBQVEsR0FBR1AsT0FBTyxDQUFDOXlCLEVBQUQsQ0FBeEI7O0FBQ0EsTUFBSXF6QixRQUFRLElBQUksQ0FBaEIsRUFBbUI7QUFDakJDLHNHQUFVLENBQUNELFFBQUQsRUFBVyxtQkFBWCxFQUFnQ3J6QixFQUFoQyxDQUFWO0FBQ0Q7O0FBQ0QsTUFBSSxPQUFPcXpCLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbENBLFlBQVE7QUFDVDtBQUNGLENBUkQ7QUFVQTd2QixPQUFPLENBQUM4dUIsYUFBUixDQUFzQmlCLFFBQXRCLENBQStCNXZCLFdBQS9CLENBQTRDM0QsRUFBRCxJQUFRO0FBQ2pELFFBQU1xekIsUUFBUSxHQUFHUCxPQUFPLENBQUM5eUIsRUFBRCxDQUF4QjtBQUNBLFNBQU84eUIsT0FBTyxDQUFDOXlCLEVBQUQsQ0FBZDs7QUFDQSxNQUFJcXpCLFFBQVEsSUFBSSxDQUFoQixFQUFtQjtBQUNqQkMsc0dBQVUsQ0FBQ0QsUUFBRCxFQUFXLG1CQUFYLEVBQWdDcnpCLEVBQWhDLENBQVY7QUFDRDtBQUNGLENBTkQsRTs7Ozs7Ozs7Ozs7O0FDaENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBZixNQUFNLENBQUNDLE1BQVAsQ0FBY0MsaURBQWQsRUFBd0I7QUFDdEI7QUFDQXEwQixlQUFhLEdBQUc7QUFDZCxXQUFPcjBCLGlEQUFRLENBQUNzMEIsVUFBVCxDQUFvQkMsd0dBQXBCLENBQVA7QUFDRCxHQUpxQjs7QUFLdEI7QUFDQUQsWUFBVSxDQUFDbjBCLElBQUQsRUFBTztBQUNmLFdBQU8sU0FBTXEwQiwrRkFBTixFQUFBcjBCLElBQUksRUFBVyxDQUFDLENBQUNxSSxHQUFELENBQUQsS0FBVzNGLFNBQVMsQ0FBQzJGLEdBQUQsQ0FBL0IsQ0FBWDtBQUNELEdBUnFCOztBQVN0QjtBQUNBaXNCLFlBQVUsQ0FBQ3QwQixJQUFELEVBQU87QUFDZitKLHVHQUFXLENBQUMvSixJQUFELENBQVgsQ0FBa0I0TCxPQUFsQixDQUEwQnlFLElBQUksSUFBSXpILFNBQVMsQ0FBQ3lILElBQUksQ0FBQ2hJLEdBQU4sRUFBV2dJLElBQUksQ0FBQzFILEtBQWhCLENBQTNDO0FBQ0Q7O0FBWnFCLENBQXhCO0FBZUEsSUFBSXJKLE9BQU8sR0FBRyxFQUFkO0FBQ0EsTUFBTWkxQixLQUFLLEdBQUdDLGlHQUFTLEVBQXZCO0FBQ0EsTUFBTUMsY0FBYyxHQUFHdnRCLGdHQUFRLENBQUN3dEIsU0FBRCxFQUFZLEdBQVosQ0FBL0I7QUFFQSxJQUFJdG9CLE9BQU8sR0FBRyxFQUFkO0FBQ0EsSUFBSXVvQixXQUFXLEdBQUd6d0IsT0FBTyxDQUFDOGIsT0FBUixDQUFnQm5QLEtBQWhCLENBQXNCcEssR0FBdEIsQ0FBMEIsU0FBMUIsRUFDakJrSCxJQURpQixDQUNaLENBQUM7QUFBRXZCLFNBQU8sRUFBRXBNO0FBQVgsQ0FBRCxLQUF1QjtBQUMzQixNQUFJQSxJQUFJLElBQUksT0FBT0EsSUFBUCxLQUFnQixRQUE1QixFQUFzQ29NLE9BQU8sR0FBR3BNLElBQVY7O0FBQ3RDLE1BQUl3RixLQUFKLEVBQXVCLEVBRXRCOztBQUNELE1BQUksQ0FBQzRQLHdHQUFTLENBQUNoSixPQUFELEVBQVUsU0FBVixDQUFkLEVBQW9DO0FBQ2xDeEQsYUFBUyxDQUFDLFNBQUQsRUFBWSxDQUFaLENBQVQ7QUFDRDs7QUFDRCtyQixhQUFXLEdBQUcsSUFBZDtBQUNELENBVmlCLENBQWxCO0FBV0E3UyxtREFBYSxDQUFDbFIsSUFBZCxDQUFtQitqQixXQUFuQjs7QUFFQSxTQUFTQyxVQUFULENBQW9CcnNCLElBQXBCLEVBQTBCSSxLQUExQixFQUFpQztBQUMvQjtBQUNBLFFBQU1OLEdBQUcsR0FBR0UsSUFBSSxDQUFDd04sSUFBTCxDQUFVLEdBQVYsQ0FBWixDQUYrQixDQUcvQjs7QUFDQSxTQUFPelcsT0FBTyxDQUFDK0ksR0FBRCxDQUFkO0FBQ0EvSSxTQUFPLENBQUMrSSxHQUFELENBQVAsR0FBZU0sS0FBZjtBQUNBOHJCLGdCQUFjO0FBQ2Y7O0FBRUQsU0FBU0MsU0FBVCxHQUFxQjtBQUNuQkgsT0FBSyxDQUFDckssSUFBTixDQUFXNXFCLE9BQVg7QUFDQUEsU0FBTyxHQUFHLEVBQVY7QUFDRDs7QUFFTSxTQUFTb0QsU0FBVCxDQUFtQjJGLEdBQW5CLEVBQXdCQyxHQUF4QixFQUE2QjtBQUNsQyxRQUFNQyxJQUFJLEdBQUdDLHFHQUFhLENBQUNILEdBQUQsQ0FBMUI7QUFDQSxRQUFNd3NCLE9BQU8sR0FBR3RzQixJQUFJLENBQUMsQ0FBRCxDQUFwQjtBQUNBLE1BQUlJLEtBQUssR0FBR3lELE9BQU8sQ0FBQ3lvQixPQUFELENBQW5CO0FBQ0EsTUFBSWxzQixLQUFLLElBQUksSUFBYixFQUFtQkEsS0FBSyxHQUFHeXJCLHdHQUFRLENBQUNTLE9BQUQsQ0FBaEI7QUFDbkIsTUFBSWxzQixLQUFLLElBQUksSUFBYixFQUFtQkEsS0FBSyxHQUFHTCxHQUFSO0FBQ25CLFNBQU9DLElBQUksQ0FBQ25ILE1BQUwsR0FBYyxDQUFkLEdBQWtCZ1Usd0dBQVMsQ0FBQ3pNLEtBQUQsRUFBUUosSUFBSSxDQUFDUCxLQUFMLENBQVcsQ0FBWCxDQUFSLEVBQXVCTSxHQUF2QixDQUEzQixHQUF5REssS0FBaEU7QUFDRDtBQUVNLFNBQVNtc0IsZ0JBQVQsQ0FBMEJ6c0IsR0FBMUIsRUFBK0I7QUFDcEMsU0FBTytNLHdHQUFTLENBQUNnZix3R0FBRCxFQUFXL3JCLEdBQVgsQ0FBaEI7QUFDRDtBQUVNLFNBQVNPLFNBQVQsQ0FBbUJQLEdBQW5CLEVBQXdCTSxLQUF4QixFQUErQjtBQUNwQyxNQUFJZ3NCLFdBQUosRUFBaUI7QUFDZkEsZUFBVyxDQUFDaG5CLElBQVosQ0FBaUIsTUFBTTtBQUNyQi9FLGVBQVMsQ0FBQ1AsR0FBRCxFQUFNTSxLQUFOLENBQVQ7QUFDRCxLQUZEO0FBR0E7QUFDRDs7QUFDRCxRQUFNSixJQUFJLEdBQUdDLHFHQUFhLENBQUNILEdBQUQsQ0FBMUI7QUFDQSxRQUFNMHNCLFNBQVMsR0FBR3hzQixJQUFJLENBQUN3TixJQUFMLENBQVUsR0FBVixDQUFsQjtBQUNBLE1BQUlpZixXQUFXLEdBQUdyc0IsS0FBbEI7QUFDQSxRQUFNa3NCLE9BQU8sR0FBR3RzQixJQUFJLENBQUMsQ0FBRCxDQUFwQjs7QUFDQSxNQUFJc3NCLE9BQU8sSUFBSVQsd0dBQWYsRUFBeUI7QUFDdkIsUUFBSTdyQixJQUFJLENBQUNuSCxNQUFMLEdBQWMsQ0FBbEIsRUFBcUI7QUFDbkI0ekIsaUJBQVcsR0FBR2hrQix3R0FBUyxDQUFDdE8sU0FBUyxDQUFDbXlCLE9BQUQsQ0FBVixFQUFxQnRzQixJQUFJLENBQUNQLEtBQUwsQ0FBVyxDQUFYLENBQXJCLEVBQW9DVyxLQUFwQyxDQUF2QjtBQUNEOztBQUNEeUQsV0FBTyxDQUFDeW9CLE9BQUQsQ0FBUCxHQUFtQkcsV0FBbkI7QUFDQTl3QixXQUFPLENBQUM4YixPQUFSLENBQWdCblAsS0FBaEIsQ0FBc0JuSSxHQUF0QixDQUEwQjtBQUFFMEQ7QUFBRixLQUExQjtBQUNBd29CLGNBQVUsQ0FBQ3JzQixJQUFELEVBQU9JLEtBQVAsQ0FBVjs7QUFDQSxRQUFJbkQsS0FBSixFQUF1QixFQUV0QjtBQUNGO0FBQ0Y7QUFFTSxNQUFNbkcsV0FBVyxHQUFHazFCLEtBQUssQ0FBQ1UsSUFBMUIsQzs7Ozs7Ozs7Ozs7O0FDNUZQO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFZSxxRUFBTSxJQUFJdndCLE9BQUosQ0FBWSxDQUFDMkMsT0FBRCxFQUFVMUMsTUFBVixLQUFxQjtBQUNwREUsU0FBTyxDQUFDQyxJQUFSLENBQWEscUJBQWI7QUFDQStELE1BQUk7O0FBQ0osV0FBU0EsSUFBVCxHQUFnQjtBQUNkLFVBQU14RyxHQUFHLEdBQUc2eUIsU0FBUyxDQUFDMUQsSUFBVixDQUFlLGVBQWYsRUFBZ0MsQ0FBaEMsQ0FBWjs7QUFDQW52QixPQUFHLENBQUM4eUIsU0FBSixHQUFnQixNQUFNO0FBQ3BCLFVBQUk7QUFDRkMsaUJBQVMsQ0FBQy95QixHQUFHLENBQUN1a0IsTUFBTCxDQUFUO0FBQ0QsT0FGRCxDQUVFLE9BQU96ZSxHQUFQLEVBQVk7QUFDWjtBQUNBeEQsY0FBTSxDQUFDd0QsR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQVBEOztBQVFBOUYsT0FBRyxDQUFDd21CLE9BQUosR0FBY2xrQixNQUFkOztBQUNBdEMsT0FBRyxDQUFDZ3pCLGVBQUosR0FBc0IsTUFBTTtBQUMxQjtBQUNBMXdCLFlBQU07QUFDUCxLQUhEO0FBSUQ7O0FBQ0QsV0FBU3l3QixTQUFULENBQW1CRSxFQUFuQixFQUF1QjtBQUNyQixVQUFNQyxFQUFFLEdBQUdELEVBQUUsQ0FBQ0UsV0FBSCxDQUFlLENBQUMsU0FBRCxFQUFZLFNBQVosRUFBdUIsT0FBdkIsRUFBZ0MsUUFBaEMsQ0FBZixDQUFYO0FBQ0EsVUFBTXJrQixPQUFPLEdBQUcsRUFBaEI7QUFDQSxRQUFJc2tCLFVBQVUsR0FBRyxDQUFqQjs7QUFDQSxVQUFNQyxJQUFJLEdBQUcsTUFBTTtBQUNqQkQsZ0JBQVUsSUFBSSxDQUFkO0FBQ0EsVUFBSSxDQUFDQSxVQUFMLEVBQWlCcHVCLE9BQU8sQ0FBQ25ELE9BQU8sQ0FBQzhiLE9BQVIsQ0FBZ0JuUCxLQUFoQixDQUFzQm5JLEdBQXRCLENBQTBCeUksT0FBMUIsQ0FBRCxDQUFQO0FBQ2xCLEtBSEQ7O0FBSUEsVUFBTXdrQixNQUFNLEdBQUcsQ0FBQ0MsU0FBRCxFQUFZMWQsUUFBWixLQUF5QjtBQUN0QyxZQUFNN1YsR0FBRyxHQUFHa3pCLEVBQUUsQ0FBQ00sV0FBSCxDQUFlRCxTQUFmLEVBQTBCRCxNQUExQixFQUFaOztBQUNBdHpCLFNBQUcsQ0FBQzh5QixTQUFKLEdBQWdCLE1BQU1qZCxRQUFRLENBQUM3VixHQUFHLENBQUN1a0IsTUFBTCxDQUE5Qjs7QUFDQXZrQixTQUFHLENBQUN3bUIsT0FBSixHQUFjbGtCLE1BQWQ7QUFDRCxLQUpEOztBQUtBZ3hCLFVBQU0sQ0FBQyxTQUFELEVBQWFwUixVQUFELElBQWdCO0FBQ2hDLFlBQU1wQyxNQUFNLEdBQUcsRUFBZjtBQUNBb0MsZ0JBQVUsQ0FBQzNZLE9BQVgsQ0FBb0J2RixNQUFELElBQVk7QUFDN0IsY0FBTTtBQUFFMUMsY0FBRjtBQUFRakQsWUFBUjtBQUFZK0c7QUFBWixZQUFvQnBCLE1BQTFCO0FBQ0E4SyxlQUFPLENBQUUsR0FBRTZPLCtGQUFPLENBQUMzWixNQUFSLENBQWV3SSxNQUFPLEdBQUVuTyxFQUFHLEVBQS9CLENBQVAsR0FBMkNvMUIsZUFBZSxDQUFDenZCLE1BQUQsQ0FBMUQ7QUFDQThLLGVBQU8sQ0FBRSxHQUFFNk8sK0ZBQU8sQ0FBQ3JjLElBQVIsQ0FBYWtMLE1BQU8sR0FBRW5PLEVBQUcsRUFBN0IsQ0FBUCxHQUF5Q2lELElBQXpDO0FBQ0F3ZSxjQUFNLENBQUMxYSxHQUFELENBQU4sR0FBYy9HLEVBQWQ7QUFDRCxPQUxEO0FBTUFpMUIsWUFBTSxDQUFDLFFBQUQsRUFBWUksU0FBRCxJQUFlO0FBQzlCQSxpQkFBUyxDQUFDbnFCLE9BQVYsQ0FBa0IsQ0FBQztBQUFFbkUsYUFBRjtBQUFPaVo7QUFBUCxTQUFELEtBQXFCO0FBQ3JDLGdCQUFNaGdCLEVBQUUsR0FBR3loQixNQUFNLENBQUMxYSxHQUFELENBQWpCO0FBQ0EsY0FBSS9HLEVBQUosRUFBUXlRLE9BQU8sQ0FBRSxHQUFFNk8sK0ZBQU8sQ0FBQ3JYLEtBQVIsQ0FBY2tHLE1BQU8sR0FBRW5PLEVBQUcsRUFBOUIsQ0FBUCxHQUEwQ2dnQixNQUExQztBQUNULFNBSEQ7QUFJQWdWLFlBQUk7QUFDTCxPQU5LLENBQU47QUFPRCxLQWZLLENBQU47QUFnQkFDLFVBQU0sQ0FBQyxPQUFELEVBQVdLLFFBQUQsSUFBYztBQUM1QkEsY0FBUSxDQUFDcHFCLE9BQVQsQ0FBaUIsQ0FBQztBQUFFbkUsV0FBRjtBQUFPekg7QUFBUCxPQUFELEtBQW1CO0FBQ2xDbVIsZUFBTyxDQUFFLEdBQUU2TywrRkFBTyxDQUFDemMsS0FBUixDQUFjc0wsTUFBTyxHQUFFcEgsR0FBSSxFQUEvQixDQUFQLEdBQTJDekgsSUFBM0M7QUFDRCxPQUZEO0FBR0EwMUIsVUFBSTtBQUNMLEtBTEssQ0FBTjtBQU1BQyxVQUFNLENBQUMsU0FBRCxFQUFhTSxVQUFELElBQWdCO0FBQ2hDQSxnQkFBVSxDQUFDcnFCLE9BQVgsQ0FBbUIsQ0FBQztBQUFFbkUsV0FBRjtBQUFPOUQ7QUFBUCxPQUFELEtBQW1CO0FBQ3BDd04sZUFBTyxDQUFFLEdBQUU2TywrRkFBTyxDQUFDK0MsT0FBUixDQUFnQmxVLE1BQU8sR0FBRXBILEdBQUksRUFBakMsQ0FBUCxHQUE2QzlELElBQTdDO0FBQ0QsT0FGRDtBQUdBK3hCLFVBQUk7QUFDTCxLQUxLLENBQU47QUFNRDs7QUFDRCxXQUFTSSxlQUFULENBQXlCenZCLE1BQXpCLEVBQWlDO0FBQy9CLFdBQU87QUFDTDRhLFVBQUksRUFBRVEseURBQVMsQ0FBQ3BiLE1BQU0sQ0FBQzFDLElBQVIsQ0FEVjtBQUVMQyxZQUFNLEVBQUVqRSxNQUFNLENBQUNDLE1BQVAsQ0FBYztBQUNwQnMyQixtQkFBVyxFQUFFLElBRE87QUFFcEJDLG1CQUFXLEVBQUUsSUFGTztBQUdwQkMsaUJBQVMsRUFBRSxJQUhTO0FBSXBCQyx3QkFBZ0IsRUFBRTtBQUpFLE9BQWQsRUFLTGh3QixNQUFNLENBQUN6QyxNQUxGLENBRkg7QUFRTGtILFdBQUssRUFBRTtBQUNMcEssVUFBRSxFQUFFMkYsTUFBTSxDQUFDM0YsRUFETjtBQUVMK0csV0FBRyxFQUFFcEIsTUFBTSxDQUFDb0IsR0FGUDtBQUdMK0ksZ0JBQVEsRUFBRW5LLE1BQU0sQ0FBQ21LO0FBSFosT0FSRjtBQWFMMUgsWUFBTSxFQUFFO0FBQ05tQyxlQUFPLEVBQUU1RSxNQUFNLENBQUM0RSxPQURWO0FBRU5DLG9CQUFZLEVBQUU3RSxNQUFNLENBQUNDO0FBRmY7QUFiSCxLQUFQO0FBa0JEO0FBQ0YsQ0FqRm9CLEVBa0ZyQjtBQWxGcUIsQ0FtRnBCOUIsS0FuRm9CLENBbUZkLE1BQU0sQ0FBRSxDQW5GTSxDQUFyQixFOzs7Ozs7Ozs7Ozs7QUNIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFTyxNQUFNckQsU0FBUyxHQUFHLEVBQWxCLEMsQ0FBc0I7O0FBRTdCaXBCLG9EQUFjLENBQUN4WixJQUFmLENBQW9CLE1BQU07QUFDeEIxTSxTQUFPLENBQUNDLE9BQVIsQ0FBZ0JteUIsU0FBaEIsQ0FBMEJqeUIsV0FBMUIsQ0FBc0NreUIsYUFBdEM7QUFDQXJ5QixTQUFPLENBQUNvTyxVQUFSLENBQW1CQyxlQUFuQixDQUFtQ2xPLFdBQW5DLENBQStDbXlCLGdCQUEvQyxFQUFpRTtBQUMvRGhrQixRQUFJLEVBQUUsQ0FBQ3RPLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQjJwQixNQUFoQixDQUF1QjVwQixPQUFPLENBQUNDLE9BQVIsQ0FBZ0IrQixXQUFoQixHQUE4QnV3QixjQUE5QixDQUE2Q0MsYUFBcEUsQ0FBRCxDQUR5RDtBQUUvRGprQixTQUFLLEVBQUUsQ0FBQyxZQUFEO0FBRndELEdBQWpFO0FBSUQsQ0FORDs7QUFRQSxTQUFTOGpCLGFBQVQsQ0FBdUJJLElBQXZCLEVBQTZCO0FBQzNCLFFBQU1sMkIsS0FBSyxHQUFHLENBQUNrMkIsSUFBSSxDQUFDbnZCLElBQXBCO0FBQ0FyRyxXQUFTLENBQUNWLEtBQUQsQ0FBVCxHQUFtQixDQUFuQjtBQUNBdXpCLG9HQUFVLENBQUN2ekIsS0FBRCxFQUFRLFlBQVIsRUFBc0IsSUFBdEIsQ0FBVjtBQUNBazJCLE1BQUksQ0FBQ0MsWUFBTCxDQUFrQnZ5QixXQUFsQixDQUE4Qnd5QixhQUE5QjtBQUNBLFNBQU9oM0IsaURBQVEsQ0FBQ2kzQixRQUFoQjtBQUNEOztBQUVELFNBQVNELGFBQVQsQ0FBdUI7QUFBRXJ2QjtBQUFGLENBQXZCLEVBQWlDO0FBQy9CLFNBQU9yRyxTQUFTLENBQUNxRyxJQUFELENBQWhCO0FBQ0F3c0Isb0dBQVUsQ0FBQyxDQUFDeHNCLElBQUYsRUFBUSxZQUFSLEVBQXNCLEtBQXRCLENBQVY7QUFDRDs7QUFFRCxlQUFlZ3ZCLGdCQUFmLEdBQWtDO0FBQ2hDLFFBQU0vMUIsS0FBSyxHQUFHLENBQUMsTUFBTWdCLG9HQUFZLEVBQW5CLEVBQXVCZixFQUFyQztBQUNBc3pCLG9HQUFVLENBQUN2ekIsS0FBRCxFQUFRLFlBQVIsRUFBc0IsSUFBdEIsQ0FBVjs7QUFDQVosbURBQVEsQ0FBQ2kzQixRQUFULEdBQW9CLE9BQU85MkIsSUFBUCxFQUFhTSxHQUFiLEtBQXFCO0FBQ3ZDWCxVQUFNLENBQUNDLE1BQVAsQ0FBY0ksSUFBZCxHQUFvQixNQUFNQyxtREFBTyxDQUFDRCxJQUFJLENBQUNELEdBQU4sQ0FBakM7QUFDQXdELGtEQUFLLENBQUMwTixHQUFOLENBQVUsVUFBVixFQUFzQnRSLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjO0FBQUUsT0FBQ1UsR0FBRyxDQUFDQyxPQUFMLEdBQWUsQ0FBQ1AsSUFBRCxFQUFPTSxHQUFQO0FBQWpCLEtBQWQsRUFBOENpRCw4Q0FBSyxDQUFDa0QsR0FBTixDQUFVLFVBQVYsQ0FBOUMsQ0FBdEI7QUFDRCxHQUhEO0FBSUQsQzs7Ozs7Ozs7Ozs7O0FDcENEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTXN3QixVQUFVLEdBQUc7QUFDakJ2a0IsTUFBSSxFQUFFLENBQUMsU0FBRCxDQURXO0FBQ0U7QUFDbkJDLE9BQUssRUFBRSxDQUFDLFlBQUQsRUFBZSxXQUFmO0FBRlUsQ0FBbkI7QUFJQSxNQUFNdWtCLGVBQWUsR0FBRyxJQUF4QixDLENBQThCOztBQUM5QixNQUFNQyxrQkFBa0IsR0FBRyxHQUEzQixDLENBQWdDOztBQUNoQyxNQUFNQyxjQUFjLEdBQUcsSUFBdkIsQyxDQUE2Qjs7QUFDN0IsTUFBTUMsU0FBUyxHQUFHdlkscUdBQVMsQ0FBQztBQUFFQyxVQUFRLEVBQUVxWTtBQUFaLENBQUQsQ0FBM0I7QUFDQSxNQUFNM3pCLEtBQUssR0FBR3FiLHFHQUFTLENBQUM7QUFDdEJDLFVBQVEsRUFBRXFZLGNBRFk7QUFFdEJFLFdBQVMsRUFBRSxNQUFNOXBCLE9BQU4sSUFBaUI7QUFDMUIsVUFBTXROLElBQUksR0FBRyxNQUFNc04sT0FBbkI7QUFDQSxVQUFNK3BCLEdBQUcsR0FBRyxPQUFNcjNCLElBQU4sb0JBQU1BLElBQUksQ0FBRXMzQixVQUFaLENBQVo7QUFDQUQsT0FBRyxRQUFILFlBQUFBLEdBQUcsQ0FBRUUsVUFBTDtBQUNEO0FBTnFCLENBQUQsQ0FBdkI7QUFRQSxNQUFNQyxXQUFXLEdBQUcsWUFBcEIsQyxDQUNBOztBQUNBLE1BQU1DLFVBQVUsR0FBRyxRQUFuQjtBQUNBLE1BQU1DLG1CQUFtQixHQUFHLG1CQUE1QjtBQUNBLE1BQU1yTSxjQUFjLEdBQUcsV0FBdkI7QUFDQSxNQUFNc00sY0FBYyxHQUFHLFdBQXZCO0FBQ0EsTUFBTUMsTUFBTSxHQUFHLEVBQWY7QUFDQSxJQUFJbk0sU0FBSjtBQUNBLElBQUlvTSxVQUFKO0FBQ0EsSUFBSUMsU0FBSjtBQUNBejRCLDREQUFXLENBQUMwNEIsZUFBRCxDQUFYO0FBQ0EzTixvREFBYyxDQUFDeFosSUFBZixDQUFvQixNQUFNO0FBQ3hCLE9BQUssTUFBTXZJLEdBQVgsSUFBa0IsQ0FBQ292QixVQUFELEVBQWFDLG1CQUFiLEVBQWtDck0sY0FBbEMsRUFBa0RzTSxjQUFsRCxDQUFsQixFQUFxRjtBQUNuRkksbUJBQWUsQ0FBQztBQUFFLE9BQUMxdkIsR0FBRCxHQUFPM0YsMERBQVMsQ0FBQzJGLEdBQUQ7QUFBbEIsS0FBRCxDQUFmO0FBQ0Q7QUFDRixDQUpEO0FBTUExSSxNQUFNLENBQUNDLE1BQVAsQ0FBY0MsaURBQWQsRUFBd0I7QUFDdEIsUUFBTXlCLGlCQUFOLENBQXdCO0FBQUUwMkIsVUFBRjtBQUFVajNCLFlBQVY7QUFBb0JWO0FBQXBCLEdBQXhCLEVBQTREQyxHQUE1RCxFQUFpRTtBQUMvRFMsWUFBUSxDQUFDNkssT0FBVCxDQUFpQnFzQixlQUFqQixFQUFrQzMzQixHQUFsQzs7QUFDQSxRQUFJMDNCLE1BQUosRUFBWTtBQUNWO0FBQ0F6MEIsV0FBSyxDQUFDMjBCLEdBQU4sQ0FBVUYsTUFBTSxDQUFDRyxRQUFqQixFQUZVLENBR1Y7O0FBQ0EsWUFBTW5ULEdBQUcsR0FBRyxNQUFNemhCLEtBQUssQ0FBQzJiLEdBQU4sQ0FBVThZLE1BQU0sQ0FBQ0ksTUFBakIsQ0FBbEI7O0FBQ0EsVUFBSXBULEdBQUosRUFBUztBQUNQQSxXQUFHLENBQUMza0IsWUFBSixHQUFtQkEsWUFBbkI7QUFDQTJrQixXQUFHLENBQUN6VCxPQUFKLENBQVl0SCxHQUFaLENBQWdCb3VCLGFBQWhCLEVBQStCclQsR0FBL0IsRUFBb0N0VCxNQUFwQyxDQUEyQ0MsT0FBM0MsRUFBb0QvRixPQUFwRCxDQUE0RHFzQixlQUE1RCxFQUE2RTMzQixHQUE3RTtBQUNBLGVBQU95Syx5R0FBVSxDQUFDaWEsR0FBRCxFQUFNLENBQUMsT0FBRCxFQUFVLFNBQVYsQ0FBTixDQUFqQjtBQUNEO0FBQ0Y7QUFDRjs7QUFkcUIsQ0FBeEI7QUFpQkE7O0FBQ0EsU0FBU2lULGVBQVQsQ0FBeUIsQ0FBQzV2QixHQUFELEVBQU1pd0IsY0FBTixDQUF6QixFQUFnRDtBQUM5QyxRQUFNMzBCLElBQUksR0FBR3d6QixTQUFTLENBQUNqWSxHQUFWLENBQWM3VyxHQUFkLENBQWIsQ0FEOEMsQ0FFOUM7O0FBQ0EsTUFBSWl3QixjQUFjLElBQUkzMEIsSUFBdEIsRUFBNEI7QUFDMUJPLFdBQU8sQ0FBQ3dPLElBQVIsQ0FBYTZsQixhQUFiLENBQTJCLEtBQUsvM0IsR0FBTCxDQUFTRSxFQUFwQyxFQUF3QztBQUN0Q2lELFVBRHNDO0FBRXRDcEQsYUFBTyxFQUFFLEtBQUtBLE9BRndCO0FBR3RDd2tCLFdBQUssRUFBRTtBQUgrQixLQUF4QztBQUtEO0FBQ0Y7O0FBRUQsTUFBTXlULFlBQVksR0FBRztBQUNuQixHQUFDeFksK0ZBQU8sQ0FBQ3pjLEtBQVIsQ0FBY3NMLE1BQWYsR0FBd0JtVixrREFETDtBQUVuQixHQUFDaEUsK0ZBQU8sQ0FBQ3JjLElBQVIsQ0FBYWtMLE1BQWQsR0FBdUIsSUFGSjtBQUduQixHQUFDbVIsK0ZBQU8sQ0FBQytDLE9BQVIsQ0FBZ0JsVSxNQUFqQixHQUEwQm9WLGdEQUhQO0FBSW5CLEdBQUNqRSwrRkFBTyxDQUFDM1osTUFBUixDQUFld0ksTUFBaEIsR0FBeUIsSUFKTjtBQUtuQixHQUFDbVIsK0ZBQU8sQ0FBQ3JYLEtBQVIsQ0FBY2tHLE1BQWYsR0FBd0JxVixpREFBYUE7QUFMbEIsQ0FBckI7QUFRQWhnQixPQUFPLENBQUM4YixPQUFSLENBQWdCeVksU0FBaEIsQ0FBMEJwMEIsV0FBMUIsQ0FBc0MsTUFBTS9FLE9BQU4sSUFBaUI7QUFDckQsUUFBTW81QixNQUFNLEdBQUcvNEIsTUFBTSxDQUFDNEksSUFBUCxDQUFZakosT0FBWixDQUFmO0FBQ0EsUUFBTXE1QixXQUFXLEdBQUcsTUFBTWowQixPQUFPLENBQUN3SyxHQUFSLENBQVkzTCxLQUFLLENBQUNxMUIsU0FBTixFQUFaLENBQTFCO0FBQ0EsUUFBTUMsS0FBSyxHQUFHRixXQUFXLENBQUMxVCxJQUFaLENBQWlCamxCLElBQUksSUFBSUEsSUFBSSxDQUFDZ0IsTUFBTCxJQUNsQzAzQixNQUFNLENBQUN6VCxJQUFQLENBQWE1YyxHQUFELElBQVM7QUFBQTs7QUFDdEIsVUFBTXdHLE1BQU0sR0FBR3hHLEdBQUcsQ0FBQ0wsS0FBSixDQUFVLENBQVYsRUFBYUssR0FBRyxDQUFDUCxPQUFKLENBQVksR0FBWixJQUFtQixDQUFoQyxDQUFmO0FBQ0EsVUFBTXdSLElBQUksR0FBR2tmLFlBQVksQ0FBQzNwQixNQUFELENBQXpCO0FBQ0F4RyxPQUFHLEdBQUdBLEdBQUcsQ0FBQ0wsS0FBSixDQUFVNkcsTUFBTSxDQUFDek4sTUFBakIsQ0FBTjtBQUNBLFdBQU9rWSxJQUFJLEtBQUssSUFBVCxtQkFDRnRaLElBQUksQ0FBQ3NaLElBQUQsQ0FERixxQkFDRixXQUFZL1csUUFBWixDQUFxQnNNLE1BQU0sS0FBS21SLCtGQUFPLENBQUNyWCxLQUFSLENBQWNrRyxNQUF6QixHQUFrQyxDQUFDeEcsR0FBbkMsR0FBeUNBLEdBQTlELENBREUsQ0FBUDtBQUVELEdBTkUsQ0FEUyxDQUFkOztBQVFBLE1BQUl3d0IsS0FBSixFQUFXO0FBQ1R0MUIsU0FBSyxDQUFDb2IsT0FBTjtBQUNEO0FBQ0YsQ0FkRDs7QUFnQkEsU0FBU21hLGNBQVQsQ0FBd0Jud0IsS0FBeEIsRUFBK0I7QUFDN0IsU0FBTyxTQUFnQm93QixjQUFoQixFQUFBQyxxR0FBYyxFQUFpQnJ3QixLQUFqQixDQUFkLEdBQ0hBLEtBREcsR0FFSGt2QixVQUFVLElBQUl0VSxrR0FGbEI7QUFHRDs7QUFFRCxTQUFTd1UsZUFBVCxDQUF5Qno0QixPQUF6QixFQUFrQztBQUNoQyxXQUFTNEosbUdBQVQsRUFBQTVKLE9BQU8sRUFBZSxDQUFDLENBQUMrSSxHQUFELEVBQU1NLEtBQU4sQ0FBRCxLQUFrQjtBQUN0QyxZQUFRTixHQUFSO0FBQ0EsV0FBS3F2QixtQkFBTDtBQUNFRyxrQkFBVSxHQUFHaUIsY0FBYyxDQUFDbndCLEtBQUQsQ0FBM0I7QUFDQXBGLGFBQUssQ0FBQ29iLE9BQU47QUFDQTs7QUFDRixXQUFLZ1osY0FBTDtBQUNFc0IsdUJBQWUsQ0FBQ3R3QixLQUFELENBQWY7QUFDQXBGLGFBQUssQ0FBQ29iLE9BQU47QUFDQTs7QUFDRixXQUFLME0sY0FBTDtBQUNFNk4sdUJBQWUsQ0FBQ3Z3QixLQUFELENBQWY7QUFDQTs7QUFDRixXQUFLOHVCLFVBQUw7QUFDRSxpQkFBT3Z1QixtR0FBUCxFQUFBUCxLQUFLLEVBQWUsQ0FBQyxDQUFDd3dCLElBQUQsRUFBT0MsU0FBUCxDQUFELEtBQXVCO0FBQ3pDeEIsZ0JBQU0sQ0FBQzF2QixrQkFBa0IsQ0FBQ2l4QixJQUFELENBQW5CLENBQU4sR0FBbUNDLFNBQW5DO0FBQ0QsU0FGSSxDQUFMO0FBR0E7O0FBQ0Y7QUFDRSxZQUFJL3dCLEdBQUcsQ0FBQzlGLFFBQUosQ0FBYSxHQUFiLENBQUosRUFBdUI7QUFBRTtBQUN2QncxQix5QkFBZSxDQUFDL21CLHdHQUFTLENBQUMsRUFBRCxFQUFLM0ksR0FBTCxFQUFVTSxLQUFWLENBQVYsQ0FBZjtBQUNEOztBQXBCSDtBQXNCRCxHQXZCTSxDQUFQO0FBd0JEO0FBRUQ7OztBQUNPLFNBQVM3SCxrQkFBVCxDQUE0QlYsR0FBNUIsRUFBaUNLLEtBQWpDLEVBQXdDRixPQUF4QyxFQUFpREYsWUFBakQsRUFBK0Q7QUFDcEUsUUFBTWdJLEdBQUcsR0FBR21kLE1BQU0sQ0FBQ3BsQixHQUFELEVBQU0sQ0FBQ0csT0FBUCxDQUFsQjtBQUNBLFNBQU9nRCxLQUFLLENBQUMyYixHQUFOLENBQVU3VyxHQUFWLEtBQWtCeUYsT0FBTyxDQUFDekYsR0FBRCxFQUFNakksR0FBTixFQUFXSyxLQUFYLEVBQWtCRixPQUFsQixFQUEyQkYsWUFBM0IsQ0FBaEM7QUFDRDs7QUFFRCxTQUFTbWxCLE1BQVQsQ0FBZ0JwbEIsR0FBaEIsRUFBcUJra0IsS0FBckIsRUFBNEI7QUFDMUIsU0FBT0EsS0FBSyxHQUFHbGtCLEdBQUgsR0FBVSxJQUFHQSxHQUFJLEVBQTdCO0FBQ0Q7O0FBRUQsU0FBUzg0QixlQUFULENBQXlCRyxNQUF6QixFQUFpQztBQUMvQjVOLFdBQVMsR0FBRzROLE1BQVosQ0FEK0IsQ0FFL0I7QUFDQTs7QUFDQSxRQUFNQyxLQUFLLEdBQUksR0FBRUQsTUFBTSxHQUFHLEtBQUgsR0FBVyxRQUFTLFVBQTNDO0FBQ0EsUUFBTXZ3QixNQUFNLEdBQUd1d0IsTUFBTSxHQUFHdEMsVUFBSCxHQUFnQnZkLFNBQXJDO0FBQ0F0VixTQUFPLENBQUNvTyxVQUFSLENBQW1CaW5CLGFBQW5CLENBQWlDRCxLQUFqQyxFQUF3Q0MsYUFBeEMsRUFBdUR6d0IsTUFBdkQ7O0FBQ0EsTUFBSSxDQUFDMmlCLFNBQUQsSUFBYyxDQUFDcU0sU0FBbkIsRUFBOEI7QUFBRTtBQUM5QjV6QixXQUFPLENBQUNvTyxVQUFSLENBQW1Ca25CLGlCQUFuQixDQUFxQ0YsS0FBckMsRUFBNENFLGlCQUE1QyxFQUErRDF3QixNQUEvRDtBQUNEOztBQUNEdkYsT0FBSyxDQUFDb2IsT0FBTjtBQUNEOztBQUVELFNBQVNzYSxlQUFULENBQXlCSSxNQUF6QixFQUFpQztBQUMvQnZCLFdBQVMsR0FBR3VCLE1BQVo7QUFDQW4xQixTQUFPLENBQUNvTyxVQUFSLENBQW1Ca25CLGlCQUFuQixDQUFxQzNtQixjQUFyQyxDQUFvRDJtQixpQkFBcEQ7O0FBQ0EsTUFBSUgsTUFBSixFQUFZO0FBQ1ZuMUIsV0FBTyxDQUFDb08sVUFBUixDQUFtQmtuQixpQkFBbkIsQ0FBcUNuMUIsV0FBckMsQ0FBaURtMUIsaUJBQWpELEVBQW9FekMsVUFBcEUsRUFBZ0YsQ0FDOUUsVUFEOEUsRUFFOUUsaUJBRjhFLEVBRzlFN3lCLE9BQU8sQ0FBQ29PLFVBQVIsQ0FBbUJtbkIsd0JBQW5CLENBQTRDQyxhQUhrQyxFQUk5RWhvQixNQUo4RSxDQUl2RUMsT0FKdUUsQ0FBaEY7QUFLRDtBQUNGOztBQUVELFNBQVM0bkIsYUFBVCxDQUF1QjtBQUFFbjVCLEtBQUY7QUFBT0ssT0FBUDtBQUFjRjtBQUFkLENBQXZCLEVBQWdEO0FBQzlDLE1BQUksQ0FBQ3dzQiw0R0FBcUIsQ0FBQ3BsQixJQUF0QixDQUEyQnZILEdBQTNCLENBQUwsRUFBc0M7QUFDdEMsUUFBTWtrQixLQUFLLEdBQUcsQ0FBQy9qQixPQUFmO0FBQ0EsUUFBTThILEdBQUcsR0FBR21kLE1BQU0sQ0FBQ3BsQixHQUFELEVBQU1ra0IsS0FBTixDQUFsQjs7QUFDQSxNQUFJLENBQUMvZ0IsS0FBSyxDQUFDbzJCLEdBQU4sQ0FBVXR4QixHQUFWLENBQUwsRUFBcUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E5RSxTQUFLLENBQUMwTixHQUFOLENBQVU1SSxHQUFWLEVBQWV5RixPQUFPLENBQUN6RixHQUFELEVBQU1qSSxHQUFOLEVBQVdLLEtBQVgsRUFBa0JGLE9BQWxCLENBQXRCLEVBQWtEeTJCLGVBQWxEO0FBQ0Q7QUFDRjtBQUVEOzs7QUFDQSxTQUFTd0MsaUJBQVQsQ0FBMkIxMEIsSUFBM0IsRUFBaUM7QUFDL0IsUUFBTXVELEdBQUcsR0FBR21kLE1BQU0sQ0FBQzFnQixJQUFJLENBQUMxRSxHQUFOLEVBQVcsQ0FBQzBFLElBQUksQ0FBQ3ZFLE9BQWpCLENBQWxCO0FBQ0EsUUFBTVAsSUFBSSxHQUFHODNCLFNBQVMsSUFBSXYwQixLQUFLLENBQUNrRCxHQUFOLENBQVU0QixHQUFWLENBQTFCO0FBQ0E5RSxPQUFLLENBQUN5YixHQUFOLENBQVUzVyxHQUFWLEVBQWU0dUIsa0JBQWY7QUFDQSxTQUFPLENBQUFqM0IsSUFBSSxRQUFKLFlBQUFBLElBQUksQ0FBRWdCLE1BQU4sS0FBZ0I0NEIsY0FBYyxDQUFDOTBCLElBQUQsRUFBTzlFLElBQVAsQ0FBckM7QUFDRDtBQUVEOzs7Ozs7QUFJQSxTQUFTNDVCLGNBQVQsQ0FBd0I7QUFBRXg1QixLQUFGO0FBQU95NUI7QUFBUCxDQUF4QixFQUFrRDc1QixJQUFsRCxFQUF3RDtBQUN0RCxNQUFJSSxHQUFHLENBQUN3TyxVQUFKLENBQWUsUUFBZixLQUE0QmtyQixlQUFlLENBQUNELGVBQUQsQ0FBL0MsRUFBa0U7QUFDaEVFLHlCQUFxQixDQUFDLzVCLElBQUQsQ0FBckI7QUFDRDs7QUFDRCxRQUFNcW9CLE9BQU8sR0FBR3pQLEdBQUcsQ0FBQzBQLGVBQUosQ0FBb0IsSUFBSUMsSUFBSixDQUFTLENBQzNDaGQsSUFBSSxDQUFDMkYsU0FBTCxDQUFlbFIsSUFBSSxDQUFDZ0IsTUFBcEIsQ0FEMkMsQ0FBVCxDQUFwQixDQUFoQjtBQUdBNjRCLGlCQUFlLENBQUNqcEIsSUFBaEIsQ0FBcUI7QUFDbkJwSixRQUFJLEVBQUUsWUFEYTtBQUVuQm1CLFNBQUssRUFBRyxJQUFHbkQsNEJBQTJCLEtBQUk2aUIsT0FBTyxDQUFDcGdCLEtBQVIsQ0FBYyxHQUFkLEVBQW1CaVgsR0FBbkIsRUFBeUI7QUFGaEQsR0FBckI7QUFJQTdkLFlBQVUsQ0FBQ3VYLEdBQUcsQ0FBQzZQLGVBQUwsRUFBc0J5TyxjQUF0QixFQUFzQzdPLE9BQXRDLENBQVY7QUFDQSxTQUFPO0FBQUV3UjtBQUFGLEdBQVA7QUFDRDs7QUFFRCxTQUFTL3JCLE9BQVQsQ0FBaUJ6RixHQUFqQixFQUFzQmpJLEdBQXRCLEVBQTJCSyxLQUEzQixFQUFrQ0YsT0FBbEMsRUFBMkNGLFlBQTNDLEVBQXlEO0FBQ3ZEO0FBQ0EsUUFBTVEsR0FBRyxHQUFHO0FBQ1Y7QUFDQUcsVUFBTSxFQUFFO0FBQ040MkIsWUFBTSxFQUFFLENBQUNyM0IsT0FBRCxJQUNISCxHQUFHLENBQUN3TyxVQUFKLENBQWUsVUFBZixDQURHLElBRUhncEIsTUFBTSxDQUFDeDNCLEdBQUcsQ0FBQzZILEtBQUosQ0FBVSxHQUFWLEVBQWUsQ0FBZixFQUFrQixDQUFsQixDQUFEO0FBSEw7QUFGRSxHQUFaO0FBUUEsU0FBT3dqQixTQUFTLEdBQ1p1TyxjQUFjLENBQUNuNUIsR0FBRCxFQUFNd0gsR0FBTixFQUFXakksR0FBWCxFQUFnQkssS0FBaEIsRUFBdUJGLE9BQXZCLEVBQWdDRixZQUFoQyxDQURGLEdBRVpRLEdBRko7QUFHRDs7QUFFRCxlQUFlbTVCLGNBQWYsQ0FBOEJuNUIsR0FBOUIsRUFBbUNzM0IsUUFBbkMsRUFBNkMvM0IsR0FBN0MsRUFBa0RLLEtBQWxELEVBQXlERixPQUF6RCxFQUFrRUYsWUFBbEUsRUFBZ0Y7QUFDOUUsUUFBTUwsSUFBSSxHQUFHLE1BQU1xa0IsMkRBQWUsQ0FBQ2prQixHQUFELEVBQU0sQ0FBQ0csT0FBUCxDQUFsQztBQUNBLFFBQU07QUFBRXNrQixjQUFGO0FBQWN0VDtBQUFkLE1BQTBCdlIsSUFBaEM7QUFDQSxRQUFNaTZCLE1BQU0sR0FBRzU1QixZQUFZLElBQUksSUFBL0I7QUFDQUwsTUFBSSxDQUFDSyxZQUFMLEdBQW9CQSxZQUFwQjtBQUNBLFFBQU1VLFFBQVEsR0FBR3dRLE9BQU8sQ0FBQ3RILEdBQVIsQ0FBWW91QixhQUFaLEVBQTJCcjRCLElBQTNCLEVBQWlDMFIsTUFBakMsQ0FBd0NDLE9BQXhDLENBQWpCO0FBQ0EsUUFBTTNHLElBQUksR0FBRzZaLFVBQVUsQ0FBQ3ZYLE9BQXhCO0FBQ0EsUUFBTThxQixNQUFNLEdBQUd4aUIsaUdBQVMsQ0FBRSxHQUFFblYsS0FBTSxJQUFHRixPQUFRLEdBQXJCLENBQXhCO0FBQ0EsUUFBTTtBQUFFUztBQUFGLE1BQWFILEdBQW5CO0FBQ0E7O0FBQ0FsQixRQUFNLENBQUNDLE1BQVAsQ0FBY29CLE1BQWQsRUFBc0I7QUFDcEJ1USxXQURvQjtBQUVwQixLQUFDaW1CLFdBQUQsR0FBZUssVUFGSztBQUdwQnQwQixTQUFLLEVBQUV2RCxJQUFJLENBQUN1RCxLQUhRO0FBSXBCeTBCLFVBQU0sRUFBRTtBQUNORyxjQURNO0FBQ0k7QUFDVkMsWUFGTSxDQUVFOztBQUZGLEtBSlk7QUFRcEI4QixXQUFPLEVBQUUsQ0FBQyxDQUFDbHZCLElBUlM7QUFRSDtBQUNqQjNLLGdCQUFZLEVBQUVBLFlBQVksSUFBTTtBQUM5QlUsWUFBUSxDQUFDSyxNQUFULEtBQW9CbVEsT0FBTyxDQUFDblEsTUFBNUIsQ0FBbUM7QUFBbkMsT0FDR3lqQixVQUFVLENBQUN0VCxPQUFYLENBQW1CNG9CLEtBQW5CLENBQXlCQyxHQUFHLElBQUlDLGNBQWMsQ0FBQ0QsR0FBRCxFQUFNLzVCLFlBQU4sQ0FBOUMsQ0FGcUIsQ0FFOEM7QUFYcEQ7QUFhcEJOLE9BQUcsRUFBRUMsSUFBSSxDQUFDMmtCLFdBYlU7QUFhRztBQUN2QjdmLFFBQUksRUFBRTtBQUNKdzFCLG9HQUFFQTtBQURFO0FBZGMsR0FBdEI7QUFrQkE7O0FBQ0EzNkIsUUFBTSxDQUFDQyxNQUFQLENBQWNpQixHQUFkLEVBQW1CO0FBQ2pCRSxZQURpQjtBQUVqQkUsWUFBUSxFQUFFLENBQUMsR0FBR2pCLElBQUksQ0FBQ2trQixpREFBRCxDQUFSLEVBQXlCLEdBQUdXLFVBQVUsQ0FBQ1gsaURBQUQsQ0FBdEMsQ0FGTztBQUdqQm9ULGNBQVUsRUFBRSxDQUFDMkMsTUFBRCxJQUFXLENBQUNuQyxTQUFaLElBQXlCeHpCLFVBQXpCLEdBQ1JpMkIsb0JBQW9CLENBQUN2NUIsTUFBRCxFQUFTWixHQUFULEVBQWMsQ0FBQyxDQUFDRyxPQUFoQixDQURaLEdBRVI7QUFMYSxHQUFuQjtBQU9BLE1BQUl5SyxJQUFKLEVBQVV6SCxLQUFLLENBQUMwTixHQUFOLENBQVVtbkIsTUFBVixFQUFrQnB0QixJQUFsQjtBQUNWekgsT0FBSyxDQUFDME4sR0FBTixDQUFVa25CLFFBQVYsRUFBb0J0M0IsR0FBcEIsRUFyQzhFLENBcUNwRDs7QUFDMUIsU0FBT0EsR0FBUDtBQUNEO0FBRUQ7OztBQUNBLFNBQVN3M0IsYUFBVCxDQUF1Qmh5QixNQUF2QixFQUErQjtBQUFBOztBQUM3QixRQUFNO0FBQUV6QyxVQUFGO0FBQVVxZCxRQUFWO0FBQWdCblc7QUFBaEIsTUFBMEJ6RSxNQUFoQztBQUNBLFFBQU07QUFBRTNGO0FBQUYsTUFBU29LLEtBQWY7QUFDQSxRQUFNO0FBQUV6SyxnQkFBRjtBQUFnQjBpQixXQUFoQjtBQUF5QnBhO0FBQXpCLE1BQW1DLElBQXpDO0FBQ0EsUUFBTWhGLElBQUksR0FBRyxLQUFLQSxJQUFMLENBQVVqRCxFQUFWLENBQWI7QUFDQSxRQUFNODVCLE9BQU8sR0FBRzVrQixpR0FBUyxDQUFDLE1BQUQsQ0FBekI7QUFDQSxRQUFNekwsV0FBVyxHQUFHMmYscUdBQWEsQ0FBQ3pqQixNQUFELENBQWpDO0FBQ0EsUUFBTW1CLElBQUksR0FBRytPLGtCQUFrQixDQUFDcE0sV0FBVyxDQUFDb0osT0FBWixDQUFvQixnQkFBcEIsRUFBc0NrbkIsd0JBQXRDLENBQUQsQ0FBL0I7QUFDQSxRQUFNQyxTQUFTLEdBQUdMLGNBQWMsQ0FBQ2gwQixNQUFELEVBQVNoRyxZQUFULENBQWhDO0FBQ0EsUUFBTXVpQixPQUFPLEdBQUdoZixNQUFNLENBQUNnZixPQUFQLElBQWtCLEVBQWxDO0FBQ0EsUUFBTStYLElBQUksb0JBQUcxWixJQUFJLENBQUM4QixPQUFSLHFCQUFHLGNBQWM5WSxHQUFkLENBQWtCNUIsR0FBRyxJQUFJMGEsT0FBTyxDQUFDSCxPQUFPLENBQUN2YSxHQUFELENBQVAsSUFBZ0JBLEdBQWpCLENBQWhDLEVBQXVEcUosTUFBdkQsQ0FBOERDLE9BQTlELENBQWIsQ0FWNkIsQ0FXN0I7QUFDQTs7QUFDQSxRQUFNaXBCLFVBQVUsR0FBR0QsSUFBSSxHQUFHLEdBQUdFLE1BQUgsQ0FBVSxHQUFHRixJQUFJLENBQUMxd0IsR0FBTCxDQUFTNUgsR0FBRyxJQUFJLENBQUNBLEdBQUQsRUFBTSxLQUFOLENBQWhCLENBQWIsQ0FBSCxHQUFpRCxFQUF4RTtBQUNBLFFBQU15NEIsT0FBTyxHQUFHRixVQUFVLENBQUN4NUIsTUFBM0I7QUFDQSxRQUFNMjVCLFlBQVksR0FBRyxDQUNuQjtBQUNDLFlBQVNQLE9BQVEsYUFBWUEsT0FBUSw2Q0FGbkIsRUFHbkIsR0FBR0ksVUFIZ0IsRUFJbkI7QUFDQUUsU0FBTyxHQUFHLFFBQUgsR0FBYyxFQUxGLEVBTW5CbjNCLElBTm1CLEVBT25CO0FBQ0FBLE1BQUksQ0FBQ2dWLFFBQUwsQ0FBYyxJQUFkLElBQXNCLEVBQXRCLEdBQTJCLElBUlIsRUFTbkJtaUIsT0FBTyxHQUFHLE1BQUgsR0FBWSxFQVRBLEVBVW5CO0FBQ0MsbUJBQWdCTixPQUFRLFNBWE4sRUFZbkI7QUFDQyxxQkFBa0IzTSxtREFBYyxHQUFFdnBCLFVBQVUsR0FBRyxLQUFILEdBQVcsRUFBRyxHQUFFa0QsSUFBSyxZQUFXOUcsRUFBRyxFQWI3RCxFQWNuQnFWLElBZG1CLENBY2QsRUFkYyxDQUFyQjtBQWVBb2hCLFdBQVMsQ0FBQ2xtQixHQUFWLENBQWN1cEIsT0FBZCxFQUF1Qk8sWUFBdkIsRUFBcUM3RCxjQUFyQztBQUNBOztBQUNBdjNCLFFBQU0sQ0FBQ0MsTUFBUCxDQUFjeUcsTUFBZCxFQUFzQjtBQUNwQm0wQixXQURvQjtBQUVwQnJ3QixlQUZvQjtBQUdwQjtBQUNBeEcsUUFBSSxFQUFFKzJCLFNBQVMsR0FBRyxFQUFILEdBQVFyNkIsWUFBWSxJQUFJMDZCLFlBSm5CO0FBS3BCQyxXQUFPLEVBQUVyM0IsSUFBSSxDQUFDL0IsS0FBTCxDQUFXcTVCLG1HQUFYLEVBQXlCLENBQXpCLEtBQStCLEVBTHBCO0FBTXBCdmEsVUFBTSxFQUFFL1gsS0FBSyxDQUFDakksRUFBRCxDQUFMLElBQWE7QUFORCxHQUF0QjtBQVFBLFNBQU9nNkIsU0FBUyxJQUFJLENBQUNGLE9BQUQsRUFBVSxJQUFWLENBQXBCO0FBQ0Q7O0FBRUQsU0FBU0Msd0JBQVQsQ0FBa0M1SyxDQUFsQyxFQUFxQztBQUNuQztBQUNBLFNBQU9xTCxNQUFNLENBQUNDLFlBQVAsQ0FBb0J0TCxDQUFDLENBQUMxYyxVQUFGLENBQWEsQ0FBYixJQUFrQixJQUFsQixHQUF5QixNQUE3QyxDQUFQO0FBQ0Q7O0FBRUQsTUFBTWlvQixrQkFBa0IsR0FBSSxJQUFHLFNBQVM3WSxDQUFULENBQVd2aUIsSUFBWCxFQUFpQjtBQUM5Qzs7QUFFQSxRQUFNO0FBQUVxN0I7QUFBRixNQUFnQixJQUF0Qjs7QUFDQSxNQUFJQSxTQUFKLEVBQWU7QUFDYkEsYUFBUyxDQUFDcjdCLElBQUQsQ0FBVDtBQUNELEdBRkQsTUFFTztBQUNMO0FBQ0EsU0FBS3M3QixNQUFMLEdBQWN0N0IsSUFBZDtBQUNEO0FBQ0YsQ0FBQyxHQVZGLEMsQ0FZQTs7QUFDQSxTQUFTdTZCLG9CQUFULENBQThCdjVCLE1BQTlCLEVBQXNDWixHQUF0QyxFQUEyQ203QixTQUEzQyxFQUFzRDtBQUFBOztBQUNwRCxrQ0FBT3IzQixPQUFPLENBQUNzM0IsY0FBZixxQkFBTyxzQkFBd0I1cEIsUUFBeEIsQ0FBaUM7QUFDdEMycEIsYUFEc0M7QUFFdEN0MUIsTUFBRSxFQUFFLENBQUM7QUFDSHRDLFVBQUksRUFBRyxHQUFFeTNCLGtCQUFtQixJQUFHN3ZCLElBQUksQ0FBQzJGLFNBQUwsQ0FBZWxRLE1BQWYsQ0FBdUI7QUFEbkQsS0FBRCxDQUZrQztBQUt0Q3k2QixXQUFPLEVBQUVyN0IsR0FBRyxDQUFDNkgsS0FBSixDQUFVLEdBQVYsRUFBZSxDQUFmLENBTDZCO0FBTXRDOGMsU0FBSyxFQUFFO0FBTitCLEdBQWpDLENBQVA7QUFRRDtBQUVEOzs7QUFDQSxTQUFTK1UsZUFBVCxDQUF5QkQsZUFBekIsRUFBMEM7QUFDeEMsU0FBT0EsZUFBZSxDQUFDNVUsSUFBaEIsQ0FBcUIsQ0FBQztBQUFFemQsUUFBRjtBQUFRbUI7QUFBUixHQUFELEtBQzFCLDZCQUE2QmhCLElBQTdCLENBQWtDSCxJQUFsQyxLQUNHLDBCQUEwQkcsSUFBMUIsRUFBZ0M7QUFDakNnQixPQUFLLENBQUMvRyxLQUFOLENBQVksa0NBQVosS0FDRytHLEtBQUssQ0FBQy9HLEtBQU4sQ0FBWSw2QkFBWixDQURILElBRUcrRyxLQUFLLENBQUMvRyxLQUFOLENBQVksOEJBQVosQ0FGSCxJQUdHLEVBSkYsQ0FGRSxDQUFQO0FBU0Q7QUFFRDs7O0FBQ0EsU0FBU200QixxQkFBVCxDQUErQi81QixJQUEvQixFQUFxQztBQUNuQztBQUNBLFFBQU1nQixNQUFNLEdBQUdoQixJQUFJLENBQUNnQixNQUFwQjtBQUNBQSxRQUFNLENBQUNYLFlBQVAsR0FBc0IsSUFBdEI7QUFDQVcsUUFBTSxDQUFDdVEsT0FBUCxDQUFlM0YsT0FBZixDQUF1Qnd1QixHQUFHLElBQUk7QUFDNUI7QUFDQUEsT0FBRyxDQUFDejJCLElBQUosR0FBVyxDQUFDMDJCLGNBQWMsQ0FBQ0QsR0FBRCxFQUFNLElBQU4sQ0FBZixJQUE4QixFQUF6QztBQUNBcDZCLFFBQUksQ0FBQ2UsUUFBTCxDQUFjNlAsSUFBZCxDQUFtQixDQUFDd3BCLEdBQUcsQ0FBQ0ksT0FBTCxFQUFjLElBQWQsQ0FBbkI7QUFDRCxHQUpEO0FBS0Q7O0FBRUQsU0FBU0gsY0FBVCxDQUF3QkQsR0FBeEIsRUFBNkIvNUIsWUFBN0IsRUFBMkM7QUFDekMsUUFBTXE3QixLQUFLLEdBQUd0QixHQUFHLENBQUM1QyxXQUFELENBQUgsS0FDWjRDLEdBQUcsQ0FBQzVDLFdBQUQsQ0FBSCxHQUFtQnNCLGNBQWMsQ0FBQ3NCLEdBQUcsQ0FBQ3gyQixNQUFKLENBQVc0ekIsV0FBWCxLQUEyQjRDLEdBQUcsQ0FBQ25aLElBQUosQ0FBU3VXLFdBQVQsQ0FBNUIsQ0FEckIsQ0FBZDtBQUdBLFNBQU9rRSxLQUFLLEtBQUtDLHFHQUFWLElBQTRCdDdCLFlBQVksSUFBSXE3QixLQUFLLEtBQUtuWSxrR0FBN0Q7QUFDRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9XRDtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxNQUFNcVksVUFBVSxHQUFHO0FBQ2pCaE4sTUFBSSxFQUFFRCxrREFEVztBQUVqQm1ELE9BQUssRUFBRVEsdURBQVVBO0FBRkEsQ0FBbkI7QUFLQSxNQUFNdUosU0FBUyxHQUFHLFdBQWxCO0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUksR0FBRWpPLG1EQUFjLHFCQUExQztBQUNBOztBQUNBLE1BQU1zRSxRQUFRLEdBQUcsRUFBakI7QUFDQSxNQUFNcEIsU0FBUyxHQUFHLEVBQWxCO0FBQ0EsTUFBTWdMLE1BQU0sR0FBRyxFQUFmO0FBQ0EsTUFBTUMsV0FBVyxHQUFHLEVBQXBCO0FBQ0EsTUFBTTtBQUFFOTJCO0FBQUYsSUFBYWxCLE1BQW5CO0FBQ0EsSUFBSWk0QixPQUFKOztBQUVBLElBQUkvMkIsTUFBSixFQUFZO0FBQ1ZBLFFBQU0sQ0FBQzZyQixTQUFQLENBQWlCMEgsU0FBakIsQ0FBMkJwMEIsV0FBM0IsQ0FBdUM2M0IsR0FBRyxJQUFJO0FBQUE7O0FBQzVDO0FBQ0EsUUFBSSxDQUFDbkwsU0FBUyxDQUFDbUwsR0FBRyxDQUFDeDdCLEVBQUwsQ0FBZCxFQUF3QjtBQUN4QixVQUFNO0FBQUUyQixTQUFGO0FBQU8vQjtBQUFQLFFBQWV5d0IsU0FBUyxDQUFDbUwsR0FBRyxDQUFDeDdCLEVBQUwsQ0FBOUI7QUFDQSxVQUFNO0FBQUVGLFNBQUcsRUFBRTtBQUFFRSxVQUFFLEVBQUVEO0FBQU4sT0FBUDtBQUFzQkY7QUFBdEIsUUFBa0NELEdBQXhDOztBQUVBLFFBQUksZUFBQTQ3QixHQUFHLENBQUN4eUIsS0FBSixnQ0FBV3l5QixPQUFYLE1BQXVCLFVBQTNCLEVBQXVDO0FBQ3JDbkksd0dBQVUsQ0FBQ3Z6QixLQUFELEVBQVEsZUFBUixFQUF5QjtBQUNqQ3dOLFlBQUksRUFBRSxNQUQyQjtBQUNuQnZOLFVBQUUsRUFBRTJCLEdBQUcsQ0FBQzNCLEVBRFc7QUFDUHd3QixrQkFBVSxFQUFFZ0wsR0FBRyxDQUFDeDdCO0FBRFQsT0FBekIsRUFFUDtBQUFFSDtBQUFGLE9BRk8sQ0FBVjtBQUdELEtBSkQsTUFJTyxJQUFJLGdCQUFBMjdCLEdBQUcsQ0FBQ3h5QixLQUFKLGlDQUFXeXlCLE9BQVgsTUFBdUIsYUFBM0IsRUFBMEM7QUFDL0NuSSx3R0FBVSxDQUFDdnpCLEtBQUQsRUFBUSxlQUFSLEVBQXlCO0FBQ2pDd04sWUFBSSxFQUFFLE9BRDJCO0FBQ2xCdk4sVUFBRSxFQUFFMkIsR0FBRyxDQUFDM0IsRUFEVTtBQUNOd3dCLGtCQUFVLEVBQUVnTCxHQUFHLENBQUN4N0I7QUFEVixPQUF6QixFQUVQO0FBQUVIO0FBQUYsT0FGTyxDQUFWO0FBR0QsS0FKTSxNQUlBO0FBQ0w7QUFDRDs7QUFDRCxXQUFPd3dCLFNBQVMsQ0FBQ21MLEdBQUcsQ0FBQ3g3QixFQUFMLENBQWhCO0FBQ0EsV0FBT3l4QixRQUFRLENBQUM5dkIsR0FBRyxDQUFDM0IsRUFBTCxDQUFmO0FBQ0QsR0FuQkQ7QUFvQkQ7O0FBRURmLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjQyxpREFBZCxFQUF3QjtBQUN0QnU4QixnQkFBYyxFQUFFQyxjQURNOztBQUV0QixRQUFNQyxpQkFBTixDQUF3Qjc3QixLQUF4QixFQUErQkgsR0FBL0IsRUFBb0M7QUFDbEMsVUFBTUUsR0FBRyxHQUFHOEQsVUFBVSxJQUFJLENBQUNoRSxHQUFHLENBQUNGLEdBQUosSUFBVyxFQUFaLEVBQWdCd08sVUFBaEIsQ0FBMkIsT0FBM0IsQ0FBZCxLQUNQLE1BQU0xSyxPQUFPLENBQUN3TyxJQUFSLENBQWFqTSxHQUFiLENBQWlCaEcsS0FBakIsRUFBd0IrRCxLQUF4QixDQUE4Qm9JLG9GQUE5QixDQURDLENBQVo7QUFFQSxXQUFPcE0sR0FBRyxJQUFJLENBQUNBLEdBQUcsQ0FBQ2tCLFVBQUosSUFBa0JsQixHQUFHLENBQUNKLEdBQXRCLElBQTZCLEVBQTlCLEVBQWtDd08sVUFBbEMsQ0FBNkNrdEIsZ0JBQTdDLENBQWQ7QUFDRCxHQU5xQjs7QUFPdEI7QUFDQVMsYUFBVyxDQUFDdmIsSUFBRCxFQUFPMWdCLEdBQVAsRUFBWTtBQUNyQixVQUFNO0FBQUVFLFNBQUcsRUFBRTtBQUFFRSxVQUFFLEVBQUVEO0FBQU4sT0FBUDtBQUFzQkY7QUFBdEIsUUFBa0NELEdBQXhDO0FBQ0EsVUFBTTtBQUFFSSxRQUFGO0FBQU0weEI7QUFBTixRQUF5QnBSLElBQS9CO0FBRUFuYyxXQUFPLENBQUNDLElBQVIsQ0FBYSxVQUFiLEVBQXlCa2MsSUFBekI7O0FBRUEsUUFBSTRhLFVBQVUsQ0FBQzVhLElBQUksQ0FBQy9TLElBQU4sQ0FBZCxFQUEyQjtBQUN6QixZQUFNaWpCLFVBQVUsR0FBR3h3QixFQUFuQixDQUR5QixDQUNGOztBQUN2QnNnQixVQUFJLENBQUMxZ0IsR0FBTCxHQUFXQSxHQUFYO0FBQ0EwZ0IsVUFBSSxDQUFDbVIsUUFBTCxHQUFnQkEsUUFBaEIsQ0FIeUIsQ0FHQzs7QUFDMUJuUixVQUFJLENBQUMrTyxVQUFMLEdBQWtCLENBQUNzQyxNQUFELEVBQVN0bEIsS0FBVCxLQUFtQjtBQUNuQyxZQUFJcWxCLGNBQUosb0JBQUlBLGNBQWMsQ0FBRTd2QixRQUFoQixDQUF5QixVQUF6QixDQUFKLEVBQTBDO0FBQ3hDO0FBQ0F5eEIsNEdBQVUsQ0FBQ3Z6QixLQUFELEVBQVEsZUFBUixFQUF5QjtBQUNqQ3dOLGdCQUFJLEVBQUUsVUFEMkI7QUFDZnZOLGNBRGU7QUFDWHd3QixzQkFEVztBQUNDbUIsa0JBREQ7QUFDU3RsQjtBQURULFdBQXpCLEVBRVA7QUFBRXhNO0FBQUYsV0FGTyxDQUFWO0FBR0Q7QUFDRixPQVBEOztBQVFBeWdCLFVBQUksQ0FBQzRILE1BQUwsR0FBYyxNQUFNO0FBQ2xCb0wsMEdBQVUsQ0FBQ3Z6QixLQUFELEVBQVEsZUFBUixFQUF5QjtBQUFFd04sY0FBSSxFQUFFLE1BQVI7QUFBZ0JpakIsb0JBQWhCO0FBQTRCeHdCO0FBQTVCLFNBQXpCLEVBQTJEO0FBQUVIO0FBQUYsU0FBM0QsQ0FBVjtBQUNELE9BRkQ7O0FBR0F5Z0IsVUFBSSxDQUFDNkgsT0FBTCxHQUFnQmpiLEtBQUQsSUFBVztBQUN4Qm9tQiwwR0FBVSxDQUFDdnpCLEtBQUQsRUFBUSxlQUFSLEVBQXlCO0FBQUV3TixjQUFJLEVBQUUsT0FBUjtBQUFpQmlqQixvQkFBakI7QUFBNkJ4d0IsWUFBN0I7QUFBaUNrTjtBQUFqQyxTQUF6QixFQUFtRTtBQUFFck47QUFBRixTQUFuRSxDQUFWO0FBQ0QsT0FGRDs7QUFHQSxhQUFPcTdCLFVBQVUsQ0FBQzVhLElBQUksQ0FBQy9TLElBQU4sQ0FBVixDQUFzQitTLElBQXRCLEVBQTRCa1IsV0FBNUIsQ0FBUDtBQUNEOztBQUVEQyxZQUFRLENBQUN6eEIsRUFBRCxDQUFSLEdBQWU7QUFDYkEsUUFEYTtBQUViRCxXQUZhO0FBR2IyeEIsb0JBSGE7QUFJYmpCLFNBQUcsRUFBRSxJQUFJQyxjQUFKO0FBSlEsS0FBZjtBQU1BLEtBQUM0SyxXQUFXLENBQUN2N0IsS0FBRCxDQUFYLEtBQXVCdTdCLFdBQVcsQ0FBQ3Y3QixLQUFELENBQVgsR0FBcUIsRUFBNUMsQ0FBRCxFQUFrREMsRUFBbEQsSUFBd0QsQ0FBeEQ7QUFDQXd4QixlQUFXLENBQUNsUixJQUFELEVBQU8xZ0IsR0FBUCxFQUFZTyxHQUFHLElBQUk7QUFDNUI7QUFDQSxVQUFJc3hCLFFBQVEsQ0FBQ3p4QixFQUFELENBQVosRUFBa0I7QUFDaEJzekIsMEdBQVUsQ0FBQ3Z6QixLQUFELEVBQVEsZUFBUixFQUF5QkksR0FBekIsRUFBOEI7QUFBRU47QUFBRixTQUE5QixDQUFWO0FBQ0Q7QUFDRixLQUxVLENBQVg7QUFNRCxHQWhEcUI7O0FBaUR0QjtBQUNBaThCLGNBQVksQ0FBQzk3QixFQUFELEVBQUs7QUFDZixVQUFNMkIsR0FBRyxHQUFHOHZCLFFBQVEsQ0FBQ3p4QixFQUFELENBQXBCOztBQUNBLFFBQUkyQixHQUFKLEVBQVM7QUFDUDtBQUNBLFVBQUk2QyxNQUFKLEVBQVk7QUFDVjtBQUNBQSxjQUFNLENBQUM2ckIsU0FBUCxDQUFpQm5lLE1BQWpCLENBQXdCdlEsR0FBRyxDQUFDM0IsRUFBNUI7QUFDQSxlQUFPeXhCLFFBQVEsQ0FBQzl2QixHQUFHLENBQUMzQixFQUFMLENBQWY7QUFDRCxPQUpELE1BSU87QUFDTDJCLFdBQUcsQ0FBQzh1QixHQUFKLENBQVFzTCxLQUFSO0FBQ0FDLG9CQUFZLENBQUNyNkIsR0FBRCxDQUFaO0FBQ0Q7QUFDRjtBQUNGLEdBL0RxQjs7QUFnRXRCczZCLFlBQVUsQ0FBQ3Y4QixHQUFELEVBQU07QUFDZCxVQUFNNEMsS0FBSyxHQUFHTyw4Q0FBSyxDQUFDMmIsR0FBTixDQUFXLFdBQVU5ZSxHQUFJLEVBQXpCLENBQWQ7O0FBQ0EsUUFBSTRDLEtBQUosRUFBVztBQUNURCxrQkFBWSxDQUFDQyxLQUFELENBQVo7QUFDQTRWLFNBQUcsQ0FBQzZQLGVBQUosQ0FBb0Jyb0IsR0FBcEI7QUFDRDtBQUNGOztBQXRFcUIsQ0FBeEI7QUF5RUEsTUFBTXc4QixjQUFjLEdBQUcsQ0FDckIsWUFEcUIsRUFFckI7QUFDQTtBQUNBLGdCQUpxQixFQUtyQixpQkFMcUIsRUFNckIsZ0NBTnFCLEVBT3JCLCtCQVBxQixFQVFyQixZQVJxQixFQVNyQixnQkFUcUIsRUFVckIsUUFWcUIsRUFXckIsU0FYcUIsRUFZckIsTUFacUIsRUFhckIsS0FicUIsRUFjckIsUUFkcUIsRUFlckIsTUFmcUIsRUFnQnJCLFlBaEJxQixFQWlCckIsUUFqQnFCLEVBa0JyQixTQWxCcUIsRUFtQnJCLElBbkJxQixFQW9CckIsU0FwQnFCLEVBcUJyQixtQkFyQnFCLEVBc0JyQixTQXRCcUIsRUF1QnJCLEtBdkJxQixDQUF2QixDLENBeUJBOztBQUNBLE1BQU1DLGNBQWMsR0FBRyxDQUFDLE1BQU07QUFDNUI7QUFDQSxRQUFNQyxTQUFTLEdBQUc7QUFDaEJ0cUIsUUFBSSxFQUFFLENBQUMsWUFBRCxDQURVO0FBRWhCQyxTQUFLLEVBQUUsQ0FBQyxnQkFBRDtBQUZTLEdBQWxCO0FBSUEsUUFBTWluQixhQUFhLEdBQUcsQ0FDcEJ4MUIsT0FBTyxDQUFDb08sVUFBUixDQUFtQnlxQiwwQkFBbkIsQ0FBOENyRCxhQUQxQixFQUVwQmhvQixNQUZvQixDQUViQyxPQUZhLENBQXRCO0FBR0EsUUFBTXFyQixlQUFlLEdBQUcsRUFBeEI7QUFDQTs7QUFDQSxRQUFNQyxVQUFVLEdBQUc1bUIsTUFBTSxJQUFJQSxNQUFNLENBQUM3TyxJQUFQLEtBQWdCcTBCLFNBQTdDOztBQUNBLFFBQU1xQixXQUFXLEdBQUc3bUIsTUFBTSxJQUFJLENBQUMsY0FBYzFPLElBQWQsQ0FBbUIwTyxNQUFNLENBQUM3TyxJQUExQixDQUEvQjs7QUFDQSxRQUFNMjFCLFVBQVUsR0FBRzltQixNQUFNLElBQUlBLE1BQU0sQ0FBQzdPLElBQVAsS0FBZ0JxMEIsU0FBN0M7O0FBQ0EsUUFBTXVCLGNBQWMsR0FBRy9tQixNQUFNLElBQUk4bUIsVUFBVSxDQUFDOW1CLE1BQUQsQ0FBVixJQUFzQjZtQixXQUFXLENBQUM3bUIsTUFBRCxDQUFsRTs7QUFDQSxRQUFNZ25CLGFBQWEsR0FBRyxpQkFBdEI7QUFDQSxRQUFNQyxtQkFBbUIsR0FBRyx5RUFBNUI7QUFDQSxRQUFNQyxrQkFBa0IsR0FBRyxnREFBM0I7QUFDQSxRQUFNQyxhQUFhLEdBQUc7QUFDcEJDLFVBQU0sRUFBRSxRQURZO0FBRXBCQyxPQUFHLEVBQUUsS0FGZTtBQUdwQkMsUUFBSSxFQUFFO0FBSGMsR0FBdEI7QUFLQTs7Ozs7O0FBS0EsUUFBTUMsZ0JBQWdCLEdBQUcsQ0FBQ0MsV0FBRCxFQUFjeDdCLEdBQWQsRUFBbUJqQyxHQUFuQixLQUEyQjtBQUNsRCxRQUFJOFMsQ0FBQyxHQUFHb3FCLG1CQUFtQixDQUFDUSxJQUFwQixDQUF5QkQsV0FBekIsQ0FBUjs7QUFDQSxRQUFJM3FCLENBQUosRUFBTztBQUFBOztBQUNMLFlBQU0sR0FBR3JFLE1BQUgsRUFBV3JILElBQVgsR0FBbUJtQixLQUFuQixFQUEwQm8xQixNQUExQixJQUFvQzdxQixDQUExQztBQUNBLFlBQU04cUIsR0FBRyxHQUFHLEVBQVo7QUFDQSxZQUFNQyxNQUFNLEdBQUdwdkIsTUFBTSxLQUFLLE1BQTFCO0FBQ0EwdUIsd0JBQWtCLENBQUNXLFNBQW5CLEdBQStCLENBQS9COztBQUNBLGFBQVFockIsQ0FBQyxHQUFHcXFCLGtCQUFrQixDQUFDTyxJQUFuQixDQUF3QkMsTUFBeEIsQ0FBWixFQUE4QztBQUM1Q0MsV0FBRyxDQUFDOXFCLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBSzZiLFdBQUwsRUFBRCxDQUFILEdBQTBCN2IsQ0FBQyxDQUFDLENBQUQsQ0FBM0I7QUFDRDs7QUFDRCxZQUFNaXJCLFFBQVEsb0JBQUdILEdBQUcsQ0FBQ0csUUFBUCxxQkFBRyxjQUFjcFAsV0FBZCxFQUFqQjtBQUNBN3FCLGFBQU8sQ0FBQ2s2QixPQUFSLENBQWdCMTFCLEdBQWhCLENBQW9CO0FBQ2xCdEksV0FEa0I7QUFFbEJvSCxZQUZrQjtBQUdsQm1CLGFBSGtCO0FBSWxCOUcsY0FBTSxFQUFFbzhCLE1BQU0sR0FBR3prQixTQUFILEdBQWV3a0IsR0FBRyxDQUFDbjhCLE1BSmY7QUFLbEJ3OEIsc0JBQWMsRUFBRXA3QixJQUFJLENBQUMwZixHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsSUFBSTlmLElBQUosQ0FBU203QixHQUFHLENBQUMsU0FBRCxDQUFILEdBQWlCLElBQWpCLElBQXlCQSxHQUFHLENBQUNNLE9BQXRDLENBQWIsS0FBZ0U5a0IsU0FMOUQ7QUFNbEIra0IsZ0JBQVEsRUFBRSxjQUFjUCxHQU5OO0FBT2xCcHFCLFlBQUksRUFBRXFxQixNQUFNLEdBQUcsR0FBSCxHQUFTRCxHQUFHLENBQUNwcUIsSUFQUDtBQVFsQnVxQixnQkFBUSxFQUFFWCxhQUFhLENBQUNXLFFBQUQsQ0FSTDtBQVNsQkssY0FBTSxFQUFFcCtCLEdBQUcsQ0FBQ3dPLFVBQUosQ0FBZSxRQUFmLE1BQTZCLENBQUMsQ0FBQ0MsTUFBRixJQUFZc3ZCLFFBQVEsS0FBSyxNQUF6QixJQUFtQyxZQUFZSCxHQUE1RSxDQVRVO0FBVWxCUyxlQUFPLEVBQUVwOEIsR0FBRyxDQUFDbzhCO0FBVkssT0FBcEI7QUFZRDtBQUNGLEdBeEJEOztBQXlCQSxRQUFNQyxTQUFTLEdBQUc7QUFDaEJDLHVCQUFtQixFQUFFO0FBQ25CdnlCLGFBQU8sRUFBRSxDQUFDLGdCQUFELEVBQW1CLFVBQW5CLEVBQStCLEdBQUdzdEIsYUFBbEMsQ0FEVTs7QUFFbkI7QUFDQWtGLGNBQVEsQ0FBQztBQUFFQyxzQkFBYyxFQUFFcjdCLE9BQWxCO0FBQTJCczdCO0FBQTNCLE9BQUQsRUFBeUM7QUFBQTs7QUFDL0M7QUFDQSxjQUFNQyxLQUFLLEdBQUcsa0JBQUF2N0IsT0FBTyxDQUFDNFUsSUFBUixDQUFhNmtCLFVBQWIsb0NBQTBCdDBCLEtBQTFCLEtBQW1Db3pCLE1BQU0sQ0FBQytDLFNBQUQsQ0FBdkQ7QUFDQSxjQUFNejhCLEdBQUcsR0FBRzA4QixLQUFLLElBQUk1TSxRQUFRLENBQUM0TSxLQUFELENBQTdCOztBQUNBLFlBQUlBLEtBQUssSUFBSTE4QixHQUFiLEVBQWtCO0FBQ2hCMDVCLGdCQUFNLENBQUMrQyxTQUFELENBQU4sR0FBb0JDLEtBQXBCO0FBQ0ExOEIsYUFBRyxDQUFDMjhCLE1BQUosR0FBYUYsU0FBYjtBQUNBdDdCLGlCQUFPLEdBQUcsQ0FBQ25CLEdBQUcsQ0FBQzQ4QixjQUFKLEdBQXFCejdCLE9BQU8sQ0FBQ2tPLE1BQVIsQ0FBZXdyQixXQUFmLENBQXJCLEdBQW1EMTVCLE9BQXBELEVBQ1RxM0IsTUFEUyxDQUNGbUMsZUFBZSxDQUFDK0IsS0FBRCxDQUFmLElBQTBCLEVBRHhCLEVBRVRydEIsTUFGUyxDQUVGclAsR0FBRyxDQUFDa1csU0FBSixHQUFnQjZrQixjQUFoQixHQUFpQ0QsVUFGL0IsQ0FBVjtBQUdEOztBQUNELGVBQU87QUFBRTBCLHdCQUFjLEVBQUVyN0I7QUFBbEIsU0FBUDtBQUNEOztBQWZrQixLQURMO0FBa0JoQmcyQixxQkFBaUIsRUFBRTtBQUNqQnB0QixhQUFPLEVBQUUsQ0FBQyxpQkFBRCxFQUFvQixVQUFwQixFQUFnQyxHQUFHc3RCLGFBQW5DLENBRFE7O0FBRWpCO0FBQ0FrRixjQUFRLENBQUM7QUFBRS9FLHVCQUFlLEVBQUVyMkIsT0FBbkI7QUFBNEJzN0IsaUJBQTVCO0FBQXVDMStCO0FBQXZDLE9BQUQsRUFBK0M7QUFDckQsY0FBTWlDLEdBQUcsR0FBRzh2QixRQUFRLENBQUM0SixNQUFNLENBQUMrQyxTQUFELENBQVAsQ0FBcEI7O0FBQ0EsWUFBSXo4QixHQUFKLEVBQVM7QUFDUCxjQUFJQSxHQUFHLENBQUNrVyxTQUFKLElBQWlCbFcsR0FBRyxDQUFDbzhCLE9BQXpCLEVBQWtDO0FBQ2hDajdCLG1CQUFPLEdBQUdBLE9BQU8sQ0FBQ2tPLE1BQVIsQ0FBZXd0QixDQUFDLElBQ3hCLENBQUM3QixhQUFhLENBQUMxMUIsSUFBZCxDQUFtQnUzQixDQUFDLENBQUMxM0IsSUFBckIsQ0FBRCxJQUNHLENBQUNuRixHQUFHLENBQUNvOEIsT0FEUixJQUVHYixnQkFBZ0IsQ0FBQ3NCLENBQUMsQ0FBQ3YyQixLQUFILEVBQVV0RyxHQUFWLEVBQWVqQyxHQUFmLENBSFgsQ0FBVjtBQUtEOztBQUNEaUMsYUFBRyxDQUFDdzNCLGVBQUosR0FBc0JyMkIsT0FBTyxDQUFDeUcsR0FBUixDQUFZazFCLHNCQUFaLEVBQW9DcHBCLElBQXBDLENBQXlDLEVBQXpDLENBQXRCO0FBQ0EsaUJBQU87QUFBRThqQiwyQkFBZSxFQUFFcjJCO0FBQW5CLFdBQVA7QUFDRDtBQUNGOztBQWhCZ0I7QUFsQkgsR0FBbEIsQ0FyRDRCLENBMEY1QjtBQUNBOztBQUNBLE1BQUk4MkIsMEZBQUUsQ0FBQ3AxQixNQUFILElBQWEsRUFBYixJQUFtQm8xQiwwRkFBRSxDQUFDcDFCLE1BQUgsSUFBYSxFQUFwQyxFQUF3QztBQUN0Q2hCLFdBQU8sQ0FBQ29PLFVBQVIsQ0FBbUJxc0IsbUJBQW5CLENBQXVDdDZCLFdBQXZDLENBQW1EdUksb0ZBQW5ELEVBQXlEa3dCLFNBQXpELEVBQW9FLENBQUMsY0FBRCxDQUFwRTtBQUNEOztBQUNELFNBQU87QUFDTHNDLE9BQUcsQ0FBQ0wsS0FBRCxFQUFRdjdCLE9BQVIsRUFBaUI7QUFDbEI7QUFDQXc1QixxQkFBZSxDQUFDK0IsS0FBRCxDQUFmLEdBQXlCdjdCLE9BQXpCLENBRmtCLENBR2xCOztBQUNBLGVBQVcwRixtR0FBWCxFQUFBdzFCLFNBQVMsRUFBZSxDQUFDLENBQUNsM0IsSUFBRCxFQUFPO0FBQUVvM0IsZ0JBQUY7QUFBWXh5QjtBQUFaLE9BQVAsQ0FBRCxLQUFtQztBQUN6RGxJLGVBQU8sQ0FBQ29PLFVBQVIsQ0FBbUI5SyxJQUFuQixFQUF5Qm5ELFdBQXpCLENBQXFDdTZCLFFBQXJDLEVBQStDOUIsU0FBL0MsRUFBMEQxd0IsT0FBMUQ7QUFDRCxPQUZRLENBQVQ7QUFHRCxLQVJJOztBQVNMOHJCLE9BQUcsQ0FBQzZHLEtBQUQsRUFBUTtBQUNULFVBQUlBLEtBQUssSUFBSS9CLGVBQWIsRUFBOEI7QUFDNUIsZUFBT0EsZUFBZSxDQUFDK0IsS0FBRCxDQUF0Qjs7QUFDQSxZQUFJTSwrRkFBTyxDQUFDckMsZUFBRCxDQUFYLEVBQThCO0FBQzVCLG1CQUFXOXpCLG1HQUFYLEVBQUF3MUIsU0FBUyxFQUFlLENBQUMsQ0FBQ2wzQixJQUFELEVBQU87QUFBRW8zQjtBQUFGLFdBQVAsQ0FBRCxLQUEwQjtBQUNoRDE2QixtQkFBTyxDQUFDb08sVUFBUixDQUFtQjlLLElBQW5CLEVBQXlCcUwsY0FBekIsQ0FBd0MrckIsUUFBeEM7QUFDRCxXQUZRLENBQVQ7QUFHRDtBQUNGO0FBQ0Y7O0FBbEJJLEdBQVA7QUFvQkQsQ0FuSHNCLEdBQXZCO0FBcUhBOzs7O0FBRUEsTUFBTVUsVUFBVSxHQUFHLEdBQW5COztBQUVBLGVBQWVDLFVBQWYsQ0FBMEJoTyxRQUExQixFQUFvQ25RLEtBQXBDLEVBQTJDO0FBQ3pDLFNBQU9vZSxtR0FBVyxDQUFDak8sUUFBRCxFQUFXblEsS0FBSyxHQUFHa2UsVUFBbkIsRUFBK0JBLFVBQS9CLENBQWxCO0FBQ0Q7O0FBRUQsU0FBU0csY0FBVCxDQUF3QmxPLFFBQXhCLEVBQWtDO0FBQ2hDLFFBQU1ueEIsR0FBRyxHQUFHd1ksR0FBRyxDQUFDMFAsZUFBSixDQUFvQmlKLFFBQXBCLENBQVo7QUFDQWh1QixnREFBSyxDQUFDME4sR0FBTixDQUFXLFdBQVU3USxHQUFJLEVBQXpCLEVBQTRCaUIsVUFBVSxDQUFDeEIsaURBQVEsQ0FBQzg4QixVQUFWLEVBQXNCLElBQXRCLEVBQTRCdjhCLEdBQTVCLENBQXRDLEVBQXdFLElBQXhFO0FBQ0EsU0FBT0EsR0FBUDtBQUNEO0FBRUQ7OztBQUNBLFNBQVNzL0Isa0JBQVQsQ0FBNEJyOUIsR0FBNUIsRUFBaUM7QUFDL0IsTUFBSXM5QixXQUFXLEdBQUdqN0IsT0FBTyxDQUFDMkMsT0FBUixFQUFsQjtBQUNBLE1BQUl1NEIsV0FBSjtBQUNBLE1BQUlDLFFBQUo7QUFDQSxNQUFJQyxTQUFKO0FBQ0EsTUFBSXZPLFFBQUo7QUFDQSxNQUFJd08sWUFBSjtBQUNBLE1BQUlsRyxlQUFKLENBUCtCLENBUS9COztBQUNBLFFBQU07QUFBRW41QixNQUFGO0FBQU1zL0IsV0FBTjtBQUFlQyxXQUFmO0FBQXdCOU87QUFBeEIsTUFBZ0M5dUIsR0FBdEMsQ0FUK0IsQ0FVL0I7O0FBQ0EsUUFBTTY5QixRQUFRLEdBQUdGLE9BQU8sSUFBSVAsY0FBWCxJQUE2QlEsT0FBTyxJQUFJVixVQUF6RDs7QUFDQSxRQUFNWSxrQkFBa0IsR0FBRyxNQUFNO0FBQy9CLFVBQU0zOEIsT0FBTyxHQUFHbkIsR0FBRyxDQUFDdzNCLGVBQUosSUFBdUIxSSxHQUFHLENBQUNpUCxxQkFBSixFQUF2Qzs7QUFDQSxRQUFJdkcsZUFBZSxLQUFLcjJCLE9BQXhCLEVBQWlDO0FBQy9CcTJCLHFCQUFlLEdBQUdyMkIsT0FBbEI7QUFDQSxhQUFPO0FBQUVxMkI7QUFBRixPQUFQO0FBQ0Q7QUFDRixHQU5EOztBQU9BLFNBQVFxQyxHQUFELElBQVM7QUFDZCxVQUFNanVCLElBQUksR0FBR2l1QixHQUFHLENBQUNqdUIsSUFBakI7O0FBQ0EsUUFBSSxDQUFDMnhCLFdBQUwsRUFBa0I7QUFDaEJBLGlCQUFXLEdBQUd6TyxHQUFHLENBQUNrUCxpQkFBSixDQUFzQixjQUF0QixLQUF5QywwQkFBdkQ7QUFDRDs7QUFDRCxRQUFJbFAsR0FBRyxDQUFDSSxRQUFKLEtBQWlCQSxRQUFyQixFQUErQjtBQUM3QkEsY0FBUSxHQUFHSixHQUFHLENBQUNJLFFBQWYsQ0FENkIsQ0FFN0I7O0FBQ0EsVUFBSTtBQUNGd08sb0JBQVksR0FBRzVPLEdBQUcsQ0FBQzRPLFlBQW5CO0FBQ0EsWUFBSUEsWUFBWSxLQUFLeE8sUUFBckIsRUFBK0J3TyxZQUFZLEdBQUcsQ0FBQyxNQUFELENBQWY7QUFDaEMsT0FIRCxDQUdFLE9BQU90N0IsQ0FBUCxFQUFVLENBQ1Y7QUFDRDs7QUFDRCxVQUFJLENBQUN1N0IsT0FBTyxJQUFJQyxPQUFaLEtBQXdCMU8sUUFBNUIsRUFBc0M7QUFDcENzTyxnQkFBUSxHQUFHdE8sUUFBUSxDQUFDL2MsSUFBcEI7QUFDQXNyQixpQkFBUyxHQUFHRyxPQUFPLElBQUloOUIsSUFBSSxDQUFDcTlCLElBQUwsQ0FBVVQsUUFBUSxHQUFHUCxVQUFyQixDQUFYLElBQStDLENBQTNEO0FBQ0Q7QUFDRjs7QUFDRCxVQUFNaUIsWUFBWSxHQUFHbCtCLEdBQUcsQ0FBQyt2QixjQUFKLENBQW1CN3ZCLFFBQW5CLENBQTRCMEwsSUFBNUIsQ0FBckIsQ0FuQmMsQ0FvQmQ7O0FBQ0EsVUFBTXV5QixrQkFBa0IsR0FBR3JQLEdBQUcsQ0FBQ0csVUFBSixLQUFtQixDQUFuQixJQUF3QmlQLFlBQW5EO0FBQ0FaLGVBQVcsR0FBR0EsV0FBVyxDQUFDaHlCLElBQVosQ0FBaUIsWUFBWTtBQUN6QyxVQUFJNnlCLGtCQUFrQixJQUFJUixPQUF0QixJQUFpQzM5QixHQUFHLENBQUM0TCxJQUFKLEtBQWEsVUFBbEQsRUFBOEQ7QUFDNUQsWUFBSTVMLEdBQUcsQ0FBQzR1QixRQUFKLElBQWdCL3JCLE1BQXBCLEVBQTRCO0FBQzFCLGdCQUFNbWpCLE9BQU8sR0FBR3pQLEdBQUcsQ0FBQzBQLGVBQUosQ0FBb0JpSixRQUFwQixDQUFoQjtBQUNBLGlCQUFPcnNCLE1BQU0sQ0FBQzZyQixTQUFQLENBQWlCcEIsUUFBakIsQ0FBMEI7QUFDL0J2dkIsZUFBRyxFQUFFaW9CLE9BRDBCO0FBRS9CMkksb0JBQVEsRUFBRTN1QixHQUFHLENBQUM0dUI7QUFGaUIsV0FBMUIsRUFHSkMsVUFBVSxJQUFJO0FBQ2Y3dUIsZUFBRyxDQUFDbytCLEVBQUosQ0FBTztBQUNMVCxxQkFESztBQUVMQyxxQkFGSztBQUdMTCx5QkFISztBQUlMQyxzQkFKSztBQUtMbi9CLGdCQUxLO0FBTUx1TixrQkFOSztBQU9Mak8sa0JBQUksRUFBRTtBQUFFMGdDLHdCQUFRLEVBQUV2UCxHQUFHLENBQUN3UCxXQUFoQjtBQUE2QnBQLHdCQUFRLEVBQUUsRUFBdkM7QUFBMkN3Tyw0QkFBWSxFQUFFN087QUFBekQ7QUFQRCxhQUFQO0FBU0F0WSxlQUFHLENBQUM2UCxlQUFKLENBQW9CSixPQUFwQjtBQUNELFdBZE0sQ0FBUDtBQWVEOztBQUNELGVBQU9obUIsR0FBRyxDQUFDbytCLEVBQUosQ0FBTztBQUNaVCxpQkFEWTtBQUVaQyxpQkFGWTtBQUdaTCxxQkFIWTtBQUlaQyxrQkFKWTtBQUtabi9CLFlBTFk7QUFNWnVOLGNBTlk7QUFPWmpPLGNBQUksRUFBRXV4QjtBQVBNLFNBQVAsQ0FBUDtBQVNELE9BN0J3QyxDQStCekM7OztBQUNBLFlBQU1sdkIsR0FBRyxDQUFDbytCLEVBQUosQ0FBTztBQUNYVCxlQURXO0FBRVhDLGVBRlc7QUFHWEwsbUJBSFc7QUFJWEMsZ0JBSlc7QUFLWG4vQixVQUxXO0FBTVhvL0IsaUJBTlc7QUFPWDd4QixZQVBXO0FBUVhqTyxZQUFJLEVBQUV1Z0MsWUFBWSxJQUFJO0FBQ3BCRyxrQkFBUSxFQUFFdlAsR0FBRyxDQUFDd1A7QUFERSxXQUViUixrQkFBa0IsRUFGTCxNQUdicDFCLHlHQUFVLENBQUNvbUIsR0FBRCxFQUFNLENBQUMsWUFBRCxFQUFlLFFBQWYsRUFBeUIsWUFBekIsQ0FBTixDQUhHLE1BSVosWUFBWStLLEdBQWIsSUFBcUJueEIseUdBQVUsQ0FBQ214QixHQUFELEVBQU0sQ0FBQyxrQkFBRCxFQUFxQixRQUFyQixFQUErQixPQUEvQixDQUFOLENBSmxCO0FBS2hCM0ssa0JBQVEsRUFBRWlQLGtCQUFrQixHQUN4QlYsU0FBUyxLQUFJLE1BQU1JLFFBQVEsQ0FBQzNPLFFBQUQsRUFBVyxDQUFYLENBQWxCLENBQVQsSUFBNENBLFFBRHBCLEdBRXhCLElBUFk7QUFRaEJ3TyxzQkFBWSxFQUFFUyxrQkFBa0IsR0FDNUJULFlBRDRCLEdBRTVCO0FBVlk7QUFSUCxPQUFQLENBQU47O0FBcUJBLFVBQUlTLGtCQUFKLEVBQXdCO0FBQ3RCLGFBQUssSUFBSTM0QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaTRCLFNBQXBCLEVBQStCajRCLENBQUMsSUFBSSxDQUFwQyxFQUF1QztBQUNyQyxnQkFBTXhGLEdBQUcsQ0FBQ28rQixFQUFKLENBQU87QUFDWC8vQixjQURXO0FBRVhrZ0MsaUJBQUssRUFBRTtBQUNMQyxpQkFBRyxFQUFFaDVCLENBQUMsR0FBR3kzQixVQURKO0FBRUx0L0Isa0JBQUksRUFBRSxNQUFNa2dDLFFBQVEsQ0FBQzNPLFFBQUQsRUFBVzFwQixDQUFYLENBRmY7QUFHTGk1QixrQkFBSSxFQUFFajVCLENBQUMsR0FBRyxDQUFKLEtBQVVpNEI7QUFIWDtBQUZJLFdBQVAsQ0FBTjtBQVFEO0FBQ0Y7O0FBQ0QsVUFBSTd4QixJQUFJLEtBQUssU0FBYixFQUF3QjtBQUN0Qnl1QixvQkFBWSxDQUFDcjZCLEdBQUQsQ0FBWjtBQUNEO0FBQ0YsS0FwRWEsQ0FBZDtBQXFFRCxHQTNGRDtBQTRGRDs7QUFFRCxTQUFTMCtCLGVBQVQsQ0FBeUJDLFdBQXpCLEVBQXNDO0FBQ3BDLFNBQU9wRSxjQUFjLENBQUNyNkIsUUFBZixDQUF3QnkrQixXQUF4QixLQUNGQSxXQUFXLENBQUNweUIsVUFBWixDQUF1QixRQUF2QixDQURFLElBRUZveUIsV0FBVyxDQUFDcHlCLFVBQVosQ0FBdUIsTUFBdkIsQ0FGTDtBQUdEO0FBRUQ7Ozs7Ozs7QUFLQSxlQUFlc2pCLFdBQWYsQ0FBMkJsUixJQUEzQixFQUFpQzFnQixHQUFqQyxFQUFzQ21nQyxFQUF0QyxFQUEwQztBQUN4QyxRQUFNO0FBQUVqZ0M7QUFBRixNQUFVRixHQUFoQjtBQUNBLFFBQU07QUFBRTJnQztBQUFGLE1BQWdCemdDLEdBQXRCO0FBQ0EsUUFBTTtBQUFFK1gsYUFBRjtBQUFhN1gsTUFBYjtBQUFpQndnQyxvQkFBakI7QUFBbUNDLFdBQW5DO0FBQTRDL2dDO0FBQTVDLE1BQW9ENGdCLElBQTFEO0FBQ0EsUUFBTTNlLEdBQUcsR0FBRzh2QixRQUFRLENBQUN6eEIsRUFBRCxDQUFwQjtBQUNBLE1BQUksQ0FBQzJCLEdBQUQsSUFBUUEsR0FBRyxDQUFDbytCLEVBQWhCLEVBQW9CO0FBQ3BCcCtCLEtBQUcsQ0FBQ28rQixFQUFKLEdBQVNBLEVBQVQ7QUFDQXArQixLQUFHLENBQUM0TCxJQUFKLEdBQVcrUyxJQUFJLENBQUMvUyxJQUFoQjtBQUNBNUwsS0FBRyxDQUFDNHVCLFFBQUosR0FBZWpRLElBQUksQ0FBQ2lRLFFBQXBCO0FBQ0E1dUIsS0FBRyxDQUFDa1csU0FBSixHQUFnQkEsU0FBaEI7QUFDQSxRQUFNO0FBQUU0WTtBQUFGLE1BQVU5dUIsR0FBaEI7QUFDQSxRQUFNKytCLFNBQVMsR0FBRyxFQUFsQixDQVh3QyxDQVl4Qzs7QUFDQSxRQUFNbkIsT0FBTyxHQUFHLENBQUMzN0IsVUFBRCxJQUFlMjhCLFNBQS9CO0FBQ0EsUUFBTWpCLE9BQU8sR0FBR21CLE9BQU8sSUFBSSxDQUFDNzhCLFVBQVosSUFBMEIsQ0FBQzI4QixTQUEzQztBQUNBLFFBQU0sQ0FBQ3R0QixJQUFELEVBQU9pc0IsV0FBUCxJQUFzQnlCLFVBQVUsQ0FBQ3JnQixJQUFJLENBQUNoaEIsSUFBTixDQUF0QyxDQWZ3QyxDQWdCeEM7O0FBQ0FxQyxLQUFHLENBQUMyOUIsT0FBSixHQUFjQSxPQUFkO0FBQ0EzOUIsS0FBRyxDQUFDNDlCLE9BQUosR0FBY0EsT0FBZCxDQWxCd0MsQ0FtQnhDO0FBQ0E7O0FBQ0EsTUFBSXFCLGlCQUFpQixHQUFHLENBQUMvb0IsU0FBRCxLQUFlMG9CLFNBQVMsSUFBSTM4QixVQUE1QixDQUF4QjtBQUNBNnNCLEtBQUcsQ0FBQ0ssSUFBSixDQUFTeFEsSUFBSSxDQUFDdk4sTUFBTCxJQUFlLEtBQXhCLEVBQStCclQsR0FBL0IsRUFBb0MsSUFBcEMsRUFBMEM0Z0IsSUFBSSxDQUFDaFQsSUFBTCxJQUFhLEVBQXZELEVBQTJEZ1QsSUFBSSxDQUFDdkksUUFBTCxJQUFpQixFQUE1RTtBQUNBMFksS0FBRyxDQUFDb1EsZ0JBQUosQ0FBcUIxRixTQUFyQixFQUFnQ243QixFQUFoQztBQUNBLE1BQUlrL0IsV0FBSixFQUFpQnpPLEdBQUcsQ0FBQ29RLGdCQUFKLENBQXFCLGNBQXJCLEVBQXFDM0IsV0FBckM7QUFDakIsV0FBYzEyQixtR0FBZCxFQUFBOFgsSUFBSSxDQUFDeGQsT0FBTCxFQUEyQixDQUFDLENBQUNnRSxJQUFELEVBQU9tQixLQUFQLENBQUQsS0FBbUI7QUFDNUMsVUFBTTY0QixTQUFTLEdBQUdoNkIsSUFBSSxDQUFDdW5CLFdBQUwsRUFBbEI7O0FBQ0EsUUFBSWdTLGVBQWUsQ0FBQ1MsU0FBRCxDQUFuQixFQUFnQztBQUM5QkosZUFBUyxDQUFDeHdCLElBQVYsQ0FBZTtBQUFFcEosWUFBRjtBQUFRbUI7QUFBUixPQUFmO0FBQ0QsS0FGRCxNQUVPLElBQUksQ0FBQzY0QixTQUFTLENBQUM1eUIsVUFBVixDQUFxQixLQUFyQixDQUFMLEVBQWtDO0FBQ3ZDO0FBQ0F1aUIsU0FBRyxDQUFDb1EsZ0JBQUosQ0FBcUIvNUIsSUFBckIsRUFBMkJtQixLQUEzQjtBQUNEOztBQUNELFFBQUk2NEIsU0FBUyxLQUFLLFFBQWxCLEVBQTRCO0FBQzFCRix1QkFBaUIsR0FBRyxLQUFwQjtBQUNEO0FBQ0YsR0FYRDtBQVlBblEsS0FBRyxDQUFDdGQsWUFBSixHQUFtQixDQUFDb3NCLE9BQU8sSUFBSUQsT0FBWixLQUF3QixNQUF4QixJQUFrQ21CLE9BQWxDLElBQTZDLE1BQWhFO0FBQ0FoUSxLQUFHLENBQUNzUSxPQUFKLEdBQWN4K0IsSUFBSSxDQUFDMGYsR0FBTCxDQUFTLENBQVQsRUFBWTFmLElBQUksQ0FBQ0MsR0FBTCxDQUFTLFVBQVQsRUFBc0I4ZCxJQUFJLENBQUN5Z0IsT0FBM0IsQ0FBWixLQUFvRCxDQUFsRTtBQUNBLE1BQUlQLGdCQUFKLEVBQXNCL1AsR0FBRyxDQUFDK1AsZ0JBQUosQ0FBcUJBLGdCQUFyQjs7QUFDdEIsTUFBSUksaUJBQUosRUFBdUI7QUFDckJqL0IsT0FBRyxDQUFDNDhCLGNBQUosR0FBcUIsSUFBckI7O0FBQ0EsU0FBSyxNQUFNbGYsS0FBWCxJQUFvQixNQUFNN2IsT0FBTyxDQUFDazZCLE9BQVIsQ0FBZ0JzRCxrQkFBaEIsRUFBMUIsRUFBZ0U7QUFDOUQsVUFBSTNoQixLQUFLLENBQUM0aEIsTUFBTixDQUFhcC9CLFFBQWIsQ0FBc0IvQixHQUFHLENBQUNFLEVBQTFCLENBQUosRUFBbUM7QUFDakMsWUFBSTRELFVBQVUsR0FBR3liLEtBQUssQ0FBQ3JmLEVBQU4sS0FBYSxpQkFBaEIsR0FBb0NxZixLQUFLLENBQUNyZixFQUFOLEtBQWEsR0FBL0QsRUFBb0U7QUFDbEU7O0FBRUEyQixhQUFHLENBQUNvOEIsT0FBSixHQUFjMWUsS0FBSyxDQUFDcmYsRUFBcEI7QUFDRDs7QUFDRDtBQUNEO0FBQ0Y7O0FBQ0QsVUFBTW9DLEdBQUcsR0FBR0QsSUFBSSxDQUFDQyxHQUFMLEtBQWEsSUFBekI7QUFDQSxVQUFNczdCLE9BQU8sR0FBRyxDQUFDLE1BQU1sNkIsT0FBTyxDQUFDazZCLE9BQVIsQ0FBZ0J6SSxNQUFoQjtBQUNyQnYxQixTQURxQjtBQUVyQnErQixhQUFPLEVBQUVwOEIsR0FBRyxDQUFDbzhCO0FBRlEsT0FHbEJuRSwwRkFBRSxDQUFDc0gsT0FBSCxJQUFjLEVBQWQsSUFBb0I7QUFBRUMsc0JBQWdCLEVBQUU7QUFBcEIsS0FIRixFQUFQLEVBSVpud0IsTUFKWSxDQUlMb3dCLENBQUMsSUFBSUEsQ0FBQyxDQUFDQyxPQUFGLElBQWFELENBQUMsQ0FBQ3pELGNBQUYsR0FBbUJ2N0IsR0FKaEMsQ0FBaEIsQ0FicUIsQ0FpQmlDOztBQUN0RCxRQUFJczdCLE9BQU8sQ0FBQ2g5QixNQUFaLEVBQW9CO0FBQ2xCZ2dDLGVBQVMsQ0FBQ3h3QixJQUFWLENBQWU7QUFDYnBKLFlBQUksRUFBRSxRQURPO0FBRWJtQixhQUFLLEVBQUV5MUIsT0FBTyxDQUFDbjBCLEdBQVIsQ0FBWTYzQixDQUFDLElBQUssR0FBRUEsQ0FBQyxDQUFDdDZCLElBQUssSUFBR3M2QixDQUFDLENBQUNuNUIsS0FBTSxHQUF0QyxFQUEwQ29OLElBQTFDLENBQStDLEdBQS9DO0FBRk0sT0FBZjtBQUlEO0FBQ0Y7O0FBQ0Q4bUIsZ0JBQWMsQ0FBQ3VDLEdBQWYsQ0FBbUIxK0IsRUFBbkIsRUFBdUIwZ0MsU0FBdkI7QUFDQSxRQUFNbHBCLFFBQVEsR0FBR3duQixrQkFBa0IsQ0FBQ3I5QixHQUFELENBQW5DO0FBQ0FBLEtBQUcsQ0FBQyt2QixjQUFKLENBQW1CeG1CLE9BQW5CLENBQTJCc3dCLEdBQUcsSUFBSTtBQUFFL0ssT0FBRyxDQUFFLEtBQUkrSyxHQUFJLEVBQVYsQ0FBSCxHQUFrQmhrQixRQUFsQjtBQUE2QixHQUFqRTtBQUNBaVosS0FBRyxDQUFDNlEsU0FBSixHQUFnQjlwQixRQUFoQixDQXBFd0MsQ0FvRWQ7O0FBQzFCaVosS0FBRyxDQUFDTSxJQUFKLENBQVM5ZCxJQUFUO0FBQ0Q7QUFFRDs7O0FBQ0EsU0FBUytvQixZQUFULENBQXNCcjZCLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUlBLEdBQUcsQ0FBQzI4QixNQUFSLEVBQWdCLE9BQU9qRCxNQUFNLENBQUMxNUIsR0FBRyxDQUFDMjhCLE1BQUwsQ0FBYjtBQUNoQixTQUFPN00sUUFBUSxDQUFDOXZCLEdBQUcsQ0FBQzNCLEVBQUwsQ0FBZjtBQUNBLFNBQU8sQ0FBQ3M3QixXQUFXLENBQUMzNUIsR0FBRyxDQUFDNUIsS0FBTCxDQUFYLElBQTBCLEVBQTNCLEVBQStCNEIsR0FBRyxDQUFDM0IsRUFBbkMsQ0FBUDtBQUNBbThCLGdCQUFjLENBQUMzRSxHQUFmLENBQW1CNzFCLEdBQUcsQ0FBQzNCLEVBQXZCO0FBQ0Q7QUFFRDs7O0FBQ0EsU0FBUzJnQyxVQUFULENBQW9CLENBQUMxdEIsSUFBRCxFQUFPMUYsSUFBUCxFQUFhZzBCLE9BQWIsQ0FBcEIsRUFBMkM7QUFDekMsTUFBSWgwQixJQUFJLEtBQUssT0FBYixFQUFzQjtBQUNwQkEsUUFBSSxHQUFHLG1DQUFQO0FBQ0QsR0FGRCxNQUVPLElBQUlBLElBQUosRUFBVTtBQUNmO0FBQ0EsVUFBTXBOLEdBQUcsR0FBR3FoQyx5R0FBaUIsQ0FBQ0MsSUFBSSxDQUFDeHVCLElBQUksQ0FBQzNMLEtBQUwsQ0FBVzJMLElBQUksQ0FBQzdMLE9BQUwsQ0FBYSxHQUFiLElBQW9CLENBQS9CLENBQUQsQ0FBTCxDQUE3Qjs7QUFDQSxRQUFJLENBQUNtNkIsT0FBTCxFQUFjO0FBQ1poMEIsVUFBSSxHQUFHMEYsSUFBSSxDQUFDL1IsS0FBTCxDQUFXLG9CQUFYLEVBQWlDLENBQWpDLEVBQW9DMlIsT0FBcEMsQ0FBNEMsa0JBQTVDLEVBQ0w7QUFDQSxPQUFDZ1AsQ0FBRCxFQUFJNmYsRUFBSixLQUFXQSxFQUFFLEdBQUdsSCxNQUFNLENBQUNDLFlBQVAsQ0FBb0IsR0FBR3Q2QixHQUFHLENBQUNtSCxLQUFKLENBQVUsQ0FBVixFQUFhbkgsR0FBRyxDQUFDaUgsT0FBSixDQUFZLEVBQVosQ0FBYixDQUF2QixDQUZYLENBQVA7QUFHRDs7QUFDRDZMLFFBQUksR0FBRzlTLEdBQVA7QUFDRDs7QUFDRCxTQUFPLENBQUM4UyxJQUFELEVBQU8xRixJQUFQLENBQVA7QUFDRCxDLENBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQSxlQUFlb3VCLGNBQWYsQ0FBOEI7QUFBRTE0QixNQUFGO0FBQVF1akIsTUFBUjtBQUFjOW1CO0FBQWQsQ0FBOUIsRUFBbUQ7QUFBRUksS0FBRyxHQUFHO0FBQVIsQ0FBbkQsRUFBaUU7QUFDL0QsTUFBSSxDQUFDbUQsSUFBTCxFQUFXQSxJQUFJLEdBQUcsQ0FBQyxNQUFNTiwrRkFBTyxDQUFDakQsR0FBRCxDQUFkLEVBQXFCSixJQUE1QixDQURvRCxDQUUvRDs7QUFDQSxNQUFJLENBQUNxaUMsNERBQVksQ0FBQzErQixJQUFELENBQWpCLEVBQXlCLE1BQU0raUIsNEZBQUksQ0FBQyxrQkFBRCxDQUFWO0FBQ3pCbmpCLGdEQUFLLENBQUMwTixHQUFOLENBQVU3USxHQUFWLEVBQWV1RCxJQUFmLEVBQXFCLElBQXJCO0FBQ0EsUUFBTTIrQixVQUFVLEdBQUcxc0IsaUdBQVMsRUFBNUI7QUFDQSxRQUFNO0FBQUUyc0IsVUFBRjtBQUFVN2hDLE1BQUUsRUFBRUQsS0FBZDtBQUFxQndnQztBQUFyQixNQUFtQ3pnQyxHQUF6QyxDQU4rRCxDQU8vRDs7QUFDQSxRQUFNZ2lDLGdCQUFnQixHQUFHLENBQUMsQ0FBQ3ZCLFNBQUQsSUFBYzM4QixVQUFmLE1BQ3ZCbEUsR0FBRyxLQUFLOG1CLElBQVIsSUFDRzNqQiw4Q0FBSyxDQUFDbzJCLEdBQU4sQ0FBVyxhQUFZbDVCLEtBQU0sRUFBN0IsQ0FESCxJQUVHLDBEQUEwRGtILElBQTFELENBQStEdWYsSUFBL0QsQ0FIb0IsQ0FBekI7QUFJQTs7QUFDQTNqQixnREFBSyxDQUFDME4sR0FBTixDQUFXLFdBQVVxeEIsVUFBVyxFQUFoQyxFQUFtQztBQUFFckIsYUFBRjtBQUFhN2dDLE9BQWI7QUFBa0I4bUIsUUFBbEI7QUFBd0J6bUIsU0FBeEI7QUFBK0JnaUMsTUFBRSxFQUFFbkksMEZBQUUsQ0FBQ3NIO0FBQXRDLEdBQW5DO0FBQ0EsUUFBTWMsVUFBVSxHQUFHNUcsZ0JBQWdCLEdBQUd3RyxVQUF0QztBQUNBLFFBQU07QUFBRUs7QUFBRixNQUFlSCxnQkFBZ0IsR0FDakMsTUFBTXQrQixPQUFPLENBQUN3TyxJQUFSLENBQWFwTSxNQUFiLENBQW9CN0YsS0FBcEIsRUFBMkI7QUFBRUwsT0FBRyxFQUFFc2lDO0FBQVAsR0FBM0IsQ0FEMkIsR0FFakMsTUFBTTdpQyxpREFBUSxDQUFDMnFCLE9BQVQsQ0FBaUI7QUFBRXBxQixPQUFHLEVBQUVzaUMsVUFBUDtBQUFtQkgsVUFBTSxFQUFFLENBQUMsQ0FBQ0E7QUFBN0IsR0FBakIsRUFBd0Q7QUFBRS9oQztBQUFGLEdBQXhELENBRlY7O0FBR0EsTUFBSStoQyxNQUFNLElBQUlJLFFBQVEsS0FBS25pQyxHQUFHLENBQUNtaUMsUUFBL0IsRUFBeUM7QUFDdkMsVUFBTXorQixPQUFPLENBQUMwK0IsT0FBUixDQUFnQnQ4QixNQUFoQixDQUF1QnE4QixRQUF2QixFQUFpQztBQUFFRSxhQUFPLEVBQUU7QUFBWCxLQUFqQyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxNQUFNQyxXQUFXLEdBQUcsSUFBSUMsTUFBSixDQUFZLGFBQzlCLENBQ0Usa0NBREYsRUFFRSw2QkFGRixFQUdFLHlCQUhGLEVBSUUsdUNBSkYsRUFLRSx1Q0FMRixFQU1FLDBCQU5GLEVBT0VodEIsSUFQRixDQU9PLEdBUFAsQ0FRRCx5QkFUOEIsQ0FTTHhDLE9BVEssQ0FTRyxJQVRILEVBU1MsT0FUVCxDQUFYLENBQXBCO0FBV0EsTUFBTXl2QixXQUFXLEdBQUcsSUFBSUQsTUFBSixDQUFZLGFBQzlCLENBQ0Usd0JBREYsRUFFRSxrQkFGRixFQUdFLGtCQUhGLEVBSUVodEIsSUFKRixDQUlPLEdBSlAsQ0FLRCxJQU5tQixDQUFwQjs7QUFRQSxNQUFNa3RCLGlCQUFpQixHQUFHN2lDLEdBQUcsSUFDMUIsR0FBRXl0QixtREFBYyw4QkFBNkIsQ0FBQ3p0QixHQUFHLENBQUM2SCxLQUFKLENBQVUsR0FBVixFQUFlLENBQWYsQ0FBa0IsRUFEbkUsQyxDQUdBOzs7QUFDQSxNQUFNaTdCLFlBQVksR0FBRzUrQixVQUFVLElBQUksSUFBSXkrQixNQUFKLENBQ2hDLG9CQUFtQmxWLG1EQUFhLENBQUN0YSxPQUFkLENBQXNCLEtBQXRCLEVBQTZCLE1BQTdCLENBQXFDLHdCQUR4QixDQUFuQzs7QUFHQSxNQUFNNHZCLHlCQUF5QixHQUFHRCxZQUFZLEtBQUssQ0FBQ3ppQyxLQUFELEVBQVFILEdBQVIsS0FBZ0I7QUFDakUsTUFBSTRpQyxZQUFZLENBQUN2N0IsSUFBYixDQUFrQnJILEdBQWxCLENBQUosRUFBNEI7QUFDMUI0RCxXQUFPLENBQUN3TyxJQUFSLENBQWFwTSxNQUFiLENBQW9CN0YsS0FBcEIsRUFBMkI7QUFBRUwsU0FBRyxFQUFFNmlDLGlCQUFpQixDQUFDM2lDLEdBQUQ7QUFBeEIsS0FBM0I7QUFDRDtBQUNGLENBSjZDLENBQTlDOztBQUtBLElBQUk0aUMsWUFBSixFQUFrQjtBQUNoQixRQUFNdEUsUUFBUSxHQUFHLENBQUNuK0IsS0FBRCxFQUFRO0FBQUVMO0FBQUYsR0FBUixLQUFvQkEsR0FBRyxJQUFJK2lDLHlCQUF5QixDQUFDMWlDLEtBQUQsRUFBUUwsR0FBUixDQUFyRTs7QUFDQSxRQUFNZ2pDLFFBQVEsR0FBR2wvQixPQUFPLENBQUN3TyxJQUFSLENBQWE2WixTQUE5QjtBQUNBLFFBQU1sb0IsV0FBVyxHQUFHKytCLFFBQVEsQ0FBQy8rQixXQUFULENBQXFCZy9CLElBQXJCLENBQTBCRCxRQUExQixFQUFvQ3hFLFFBQXBDLENBQXBCOztBQUNBLE1BQUk7QUFBRXY2QixlQUFXLENBQUM7QUFBRW1HLGdCQUFVLEVBQUUsQ0FBQyxLQUFEO0FBQWQsS0FBRCxDQUFYO0FBQXVDLEdBQTdDLENBQThDLE9BQU8vRixDQUFQLEVBQVU7QUFBRUosZUFBVztBQUFLO0FBQzNFOztBQUVESCxPQUFPLENBQUN3TyxJQUFSLENBQWE0d0IsU0FBYixDQUF1QmovQixXQUF2QixDQUFvQzdELEdBQUQsSUFBUztBQUMxQyxRQUFNO0FBQUVFLE1BQUY7QUFBTXlVLFNBQU47QUFBYS9VO0FBQWIsTUFBcUJJLEdBQTNCO0FBQ0E7OztBQUVBLE1BQUksQ0FBQyxDQUFDSixHQUFHLENBQUN3TyxVQUFKLENBQWUsT0FBZixDQUFELElBQTRCMHJCLDBGQUFFLENBQUNzSCxPQUFILEdBQWEsRUFBMUMsS0FDRyxxQkFBcUJqNkIsSUFBckIsQ0FBMEJuSCxHQUFHLENBQUNrQixVQUFKLElBQWtCdEIsR0FBNUMsQ0FEUCxFQUN5RDtBQUN2RG1ELGtEQUFLLENBQUMwTixHQUFOLENBQVcsYUFBWXZRLEVBQUcsRUFBMUIsRUFBNkIsSUFBN0IsRUFBbUMsSUFBbkM7QUFDRDs7QUFDRCxNQUFJd2lDLFlBQVksSUFBSTlpQyxHQUFHLEtBQUssYUFBNUIsRUFBMkM7QUFDekMraUMsNkJBQXlCLENBQUN6aUMsRUFBRCxFQUFLeVUsS0FBTCxDQUF6QjtBQUNEO0FBQ0YsQ0FYRDtBQWFBalIsT0FBTyxDQUFDb08sVUFBUixDQUFtQkMsZUFBbkIsQ0FBbUNsTyxXQUFuQyxDQUFnRGhDLEdBQUQsSUFBUztBQUN0RCxRQUFNO0FBQUVvUixVQUFGO0FBQVVoVCxTQUFWO0FBQWlCTDtBQUFqQixNQUF5QmlDLEdBQS9COztBQUNBLE1BQUlvUixNQUFNLEtBQUssS0FBZixFQUFzQjtBQUNwQjtBQUNELEdBSnFELENBS3REOzs7QUFDQSxNQUFJclQsR0FBRyxDQUFDd08sVUFBSixDQUFlaWYsbURBQWYsQ0FBSixFQUFtQztBQUNqQyxXQUFPO0FBQUUwVixpQkFBVyxFQUFFTixpQkFBaUIsQ0FBQzdpQyxHQUFEO0FBQWhDLEtBQVA7QUFDRDs7QUFDRCxNQUFJLENBQUNtRCw4Q0FBSyxDQUFDbzJCLEdBQU4sQ0FBVyxVQUFTdjVCLEdBQUksRUFBeEIsQ0FBRCxLQUNBLENBQUM0aUMsV0FBVyxDQUFDcjdCLElBQVosQ0FBaUJ2SCxHQUFqQixDQUFELElBQTBCMGlDLFdBQVcsQ0FBQ243QixJQUFaLENBQWlCdkgsR0FBakIsQ0FEMUIsQ0FBSixFQUNzRDtBQUNwRG9qQyxzQkFBa0IsQ0FBQy9pQyxLQUFELEVBQVFMLEdBQVIsQ0FBbEI7QUFDQSxXQUFPO0FBQUVtakMsaUJBQVcsRUFBRTtBQUFmLEtBQVAsQ0FGb0QsQ0FFUDtBQUM5QztBQUNGLENBZEQsRUFjRztBQUNEL3dCLE1BQUksRUFBRSxDQUNKO0FBQ0E7QUFDQTtBQUNBLG1CQUpJLEVBS0osbUJBTEksRUFNSixvQkFOSSxFQU9KLHNCQVBJLEVBUUgsR0FBRXFiLG1EQUFjLFdBUmIsQ0FETDtBQVdEcGIsT0FBSyxFQUFFLENBQUMsWUFBRDtBQVhOLENBZEgsRUEwQkcsQ0FBQyxVQUFELENBMUJIOztBQTRCQSxlQUFlK3dCLGtCQUFmLENBQWtDL2lDLEtBQWxDLEVBQXlDTCxHQUF6QyxFQUE4QztBQUM1QyxRQUFNO0FBQUVKLFFBQUksRUFBRTJEO0FBQVIsTUFBaUIsT0FBTU4sK0ZBQU8sQ0FBQ2pELEdBQUQsQ0FBUCxDQUFhb0UsS0FBYixDQUFtQm9JLG9GQUFuQixDQUFOLEtBQWtDLEVBQXpEOztBQUNBLE1BQUlqSixJQUFJLElBQUk4ZCx5REFBUyxDQUFDOWQsSUFBRCxDQUFULENBQWdCNkQsSUFBNUIsRUFBa0M7QUFDaEMsVUFBTWhILEdBQUcsR0FBR0MsS0FBSyxJQUFJLENBQVQsS0FBYyxNQUFNeUQsT0FBTyxDQUFDd08sSUFBUixDQUFhak0sR0FBYixDQUFpQmhHLEtBQWpCLENBQXBCLEtBQStDLEVBQTNEO0FBQ0E0N0Isa0JBQWMsQ0FBQztBQUFFMTRCLFVBQUY7QUFBUXZELFNBQVI7QUFBYThtQixVQUFJLEVBQUUxbUIsR0FBRyxDQUFDSjtBQUF2QixLQUFELEVBQStCO0FBQUVJO0FBQUYsS0FBL0IsQ0FBZDtBQUNELEdBSEQsTUFHTztBQUNMK0Msa0RBQUssQ0FBQzBOLEdBQU4sQ0FBVyxVQUFTN1EsR0FBSSxFQUF4QixFQUEyQixJQUEzQixFQUFpQyxJQUFqQztBQUNBLFFBQUlLLEtBQUssSUFBSSxDQUFiLEVBQWdCeUQsT0FBTyxDQUFDd08sSUFBUixDQUFhcE0sTUFBYixDQUFvQjdGLEtBQXBCLEVBQTJCO0FBQUVMO0FBQUYsS0FBM0I7QUFDakI7QUFDRixDLENBRUQ7QUFDQTs7O0FBRUE4RCxPQUFPLENBQUN3TyxJQUFSLENBQWE0WixTQUFiLENBQXVCam9CLFdBQXZCLENBQW9DNUQsS0FBRCxJQUFXO0FBQzVDRyxzQkFBb0IsQ0FBQ0gsS0FBRCxDQUFwQjtBQUNELENBRkQ7QUFJTyxTQUFTRyxvQkFBVCxDQUE4QkgsS0FBOUIsRUFBcUM7QUFDMUMsUUFBTWlJLEdBQUcsR0FBR3N6QixXQUFXLENBQUN2N0IsS0FBRCxDQUF2Qjs7QUFDQSxNQUFJaUksR0FBSixFQUFTO0FBQ1AsV0FBT3N6QixXQUFXLENBQUN2N0IsS0FBRCxDQUFsQjtBQUNBLGFBQUt5SSxtR0FBTCxFQUFBUixHQUFHLEVBQWUsQ0FBQyxDQUFDaEksRUFBRCxDQUFELEtBQVViLGlEQUFRLENBQUMyOEIsWUFBVCxDQUFzQjk3QixFQUF0QixDQUF6QixDQUFIO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7QUFLQSxTQUFTeStCLHNCQUFULENBQWdDO0FBQUUzM0IsTUFBRjtBQUFRbUIsT0FBUjtBQUFlODZCO0FBQWYsQ0FBaEMsRUFBOEQ7QUFDNUQsU0FBUSxHQUFFQyxpQkFBaUIsQ0FBQ2w4QixJQUFELENBQU8sS0FDaENpOEIsV0FBVyxHQUNQRSxxR0FBYSxDQUFDRixXQUFELENBRE4sR0FFUEMsaUJBQWlCLENBQUMvNkIsS0FBRCxDQUN0QixNQUpEO0FBS0Q7QUFFRDs7Ozs7O0FBSUEsU0FBUys2QixpQkFBVCxDQUEyQmxWLEdBQTNCLEVBQWdDO0FBQzlCLE1BQUksQ0FBQyxrQkFBa0I3bUIsSUFBbEIsQ0FBdUI2bUIsR0FBdkIsQ0FBTCxFQUFrQyxPQUFPQSxHQUFQO0FBQ2xDLE1BQUksQ0FBQ3lOLE9BQUwsRUFBY0EsT0FBTyxHQUFHLElBQUl4TixXQUFKLEVBQVY7QUFDZCxTQUFPa1YscUdBQWEsQ0FBQzFILE9BQU8sQ0FBQ3ZOLE1BQVIsQ0FBZUYsR0FBZixDQUFELENBQXBCO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE3dUIsTUFBTSxDQUFDQyxNQUFQLENBQWNDLGlEQUFkLEVBQXdCO0FBQ3RCO0FBQ0ErakMsZ0JBQWMsQ0FBQzVqQyxJQUFELEVBQU87QUFDbkIsVUFBTVUsRUFBRSxHQUFHa1YsaUdBQVMsRUFBcEI7QUFDQXJTLGtEQUFLLENBQUMwTixHQUFOLENBQVcsT0FBTXZRLEVBQUcsRUFBcEIsRUFBdUJxbUIsU0FBUyxDQUFDL21CLElBQUQsQ0FBaEM7QUFDQSxXQUFPVSxFQUFQO0FBQ0QsR0FOcUI7O0FBT3RCO0FBQ0FtakMsV0FBUyxDQUFDbmpDLEVBQUQsRUFBSztBQUNaLFdBQU9BLEVBQUUsSUFBSTZDLDhDQUFLLENBQUNrRCxHQUFOLENBQVcsT0FBTS9GLEVBQUcsRUFBcEIsQ0FBTixJQUFnQ3FtQixTQUFTLEVBQWhEO0FBQ0QsR0FWcUI7O0FBV3RCdkYsV0FBUyxFQUFFQztBQVhXLENBQXhCO0FBY08sU0FBUzRnQixZQUFULENBQXNCeHFCLElBQXRCLEVBQTRCO0FBQ2pDLE1BQUksUUFBUWxRLElBQVIsQ0FBYWtRLElBQWIsQ0FBSixFQUF3QixPQUFPLEtBQVAsQ0FEUyxDQUNLOztBQUN0QyxNQUFJQSxJQUFJLENBQUMvUCxPQUFMLENBQWEsbUJBQWIsSUFBb0MsQ0FBeEMsRUFBMkMsT0FBTyxLQUFQLENBRlYsQ0FFd0I7O0FBQ3pELFNBQU8sSUFBUDtBQUNEO0FBRUQsTUFBTWc4QixTQUFTLEdBQUc7QUFDaEJDLFNBQU8sRUFBRSxNQUFNLEVBREM7QUFFaEIzTyxXQUFTLEVBQUUsQ0FBQ3YwQixHQUFELEVBQU1vSSxHQUFOLEtBQWM7QUFDdkJwSSxPQUFHLENBQUMrUCxJQUFKLENBQVMzSCxHQUFUO0FBQ0EsV0FBT3BJLEdBQVA7QUFDRDtBQUxlLENBQWxCO0FBT0EsTUFBTW1qQyxXQUFXLEdBQUc7QUFDbEJELFNBQU8sRUFBRSxNQUFNLElBREc7QUFFbEIzTyxXQUFTLEVBQUUsQ0FBQ3YwQixHQUFELEVBQU1vSSxHQUFOLEtBQWVwSSxHQUFHLElBQUksSUFBUCxHQUFjb0ksR0FBZCxHQUFvQnBJO0FBRjVCLENBQXBCO0FBSUEsTUFBTW9qQyxTQUFTLEdBQUc7QUFDaEJDLFNBQU8sRUFBRUosU0FETztBQUVoQkssU0FBTyxFQUFFTCxTQUZPO0FBR2hCbGlDLE9BQUssRUFBRWtpQyxTQUhTO0FBSWhCTSxjQUFZLEVBQUVOLFNBSkU7QUFLaEIvZ0IsU0FBTyxFQUFFK2dCLFNBTE87QUFNaEJPLFVBQVEsRUFBRTtBQUNSTixXQUFPLEVBQUUsT0FBTyxFQUFQLENBREQ7QUFFUjNPLGFBQVMsRUFBRSxDQUFDdjBCLEdBQUQsRUFBTW9JLEdBQU4sS0FBYztBQUN2QixZQUFNcTdCLElBQUksR0FBR3I3QixHQUFHLENBQUNySCxLQUFKLENBQVUsaUJBQVYsQ0FBYjtBQUNBLFVBQUkwaUMsSUFBSixFQUFVempDLEdBQUcsQ0FBQ3lqQyxJQUFJLENBQUMsQ0FBRCxDQUFMLENBQUgsR0FBZUEsSUFBSSxDQUFDLENBQUQsQ0FBbkI7QUFDVixhQUFPempDLEdBQVA7QUFDRDtBQU5PLEdBTk07QUFjaEJnaUIsT0FBSyxFQUFFaWhCLFNBZFM7QUFlaEJyZixVQUFRLEVBQUU7QUFDUnNmLFdBQU8sRUFBRSxNQUFNLEtBRFA7QUFFUjNPLGFBQVMsRUFBRSxNQUFNO0FBRlQ7QUFmTSxDQUFsQjtBQW9CQSxNQUFNbVAsaUJBQWlCLEdBQUc7QUFDeEJDLGFBQVcsRUFBRVYsU0FEVztBQUV4QlcsWUFBVSxFQUFFWCxTQUZZO0FBR3hCWSxTQUFPLEVBQUVaO0FBSGUsQ0FBMUI7QUFLTyxTQUFTcmlCLFNBQVQsQ0FBbUI5ZCxJQUFuQixFQUF5QjtBQUM5QjtBQUNBLFFBQU1zZCxJQUFJLEdBQUcsU0FBV29ULCtGQUFYLEVBQUE0UCxTQUFTLEVBQVcsQ0FBQyxHQUFHdDdCLEtBQUgsQ0FBRCxLQUFlQSxLQUFLLENBQUNvN0IsT0FBTixFQUExQixDQUF0QjtBQUNBLFFBQU1ZLFFBQVEsR0FBR2hoQyxJQUFJLENBQUMvQixLQUFMLENBQVdxNUIsbUdBQVgsRUFBeUIsQ0FBekIsS0FBK0IsRUFBaEQ7QUFDQTBKLFVBQVEsQ0FBQ3B4QixPQUFULENBQWlCLGdDQUFqQixFQUFtRCxDQUFDcXhCLE1BQUQsRUFBU0MsTUFBVCxFQUFpQkMsUUFBakIsS0FBOEI7QUFDL0UsVUFBTSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsSUFBb0JILE1BQU0sQ0FBQzc4QixLQUFQLENBQWEsQ0FBYixFQUFnQkMsS0FBaEIsQ0FBc0IsR0FBdEIsQ0FBMUI7QUFDQSxVQUFNZzlCLFFBQVEsR0FBR0YsT0FBTyxDQUFDeHhCLE9BQVIsQ0FBZ0IsV0FBaEIsRUFBNkIsQ0FBQ0wsQ0FBRCxFQUFJZ3lCLENBQUosS0FBVUEsQ0FBQyxDQUFDQyxXQUFGLEVBQXZDLENBQWpCO0FBQ0EsVUFBTTk4QixHQUFHLEdBQUcyOEIsTUFBTSxHQUFJLEdBQUVDLFFBQVMsSUFBR0QsTUFBTSxDQUFDalcsV0FBUCxFQUFxQixFQUF2QyxHQUEyQ2tXLFFBQTdEO0FBQ0EsVUFBTWg4QixHQUFHLEdBQUc2N0IsUUFBUSxDQUFDL3NCLElBQVQsRUFBWjtBQUNBLFVBQU1xdEIsUUFBUSxHQUFHbkIsU0FBUyxDQUFDNTdCLEdBQUQsQ0FBVCxJQUFrQms4QixpQkFBaUIsQ0FBQ2w4QixHQUFELENBQW5DLElBQTRDMjdCLFdBQTdEO0FBQ0EsUUFBSXFCLFFBQVEsR0FBR3BrQixJQUFJLENBQUM1WSxHQUFELENBQW5CO0FBQ0EsUUFBSSxPQUFPZzlCLFFBQVAsS0FBb0IsV0FBeEIsRUFBcUNBLFFBQVEsR0FBR0QsUUFBUSxDQUFDckIsT0FBVCxFQUFYO0FBQ3JDOWlCLFFBQUksQ0FBQzVZLEdBQUQsQ0FBSixHQUFZKzhCLFFBQVEsQ0FBQ2hRLFNBQVQsQ0FBbUJpUSxRQUFuQixFQUE2QnA4QixHQUE3QixDQUFaO0FBQ0QsR0FURDtBQVVBZ1ksTUFBSSxDQUFDK0IsU0FBTCxHQUFpQi9CLElBQUksQ0FBQ29qQixRQUF0QjtBQUNBLFNBQU9wakIsSUFBSSxDQUFDb2pCLFFBQVosQ0FmOEIsQ0FnQjlCOztBQUNBLE1BQUksQ0FBQ3BqQixJQUFJLENBQUNnRyxXQUFOLElBQXFCaEcsSUFBSSxDQUFDcWtCLFFBQTlCLEVBQXdDcmtCLElBQUksQ0FBQ2dHLFdBQUwsR0FBbUJoRyxJQUFJLENBQUNxa0IsUUFBeEI7QUFDeEMsU0FBT3JrQixJQUFQO0FBQ0Q7QUFFTSxTQUFTeUIsZ0JBQVQsR0FBNEI7QUFDakMsU0FBTztBQUNMd1QsZUFBVyxFQUFFLElBRFI7QUFFTEMsZUFBVyxFQUFFLElBRlI7QUFHTEMsYUFBUyxFQUFFLElBSE47QUFJTEMsb0JBQWdCLEVBQUU7QUFKYixHQUFQO0FBTUQ7QUFFTSxTQUFTdFAsU0FBVCxDQUFtQi9tQixJQUFuQixFQUF5QjtBQUM5QixRQUFNMEosS0FBSyxHQUFHO0FBQ1p0SixPQUFHLEVBQUUsU0FESTtBQUVUb0gsUUFBSSxFQUFFLEVBRkc7QUFHVCs5QixRQUFJLEVBQUUsSUFBSTFpQyxJQUFKLEdBQVcyaUMsY0FBWDtBQUhHLEtBSU54bEMsSUFKTSxDQUFYOztBQU1BLFFBQU0yRCxJQUFJLEdBQUdqQiwwREFBUyxDQUFDLGdCQUFELENBQVQsQ0FDWjZRLE9BRFksQ0FDSixZQURJLEVBQ1UsQ0FBQ2liLEdBQUQsRUFBTWhuQixJQUFOLEtBQWU7QUFDcEMsVUFBTW1CLEtBQUssR0FBR2UsS0FBSyxDQUFDbEMsSUFBRCxDQUFuQjtBQUNBLFdBQU9tQixLQUFLLElBQUksSUFBVCxHQUFnQjZsQixHQUFoQixHQUFzQjdsQixLQUE3QjtBQUNELEdBSlksQ0FBYjtBQUtBLFFBQU10QyxNQUFNLEdBQUc7QUFDYnpDLFVBQU0sRUFBRThlLGdCQUFnQixFQURYO0FBRWI1WixVQUFNLEVBQUU7QUFDTm1DLGFBQU8sRUFBRSxDQURIO0FBRU5DLGtCQUFZLEVBQUU7QUFGUixLQUZLO0FBTWIrVixRQUFJLEVBQUVRLFNBQVMsQ0FBQzlkLElBQUQsQ0FORjtBQU9ibUgsU0FBSyxFQUFFO0FBUE0sR0FBZjtBQVNBLFNBQU87QUFBRXpFLFVBQUY7QUFBVTFDO0FBQVYsR0FBUDtBQUNEO0FBRU0sU0FBUzhlLFVBQVQsQ0FBb0JwYyxNQUFwQixFQUE0QjtBQUNqQyxRQUFNdVIsRUFBRSxHQUFHdlIsTUFBTSxDQUFDNGEsSUFBUCxDQUFZd2tCLFNBQVosSUFBeUIsRUFBcEM7QUFDQSxRQUFNaitCLElBQUksR0FBR25CLE1BQU0sQ0FBQzRhLElBQVAsQ0FBWXpaLElBQVosSUFBb0IsRUFBakM7QUFDQSxNQUFJaytCLE9BQU8sR0FBR0Msc0dBQWMsQ0FBRSxHQUFFL3RCLEVBQUcsS0FBSXBRLElBQUssSUFBaEIsQ0FBNUI7QUFDQSxNQUFJLENBQUNvUSxFQUFELElBQU8sQ0FBQ3BRLElBQVosRUFBa0JrK0IsT0FBTyxJQUFJci9CLE1BQU0sQ0FBQ3lFLEtBQVAsQ0FBYXBLLEVBQWIsSUFBbUIsRUFBOUI7QUFDbEIsU0FBT2dsQyxPQUFQO0FBQ0QsQzs7Ozs7Ozs7Ozs7O0FDM0hEO0FBQUE7QUFBQTtBQUFPLFNBQVNyeEIsU0FBVCxDQUFtQmYsTUFBbkIsRUFBMkI7QUFDaEMsU0FBT0EsTUFBTSxDQUFDckwsS0FBUCxDQUFhLEdBQWIsRUFBa0JtSSxNQUFsQixDQUF5QixDQUFDcFEsSUFBRCxFQUFPNGxDLEtBQVAsS0FBaUI7QUFDL0MsVUFBTSxDQUFDdjlCLEdBQUQsRUFBTVksR0FBTixJQUFhMjhCLEtBQUssQ0FBQzM5QixLQUFOLENBQVksR0FBWixFQUFpQmdDLEdBQWpCLENBQXFCL0Isa0JBQXJCLENBQW5CO0FBQ0FsSSxRQUFJLENBQUNxSSxHQUFELENBQUosR0FBWVksR0FBWjtBQUNBLFdBQU9qSixJQUFQO0FBQ0QsR0FKTSxFQUlKLEVBSkksQ0FBUDtBQUtEO0FBRU0sU0FBU21VLFNBQVQsQ0FBbUIweEIsSUFBbkIsRUFBeUI7QUFDOUIsU0FBT2xtQyxNQUFNLENBQUNtVSxPQUFQLENBQWUreEIsSUFBZixFQUNONTdCLEdBRE0sQ0FDRjY3QixNQUFNLElBQUlBLE1BQU0sQ0FBQzc3QixHQUFQLENBQVdzTSxrQkFBWCxFQUErQlIsSUFBL0IsQ0FBb0MsR0FBcEMsQ0FEUixFQUVOQSxJQUZNLENBRUQsR0FGQyxDQUFQO0FBR0QsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWkQ7QUFDQTtBQUVBOztBQUNBaUssK0ZBQU8sQ0FBQ3pjLEtBQVIsQ0FBY3drQixLQUFkLEdBQXNCZ2UsWUFBWSxDQUFDO0FBQ2pDbDlCLE1BQUksQ0FBQ3VELE9BQUQsRUFBVTtBQUNaLHFGQUFZQSxPQUFaO0FBQXFCeUgsa0JBQVksRUFBRTtBQUFuQztBQUNELEdBSGdDOztBQUlqQyxRQUFNdWhCLFNBQU4sQ0FBZ0I3RCxRQUFoQixFQUEwQm54QixHQUExQixFQUErQmdNLE9BQS9CLEVBQXdDNDVCLEtBQXhDLEVBQStDO0FBQzdDLFVBQU0sQ0FBQy8zQixJQUFELEVBQU8wRixJQUFQLElBQWUsTUFBTXFNLCtGQUFPLENBQUN6YyxLQUFSLENBQWMwaUMsT0FBZCxDQUFzQjFVLFFBQXRCLEVBQWdDLElBQWhDLENBQTNCO0FBQ0EsV0FBTXlVLEtBQU4sb0JBQU1BLEtBQUssQ0FBRzVsQyxHQUFILEVBQVFteEIsUUFBUSxDQUFDdnhCLElBQWpCLEVBQXVCaU8sSUFBdkIsQ0FBWDtBQUNBLFdBQVEsR0FBRUEsSUFBSyxJQUFHMEYsSUFBSyxFQUF2QjtBQUNEOztBQVJnQyxDQUFELENBQWxDO0FBV0E7O0FBQ0FxTSwrRkFBTyxDQUFDK0MsT0FBUixDQUFnQmdGLEtBQWhCLEdBQXdCZ2UsWUFBWSxDQUFDO0FBQ25DM1EsV0FBUyxFQUFFLENBQUM7QUFBRXAxQjtBQUFGLEdBQUQsRUFBV0ksR0FBWCxLQUNULFFBQVF1SCxJQUFSLENBQWEzSCxJQUFiLElBQ0kwRSxPQUFPLENBQUNDLE1BQVIsQ0FBZ0IsV0FBVXZFLEdBQUksS0FBSUosSUFBSSxDQUFDZ0ksS0FBTCxDQUFXLENBQVgsRUFBYyxHQUFkLEVBQW1CK1AsSUFBbkIsR0FBMEJ4RSxPQUExQixDQUFrQyxTQUFsQyxFQUE2QyxHQUE3QyxDQUFrRCxHQUFwRixDQURKLEdBRUl2VDtBQUo2QixDQUFELENBQXBDOztBQVFBLFNBQVMrbEMsWUFBVCxDQUFzQkcsUUFBUSxHQUFHLEVBQWpDLEVBQXFDO0FBQ25DLFFBQU0vVCxRQUFRLEdBQUcsRUFBakI7QUFDQSxRQUFNO0FBQUV0cEIsUUFBRjtBQUFRdXNCO0FBQVIsTUFBc0I4USxRQUE1QjtBQUNBOztBQUNBLFNBQU8sU0FBU0MsbUJBQVQsQ0FBNkIsR0FBRzVoQyxJQUFoQyxFQUFzQztBQUMzQyxVQUFNLENBQUNuRSxHQUFELElBQVFtRSxJQUFkO0FBQ0EsVUFBTStJLE9BQU8sR0FBRzZrQixRQUFRLENBQUMveEIsR0FBRCxDQUFSLEtBQWtCK3hCLFFBQVEsQ0FBQy94QixHQUFELENBQVIsR0FBZ0IsU0FBTWdtQyxPQUFOLFFBQWMsR0FBRzdoQyxJQUFqQixDQUFsQyxDQUFoQjtBQUNBLFdBQU8rSSxPQUFQO0FBQ0QsR0FKRDtBQUtBOztBQUNBLGlCQUFlODRCLE9BQWYsQ0FBdUIsR0FBRzdoQyxJQUExQixFQUFnQztBQUM5QixVQUFNLENBQUNuRSxHQUFELEVBQU1nTSxPQUFOLElBQWlCN0gsSUFBdkI7O0FBQ0EsUUFBSTtBQUNGLFlBQU0xRCxHQUFHLEdBQUcsTUFBTXdDLCtGQUFPLENBQUNqRCxHQUFELEVBQU0sQ0FBQXlJLElBQUksUUFBSixZQUFBQSxJQUFJLENBQUd1RCxPQUFILENBQUosS0FBbUJBLE9BQXpCLENBQXpCOztBQUNBLFVBQUksTUFBTWk2QixVQUFVLENBQUN4bEMsR0FBRCxFQUFNVCxHQUFOLENBQXBCLEVBQWdDO0FBQzlCLGNBQU13bUIsTUFBTSxHQUFHd08sU0FBUyxHQUFHLE1BQU1BLFNBQVMsQ0FBQ3YwQixHQUFELEVBQU0sR0FBRzBELElBQVQsQ0FBbEIsR0FBbUMxRCxHQUFHLENBQUNiLElBQS9EO0FBQ0EsY0FBTSxLQUFLMEksR0FBTCxDQUFTdEksR0FBVCxFQUFjd21CLE1BQWQsQ0FBTjtBQUNEO0FBQ0YsS0FORCxDQU1FLE9BQU96ZSxHQUFQLEVBQVk7QUFDWixVQUFJM0MsS0FBSixFQUF1QlgsRUFBQTtBQUN2QixZQUFNc0QsR0FBTjtBQUNELEtBVEQsU0FTVTtBQUNSLGFBQU9ncUIsUUFBUSxDQUFDL3hCLEdBQUQsQ0FBZjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxlQUFlaW1DLFVBQWYsQ0FBMEI7QUFBRTdpQztBQUFGLENBQTFCLEVBQXVDcEQsR0FBdkMsRUFBNEM7QUFDMUMsUUFBTThpQixHQUFHLEdBQUcxZixPQUFPLENBQUNpRCxHQUFSLENBQVksTUFBWixLQUNULENBQUMsSUFBSTVELElBQUosQ0FBU1csT0FBTyxDQUFDaUQsR0FBUixDQUFZLGVBQVosQ0FBVCxDQURRLElBRVQsQ0FBQyxJQUFJNUQsSUFBSixDQUFTVyxPQUFPLENBQUNpRCxHQUFSLENBQVksTUFBWixDQUFULENBRko7O0FBR0EsTUFBSSxDQUFDeWMsR0FBRCxJQUFRQSxHQUFHLE1BQUssTUFBTWxELCtGQUFPLENBQUNrRCxHQUFSLENBQVlwQyxNQUFaLENBQW1CMWdCLEdBQW5CLENBQVgsQ0FBZixFQUFtRDtBQUNqRCxRQUFJOGlCLEdBQUosRUFBUyxNQUFNbEQsK0ZBQU8sQ0FBQ2tELEdBQVIsQ0FBWXhhLEdBQVosQ0FBZ0J0SSxHQUFoQixFQUFxQjhpQixHQUFyQixDQUFOO0FBQ1QsV0FBTyxJQUFQO0FBQ0Q7QUFDRixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1zUSxPQUFPLEdBQUcsRUFBaEI7QUFFQTd6QixNQUFNLENBQUNDLE1BQVAsQ0FBY0MsaURBQWQsRUFBd0I7QUFDdEI7Ozs7O0FBS0EsUUFBTXlxQixVQUFOLENBQWlCZ2MsTUFBakIsRUFBeUI7QUFDdkIsUUFBSSxDQUFDQSxNQUFMLEVBQWE7QUFDWCxZQUFNO0FBQUU5bEMsV0FBRjtBQUFPcUI7QUFBUCxVQUFrQixNQUFNaEMsaURBQVEsQ0FBQzJCLFlBQVQsRUFBOUI7QUFDQSxZQUFNZCxFQUFFLEdBQUdtQixNQUFNLElBQUloQyxpREFBUSxDQUFDK2pDLGNBQVQsQ0FBd0I7QUFDM0N4akMsV0FBRyxFQUFFLENBQUNJLEdBQUcsQ0FBQ2tCLFVBQUosSUFBa0JsQixHQUFHLENBQUNKLEdBQXZCLEVBQTRCNkgsS0FBNUIsQ0FBa0MsTUFBbEMsRUFBMEMsQ0FBMUMsQ0FEc0M7QUFFM0NULFlBQUksRUFBRyxHQUFFOUUsMERBQVMsQ0FBQyxzQkFBRCxDQUFULEdBQW9DLEVBQXBDLEdBQXlDLElBQUssR0FBRWIsTUFBTztBQUZyQixPQUF4QixDQUFyQjtBQUlBeWtDLFlBQU0sR0FBSSxPQUFNNWxDLEVBQUUsR0FBSSxJQUFHQSxFQUFHLEVBQVYsR0FBYyxFQUFHLEVBQW5DO0FBQ0Q7O0FBQ0QsVUFBTU4sR0FBRyxHQUFJLEdBQUV5dEIsbURBQWMsOEJBQTZCeVksTUFBTyxFQUFqRSxDQVR1QixDQVV2Qjs7QUFDQSxTQUFLLE1BQU12ckIsSUFBWCxJQUFtQjdXLE9BQU8sQ0FBQ3FpQyxTQUFSLENBQWtCQyxRQUFsQixFQUFuQixFQUFpRDtBQUMvQyxVQUFJenJCLElBQUksQ0FBQzByQixRQUFMLENBQWNodEIsSUFBZCxLQUF1QnJaLEdBQTNCLEVBQWdDO0FBQzlCO0FBQ0EsY0FBTUksR0FBRyxHQUFHeUQsdUdBQVEsRUFBQyxNQUFNOFcsSUFBSSxDQUFDN1csT0FBTCxDQUFhd08sSUFBYixDQUFrQmpGLFVBQWxCLEVBQVAsRUFBcEI7QUFDQXZKLGVBQU8sQ0FBQ3dPLElBQVIsQ0FBYXBNLE1BQWIsQ0FBb0I5RixHQUFHLENBQUNFLEVBQXhCLEVBQTRCO0FBQUU2aEMsZ0JBQU0sRUFBRTtBQUFWLFNBQTVCO0FBQ0FyK0IsZUFBTyxDQUFDMCtCLE9BQVIsQ0FBZ0J0OEIsTUFBaEIsQ0FBdUI5RixHQUFHLENBQUNtaUMsUUFBM0IsRUFBcUM7QUFBRUUsaUJBQU8sRUFBRTtBQUFYLFNBQXJDO0FBQ0EsZUFBT3JpQyxHQUFQO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPWCxpREFBUSxDQUFDMnFCLE9BQVQsQ0FBaUI7QUFBRXBxQixTQUFGO0FBQU9zbUMsbUJBQWEsRUFBRTtBQUF0QixLQUFqQixDQUFQO0FBQ0QsR0EzQnFCOztBQTRCdEI7QUFDQSxRQUFNbGMsT0FBTixDQUFjO0FBQ1pwcUIsT0FEWTtBQUVabWlDLFVBQU0sR0FBRyxJQUZHO0FBR1pvRSxhQUhZO0FBSVpDLFVBQU0sR0FBRyxJQUpHO0FBS1pGLGlCQUFhLEdBQUcsS0FMSjtBQU1aRztBQU5ZLEdBQWQsRUFPR3ZtQyxHQUFHLEdBQUcsRUFQVCxFQU9hO0FBQ1g7QUFDQSxVQUFNd21DLE1BQU0sR0FBR3htQyxHQUFHLENBQUNFLEdBQUosS0FBVyxNQUFNaUIsb0dBQVksRUFBN0IsS0FBbUMsRUFBbEQsQ0FGVyxDQUdYOztBQUNBLFVBQU1zbEMsTUFBTSxHQUFHem1DLEdBQUcsQ0FBQ0YsR0FBbkI7QUFDQSxVQUFNNG1DLFVBQVUsR0FBRyxDQUFDRCxNQUFELElBQVdBLE1BQU0sQ0FBQ240QixVQUFQLENBQWtCaWYsbURBQWxCLENBQTlCLENBTFcsQ0FNWDs7QUFDQSxVQUFNO0FBQUVvVCxlQUFGO0FBQWEwQjtBQUFiLFFBQTBCbUUsTUFBaEMsQ0FQVyxDQVFYOztBQUNBLFFBQUlySSxPQUFPLEdBQUdxSSxNQUFNLENBQUNHLGFBQXJCOztBQUNBLFFBQUl4SSxPQUFPLElBQUksQ0FBQ3dDLFNBQWhCLEVBQTJCO0FBQ3pCeEMsYUFBTyxHQUFHeUksY0FBYyxDQUFDRixVQUFVLEdBQUcsQ0FBSCxHQUFPTCxTQUFsQixDQUFkLElBQThDbEksT0FBeEQ7QUFDRDs7QUFDRCxRQUFJQSxPQUFKLEVBQWFBLE9BQU8sR0FBRztBQUFFd0ksbUJBQWEsRUFBRXhJO0FBQWpCLEtBQVYsQ0FiRixDQWNYOztBQUNBLFFBQUksQ0FBQyxXQUFXOTJCLElBQVgsQ0FBZ0J2SCxHQUFoQixDQUFMLEVBQTJCO0FBQ3pCQSxTQUFHLEdBQUc0bUMsVUFBVSxHQUNaOWlDLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQjJwQixNQUFoQixDQUF1QjF0QixHQUF2QixDQURZLEdBRVpxbkIsa0dBQVUsQ0FBQ3JuQixHQUFELEVBQU0ybUMsTUFBTixDQUZkO0FBR0Q7O0FBQ0QsVUFBTUksZ0JBQWdCLEdBQUcsQ0FBQ2xHLFNBQUQsSUFBYzM4QixVQUFkLElBQTRCLENBQUMsbUJBQW1CcUQsSUFBbkIsQ0FBd0J2SCxHQUF4QixDQUF0RDtBQUNBLFFBQUlnbkMsTUFBSjs7QUFDQSxRQUFJVixhQUFhLElBQ1Z4aUMsT0FBTyxDQUFDMCtCLE9BRFgsSUFFR2xnQywwREFBUyxDQUFDLGNBQUQ7QUFDWjs7QUFIQSxRQUtJLENBQUMrN0IsT0FBRCxJQUFZbkUsMEZBQUUsQ0FBQ3NILE9BQUgsSUFBYyxFQUw5QixDQUFKLEVBS3VDO0FBQ3JDLFlBQU15RixPQUFPLEdBQUc7QUFDZGpuQyxXQURXO0FBRVg2Z0MsaUJBQVMsRUFBRWtHLGdCQUFnQixJQUFJbEc7QUFGcEIsU0FHUnYrQiwwREFBUyxDQUFDLG9CQUFELENBQVQsSUFBbUM7QUFBRXVMLFlBQUksRUFBRTtBQUFSLE9BSDNCLE1BSVIsQ0FBQzNKLFVBQUQsSUFBZTtBQUFFdStCLGVBQU8sRUFBRSxDQUFDLENBQUNOO0FBQWIsT0FKUCxNQUtSOUQsT0FMUSxDQUFiOztBQU9BLFlBQU1vQyxHQUFHLEdBQUduK0IsMERBQVMsQ0FBQyxpQkFBRCxDQUFyQjtBQUNBLFlBQU00a0MsTUFBTSxHQUFHekcsR0FBRyxJQUFJLFNBQVNBLEdBQS9CO0FBQ0EsWUFBTTBHLEdBQUcsR0FBRyxPQUFNcmpDLE9BQU8sQ0FBQzArQixPQUFSLENBQWdCdjJCLE1BQWhCLDJFQUE0Qmc3QixPQUE1QixNQUF3Q3hHLEdBQXhDLEdBQStDcjhCLEtBQS9DLENBQXFEOGlDLE1BQU0sSUFBSTE2QixvRkFBL0QsQ0FBTixLQUNQMDZCLE1BQU0sS0FBSSxNQUFNcGpDLE9BQU8sQ0FBQzArQixPQUFSLENBQWdCdjJCLE1BQWhCLENBQXVCZzdCLE9BQXZCLENBQVYsQ0FEWDtBQUVBRCxZQUFNLEdBQUdHLEdBQUcsQ0FBQzcwQixJQUFKLENBQVMsQ0FBVCxDQUFUO0FBQ0Q7O0FBQ0QsUUFBSSxDQUFDMDBCLE1BQUwsRUFBYTtBQUNYQSxZQUFNLEdBQUcsTUFBTWxqQyxPQUFPLENBQUN3TyxJQUFSLENBQWFyRyxNQUFiO0FBQ2JqTSxXQURhO0FBRWI7QUFDQW1pQyxjQUFNLEVBQUUsQ0FBQyxDQUFDQSxNQUhHO0FBSWJzRSxjQUFNLEVBQUUsQ0FBQyxDQUFDQTtBQUpHLFNBS1ZwSSxPQUxVLE1BTVYwSSxnQkFBZ0IsSUFBSTtBQUNyQnhFO0FBRGlCLFNBRWRpRSxNQUFNLElBQUk7QUFBRXhsQixhQUFLLEVBQUUwbEIsTUFBTSxDQUFDMWxCLEtBQVAsR0FBZTtBQUF4QixPQUZJLE1BR2RrWiwwRkFBRSxDQUFDa04sb0JBQUgsSUFBMkI7QUFBRUMsbUJBQVcsRUFBRVgsTUFBTSxDQUFDcG1DO0FBQXRCLE9BSGIsQ0FOTixFQUFmO0FBWUQ7O0FBQ0QsVUFBTTtBQUFFQTtBQUFGLFFBQVMwbUMsTUFBZjs7QUFDQSxRQUFJN0UsTUFBTSxJQUFJNkUsTUFBTSxDQUFDekUsUUFBUCxLQUFvQkEsUUFBbEMsRUFBNEM7QUFDMUMsWUFBTXorQixPQUFPLENBQUMwK0IsT0FBUixDQUFnQnQ4QixNQUFoQixDQUF1QjhnQyxNQUFNLENBQUN6RSxRQUE5QixFQUF3QztBQUFFRSxlQUFPLEVBQUU7QUFBWCxPQUF4QyxDQUFOO0FBQ0Q7O0FBQ0RyUCxXQUFPLENBQUM5eUIsRUFBRCxDQUFQLEdBQWNvbUMsTUFBTSxDQUFDcG1DLEVBQXJCO0FBQ0EsV0FBT3NtQyxVQUFVLEdBQUdJLE1BQUgsR0FBWTtBQUFFMW1DO0FBQUYsS0FBN0I7QUFDRCxHQWpHcUI7O0FBa0d0QjtBQUNBZ25DLFVBQVEsQ0FBQztBQUFFaG5DO0FBQUYsTUFBUyxFQUFWLEVBQWNKLEdBQWQsRUFBbUI7QUFBQTs7QUFDekIsVUFBTUcsS0FBSyxHQUFHQyxFQUFFLEtBQUlKLEdBQUosZ0NBQUlBLEdBQUcsQ0FBRUUsR0FBVCxxQkFBSSxTQUFVRSxFQUFkLENBQWhCO0FBQ0EsUUFBSUQsS0FBSyxJQUFJLENBQWIsRUFBZ0J5RCxPQUFPLENBQUN3TyxJQUFSLENBQWEvTCxNQUFiLENBQW9CbEcsS0FBcEI7QUFDakIsR0F0R3FCOztBQXVHdEJrbkMsVUFBUSxDQUFDcGxCLENBQUQsRUFBSWppQixHQUFKLEVBQVM7QUFDZjRELFdBQU8sQ0FBQ3dPLElBQVIsQ0FBYXBNLE1BQWIsQ0FBb0JoRyxHQUFHLENBQUNFLEdBQUosQ0FBUUUsRUFBNUIsRUFBZ0M7QUFBRTZoQyxZQUFNLEVBQUU7QUFBVixLQUFoQyxFQUFrRC85QixLQUFsRCxDQUF3RG9JLG9GQUF4RDtBQUNBMUksV0FBTyxDQUFDMCtCLE9BQVIsQ0FBZ0J0OEIsTUFBaEIsQ0FBdUJoRyxHQUFHLENBQUNFLEdBQUosQ0FBUW1pQyxRQUEvQixFQUF5QztBQUFFRSxhQUFPLEVBQUU7QUFBWCxLQUF6QyxFQUE0RHIrQixLQUE1RCxDQUFrRW9JLG9GQUFsRTtBQUNEOztBQTFHcUIsQ0FBeEIsRSxDQTZHQTtBQUNBO0FBQ0E7O0FBQ0EwdEIsMEZBQUUsQ0FBQ3NOLEtBQUgsQ0FBU2o2QixJQUFULENBQWMsTUFBTTtBQUNsQmhPLFFBQU0sQ0FBQ2tvQyxnQkFBUCxDQUF3QnZOLDBGQUF4QixFQUE0QjtBQUMxQmtOLHdCQUFvQixFQUFFO0FBQ3BCNytCLFdBQUssRUFBRSxDQUFDckUsVUFBRCxJQUFlZzJCLDBGQUFFLENBQUNzSCxPQUFILElBQWMsRUFBZCxJQUFvQnRILDBGQUFFLENBQUN3TixFQUFILEtBQVU7QUFEaEM7QUFESSxHQUE1QjtBQUtELENBTkQ7QUFRQTVqQyxPQUFPLENBQUN3TyxJQUFSLENBQWE0WixTQUFiLENBQXVCam9CLFdBQXZCLENBQW9DM0QsRUFBRCxJQUFRO0FBQ3pDLFFBQU1xekIsUUFBUSxHQUFHUCxPQUFPLENBQUM5eUIsRUFBRCxDQUF4Qjs7QUFDQSxNQUFJcXpCLFFBQVEsSUFBSSxDQUFoQixFQUFtQjtBQUNqQkMsc0dBQVUsQ0FBQ0QsUUFBRCxFQUFXLFdBQVgsRUFBd0JyekIsRUFBeEIsQ0FBVjtBQUNBLFdBQU84eUIsT0FBTyxDQUFDOXlCLEVBQUQsQ0FBZDtBQUNEO0FBQ0YsQ0FORDs7QUFRQSxTQUFTd21DLGNBQVQsQ0FBd0I5bEIsS0FBeEIsRUFBK0I7QUFDN0IsU0FBT0EsS0FBSyxLQUFLLENBQVYsSUFBZSxpQkFBZixJQUNHQSxLQUFLLEdBQUcsQ0FBUixJQUFjLHFCQUFvQkEsS0FBTSxFQURsRDtBQUVELEM7Ozs7Ozs7Ozs7OztBQzVJRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVPLE1BQU01aEIsZUFBZSxHQUFHLGdCQUF4QjtBQUNQLE1BQU11b0Msc0JBQXNCLEdBQUksR0FBRXZvQyxlQUFnQixRQUFsRDtBQUNBLE1BQU13b0MsZ0JBQWdCLEdBQUk7Ozs7Ozs7Q0FBMUI7QUFTQTVkLG9EQUFjLENBQUN4WixJQUFmLENBQW9CLE1BQU07QUFDeEIsTUFBSXEzQixNQUFNLEdBQUd2bEMsMERBQVMsQ0FBQ3FsQyxzQkFBRCxDQUF0QixDQUR3QixDQUV4Qjs7QUFDQSxNQUFJRSxNQUFKLEVBQVk7QUFDWixRQUFNQyxRQUFRLEdBQUd4bEMsMERBQVMsQ0FBQ2xELGVBQUQsQ0FBMUIsQ0FKd0IsQ0FLeEI7O0FBQ0EsTUFBSXlvQyxNQUFNLElBQUksSUFBZCxFQUFvQjtBQUNsQkEsVUFBTSxHQUFHQyxRQUFRLEtBQUtGLGdCQUF0QjtBQUNBLFFBQUlDLE1BQUosRUFBWXIvQiwwREFBUyxDQUFDbS9CLHNCQUFELEVBQXlCLElBQXpCLENBQVQsQ0FBWixLQUNLdG9DLG1CQUFtQixHQUhOLENBSXBCO0FBQ0MsR0FMRCxNQUtPLElBQUl5b0MsUUFBUSxLQUFLcFQsaUVBQWdCLENBQUN0MUIsZUFBRCxDQUFqQyxFQUFvRDtBQUN6REMsdUJBQW1CO0FBQ3BCO0FBQ0YsQ0FkRDtBQWdCTyxTQUFTQSxtQkFBVCxDQUE2QkgsT0FBTyxHQUFHLEVBQXZDLEVBQTJDO0FBQ2hELFFBQU02b0MsZUFBZSxHQUFHclQsaUVBQWdCLENBQUN0MUIsZUFBRCxDQUF4QztBQUNBLE1BQUkwb0MsUUFBUSxHQUFHNW9DLE9BQU8sQ0FBQ0UsZUFBRCxDQUF0Qjs7QUFDQSxNQUFJLENBQUMwb0MsUUFBTCxFQUFlO0FBQ2JBLFlBQVEsR0FBR0MsZUFBWDtBQUNBN29DLFdBQU8sQ0FBQ0UsZUFBRCxDQUFQLEdBQTJCMG9DLFFBQTNCO0FBQ0F0L0IsOERBQVMsQ0FBQ3BKLGVBQUQsRUFBa0Iwb0MsUUFBbEIsQ0FBVDtBQUNEOztBQUNELFFBQU1ELE1BQU0sR0FBR0MsUUFBUSxLQUFLQyxlQUE1Qjs7QUFDQSxNQUFJRixNQUFNLEtBQUszb0MsT0FBTyxDQUFDeW9DLHNCQUFELENBQXRCLEVBQWdEO0FBQzlDem9DLFdBQU8sQ0FBQ3lvQyxzQkFBRCxDQUFQLEdBQWtDRSxNQUFsQztBQUNBci9CLDhEQUFTLENBQUNtL0Isc0JBQUQsRUFBeUJFLE1BQXpCLENBQVQ7QUFDRDtBQUNGLEM7Ozs7Ozs7Ozs7OztBQzNDRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBdG9DLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjQyxpREFBZCxFQUF3QjtBQUN0QnVvQyxlQUFhLEVBQUU1akI7QUFETyxDQUF4QjtBQUlBNEYsb0RBQWMsQ0FBQ3haLElBQWYsQ0FBb0J5M0IsY0FBcEI7QUFFQXZtQywyRkFBQSxDQUFZLElBQVo7QUFFQSxNQUFNd21DLGNBQWMsR0FBRyx5QkFBdkI7QUFDQSxJQUFJQyxjQUFjLEdBQUcsRUFBckI7QUFDQWxwQyw0REFBVyxDQUFFQyxPQUFELElBQWE7QUFDdkIsTUFBSSxlQUFlQSxPQUFuQixFQUE0QitvQyxjQUFjLENBQUMvb0MsT0FBTyxDQUFDa3BDLFNBQVIsSUFBcUIsRUFBdEIsQ0FBZDtBQUM3QixDQUZVLENBQVg7QUFHQSxNQUFNQyxnQkFBZ0IsR0FBRyxXQUF6QjtBQUVBOzs7Ozs7Ozs7Ozs7QUFXQSxNQUFNQyxtQkFBbUIsR0FBRyxLQUE1QjtBQUNBLElBQUlDLE9BQU8sR0FBRyxFQUFkO0FBQ0EsSUFBSUMsV0FBVyxHQUFHLENBQWxCOztBQUVBLFNBQVNDLFNBQVQsQ0FBbUJ6b0MsR0FBbkIsRUFBd0Iwb0MsS0FBeEIsRUFBK0JqNkIsTUFBL0IsRUFBdUNrNkIsV0FBdkMsRUFBb0Q7QUFDbEQsU0FBT0QsS0FBSyxDQUFDN2pCLElBQU4sQ0FBVzNmLElBQUksSUFBSTtBQUN4QixVQUFNK0MsR0FBRyxHQUFJLEdBQUV3RyxNQUFPLElBQUd2SixJQUFLLEVBQTlCO0FBQ0EsVUFBTTBqQyxPQUFPLEdBQUd6bEMsOENBQUssQ0FBQ2tELEdBQU4sQ0FBVTRCLEdBQVYsS0FBa0I5RSw4Q0FBSyxDQUFDME4sR0FBTixDQUFVNUksR0FBVixFQUFlMGdDLFdBQVcsQ0FBQ3pqQyxJQUFELENBQTFCLENBQWxDO0FBQ0EsV0FBTzBqQyxPQUFPLENBQUNyaEMsSUFBUixDQUFhdkgsR0FBYixDQUFQO0FBQ0QsR0FKTSxDQUFQO0FBS0Q7QUFFRDs7Ozs7QUFHTyxTQUFTNm9DLFFBQVQsQ0FBa0I3b0MsR0FBbEIsRUFBdUIwb0MsS0FBdkIsRUFBOEI7QUFDbkMsU0FBT0QsU0FBUyxDQUFDem9DLEdBQUQsRUFBTTBvQyxLQUFOLEVBQWEsSUFBYixFQUFtQkksT0FBbkIsQ0FBaEI7QUFDRDtBQUVEOzs7O0FBR08sU0FBU0MsU0FBVCxDQUFtQi9vQyxHQUFuQixFQUF3QjBvQyxLQUF4QixFQUErQjtBQUNwQyxTQUFPRCxTQUFTLENBQUN6b0MsR0FBRCxFQUFNMG9DLEtBQU4sRUFBYSxPQUFiLEVBQXNCTSxXQUF0QixDQUFoQjtBQUNEO0FBRU0sU0FBUzFrQixVQUFULENBQW9CdGtCLEdBQXBCLEVBQXlCaUcsTUFBekIsRUFBaUM7QUFDdEM5QyxnREFBSyxDQUFDOGxDLEtBQU4sQ0FBWSxJQUFaO0FBQ0EsUUFBTTtBQUFFemxDLFVBQUY7QUFBVXFkO0FBQVYsTUFBbUI1YSxNQUF6QjtBQUNBLFFBQU1pakMsR0FBRyxHQUFHQyxVQUFVLENBQUMzbEMsTUFBTSxDQUFDd3lCLFNBQVAsSUFBb0JuVixJQUFJLENBQUNyZixLQUExQixFQUFpQ2dDLE1BQU0sQ0FBQ2hDLEtBQXhDLENBQXRCO0FBQ0EsUUFBTTRuQyxHQUFHLEdBQUdELFVBQVUsQ0FBQzNsQyxNQUFNLENBQUNzeUIsV0FBUCxJQUFzQmpWLElBQUksQ0FBQ2lqQixPQUE1QixFQUFxQ3RnQyxNQUFNLENBQUNzZ0MsT0FBNUMsQ0FBdEI7QUFDQSxRQUFNdUYsR0FBRyxHQUFHRixVQUFVLENBQUMzbEMsTUFBTSxDQUFDdXlCLFdBQVAsSUFBc0JsVixJQUFJLENBQUNrakIsT0FBNUIsRUFBcUN2Z0MsTUFBTSxDQUFDdWdDLE9BQTVDLENBQXRCO0FBQ0EsUUFBTXVGLE1BQU0sR0FBR0gsVUFBVSxDQUFDM2xDLE1BQU0sQ0FBQ3l5QixnQkFBUCxJQUEyQnBWLElBQUksQ0FBQ21qQixZQUFqQyxFQUErQ3hnQyxNQUFNLENBQUN3Z0MsWUFBdEQsQ0FBekIsQ0FOc0MsQ0FPdEM7O0FBQ0EsTUFBSXVGLEVBQUUsR0FBRyxDQUFDTCxHQUFHLENBQUNsb0MsTUFBTCxJQUFlLENBQUNvb0MsR0FBRyxDQUFDcG9DLE1BQTdCLENBUnNDLENBU3RDOztBQUNBdW9DLElBQUUsR0FBR0EsRUFBRSxJQUFJUixTQUFTLENBQUMvb0MsR0FBRCxFQUFNa3BDLEdBQU4sQ0FBcEIsQ0FWc0MsQ0FXdEM7O0FBQ0FLLElBQUUsR0FBR0EsRUFBRSxJQUFJVixRQUFRLENBQUM3b0MsR0FBRCxFQUFNb3BDLEdBQU4sQ0FBbkIsQ0Fac0MsQ0FhdEM7O0FBQ0FHLElBQUUsR0FBR0EsRUFBRSxJQUFJLENBQUNSLFNBQVMsQ0FBQy9vQyxHQUFELEVBQU1zcEMsTUFBTixDQUFyQixDQWRzQyxDQWV0Qzs7QUFDQUMsSUFBRSxHQUFHQSxFQUFFLElBQUksQ0FBQ1YsUUFBUSxDQUFDN29DLEdBQUQsRUFBTXFwQyxHQUFOLENBQXBCO0FBQ0FsbUMsZ0RBQUssQ0FBQzhsQyxLQUFOLENBQVksS0FBWjtBQUNBLFNBQU9NLEVBQVA7QUFDRDs7QUFFRCxTQUFTSixVQUFULENBQW9CLEdBQUdobEMsSUFBdkIsRUFBNkI7QUFDM0IsU0FBT0EsSUFBSSxDQUFDNkwsTUFBTCxDQUFZLENBQUN2UCxHQUFELEVBQU13UCxJQUFOLEtBQWdCQSxJQUFJLEdBQUd4UCxHQUFHLENBQUNnNkIsTUFBSixDQUFXeHFCLElBQVgsQ0FBSCxHQUFzQnhQLEdBQXRELEVBQTRELEVBQTVELENBQVA7QUFDRDs7QUFFRCxTQUFTK29DLE1BQVQsQ0FBZ0JwYixHQUFoQixFQUFxQjtBQUNuQixRQUFNcWIsRUFBRSxHQUFHcmIsR0FBRyxDQUFDamIsT0FBSixDQUFZLG9CQUFaLEVBQWtDLE1BQWxDLEVBQTBDQSxPQUExQyxDQUFrRCxLQUFsRCxFQUF5RCxLQUF6RCxDQUFYO0FBQ0EsU0FBT3MyQixFQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsTUFBVCxDQUFnQkQsRUFBaEIsRUFBb0I7QUFDbEIsU0FBT0EsRUFBRSxDQUFDbGlDLElBQUgsQ0FBUTA3QixJQUFSLENBQWF3RyxFQUFiLENBQVA7QUFDRDs7QUFFRCxTQUFTWCxPQUFULENBQWlCMWEsR0FBakIsRUFBc0I7QUFDcEI7QUFDQSxNQUFJQSxHQUFHLENBQUNwdEIsTUFBSixHQUFhLENBQWIsSUFBa0JvdEIsR0FBRyxDQUFDLENBQUQsQ0FBSCxLQUFXLEdBQTdCLElBQW9DQSxHQUFHLENBQUNBLEdBQUcsQ0FBQ3B0QixNQUFKLEdBQWEsQ0FBZCxDQUFILEtBQXdCLEdBQWhFLEVBQXFFO0FBQ25FLFFBQUl5b0MsRUFBSjs7QUFDQSxRQUFJO0FBQUVBLFFBQUUsR0FBRyxJQUFJOUcsTUFBSixDQUFXdlUsR0FBRyxDQUFDeG1CLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLENBQVgsRUFBNkIsR0FBN0IsQ0FBTDtBQUF5QyxLQUEvQyxDQUFnRCxPQUFPdkQsQ0FBUCxFQUFVO0FBQUU7QUFBYzs7QUFDMUUsV0FBTztBQUFFa0QsVUFBSSxFQUFFa2lDLEVBQUUsR0FBR0MsTUFBTSxDQUFDRCxFQUFELENBQVQsR0FBZ0IsTUFBTTtBQUFoQyxLQUFQO0FBQ0QsR0FObUIsQ0FPcEI7OztBQUNBLFFBQU1FLEtBQUssR0FBR0gsTUFBTSxDQUFDcGIsR0FBRyxDQUFDTyxXQUFKLEVBQUQsQ0FBcEI7O0FBQ0EsTUFBSWp0QiwyRkFBQSxNQUFpQjBzQixHQUFHLENBQUNqc0IsUUFBSixDQUFhLE9BQWIsQ0FBckIsRUFBNEM7QUFDMUMsVUFBTXluQyxRQUFRLEdBQUdELEtBQUssQ0FBQ3gyQixPQUFOLENBQWMsU0FBZCxFQUF5QixvQkFBekIsQ0FBakI7QUFDQSxXQUFPO0FBQ0w1TCxVQUFJLEVBQUdzaUMsSUFBRCxJQUFVO0FBQ2QsY0FBTXhPLE9BQU8sR0FBR3dPLElBQUksQ0FBQ2xiLFdBQUwsR0FBbUJudEIsS0FBbkIsQ0FBeUJvb0MsUUFBekIsQ0FBaEI7O0FBQ0EsWUFBSXZPLE9BQUosRUFBYTtBQUNYLGdCQUFNeU8sTUFBTSxHQUFHek8sT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXenpCLEtBQVgsQ0FBaUIsQ0FBakIsQ0FBZjtBQUNBLGNBQUlsRyxtR0FBQSxDQUFvQm9vQyxNQUFwQixNQUFnQ0EsTUFBcEMsRUFBNEMsT0FBTyxJQUFQO0FBQzdDOztBQUNELGVBQU8sS0FBUDtBQUNEO0FBUkksS0FBUDtBQVVEOztBQUNELFFBQU1MLEVBQUUsR0FBRyxJQUFJOUcsTUFBSixDQUFZLElBQUdnSCxLQUFNLEdBQXJCLEVBQXlCLEdBQXpCLENBQVgsQ0F0Qm9CLENBc0JzQjs7QUFDMUMsU0FBTztBQUFFcGlDLFFBQUksRUFBRW1pQyxNQUFNLENBQUNELEVBQUQ7QUFBZCxHQUFQO0FBQ0Q7O0FBRUQsU0FBU00sV0FBVCxDQUFxQjdrQyxJQUFyQixFQUEyQnRGLElBQTNCLEVBQWlDO0FBQy9CO0FBQ0EsTUFBSXNGLElBQUksS0FBS3RGLElBQWIsRUFBbUIsT0FBTyxDQUFQLENBRlksQ0FHL0I7QUFDQTs7QUFDQSxNQUFJLENBQ0YsR0FERSxFQUVGLE9BRkUsRUFHRnVDLFFBSEUsQ0FHTytDLElBSFAsS0FHZ0JtakMsZ0JBQWdCLENBQUM5Z0MsSUFBakIsQ0FBc0IzSCxJQUF0QixDQUhwQixFQUdpRCxPQUFPLENBQVA7QUFDakQsU0FBTyxDQUFQO0FBQ0Q7O0FBRUQsTUFBTW9xQyxVQUFVLEdBQUcsYUFBbkI7QUFDQSxNQUFNQyxVQUFVLEdBQUcsbUJBQW5COztBQUNBLFNBQVNDLFdBQVQsQ0FBcUJobEMsSUFBckIsRUFBMkI7QUFDekI7QUFDQSxNQUFJQSxJQUFJLEtBQUssR0FBYixFQUFrQjtBQUNoQixXQUFPLE1BQU0sQ0FBYjtBQUNELEdBSndCLENBS3pCO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBTWlsQyxNQUFNLEdBQUdqbEMsSUFBSSxDQUFDeXBCLFdBQUwsRUFBZixDQVJ5QixDQVFVOztBQUNuQyxNQUFJbGdCLE1BQU0sR0FBRyxFQUFiO0FBQ0EsTUFBSS9DLElBQUksR0FBR3krQixNQUFYO0FBQ0EsTUFBSUwsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsTUFBSTVrQyxJQUFJLENBQUNzSixVQUFMLENBQWdCLElBQWhCLENBQUosRUFBMkI7QUFDekI5QyxRQUFJLEdBQUdBLElBQUksQ0FBQzlELEtBQUwsQ0FBVyxDQUFYLENBQVA7QUFDQTZHLFVBQU0sR0FBR3U3QixVQUFUO0FBQ0Q7O0FBQ0QsTUFBSXRvQywyRkFBQSxNQUFpQndELElBQUksQ0FBQ3FULFFBQUwsQ0FBYyxNQUFkLENBQXJCLEVBQTRDO0FBQzFDN00sUUFBSSxHQUFHQSxJQUFJLENBQUM5RCxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQUMsQ0FBZixDQUFQO0FBQ0FraUMsVUFBTSxHQUFHRyxVQUFUO0FBQ0Q7O0FBQ0QsUUFBTVIsRUFBRSxHQUFHLElBQUk5RyxNQUFKLENBQVksSUFBR2wwQixNQUFPLEdBQUUrNkIsTUFBTSxDQUFDOTlCLElBQUQsQ0FBTyxHQUFFbytCLE1BQU8sR0FBOUMsQ0FBWDtBQUNBLFNBQVFscUMsSUFBRCxJQUFVO0FBQ2Y7QUFDQUEsUUFBSSxHQUFHQSxJQUFJLENBQUMrdUIsV0FBTCxFQUFQO0FBQ0EsUUFBSXdiLE1BQU0sS0FBS3ZxQyxJQUFmLEVBQXFCLE9BQU8sQ0FBUCxDQUhOLENBSWY7O0FBQ0EsVUFBTXk3QixPQUFPLEdBQUd6N0IsSUFBSSxDQUFDNEIsS0FBTCxDQUFXaW9DLEVBQVgsQ0FBaEI7O0FBQ0EsUUFBSXBPLE9BQUosRUFBYTtBQUNYLFlBQU0sR0FBRytPLE1BQUgsSUFBYS9PLE9BQW5CO0FBQ0EsVUFBSSxDQUFDK08sTUFBTCxFQUFhLE9BQU8sQ0FBUDtBQUNiLFlBQU1DLFNBQVMsR0FBR0QsTUFBTSxDQUFDeGlDLEtBQVAsQ0FBYSxDQUFiLENBQWxCO0FBQ0EsYUFBT2xHLG1HQUFBLENBQW9CMm9DLFNBQXBCLE1BQW1DQSxTQUExQztBQUNEOztBQUNELFdBQU8sQ0FBUDtBQUNELEdBYkQ7QUFjRDs7QUFFRCxTQUFTQyxXQUFULENBQXFCcGxDLElBQXJCLEVBQTJCO0FBQ3pCLFFBQU1xbEMsS0FBSyxHQUFHcmxDLElBQUksQ0FBQ3dDLE9BQUwsQ0FBYSxHQUFiLENBQWQ7QUFDQSxNQUFJOGlDLE1BQU0sR0FBR3RsQyxJQUFJLENBQUN3QyxPQUFMLENBQWEsR0FBYixDQUFiO0FBQ0EsTUFBSStpQyxLQUFLLEdBQUdqQixNQUFNLENBQUN0a0MsSUFBRCxDQUFsQjtBQUNBLE1BQUlzbEMsTUFBTSxHQUFHRCxLQUFiLEVBQW9CQyxNQUFNLEdBQUcsQ0FBQyxDQUFWOztBQUNwQixNQUFJRCxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ2IsUUFBSUMsTUFBTSxHQUFHLENBQWIsRUFBZ0JDLEtBQUssR0FBSSxJQUFHQSxLQUFNLFlBQWxCLENBQWhCLEtBQ0tBLEtBQUssR0FBSSxJQUFHQSxLQUFNLFNBQWxCO0FBQ047O0FBQ0QsU0FBT2YsTUFBTSxDQUFDLElBQUkvRyxNQUFKLENBQVc4SCxLQUFYLENBQUQsQ0FBYjtBQUNEOztBQUVELFNBQVN6QixXQUFULENBQXFCOWpDLElBQXJCLEVBQTJCO0FBQ3pCLE1BQUlxQyxJQUFKOztBQUNBLE1BQUlyQyxJQUFJLEtBQUssWUFBYixFQUEyQjtBQUN6QnFDLFFBQUksR0FBRyxNQUFNLElBQWI7QUFDRCxHQUZELE1BRU87QUFDTCxVQUFNbWpDLFNBQVMsR0FBR3hsQyxJQUFJLENBQUMxRCxLQUFMLENBQVcwbUMsY0FBWCxDQUFsQjs7QUFDQSxRQUFJd0MsU0FBSixFQUFlO0FBQ2IsWUFBTUMsU0FBUyxHQUFHVCxXQUFXLENBQUNRLFNBQVMsQ0FBQyxDQUFELENBQVYsQ0FBN0I7QUFDQSxZQUFNRSxTQUFTLEdBQUdOLFdBQVcsQ0FBQ0ksU0FBUyxDQUFDLENBQUQsQ0FBVixDQUE3Qjs7QUFDQW5qQyxVQUFJLEdBQUl2SCxHQUFELElBQVM7QUFDZCxjQUFNNnFDLEtBQUssR0FBRzdxQyxHQUFHLENBQUN3QixLQUFKLENBQVUwbUMsY0FBVixDQUFkO0FBQ0EsZUFBTyxDQUFDLENBQUN3QyxTQUFGLElBQWUsQ0FBQyxDQUFDRyxLQUFqQixJQUNGZCxXQUFXLENBQUNXLFNBQVMsQ0FBQyxDQUFELENBQVYsRUFBZUcsS0FBSyxDQUFDLENBQUQsQ0FBcEIsQ0FEVCxJQUVGRixTQUFTLENBQUNFLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FGUCxJQUdGRCxTQUFTLENBQUNDLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FIZDtBQUlELE9BTkQ7QUFPRCxLQVZELE1BVU87QUFDTDtBQUNBdGpDLFVBQUksR0FBRyxNQUFNLEtBQWI7QUFDRDtBQUNGOztBQUNELFNBQU87QUFBRUE7QUFBRixHQUFQO0FBQ0Q7O0FBRU0sU0FBUzZjLGFBQVQsQ0FBdUJwa0IsR0FBdkIsRUFBNEI7QUFDakMsTUFBSVMsR0FBRyxHQUFHOG5DLE9BQU8sQ0FBQ3ZvQyxHQUFELENBQWpCOztBQUNBLE1BQUlTLEdBQUcsS0FBSzJZLFNBQVosRUFBdUI7QUFDckIsVUFBTWxVLElBQUksR0FBR2lqQyxjQUFjLENBQUNud0IsSUFBZixDQUFvQixDQUFDO0FBQUV6UTtBQUFGLEtBQUQsS0FBY0EsSUFBSSxDQUFDdkgsR0FBRCxDQUF0QyxDQUFiO0FBQ0FTLE9BQUcsR0FBRyxDQUFBeUUsSUFBSSxRQUFKLFlBQUFBLElBQUksQ0FBRVgsTUFBTixLQUFnQlcsSUFBSSxDQUFDdVMsSUFBM0I7QUFDQXF6Qix3QkFBb0IsQ0FBQzlxQyxHQUFELEVBQU1TLEdBQUcsSUFBSSxLQUFiLENBQXBCO0FBQ0Q7O0FBQ0QsU0FBT0EsR0FBUDtBQUNEO0FBRU0sU0FBU3duQyxjQUFULENBQXdCOWhDLElBQXhCLEVBQThCO0FBQ25DaEQsZ0RBQUssQ0FBQzhsQyxLQUFOLENBQVksSUFBWjtBQUNBLFFBQU1QLEtBQUssR0FBR3ZpQyxJQUFJLElBQUksSUFBUixHQUFlN0QsMERBQVMsQ0FBQyxXQUFELENBQXhCLEdBQXdDNkQsSUFBdEQ7O0FBQ0EsTUFBSWYsS0FBSixFQUF1QixFQUhZLENBTW5DOzs7QUFDQStpQyxnQkFBYyxHQUFHLENBQUM3OEIsS0FBSyxDQUFDQyxPQUFOLENBQWNtOUIsS0FBZCxJQUF1QkEsS0FBdkIsR0FBK0IsQ0FBQ0EsS0FBSyxJQUFJLEVBQVYsRUFBYzdnQyxLQUFkLENBQW9CLElBQXBCLENBQWhDLEVBQ2hCZ0MsR0FEZ0IsQ0FDWDROLElBQUQsSUFBVTtBQUNiQSxRQUFJLEdBQUdBLElBQUksQ0FBQ0UsSUFBTCxFQUFQO0FBQ0EsUUFBSSxDQUFDRixJQUFELElBQVNBLElBQUksQ0FBQ2pKLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBYixFQUFtQyxPQUFPLElBQVA7QUFDbkMsVUFBTW9GLElBQUksR0FBRzZELElBQUksQ0FBQ2pKLFVBQUwsQ0FBZ0IsR0FBaEIsS0FBd0JpSixJQUFJLENBQUM1UCxLQUFMLENBQVcsSUFBWCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFyQztBQUNBLFVBQU0zQyxJQUFJLEdBQUcwTyxJQUFJLEdBQUc2RCxJQUFJLENBQUM3UCxLQUFMLENBQVdnTSxJQUFJLENBQUM1UyxNQUFMLEdBQWMsQ0FBekIsRUFBNEIyVyxJQUE1QixFQUFILEdBQXdDRixJQUF6RDtBQUNBLFVBQU1sVCxNQUFNLEdBQUdxUCxJQUFJLEtBQUssVUFBVCxJQUF1QkEsSUFBSSxLQUFLLFFBQS9DLENBTGEsQ0FLNEM7O0FBQ3pELFVBQU07QUFBRXJNO0FBQUYsUUFBV3FNLElBQUksS0FBSyxVQUFULElBQXVCQSxJQUFJLEtBQUssVUFBVCxJQUF1QmsxQixPQUFPLENBQUM1akMsSUFBRCxDQUFyRCxJQUNaLENBQUMwTyxJQUFELElBQVMsQ0FBQzFPLElBQUksQ0FBQy9DLFFBQUwsQ0FBYyxHQUFkLENBQVYsSUFBZ0M2bUMsV0FBVyxDQUFFLE9BQU05akMsSUFBSyxJQUFiLENBRC9CLENBQ2lEO0FBRGpELE9BRVo4akMsV0FBVyxDQUFDOWpDLElBQUQsQ0FGaEIsQ0FOYSxDQVFXOztBQUN4QixXQUFPO0FBQUVYLFlBQUY7QUFBVWdELFVBQVY7QUFBZ0JrUTtBQUFoQixLQUFQO0FBQ0QsR0FYZ0IsRUFZaEJuRyxNQVpnQixDQVlUQyxPQVpTLENBQWpCO0FBYUFnM0IsU0FBTyxHQUFHLEVBQVY7QUFDQUMsYUFBVyxHQUFHLENBQWQ7QUFDQXJsQyxnREFBSyxDQUFDOGxDLEtBQU4sQ0FBWSxLQUFaO0FBQ0Q7O0FBRUQsU0FBUzZCLG9CQUFULENBQThCN2lDLEdBQTlCLEVBQW1DTSxLQUFuQyxFQUEwQztBQUN4Q2dnQyxTQUFPLENBQUN0Z0MsR0FBRCxDQUFQLEdBQWVNLEtBQWY7QUFDQWlnQyxhQUFXLElBQUl2Z0MsR0FBRyxDQUFDakgsTUFBbkI7O0FBQ0EsTUFBSXduQyxXQUFXLEdBQUdGLG1CQUFsQixFQUF1QztBQUNyQy9vQyxVQUFNLENBQUM0SSxJQUFQLENBQVlvZ0MsT0FBWixFQUNDMWpCLElBREQsQ0FDTzliLENBQUQsSUFBTztBQUNYeS9CLGlCQUFXLElBQUl6L0IsQ0FBQyxDQUFDL0gsTUFBakI7QUFDQSxhQUFPdW5DLE9BQU8sQ0FBQ3gvQixDQUFELENBQWQsQ0FGVyxDQUdYOztBQUNBLGFBQU95L0IsV0FBVyxHQUFHRixtQkFBbUIsR0FBRyxDQUF0QixHQUEwQixDQUEvQztBQUNELEtBTkQ7QUFPRDtBQUNGLEM7Ozs7Ozs7Ozs7OztBQzVQRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBL29DLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjQyxpREFBZCxFQUF3QjtBQUN0QjtBQUNBLFFBQU1zckMsV0FBTixDQUFrQnpxQyxFQUFsQixFQUFzQjtBQUNwQixVQUFNMkYsTUFBTSxHQUFHOGEseURBQWEsQ0FBQ3pnQixFQUFELENBQTVCO0FBQ0EsVUFBTTBxQyxPQUFPLEdBQUcsTUFBTUMsaUJBQWlCLENBQUMsQ0FBQ2hsQyxNQUFELENBQUQsQ0FBdkM7QUFDQSxXQUFPK2tDLE9BQU8sQ0FBQyxDQUFELENBQWQ7QUFDRCxHQU5xQjs7QUFPdEI7QUFDQSxRQUFNRSxjQUFOLEdBQXVCO0FBQ3JCMWlDLDhEQUFTLENBQUMsWUFBRCxFQUFlL0YsSUFBSSxDQUFDQyxHQUFMLEVBQWYsQ0FBVDtBQUNBLFVBQU15b0MsUUFBUSxHQUFHL2tDLHNEQUFVLEdBQUdrTCxNQUFiLENBQW9CckIsSUFBSSxJQUFJQSxJQUFJLENBQUN2SCxNQUFMLENBQVlvQyxZQUF4QyxDQUFqQjtBQUNBLFVBQU1rZ0MsT0FBTyxHQUFHLE1BQU1DLGlCQUFpQixDQUFDRSxRQUFELENBQXZDO0FBQ0EsV0FBT0gsT0FBTyxDQUFDN29DLFFBQVIsQ0FBaUIsSUFBakIsQ0FBUDtBQUNEOztBQWJxQixDQUF4Qjs7QUFnQkEsZUFBZThvQyxpQkFBZixDQUFpQzk1QixPQUFqQyxFQUEwQztBQUN4QyxRQUFNaTZCLEtBQUssR0FBRyxFQUFkO0FBQ0EsUUFBTUosT0FBTyxHQUFHLE1BQU0xbUMsT0FBTyxDQUFDd0ssR0FBUixDQUFZcUMsT0FBTyxDQUFDdEgsR0FBUixDQUFZb0csSUFBSSxJQUFJbzdCLFdBQVcsQ0FBQ3A3QixJQUFELEVBQU9tN0IsS0FBUCxDQUEvQixDQUFaLENBQXRCOztBQUNBLE1BQUlBLEtBQUssQ0FBQ3BxQyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCOFQsVUFBTSxDQUFDczJCLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBTjtBQUNELEdBRkQsTUFFTyxJQUFJQSxLQUFLLENBQUNwcUMsTUFBVixFQUFrQjtBQUN2QjhULFVBQU0sQ0FBQztBQUNMO0FBQ0EyQyxVQUFJLEVBQUUyekIsS0FBSyxDQUFDdmhDLEdBQU4sQ0FBVWtqQixDQUFDLElBQUlBLENBQUMsQ0FBQ3RWLElBQWpCLEVBQXVCOUIsSUFBdkIsQ0FBNEIsSUFBNUIsQ0FGRDtBQUdMNmQsYUFBTyxFQUFFMXZCLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQnVuQztBQUhwQixLQUFELENBQU47QUFLRDs7QUFDRCxTQUFPTixPQUFQO0FBQ0Q7O0FBRUQsTUFBTU8sU0FBUyxHQUFHLEVBQWxCLEMsQ0FFQTs7QUFDQSxTQUFTRixXQUFULENBQXFCcGxDLE1BQXJCLEVBQTZCbWxDLEtBQTdCLEVBQW9DO0FBQ2xDLFFBQU07QUFBRTlxQztBQUFGLE1BQVMyRixNQUFNLENBQUN5RSxLQUF0QjtBQUNBLFFBQU13QyxPQUFPLEdBQUdxK0IsU0FBUyxDQUFDanJDLEVBQUQsQ0FBVCxLQUFrQmlyQyxTQUFTLENBQUNqckMsRUFBRCxDQUFULEdBQWdCa3JDLGFBQWEsQ0FBQ3ZsQyxNQUFELEVBQVNtbEMsS0FBVCxDQUEvQyxDQUFoQjtBQUNBLFNBQU9sK0IsT0FBUDtBQUNEOztBQUVELGVBQWVzK0IsYUFBZixDQUE2QnZsQyxNQUE3QixFQUFxQ21sQyxLQUFyQyxFQUE0QztBQUMxQyxRQUFNO0FBQUU5cUM7QUFBRixNQUFTMkYsTUFBTSxDQUFDeUUsS0FBdEI7QUFDQSxNQUFJK2dDLEtBQUo7QUFDQSxNQUFJQyxNQUFKO0FBQ0EsTUFBSUMsWUFBSjs7QUFDQSxNQUFJO0FBQ0YsVUFBTTtBQUFFemxDO0FBQUYsUUFBYSxNQUFNb2IsdURBQVcsQ0FBQztBQUNuQ2hoQixRQURtQztBQUVuQ2lELFVBQUksRUFBRSxNQUFNcW9DLGNBQWMsQ0FBQzNsQyxNQUFELENBRlM7QUFHbkNDLFlBQU0sRUFBRTtBQUFFMmxDLGdCQUFRLEVBQUU7QUFBWjtBQUgyQixLQUFELENBQXBDO0FBS0FKLFNBQUssR0FBR25sQiw0RkFBSSxDQUFDLGtCQUFELEVBQXFCLENBQUNvRCxxR0FBYSxDQUFDeGpCLE1BQUQsQ0FBZCxDQUFyQixDQUFaO0FBQ0F5bEMsZ0JBQVksR0FBRztBQUFFeG9DLFdBQUssRUFBRTtBQUFULEtBQWY7QUFDQSxXQUFPLElBQVA7QUFDRCxHQVRELENBU0UsT0FBTytDLE1BQVAsRUFBZTtBQUNmd2xDLFVBQU0sR0FBR3hsQyxNQUFNLENBQUNzSCxLQUFoQixDQURlLENBRWY7O0FBQ0FtK0IsZ0JBQVksR0FBRyxDQUFDemxDLE1BQU0sQ0FBQ3NILEtBQVIsSUFBaUIsQ0FBQ3RILE1BQU0sQ0FBQzJsQyxRQUF6QixJQUFxQyxFQUFwRDtBQUNBLFFBQUl6bUMsS0FBSixFQUF1QlgsRUFBQTtBQUN4QixHQWRELFNBY1U7QUFDUixRQUFJa25DLFlBQVksSUFBSSxDQUFDdHBDLDZGQUFyQixFQUE2QjtBQUFFO0FBQzdCcXBDLFlBQU0sR0FBRyxNQUFNMWtCLDBEQUFjLENBQUMvZ0IsTUFBRCxFQUFTLElBQVQsRUFBZTBsQyxZQUFmLENBQTdCO0FBQ0EsVUFBSXZtQyxLQUFKLEVBQWlDWCxFQUFBO0FBQ2xDOztBQUNELFFBQUlxbkMsU0FBUyxDQUFDN2xDLE1BQUQsQ0FBVCxLQUFzQndsQyxLQUFLLElBQUlDLE1BQS9CLENBQUosRUFBNEM7QUFDMUNOLFdBQUssQ0FBQzU2QixJQUFOLENBQVc7QUFDVHZLLGNBRFM7QUFFVHdSLFlBQUksRUFBRSxTQUFpQnFRLHdGQUFqQixHQUFDMmpCLEtBQUQsRUFBUUMsTUFBUixHQUEwQixJQUExQjtBQUZHLE9BQVg7QUFJRDs7QUFDRCxXQUFPSCxTQUFTLENBQUNqckMsRUFBRCxDQUFoQjtBQUNEO0FBQ0Y7O0FBRUQsZUFBZXNyQyxjQUFmLENBQThCO0FBQUVsaEMsT0FBSyxFQUFFO0FBQUVwSztBQUFGLEdBQVQ7QUFBaUJ1Z0IsTUFBakI7QUFBdUJyZDtBQUF2QixDQUE5QixFQUErRDtBQUM3RCxRQUFNdW9DLFdBQVcsR0FBR3ZvQyxNQUFNLENBQUN1b0MsV0FBUCxJQUFzQmxyQixJQUFJLENBQUNrckIsV0FBM0IsSUFBMEN2b0MsTUFBTSxDQUFDdWpCLGNBQXJFO0FBQ0EsTUFBSWlsQixTQUFTLEdBQUd4b0MsTUFBTSxDQUFDd29DLFNBQVAsSUFBb0JuckIsSUFBSSxDQUFDbXJCLFNBQXpCLElBQXNDRCxXQUF0RDs7QUFDQSxNQUFJMXBDLDZGQUFNLElBQUkycEMsU0FBZCxFQUF5QjtBQUN2QixRQUFJbnJCLElBQUksQ0FBQ29yQixHQUFULEVBQWM7QUFDWixZQUFNNzVCLElBQUksR0FBRzQ1QixTQUFTLENBQUNua0MsS0FBVixDQUFnQixHQUFoQixDQUFiO0FBQ0Fta0MsZUFBUyxHQUFJLG9CQUFtQm5yQixJQUFJLENBQUNvckIsR0FBSSxJQUFHNzVCLElBQUksQ0FBQ0EsSUFBSSxDQUFDcFIsTUFBTCxHQUFjLENBQWYsQ0FBa0IsRUFBbEU7QUFDRCxLQUhELE1BR087QUFDTGdyQyxlQUFTLEdBQUcsSUFBWjtBQUNELEtBTnNCLENBT3ZCOztBQUNEOztBQUNELE1BQUksQ0FBQ0EsU0FBTCxFQUFnQixNQUFNLEtBQU47QUFDaEIsTUFBSUUsWUFBSjtBQUNBLFFBQU1obUMsTUFBTSxHQUFHLEVBQWY7QUFDQSxRQUFNc2dCLE1BQU0sR0FBRztBQUFFdGdCLFVBQUY7QUFBVXhDLFNBQUssRUFBRTtBQUFFcEQ7QUFBRjtBQUFqQixHQUFmO0FBQ0E2ckMsVUFBUSxDQUFDN2xCLDRGQUFJLENBQUMsc0JBQUQsQ0FBTCxDQUFSOztBQUNBLE1BQUk7QUFDRixVQUFNO0FBQUUxbUI7QUFBRixRQUFXLE1BQU1xRCwrRkFBTyxDQUFDK29DLFNBQUQsRUFBWTtBQUN4QztBQUNBN29DLFdBQUssRUFBRSxVQUZpQztBQUd4Q0MsYUFBTyxFQUFFO0FBQUVDLGNBQU0sRUFBRTtBQUFWO0FBSCtCLEtBQVosQ0FBOUI7QUFLQSxVQUFNO0FBQUVzRTtBQUFGLFFBQWMwWix5REFBUyxDQUFDemhCLElBQUQsQ0FBN0I7O0FBQ0EsUUFBSXlDLDZGQUFKLEVBQVk7QUFDVixVQUFJd2UsSUFBSSxDQUFDbFosT0FBTCxLQUFpQkEsT0FBckIsRUFBOEIsTUFBTSxLQUFOO0FBQzlCbEQsYUFBTyxDQUFDQyxJQUFSLENBQWEsUUFBYixFQUF1Qm1jLElBQUksQ0FBQ3paLElBQTVCLEVBQWtDTyxPQUFsQyxFQUEyQ3ViLHNHQUFjLENBQUNyQyxJQUFJLENBQUNsWixPQUFOLEVBQWVBLE9BQWYsQ0FBekQ7QUFDQSxhQUFPL0gsSUFBUDtBQUNEOztBQUNELFFBQUlzakIsc0dBQWMsQ0FBQ3JDLElBQUksQ0FBQ2xaLE9BQU4sRUFBZUEsT0FBZixDQUFkLElBQXlDLENBQTdDLEVBQWdEO0FBQzlDd2tDLGNBQVEsQ0FBQzdsQiw0RkFBSSxDQUFDLGFBQUQsQ0FBTCxFQUFzQjtBQUFFdWxCLGdCQUFRLEVBQUU7QUFBWixPQUF0QixDQUFSO0FBQ0QsS0FGRCxNQUVPLElBQUksQ0FBQ0UsV0FBTCxFQUFrQjtBQUN2QkksY0FBUSxDQUFDN2xCLDRGQUFJLENBQUMsZUFBRCxDQUFMLEVBQXdCO0FBQUV1bEIsZ0JBQVEsRUFBRTtBQUFaLE9BQXhCLENBQVI7QUFDRCxLQUZNLE1BRUE7QUFDTE0sY0FBUSxDQUFDN2xCLDRGQUFJLENBQUMsYUFBRCxDQUFMLENBQVI7QUFDQTRsQixrQkFBWSxHQUFHNWxCLDRGQUFJLENBQUMsd0JBQUQsQ0FBbkI7QUFDQSxhQUFPLENBQUMsTUFBTXJqQiwrRkFBTyxDQUFDOG9DLFdBQUQsRUFBYztBQUFFNW9DLGFBQUssRUFBRTtBQUFULE9BQWQsQ0FBZCxFQUFvRHZELElBQTNEO0FBQ0Q7QUFDRixHQXJCRCxDQXFCRSxPQUFPNE4sS0FBUCxFQUFjO0FBQ2QsUUFBSXBJLEtBQUosRUFBdUJYLEVBQUE7QUFDdkIwbkMsWUFBUSxDQUFDRCxZQUFZLElBQUk1bEIsNEZBQUksQ0FBQyw0QkFBRCxDQUFyQixFQUFxRDtBQUFFOVk7QUFBRixLQUFyRCxDQUFSO0FBQ0Q7O0FBQ0QsUUFBTXRILE1BQU47O0FBQ0EsV0FBU2ltQyxRQUFULENBQWtCMWxCLE9BQWxCLEVBQTJCO0FBQUVqWixTQUFGO0FBQVNxK0IsWUFBUSxHQUFHLENBQUNyK0I7QUFBckIsTUFBK0IsRUFBMUQsRUFBOEQ7QUFDNURqTyxVQUFNLENBQUNDLE1BQVAsQ0FBYzBHLE1BQWQsRUFBc0I7QUFDcEJ1Z0IsYUFEb0I7QUFFcEJvbEIsY0FGb0I7QUFHcEJyK0IsV0FBSyxFQUFFQSxLQUFLLEdBQUksR0FBRThZLDRGQUFJLENBQUMsY0FBRCxDQUFpQixJQUFHOVksS0FBSyxDQUFDOEYsTUFBTyxLQUFJOUYsS0FBSyxDQUFDeE4sR0FBSSxFQUF6RCxHQUE2RCxJQUhyRCxDQUlwQjs7QUFKb0IsS0FBdEI7QUFNQVYsbUdBQU8sQ0FBQ2luQix3R0FBRCxFQUFvQkMsTUFBcEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3NsQixTQUFULENBQW1CN2xDLE1BQW5CLEVBQTJCO0FBQUE7O0FBQ3pCLFFBQU1tbUMsT0FBTyxHQUFHOXBDLDBEQUFTLENBQUMsZUFBRCxDQUF6QjtBQUNBLFNBQU9BLDBEQUFTLENBQUMscUJBQUQsQ0FBVCxHQUNIOHBDLE9BREcsNEJBRUhubUMsTUFBTSxDQUFDeUMsTUFBUCxDQUFjMmpDLGFBRlgsb0NBRTRCRCxPQUZuQztBQUdEOztBQUVELFNBQVN0M0IsTUFBVCxDQUFnQjtBQUNkN08sUUFEYztBQUVkd1IsTUFGYztBQUdkK2IsU0FBTyxHQUFHLE1BQU0vekIsaURBQVEsQ0FBQ3lxQixVQUFULENBQW9CamtCLE1BQU0sQ0FBQ3lFLEtBQVAsQ0FBYXBLLEVBQWpDO0FBSEYsQ0FBaEIsRUFJRztBQUNEYixtREFBUSxDQUFDNHpCLFlBQVQsQ0FBc0I7QUFDcEI1YixRQURvQjtBQUVwQjtBQUNBMUMsU0FBSyxFQUFFN1EsVUFBVSxHQUFJLEdBQUVvaUIsNEZBQUksQ0FBQyxvQkFBRCxDQUF1QixNQUFLQSw0RkFBSSxDQUFDLFNBQUQsQ0FBWSxFQUF0RCxHQUEwRDtBQUh2RCxHQUF0QixFQUlHbE4sU0FKSCxFQUljO0FBQ1pvYTtBQURZLEdBSmQ7QUFPRCxDOzs7Ozs7Ozs7Ozs7QUMxSkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1KLE9BQU8sR0FBRyxFQUFoQixDLENBQW9COztBQUNwQixJQUFJandCLEtBQUssR0FBRyxFQUFaLEMsQ0FBZ0I7O0FBQ2hCLElBQUltcEMsZUFBSjtBQUVBL3NDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjQyxpREFBZCxFQUF3QjtBQUN0QjtBQUNBLFFBQU04c0MsYUFBTixDQUFvQmpzQyxFQUFwQixFQUF3QjtBQUN0QixVQUFNa3NDLE1BQU0sR0FBRyxNQUFNL29CLCtEQUFtQixDQUFDLENBQUNuakIsRUFBRCxDQUFELENBQXhDO0FBQ0EsV0FBT2tzQyxNQUFNLENBQUNsc0MsRUFBRCxDQUFOLElBQWMsRUFBckI7QUFDRCxHQUxxQjs7QUFNdEI7O0FBRUEsUUFBTW1zQyxjQUFOLENBQXFCN3NDLElBQXJCLEVBQTJCO0FBQ3pCO0FBQ0EsVUFBTTRzQyxNQUFNLEdBQUc1c0MsSUFBSSxDQUFDb1EsTUFBTCxDQUFZLENBQUN2UCxHQUFELEVBQU07QUFBRWlELFdBQUY7QUFBU2ljO0FBQVQsS0FBTixLQUEyQjtBQUFBOztBQUNwRCxZQUFNcmYsRUFBRSxHQUFHb0QsS0FBSyxDQUFDcEQsRUFBTixtQkFBWThmLHFEQUFTLENBQUMxYyxLQUFELENBQXJCLHFCQUFZLFdBQWtCZ0gsS0FBbEIsQ0FBd0JwSyxFQUFwQyxDQUFYO0FBQ0EsVUFBSUEsRUFBSixFQUFRRyxHQUFHLENBQUNILEVBQUQsQ0FBSCxHQUFVcWYsS0FBVjtBQUNSLGFBQU9sZixHQUFQO0FBQ0QsS0FKYyxFQUlaLEVBSlksQ0FBZjtBQUtBLFVBQU02RCxPQUFPLENBQUN3SyxHQUFSLENBQVksQ0FDaEI0VSwyREFBZSxDQUFDOG9CLE1BQUQsQ0FEQyxFQUVoQkUsb0JBQW9CLENBQUNDLGtCQUFrQixDQUFDSCxNQUFELENBQW5CLENBRkosQ0FBWixDQUFOO0FBSUQsR0FuQnFCOztBQW9CdEI7QUFDQUksYUFBVyxDQUFDO0FBQUV0c0MsTUFBRjtBQUFNMkgsT0FBTjtBQUFXTSxTQUFLLEdBQUc7QUFBbkIsR0FBRCxFQUE0QnJJLEdBQTVCLEVBQWlDO0FBQzFDMFEsNEdBQVMsQ0FBQ3pOLEtBQUQsRUFBUSxDQUFDN0MsRUFBRCxFQUFLMkgsR0FBTCxFQUFVLE1BQVYsQ0FBUixFQUEyQk0sS0FBM0IsQ0FBVDtBQUNBcUksNEdBQVMsQ0FBQ3pOLEtBQUQsRUFBUSxDQUFDN0MsRUFBRCxFQUFLMkgsR0FBTCxFQUFVL0gsR0FBRyxDQUFDRSxHQUFKLENBQVFFLEVBQWxCLEVBQXNCSixHQUFHLENBQUNDLE9BQTFCLENBQVIsRUFBNENvSSxLQUE1QyxDQUFUO0FBQ0Fza0MsZUFBVztBQUNaOztBQXpCcUIsQ0FBeEI7QUE0QkEvb0MsT0FBTyxDQUFDd08sSUFBUixDQUFhNFosU0FBYixDQUF1QmpvQixXQUF2QixDQUFtQzFELGdCQUFuQztBQUNBdUQsT0FBTyxDQUFDd08sSUFBUixDQUFhdzZCLFVBQWIsQ0FBd0I3b0MsV0FBeEIsQ0FBb0MsQ0FBQzhvQyxPQUFELEVBQVVDLFNBQVYsS0FBd0J6c0MsZ0JBQWdCLENBQUN5c0MsU0FBRCxDQUE1RTtBQUVPLFNBQVN6c0MsZ0JBQVQsQ0FBMEJGLEtBQTFCLEVBQWlDO0FBQ3RDLFdBQVN5SSxtR0FBVCxFQUFBc3FCLE9BQU8sRUFBZSxDQUFDLENBQUM5eUIsRUFBRCxFQUFLMnNDLFVBQUwsQ0FBRCxLQUFzQjtBQUMxQyxRQUFJNXNDLEtBQUssSUFBSTRzQyxVQUFiLEVBQXlCO0FBQ3ZCLGFBQU9BLFVBQVUsQ0FBQzVzQyxLQUFELENBQWpCO0FBQ0EsVUFBSTQrQiwrRkFBTyxDQUFDZ08sVUFBRCxDQUFYLEVBQXlCLE9BQU83WixPQUFPLENBQUM5eUIsRUFBRCxDQUFkO0FBQzFCO0FBQ0YsR0FMTSxDQUFQO0FBTUQ7QUFFTSxTQUFTYSxjQUFULENBQXdCZCxLQUF4QixFQUErQkYsT0FBL0IsRUFBd0Mrc0MsU0FBeEMsRUFBbUQ7QUFDeERBLFdBQVMsQ0FBQzFoQyxPQUFWLENBQW1CbEwsRUFBRCxJQUFRO0FBQ3hCc1EsNEdBQVMsQ0FBQ3dpQixPQUFELEVBQVUsQ0FBQzl5QixFQUFELEVBQUtELEtBQUwsRUFBWUYsT0FBWixDQUFWLEVBQWdDLENBQWhDLENBQVQ7QUFDRCxHQUZEO0FBR0Q7O0FBRUQsZUFBZTBzQyxXQUFmLEdBQTZCO0FBQzNCLFNBQU8sQ0FBQ1AsZUFBUixFQUF5QjtBQUN2QkEsbUJBQWUsR0FBRyxJQUFsQjtBQUNBLFVBQU0sQ0FBTjtBQUNBLFVBQU1hLFlBQVksR0FBR2hxQyxLQUFyQjtBQUNBQSxTQUFLLEdBQUcsRUFBUjtBQUNBLFVBQU1pcUMsUUFBUSxDQUFDRCxZQUFELENBQWQ7QUFDQWIsbUJBQWUsR0FBRyxLQUFsQjtBQUNBLFFBQUlyTiwrRkFBTyxDQUFDOTdCLEtBQUQsQ0FBWCxFQUFvQjtBQUNyQjtBQUNGOztBQUVELGVBQWVpcUMsUUFBZixDQUF3QkQsWUFBeEIsRUFBc0M7QUFDcEMsUUFBTXh0QyxHQUFHLEdBQUdKLE1BQU0sQ0FBQzRJLElBQVAsQ0FBWWdsQyxZQUFaLENBQVo7QUFDQSxRQUFNRSxXQUFXLEdBQUcsTUFBTTVwQiwrREFBbUIsQ0FBQzlqQixHQUFELENBQTdDO0FBQ0FBLEtBQUcsQ0FBQzZMLE9BQUosQ0FBYWxMLEVBQUQsSUFBUTtBQUNsQixhQUFrQndJLG1HQUFsQixFQUFBcWtDLFlBQVksQ0FBQzdzQyxFQUFELENBQVosRUFBK0IsQ0FBQyxDQUFDMkgsR0FBRCxFQUFNO0FBQUV5NEI7QUFBRixLQUFOLENBQUQsS0FBcUI7QUFDbEQ5dkIsOEdBQVMsQ0FBQ3k4QixXQUFELEVBQWMsQ0FBQy9zQyxFQUFELEVBQUsySCxHQUFMLENBQWQsRUFBeUJ5NEIsSUFBSSxJQUFJdG5CLFNBQWpDLENBQVQ7QUFDRCxLQUZEO0FBR0QsR0FKRDtBQUtBLFFBQU05VSxPQUFPLENBQUN3SyxHQUFSLENBQVksQ0FDaEI0VSwyREFBZSxDQUFDMnBCLFdBQUQsQ0FEQyxFQUVoQlgsb0JBQW9CLENBQUNZLGlCQUFpQixDQUFDSCxZQUFELENBQWxCLEVBQWtDO0FBQUVJLFdBQU8sRUFBRTtBQUFYLEdBQWxDLENBRkosQ0FBWixDQUFOO0FBSUQ7O0FBRUQsZUFBZWIsb0JBQWYsQ0FBb0NjLFlBQXBDLEVBQWtEO0FBQUVEO0FBQUYsSUFBYyxFQUFoRSxFQUFvRTtBQUNsRSxRQUFNRSxLQUFLLEdBQUcsRUFBZDs7QUFDQSxPQUFLLE1BQU0sQ0FBQ3B0QyxLQUFELEVBQVFxdEMsTUFBUixDQUFYLElBQThCbnVDLE1BQU0sQ0FBQ21VLE9BQVAsQ0FBZTg1QixZQUFmLENBQTlCLEVBQTREO0FBQzFELFNBQUssTUFBTSxDQUFDcnRDLE9BQUQsRUFBVXd0QyxTQUFWLENBQVgsSUFBbUNwdUMsTUFBTSxDQUFDbVUsT0FBUCxDQUFlZzZCLE1BQWYsQ0FBbkMsRUFBMkQ7QUFDekQsVUFBSSxDQUFDek8sK0ZBQU8sQ0FBQzBPLFNBQUQsQ0FBWixFQUF5QjtBQUN2QixZQUFJSixPQUFKLEVBQWFJLFNBQVMsQ0FBQ0osT0FBVixHQUFvQixJQUFwQjtBQUNiRSxhQUFLLENBQUNqOUIsSUFBTixDQUFXb2pCLGtHQUFVLENBQUMsQ0FBQ3Z6QixLQUFGLEVBQVMsZUFBVCxFQUEwQnN0QyxTQUExQixFQUFxQztBQUFFeHRDLGlCQUFPLEVBQUUsQ0FBQ0E7QUFBWixTQUFyQyxDQUFyQjtBQUNBLFlBQUlzdEMsS0FBSyxDQUFDenNDLE1BQU4sS0FBaUIsRUFBckIsRUFBeUIsTUFBTXNELE9BQU8sQ0FBQ3dLLEdBQVIsQ0FBWTIrQixLQUFLLENBQUN4c0IsTUFBTixDQUFhLENBQWIsQ0FBWixDQUFOLENBSEYsQ0FHc0M7QUFDOUQ7QUFDRjtBQUNGOztBQUNELFFBQU0zYyxPQUFPLENBQUN3SyxHQUFSLENBQVkyK0IsS0FBWixDQUFOO0FBQ0QsQyxDQUVEOzs7QUFDQSxTQUFTSCxpQkFBVCxDQUEyQk0sU0FBM0IsRUFBc0M7QUFDcEMsUUFBTUMsTUFBTSxHQUFHLEVBQWY7QUFDQSxXQUFXL2tDLG1HQUFYLEVBQUE4a0MsU0FBUyxFQUFlLENBQUMsQ0FBQ3R0QyxFQUFELEVBQUt3dEMsVUFBTCxDQUFELEtBQXNCO0FBQzVDLFVBQU1DLFdBQVcsR0FBR3h1QyxNQUFNLENBQUNtVSxPQUFQLENBQWVvNkIsVUFBZixDQUFwQjtBQUNBLGFBQWFobEMsbUdBQWIsRUFBQXNxQixPQUFPLENBQUM5eUIsRUFBRCxDQUFQLEVBQTBCLENBQUMsQ0FBQ0QsS0FBRCxFQUFRcXRDLE1BQVIsQ0FBRCxLQUFxQjtBQUM3QyxlQUFRcmtCLGlHQUFSLEVBQUFxa0IsTUFBTSxFQUFjdnRDLE9BQUQsSUFBYTtBQUM5QjR0QyxtQkFBVyxDQUFDdmlDLE9BQVosQ0FBb0IsQ0FBQyxDQUFDdkQsR0FBRCxFQUFNK2xDLE9BQU4sQ0FBRCxLQUFvQjtBQUFBOztBQUN0QztBQUNBLGNBQUlBLE9BQU8sQ0FBQ3ROLElBQVIsd0JBQWlCc04sT0FBTyxDQUFDM3RDLEtBQUQsQ0FBeEIscUJBQWlCLGVBQWlCRixPQUFqQixDQUFqQixDQUFKLEVBQWdEO0FBQzlDeVEsb0hBQVMsQ0FBQ2k5QixNQUFELEVBQVMsQ0FBQ3h0QyxLQUFELEVBQVFGLE9BQVIsRUFBaUJHLEVBQWpCLEVBQXFCMkgsR0FBckIsQ0FBVCxFQUFvQytsQyxPQUFPLENBQUN0TixJQUE1QyxDQUFUO0FBQ0Q7QUFDRixTQUxEO0FBTUQsT0FQSyxDQUFOO0FBUUQsS0FURDtBQVVELEdBWlEsQ0FBVDtBQWFBLFNBQU9tTixNQUFQO0FBQ0QsQyxDQUVEOzs7QUFDQSxTQUFTbEIsa0JBQVQsQ0FBNEJILE1BQTVCLEVBQW9DO0FBQ2xDLFFBQU1xQixNQUFNLEdBQUcsRUFBZjtBQUNBLFdBQVEva0MsbUdBQVIsRUFBQTBqQyxNQUFNLEVBQWUsQ0FBQyxDQUFDbHNDLEVBQUQsRUFBS3FmLEtBQUwsQ0FBRCxLQUFpQjtBQUNwQyxhQUFhN1csbUdBQWIsRUFBQXNxQixPQUFPLENBQUM5eUIsRUFBRCxDQUFQLEVBQTBCLENBQUMsQ0FBQ0QsS0FBRCxFQUFRcXRDLE1BQVIsQ0FBRCxLQUFxQjtBQUM3QyxlQUFRcmtCLGlHQUFSLEVBQUFxa0IsTUFBTSxFQUFhdnRDLE9BQU8sSUFBSTtBQUM1QnlRLGdIQUFTLENBQUNpOUIsTUFBRCxFQUFTLENBQUN4dEMsS0FBRCxFQUFRRixPQUFSLEVBQWlCRyxFQUFqQixDQUFULEVBQStCcWYsS0FBL0IsQ0FBVDtBQUNELE9BRkssQ0FBTjtBQUdELEtBSkQ7QUFLRCxHQU5LLENBQU47QUFPQSxTQUFPa3VCLE1BQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7QUM3SEQ7QUFBQTtBQUFlLE1BQU03bkMsWUFBTixDQUFtQjtBQUNoQzRGLGFBQVcsQ0FBQ3dnQyxPQUFELEVBQVU7QUFDbkIsU0FBS3IvQixNQUFMLEdBQWMsRUFBZDtBQUNBLFNBQUtxL0IsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7O0FBRUQ2QixXQUFTLENBQUNwZ0MsSUFBRCxFQUFPO0FBQ2QsUUFBSSxLQUFLdStCLE9BQUwsSUFBZ0IsQ0FBQyxLQUFLQSxPQUFMLENBQWFqcUMsUUFBYixDQUFzQjBMLElBQXRCLENBQXJCLEVBQWtEO0FBQ2hELFlBQU0sSUFBSXJKLEtBQUosQ0FBVyx1QkFBc0JxSixJQUFLLEVBQXRDLENBQU47QUFDRDtBQUNGOztBQUVEK2IsSUFBRSxDQUFDL2IsSUFBRCxFQUFPcWdDLE1BQVAsRUFBZTtBQUNmLFNBQUtELFNBQUwsQ0FBZXBnQyxJQUFmO0FBQ0EsVUFBTTtBQUFFZDtBQUFGLFFBQWEsSUFBbkI7QUFDQSxRQUFJKzRCLFFBQVEsR0FBRy80QixNQUFNLENBQUNjLElBQUQsQ0FBckI7O0FBQ0EsUUFBSSxDQUFDaTRCLFFBQUwsRUFBZTtBQUNiQSxjQUFRLEdBQUcsRUFBWDtBQUNBLzRCLFlBQU0sQ0FBQ2MsSUFBRCxDQUFOLEdBQWVpNEIsUUFBZjtBQUNEOztBQUNELFdBQU8sTUFBTSxLQUFLamMsR0FBTCxDQUFTaGMsSUFBVCxFQUFlcWdDLE1BQWYsQ0FBYjtBQUNEOztBQUVEcmtCLEtBQUcsQ0FBQ2hjLElBQUQsRUFBT3FnQyxNQUFQLEVBQWU7QUFDaEIsU0FBS0QsU0FBTCxDQUFlcGdDLElBQWY7QUFDQSxVQUFNaTRCLFFBQVEsR0FBRyxLQUFLLzRCLE1BQUwsQ0FBWWMsSUFBWixDQUFqQjs7QUFDQSxRQUFJaTRCLFFBQUosRUFBYztBQUNaLFlBQU1yK0IsQ0FBQyxHQUFHcStCLFFBQVEsQ0FBQ3ArQixPQUFULENBQWlCd21DLE1BQWpCLENBQVY7QUFDQSxVQUFJem1DLENBQUMsSUFBSSxDQUFULEVBQVlxK0IsUUFBUSxDQUFDN2tCLE1BQVQsQ0FBZ0J4WixDQUFoQixFQUFtQixDQUFuQjtBQUNiO0FBQ0Y7O0FBRUR5ZixNQUFJLENBQUNyWixJQUFELEVBQU9qTyxJQUFQLEVBQWE7QUFDZixTQUFLcXVDLFNBQUwsQ0FBZXBnQyxJQUFmO0FBQ0EsVUFBTWk0QixRQUFRLEdBQUcsS0FBSy80QixNQUFMLENBQVljLElBQVosQ0FBakI7O0FBQ0EsUUFBSWk0QixRQUFKLEVBQWM7QUFDWixZQUFNaEssR0FBRyxHQUFHO0FBQ1ZqdUIsWUFEVTtBQUVWak8sWUFGVTtBQUdWdXVDLHdCQUFnQixFQUFFLEtBSFI7O0FBSVYxdUIsc0JBQWMsR0FBRztBQUNmcWMsYUFBRyxDQUFDcVMsZ0JBQUosR0FBdUIsSUFBdkI7QUFDRDs7QUFOUyxPQUFaO0FBUUFySSxjQUFRLENBQUNqaEIsSUFBVCxDQUFlcXBCLE1BQUQsSUFBWTtBQUN4QkEsY0FBTSxDQUFDcFMsR0FBRCxDQUFOO0FBQ0EsZUFBT0EsR0FBRyxDQUFDcVMsZ0JBQVg7QUFDRCxPQUhEO0FBSUQ7QUFDRjs7QUFqRCtCLEM7Ozs7Ozs7Ozs7OztBQ0FsQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0NBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MsT0FBVCxHQUFtQixDQUFFOztBQUU1QixTQUFTQyxZQUFULENBQXNCcG1DLEdBQXRCLEVBQTJCO0FBQ3pCLFNBQU8sQ0FBQyxHQUFHOUQsSUFBSixLQUFhbXFDLDRDQUFLLElBQUlBLDRDQUFLLENBQUNybUMsR0FBRCxDQUFMLENBQVcsR0FBRzlELElBQWQsQ0FBN0I7QUFDRDs7QUFFTSxTQUFTb3FDLE9BQVQsR0FBbUI7QUFDeEIsU0FBTyxDQUFDLENBQUNELDRDQUFUO0FBQ0Q7QUFFTSxNQUFNRSxTQUFTLEdBQUdILFlBQVksQ0FBQyxXQUFELENBQTlCO0FBQ0EsTUFBTUksWUFBWSxHQUFHSixZQUFZLENBQUMsY0FBRCxDQUFqQztBQUNBLE1BQU1LLGVBQWUsR0FBR0wsWUFBWSxDQUFDLGlCQUFELENBQXBDLEMiLCJmaWxlIjoiYmFja2dyb3VuZC9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xuIFx0ZnVuY3Rpb24gd2VicGFja0pzb25wQ2FsbGJhY2soZGF0YSkge1xuIFx0XHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuIFx0XHR2YXIgbW9yZU1vZHVsZXMgPSBkYXRhWzFdO1xuIFx0XHR2YXIgZXhlY3V0ZU1vZHVsZXMgPSBkYXRhWzJdO1xuXG4gXHRcdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuIFx0XHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcbiBcdFx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMCwgcmVzb2x2ZXMgPSBbXTtcbiBcdFx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRyZXNvbHZlcy5wdXNoKGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSk7XG4gXHRcdFx0fVxuIFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG4gXHRcdH1cbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZihwYXJlbnRKc29ucEZ1bmN0aW9uKSBwYXJlbnRKc29ucEZ1bmN0aW9uKGRhdGEpO1xuXG4gXHRcdHdoaWxlKHJlc29sdmVzLmxlbmd0aCkge1xuIFx0XHRcdHJlc29sdmVzLnNoaWZ0KCkoKTtcbiBcdFx0fVxuXG4gXHRcdC8vIGFkZCBlbnRyeSBtb2R1bGVzIGZyb20gbG9hZGVkIGNodW5rIHRvIGRlZmVycmVkIGxpc3RcbiBcdFx0ZGVmZXJyZWRNb2R1bGVzLnB1c2guYXBwbHkoZGVmZXJyZWRNb2R1bGVzLCBleGVjdXRlTW9kdWxlcyB8fCBbXSk7XG5cbiBcdFx0Ly8gcnVuIGRlZmVycmVkIG1vZHVsZXMgd2hlbiBhbGwgY2h1bmtzIHJlYWR5XG4gXHRcdHJldHVybiBjaGVja0RlZmVycmVkTW9kdWxlcygpO1xuIFx0fTtcbiBcdGZ1bmN0aW9uIGNoZWNrRGVmZXJyZWRNb2R1bGVzKCkge1xuIFx0XHR2YXIgcmVzdWx0O1xuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVmZXJyZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0dmFyIGRlZmVycmVkTW9kdWxlID0gZGVmZXJyZWRNb2R1bGVzW2ldO1xuIFx0XHRcdHZhciBmdWxmaWxsZWQgPSB0cnVlO1xuIFx0XHRcdGZvcih2YXIgaiA9IDE7IGogPCBkZWZlcnJlZE1vZHVsZS5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0dmFyIGRlcElkID0gZGVmZXJyZWRNb2R1bGVbal07XG4gXHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbZGVwSWRdICE9PSAwKSBmdWxmaWxsZWQgPSBmYWxzZTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYoZnVsZmlsbGVkKSB7XG4gXHRcdFx0XHRkZWZlcnJlZE1vZHVsZXMuc3BsaWNlKGktLSwgMSk7XG4gXHRcdFx0XHRyZXN1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IGRlZmVycmVkTW9kdWxlWzBdKTtcbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHRyZXR1cm4gcmVzdWx0O1xuIFx0fVxuXG4gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuIFx0Ly8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4gXHQvLyBQcm9taXNlID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxuIFx0dmFyIGluc3RhbGxlZENodW5rcyA9IHtcbiBcdFx0XCJiYWNrZ3JvdW5kL2luZGV4XCI6IDBcbiBcdH07XG5cbiBcdHZhciBkZWZlcnJlZE1vZHVsZXMgPSBbXTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0dmFyIGpzb25wQXJyYXkgPSB3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBcIl0gPSB3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBcIl0gfHwgW107XG4gXHR2YXIgb2xkSnNvbnBGdW5jdGlvbiA9IGpzb25wQXJyYXkucHVzaC5iaW5kKGpzb25wQXJyYXkpO1xuIFx0anNvbnBBcnJheS5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2s7XG4gXHRqc29ucEFycmF5ID0ganNvbnBBcnJheS5zbGljZSgpO1xuIFx0Zm9yKHZhciBpID0gMDsgaSA8IGpzb25wQXJyYXkubGVuZ3RoOyBpKyspIHdlYnBhY2tKc29ucENhbGxiYWNrKGpzb25wQXJyYXlbaV0pO1xuIFx0dmFyIHBhcmVudEpzb25wRnVuY3Rpb24gPSBvbGRKc29ucEZ1bmN0aW9uO1xuXG5cbiBcdC8vIGFkZCBlbnRyeSBtb2R1bGUgdG8gZGVmZXJyZWQgbGlzdFxuIFx0ZGVmZXJyZWRNb2R1bGVzLnB1c2goW1wiLi9zcmMvYmFja2dyb3VuZC9pbmRleC5qc1wiLFwicHVibGljL2xpYi90bGRqc1wiLFwiY29tbW9uXCJdKTtcbiBcdC8vIHJ1biBkZWZlcnJlZCBtb2R1bGVzIHdoZW4gcmVhZHlcbiBcdHJldHVybiBjaGVja0RlZmVycmVkTW9kdWxlcygpO1xuIiwiY29uc3QgcmVzb2x2ZVVSTCA9IHJlcXVpcmUoJ3Jlc29sdmUtdXJsJyk7XG5jb25zdCB7IGRldkRlcGVuZGVuY2llcyB9ID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbi8qXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcmVQYXRoOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xuICAgID8gcmVzb2x2ZVVSTCgnL25vZGVfbW9kdWxlcy9AZmZtcGVnL2NvcmUvZGlzdC9mZm1wZWctY29yZS5qcycpXG4gICAgOiBgaHR0cHM6Ly91bnBrZy5jb20vQGZmbXBlZy9jb3JlQCR7ZGV2RGVwZW5kZW5jaWVzWydAZmZtcGVnL2NvcmUnXS5zdWJzdHJpbmcoMSl9L2Rpc3QvZmZtcGVnLWNvcmUuanNgLFxufTtcbiIsImNvbnN0IHJlc29sdmVVUkwgPSByZXF1aXJlKCdyZXNvbHZlLXVybCcpO1xuXG5jb25zdCByZWFkRnJvbUJsb2JPckZpbGUgPSAoYmxvYikgPT4gKFxuICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKGZpbGVSZWFkZXIucmVzdWx0KTtcbiAgICB9O1xuICAgIGZpbGVSZWFkZXIub25lcnJvciA9ICh7IHRhcmdldDogeyBlcnJvcjogeyBjb2RlIH0gfSB9KSA9PiB7XG4gICAgICByZWplY3QoRXJyb3IoYEZpbGUgY291bGQgbm90IGJlIHJlYWQhIENvZGU9JHtjb2RlfWApKTtcbiAgICB9O1xuICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gIH0pXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIChfZGF0YSkgPT4ge1xuICBsZXQgZGF0YSA9IF9kYXRhO1xuICBpZiAodHlwZW9mIF9kYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBfZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvKiBGcm9tIGJhc2U2NCBmb3JtYXQgKi9cbiAgICBpZiAoL2RhdGE6X2RhdGFcXC8oW2EtekEtWl0qKTtiYXNlNjQsKFteXCJdKikvLnRlc3QoX2RhdGEpKSB7XG4gICAgICBkYXRhID0gYXRvYihfZGF0YS5zcGxpdCgnLCcpWzFdKVxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAoKGMpID0+IGMuY2hhckNvZGVBdCgwKSk7XG4gICAgLyogRnJvbSByZW1vdGUgc2VydmVyL1VSTCAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChyZXNvbHZlVVJMKF9kYXRhKSk7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgfVxuICAvKiBGcm9tIEJsb2Igb3IgRmlsZSAqL1xuICB9IGVsc2UgaWYgKF9kYXRhIGluc3RhbmNlb2YgRmlsZSB8fCBfZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICBkYXRhID0gYXdhaXQgcmVhZEZyb21CbG9iT3JGaWxlKF9kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuY29uc3QgcmVzb2x2ZVVSTCA9IHJlcXVpcmUoJ3Jlc29sdmUtdXJsJyk7XG5jb25zdCB7IGxvZyB9ID0gcmVxdWlyZSgnLi4vdXRpbHMvbG9nJyk7XG5cbi8qXG4gKiBGZXRjaCBkYXRhIGZyb20gcmVtb3RlIFVSTCBhbmQgY29udmVydCB0byBibG9iIFVSTFxuICogdG8gYXZvaWQgQ09SUyBpc3N1ZVxuICovXG5jb25zdCB0b0Jsb2JVUkwgPSBhc3luYyAodXJsLCBtaW1lVHlwZSkgPT4ge1xuICBsb2coJ2luZm8nLCBgZmV0Y2ggJHt1cmx9YCk7XG4gIGNvbnN0IGJ1ZiA9IGF3YWl0IChhd2FpdCBmZXRjaCh1cmwpKS5hcnJheUJ1ZmZlcigpO1xuICBsb2coJ2luZm8nLCBgJHt1cmx9IGZpbGUgc2l6ZSA9ICR7YnVmLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmXSwgeyB0eXBlOiBtaW1lVHlwZSB9KTtcbiAgY29uc3QgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIGxvZygnaW5mbycsIGAke3VybH0gYmxvYiBVUkwgPSAke2Jsb2JVUkx9YCk7XG4gIHJldHVybiBibG9iVVJMO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyAoeyBjb3JlUGF0aDogX2NvcmVQYXRoIH0pID0+IHtcbiAgaWYgKHR5cGVvZiBfY29yZVBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2NvcmVQYXRoIHNob3VsZCBiZSBhIHN0cmluZyEnKTtcbiAgfVxuICBjb25zdCBjb3JlUmVtb3RlUGF0aCA9IHJlc29sdmVVUkwoX2NvcmVQYXRoKTtcbiAgY29uc3QgY29yZVBhdGggPSBhd2FpdCB0b0Jsb2JVUkwoXG4gICAgY29yZVJlbW90ZVBhdGgsXG4gICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICApO1xuICBjb25zdCB3YXNtUGF0aCA9IGF3YWl0IHRvQmxvYlVSTChcbiAgICBjb3JlUmVtb3RlUGF0aC5yZXBsYWNlKCdmZm1wZWctY29yZS5qcycsICdmZm1wZWctY29yZS53YXNtJyksXG4gICAgJ2FwcGxpY2F0aW9uL3dhc20nLFxuICApO1xuICBjb25zdCB3b3JrZXJQYXRoID0gYXdhaXQgdG9CbG9iVVJMKFxuICAgIGNvcmVSZW1vdGVQYXRoLnJlcGxhY2UoJ2ZmbXBlZy1jb3JlLmpzJywgJ2ZmbXBlZy1jb3JlLndvcmtlci5qcycpLFxuICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgKTtcbiAgaWYgKHR5cGVvZiBjcmVhdGVGRm1wZWdDb3JlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgbG9nKCdpbmZvJywgJ2ZmbXBlZy1jb3JlLmpzIHNjcmlwdCBsb2FkZWQnKTtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgY3JlYXRlRkZtcGVnQ29yZSxcbiAgICAgICAgICBjb3JlUGF0aCxcbiAgICAgICAgICB3YXNtUGF0aCxcbiAgICAgICAgICB3b3JrZXJQYXRoLFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzY3JpcHQuc3JjID0gY29yZVBhdGg7XG4gICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBldmVudEhhbmRsZXIpO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xuICB9XG4gIGxvZygnaW5mbycsICdmZm1wZWctY29yZS5qcyBzY3JpcHQgaXMgbG9hZGVkIGFscmVhZHknKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgY3JlYXRlRkZtcGVnQ29yZSxcbiAgICBjb3JlUGF0aCxcbiAgICB3YXNtUGF0aCxcbiAgICB3b3JrZXJQYXRoLFxuICB9KTtcbn07XG4iLCJjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vZGVmYXVsdE9wdGlvbnMnKTtcbmNvbnN0IGdldENyZWF0ZUZGbXBlZ0NvcmUgPSByZXF1aXJlKCcuL2dldENyZWF0ZUZGbXBlZ0NvcmUnKTtcbmNvbnN0IGZldGNoRmlsZSA9IHJlcXVpcmUoJy4vZmV0Y2hGaWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWZhdWx0T3B0aW9ucyxcbiAgZ2V0Q3JlYXRlRkZtcGVnQ29yZSxcbiAgZmV0Y2hGaWxlLFxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWZhdWx0QXJnczogW1xuICAgIC8qIGFyZ3NbMF0gaXMgYWx3YXlzIHRoZSBiaW5hcnkgcGF0aCAqL1xuICAgICcuL2ZmbXBlZycsXG4gICAgLyogRGlzYWJsZSBpbnRlcmFjdGlvbiBtb2RlICovXG4gICAgJy1ub3N0ZGluJyxcbiAgICAvKiBGb3JjZSB0byBvdmVycmlkZSBvdXRwdXQgZmlsZSAqL1xuICAgICcteScsXG4gIF0sXG4gIGJhc2VPcHRpb25zOiB7XG4gICAgLyogRmxhZyB0byB0dXJuIG9uL29mZiBsb2cgbWVzc2FnZXMgaW4gY29uc29sZSAqL1xuICAgIGxvZzogZmFsc2UsXG4gICAgLypcbiAgICAgKiBDdXN0b20gbG9nZ2VyIHRvIGdldCBmZm1wZWcud2FzbSBvdXRwdXQgbWVzc2FnZXMuXG4gICAgICogYSBzYW1wbGUgbG9nZ2VyIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGxvZ2dlciA9ICh7IHR5cGUsIG1lc3NhZ2UgfSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2codHlwZSwgbWVzc2FnZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogdHlwZSBjYW4gYmUgb25lIG9mIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqIGluZm86IGludGVybmFsIHdvcmtmbG93IGRlYnVnIG1lc3NhZ2VzXG4gICAgICogZmZlcnI6IGZmbXBlZyBuYXRpdmUgc3RkZXJyIG91dHB1dFxuICAgICAqIGZmb3V0OiBmZm1wZWcgbmF0aXZlIHN0ZG91dCBvdXRwdXRcbiAgICAgKi9cbiAgICBsb2dnZXI6ICgpID0+IHt9LFxuICAgIC8qXG4gICAgICogUHJvZ3Jlc3MgaGFuZGxlciB0byBnZXQgY3VycmVudCBwcm9ncmVzcyBvZiBmZm1wZWcgY29tbWFuZC5cbiAgICAgKiBhIHNhbXBsZSBwcm9ncmVzcyBoYW5kbGVyIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHByb2dyZXNzID0gKHsgcmF0aW8gfSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2cocmF0aW8pO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIHJhdGlvIGlzIGEgZmxvYXQgbnVtYmVyIGJldHdlZW4gMCB0byAxLlxuICAgICAqL1xuICAgIHByb2dyZXNzOiAoKSA9PiB7fSxcbiAgICAvKlxuICAgICAqIFBhdGggdG8gZmluZC9kb3dubG9hZCBmZm1wZWcud2FzbS1jb3JlLFxuICAgICAqIHRoaXMgdmFsdWUgc2hvdWxkIGJlIG92ZXJ3cml0ZW4gYnkgYGRlZmF1bHRPcHRpb25zYCBpblxuICAgICAqIGVhY2ggZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgY29yZVBhdGg6ICcnLFxuICB9LFxufTtcbiIsImNvbnN0IHsgZGVmYXVsdEFyZ3MsIGJhc2VPcHRpb25zIH0gPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuY29uc3QgeyBzZXRMb2dnaW5nLCBzZXRDdXN0b21Mb2dnZXIsIGxvZyB9ID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKTtcbmNvbnN0IHBhcnNlUHJvZ3Jlc3MgPSByZXF1aXJlKCcuL3V0aWxzL3BhcnNlUHJvZ3Jlc3MnKTtcbmNvbnN0IHBhcnNlQXJncyA9IHJlcXVpcmUoJy4vdXRpbHMvcGFyc2VBcmdzJyk7XG5jb25zdCB7IGRlZmF1bHRPcHRpb25zLCBnZXRDcmVhdGVGRm1wZWdDb3JlIH0gPSByZXF1aXJlKCcuL25vZGUnKTtcbmNvbnN0IHsgdmVyc2lvbiB9ID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbmNvbnN0IE5PX0xPQUQgPSBFcnJvcignZmZtcGVnLndhc20gaXMgbm90IHJlYWR5LCBtYWtlIHN1cmUgeW91IGhhdmUgY29tcGxldGVkIGxvYWQoKS4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoX29wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7XG4gICAgbG9nOiBsb2dnaW5nLFxuICAgIGxvZ2dlcixcbiAgICBwcm9ncmVzczogb3B0UHJvZ3Jlc3MsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0ge1xuICAgIC4uLmJhc2VPcHRpb25zLFxuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLl9vcHRpb25zLFxuICB9O1xuICBsZXQgQ29yZSA9IG51bGw7XG4gIGxldCBmZm1wZWcgPSBudWxsO1xuICBsZXQgcnVuUmVzb2x2ZSA9IG51bGw7XG4gIGxldCBydW5uaW5nID0gZmFsc2U7XG4gIGxldCBwcm9ncmVzcyA9IG9wdFByb2dyZXNzO1xuICBjb25zdCBkZXRlY3RDb21wbGV0aW9uID0gKG1lc3NhZ2UpID0+IHtcbiAgICBpZiAobWVzc2FnZSA9PT0gJ0ZGTVBFR19FTkQnICYmIHJ1blJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIHJ1blJlc29sdmUoKTtcbiAgICAgIHJ1blJlc29sdmUgPSBudWxsO1xuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGFyc2VNZXNzYWdlID0gKHsgdHlwZSwgbWVzc2FnZSB9KSA9PiB7XG4gICAgbG9nKHR5cGUsIG1lc3NhZ2UpO1xuICAgIHBhcnNlUHJvZ3Jlc3MobWVzc2FnZSwgcHJvZ3Jlc3MpO1xuICAgIGRldGVjdENvbXBsZXRpb24obWVzc2FnZSk7XG4gIH07XG5cbiAgLypcbiAgICogTG9hZCBmZm1wZWcud2FzbS1jb3JlIHNjcmlwdC5cbiAgICogSW4gYnJvd3NlciBlbnZpcm9ubWVudCwgdGhlIGZmbXBlZy53YXNtLWNvcmUgc2NyaXB0IGlzIGZldGNoIGZyb21cbiAgICogQ0ROIGFuZCBjYW4gYmUgYXNzaWduIHRvIGEgbG9jYWwgcGF0aCBieSBhc3NpZ25pbmcgYGNvcmVQYXRoYC5cbiAgICogSW4gbm9kZSBlbnZpcm9ubWVudCwgd2UgdXNlIGR5bmFtaWMgcmVxdWlyZSBhbmQgdGhlIGRlZmF1bHQgYGNvcmVQYXRoYFxuICAgKiBpcyBgJGZmbXBlZy9jb3JlYC5cbiAgICpcbiAgICogVHlwaWNhbGx5IHRoZSBsb2FkKCkgZnVuYyBtaWdodCB0YWtlIGZldyBzZWNvbmRzIHRvIG1pbnV0ZXMgdG8gY29tcGxldGUsXG4gICAqIGJldHRlciB0byBkbyBpdCBhcyBlYXJseSBhcyBwb3NzaWJsZS5cbiAgICpcbiAgICovXG4gIGNvbnN0IGxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgbG9nKCdpbmZvJywgJ2xvYWQgZmZtcGVnLWNvcmUnKTtcbiAgICBpZiAoQ29yZSA9PT0gbnVsbCkge1xuICAgICAgbG9nKCdpbmZvJywgJ2xvYWRpbmcgZmZtcGVnLWNvcmUnKTtcbiAgICAgIC8qXG4gICAgICAgKiBJbiBub2RlIGVudmlyb25tZW50LCBhbGwgcGF0aHMgYXJlIHVuZGVmaW5lZCBhcyB0aGVyZVxuICAgICAgICogaXMgbm8gbmVlZCB0byBzZXQgdGhlbS5cbiAgICAgICAqL1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgICAgICBjb3JlUGF0aCxcbiAgICAgICAgd29ya2VyUGF0aCxcbiAgICAgICAgd2FzbVBhdGgsXG4gICAgICB9ID0gYXdhaXQgZ2V0Q3JlYXRlRkZtcGVnQ29yZShvcHRpb25zKTtcbiAgICAgIENvcmUgPSBhd2FpdCBjcmVhdGVGRm1wZWdDb3JlKHtcbiAgICAgICAgLypcbiAgICAgICAgICogQXNzaWduIG1haW5TY3JpcHRVcmxPckJsb2IgZml4ZXMgY2hyb21lIGV4dGVuc2lvbiB3ZWIgd29ya2VyIGlzc3VlXG4gICAgICAgICAqIGFzIHRoZXJlIGlzIG5vIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgaW4gdGhlIGNvbnRleHQgb2YgY29udGVudF9zY3JpcHRzXG4gICAgICAgICAqL1xuICAgICAgICBtYWluU2NyaXB0VXJsT3JCbG9iOiBjb3JlUGF0aCxcbiAgICAgICAgcHJpbnRFcnI6IChtZXNzYWdlKSA9PiBwYXJzZU1lc3NhZ2UoeyB0eXBlOiAnZmZlcnInLCBtZXNzYWdlIH0pLFxuICAgICAgICBwcmludDogKG1lc3NhZ2UpID0+IHBhcnNlTWVzc2FnZSh7IHR5cGU6ICdmZm91dCcsIG1lc3NhZ2UgfSksXG4gICAgICAgIC8qXG4gICAgICAgICAqIGxvY2F0ZUZpbGUgb3ZlcnJpZGVzIHBhdGhzIG9mIGZpbGVzIHRoYXQgaXMgbG9hZGVkIGJ5IG1haW4gc2NyaXB0IChmZm1wZWctY29yZS5qcykuXG4gICAgICAgICAqIEl0IGlzIGNyaXRpY2FsIGZvciBicm93c2VyIGVudmlyb25tZW50IGFuZCB3ZSBvdmVycmlkZSBib3RoIHdhc20gYW5kIHdvcmtlciBwYXRoc1xuICAgICAgICAgKiBhcyB3ZSBhcmUgdXNpbmcgYmxvYiBVUkwgaW5zdGVhZCBvZiBvcmlnaW5hbCBVUkwgdG8gYXZvaWQgY3Jvc3Mgb3JpZ2luIGlzc3Vlcy5cbiAgICAgICAgICovXG4gICAgICAgIGxvY2F0ZUZpbGU6IChwYXRoLCBwcmVmaXgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2FzbVBhdGggIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICYmIHBhdGguZW5kc1dpdGgoJ2ZmbXBlZy1jb3JlLndhc20nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gd2FzbVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdvcmtlclBhdGggIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICYmIHBhdGguZW5kc1dpdGgoJ2ZmbXBlZy1jb3JlLndvcmtlci5qcycpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3b3JrZXJQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsgcGF0aDtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgZmZtcGVnID0gQ29yZS5jd3JhcCgncHJveHlfbWFpbicsICdudW1iZXInLCBbJ251bWJlcicsICdudW1iZXInXSk7XG4gICAgICBsb2coJ2luZm8nLCAnZmZtcGVnLWNvcmUgbG9hZGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdmZm1wZWcud2FzbSB3YXMgbG9hZGVkLCB5b3Ugc2hvdWxkIG5vdCBsb2FkIGl0IGFnYWluLCB1c2UgZmZtcGVnLmlzTG9hZGVkKCkgdG8gY2hlY2sgbmV4dCB0aW1lLicpO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgQ29yZSBpcyBsb2FkZWQuXG4gICAqL1xuICBjb25zdCBpc0xvYWRlZCA9ICgpID0+IENvcmUgIT09IG51bGw7XG5cbiAgLypcbiAgICogUnVuIGZmbXBlZyBjb21tYW5kLlxuICAgKiBUaGlzIGlzIHRoZSBtYWpvciBmdW5jdGlvbiBpbiBmZm1wZWcud2FzbSwgeW91IGNhbiBqdXN0IGltYWdpbmUgaXRcbiAgICogYXMgZmZtcGVnIG5hdGl2ZSBjbGkgYW5kIHdoYXQgeW91IG5lZWQgdG8gcGFzcyBpcyB0aGUgc2FtZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHlvdSBjYW4gY29udmVydCBuYXRpdmUgY29tbWFuZCBiZWxvdzpcbiAgICpcbiAgICogYGBgXG4gICAqICQgZmZtcGVnIC1pIHZpZGVvLmF2aSAtYzp2IGxpYngyNjQgdmlkZW8ubXA0XG4gICAqIGBgYFxuICAgKlxuICAgKiBUb1xuICAgKlxuICAgKiBgYGBcbiAgICogYXdhaXQgZmZtcGVnLnJ1bignLWknLCAndmlkZW8uYXZpJywgJy1jOnYnLCAnbGlieDI2NCcsICd2aWRlby5tcDQnKTtcbiAgICogYGBgXG4gICAqXG4gICAqL1xuICBjb25zdCBydW4gPSAoLi4uX2FyZ3MpID0+IHtcbiAgICBsb2coJ2luZm8nLCBgcnVuIGZmbXBlZyBjb21tYW5kOiAke19hcmdzLmpvaW4oJyAnKX1gKTtcbiAgICBpZiAoQ29yZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgTk9fTE9BRDtcbiAgICB9IGVsc2UgaWYgKHJ1bm5pbmcpIHtcbiAgICAgIHRocm93IEVycm9yKCdmZm1wZWcud2FzbSBjYW4gb25seSBydW4gb25lIGNvbW1hbmQgYXQgYSB0aW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbLi4uZGVmYXVsdEFyZ3MsIC4uLl9hcmdzXS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcnVuUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGZmbXBlZyguLi5wYXJzZUFyZ3MoQ29yZSwgYXJncykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIFJ1biBGUyBvcGVyYXRpb25zLlxuICAgKiBGb3IgaW5wdXQvb3V0cHV0IGZpbGUgb2YgZmZtcGVnLndhc20sIGl0IGlzIHJlcXVpcmVkIHRvIHNhdmUgdGhlbSB0byBNRU1GU1xuICAgKiBmaXJzdCBzbyB0aGF0IGZmbXBlZy53YXNtIGlzIGFibGUgdG8gY29uc3VtZSB0aGVtLiBIZXJlIHdlIHJlbHkgb24gdGhlIEZTXG4gICAqIG1ldGhvZHMgcHJvdmlkZWQgYnkgRW1zY3JpcHRlbi5cbiAgICpcbiAgICogQ29tbW9uIG1ldGhvZHMgdG8gdXNlIGFyZTpcbiAgICogZmZtcGVnLkZTKCd3cml0ZUZpbGUnLCAndmlkZW8uYXZpJywgbmV3IFVpbnQ4QXJyYXkoLi4uKSk6IHdyaXRlRmlsZSB3cml0ZXNcbiAgICogZGF0YSB0byBNRU1GUy4gWW91IG5lZWQgdG8gdXNlIFVpbnQ4QXJyYXkgZm9yIGJpbmFyeSBkYXRhLlxuICAgKiBmZm1wZWcuRlMoJ3JlYWRGaWxlJywgJ3ZpZGVvLm1wNCcpOiByZWFkRmlsZSBmcm9tIE1FTUZTLlxuICAgKiBmZm1wZWcuRlMoJ3VubGluaycsICd2aWRlby5tYXAnKTogZGVsZXRlIGZpbGUgZnJvbSBNRU1GUy5cbiAgICpcbiAgICogRm9yIG1vcmUgaW5mbywgY2hlY2sgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2FwaV9yZWZlcmVuY2UvRmlsZXN5c3RlbS1BUEkuaHRtbFxuICAgKlxuICAgKi9cbiAgY29uc3QgRlMgPSAobWV0aG9kLCAuLi5hcmdzKSA9PiB7XG4gICAgbG9nKCdpbmZvJywgYHJ1biBGUy4ke21ldGhvZH0gJHthcmdzLm1hcCgoYXJnKSA9PiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBhcmcgOiBgPCR7YXJnLmxlbmd0aH0gYnl0ZXMgYmluYXJ5IGZpbGU+YCkpLmpvaW4oJyAnKX1gKTtcbiAgICBpZiAoQ29yZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgTk9fTE9BRDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJldCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBDb3JlLkZTW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdyZWFkZGlyJykge1xuICAgICAgICAgIHRocm93IEVycm9yKGBmZm1wZWcuRlMoJ3JlYWRkaXInLCAnJHthcmdzWzBdfScpIGVycm9yLiBDaGVjayBpZiB0aGUgcGF0aCBleGlzdHMsIGV4OiBmZm1wZWcuRlMoJ3JlYWRkaXInLCAnLycpYCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSAncmVhZEZpbGUnKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYGZmbXBlZy5GUygncmVhZEZpbGUnLCAnJHthcmdzWzBdfScpIGVycm9yLiBDaGVjayBpZiB0aGUgcGF0aCBleGlzdHNgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignT29wcywgc29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gRlMgb3BlcmF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZm9yY2libHkgdGVybWluYXRlIHRoZSBmZm1wZWcgcHJvZ3JhbS5cbiAgICovXG4gIGNvbnN0IGV4aXQgPSAoKSA9PiB7XG4gICAgaWYgKENvcmUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IE5PX0xPQUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIENvcmUuZXhpdCgxKTtcbiAgICAgIENvcmUgPSBudWxsO1xuICAgICAgZmZtcGVnID0gbnVsbDtcbiAgICAgIHJ1blJlc29sdmUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZXRQcm9ncmVzcyA9IChfcHJvZ3Jlc3MpID0+IHtcbiAgICBwcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgfTtcblxuICBjb25zdCBzZXRMb2dnZXIgPSAoX2xvZ2dlcikgPT4ge1xuICAgIHNldEN1c3RvbUxvZ2dlcihfbG9nZ2VyKTtcbiAgfTtcblxuICBzZXRMb2dnaW5nKGxvZ2dpbmcpO1xuICBzZXRDdXN0b21Mb2dnZXIobG9nZ2VyKTtcblxuICBsb2coJ2luZm8nLCBgdXNlIGZmbXBlZy53YXNtIHYke3ZlcnNpb259YCk7XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9ncmVzcyxcbiAgICBzZXRMb2dnZXIsXG4gICAgc2V0TG9nZ2luZyxcbiAgICBsb2FkLFxuICAgIGlzTG9hZGVkLFxuICAgIHJ1bixcbiAgICBleGl0LFxuICAgIEZTLFxuICB9O1xufTtcbiIsInJlcXVpcmUoJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZScpO1xuY29uc3QgY3JlYXRlRkZtcGVnID0gcmVxdWlyZSgnLi9jcmVhdGVGRm1wZWcnKTtcbmNvbnN0IHsgZmV0Y2hGaWxlIH0gPSByZXF1aXJlKCcuL25vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qXG4gICAqIENyZWF0ZSBmZm1wZWcgaW5zdGFuY2UuXG4gICAqIEVhY2ggZmZtcGVnIGluc3RhbmNlIG93bnMgYW4gaXNvbGF0ZWQgTUVNRlMgYW5kIHdvcmtzXG4gICAqIGluZGVwZW5kZW50bHkuXG4gICAqXG4gICAqIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZmZtcGVnID0gY3JlYXRlRkZtcGVnKHtcbiAgICogIGxvZzogdHJ1ZSxcbiAgICogIGxvZ2dlcjogKCkgPT4ge30sXG4gICAqICBwcm9ncmVzczogKCkgPT4ge30sXG4gICAqICBjb3JlUGF0aDogJycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBGb3IgdGhlIHVzYWdlIG9mIHRoZXNlIGZvdXIgYXJndW1lbnRzLCBjaGVjayBjb25maWcuanNcbiAgICpcbiAgICovXG4gIGNyZWF0ZUZGbXBlZyxcbiAgLypcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBmZXRjaGluZyBmaWxlcyBmcm9tIHZhcmlvdXMgcmVzb3VyY2UuXG4gICAqIFNvbWV0aW1lcyB0aGUgdmlkZW8vYXVkaW8gZmlsZSB5b3Ugd2FudCB0byBwcm9jZXNzIG1heSBsb2NhdGVkXG4gICAqIGluIGEgcmVtb3RlIFVSTCBhbmQgc29tZXdoZXJlIGluIHlvdXIgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gICAqXG4gICAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGhlbHBzIHlvdSB0byBmZXRjaCB0byBmaWxlIGFuZCByZXR1cm4gYW5cbiAgICogVWludDhBcnJheSB2YXJpYWJsZSBmb3IgZmZtcGVnLndhc20gdG8gY29uc3VtZS5cbiAgICpcbiAgICovXG4gIGZldGNoRmlsZSxcbn07XG4iLCJsZXQgbG9nZ2luZyA9IGZhbHNlO1xubGV0IGN1c3RvbUxvZ2dlciA9ICgpID0+IHt9O1xuXG5jb25zdCBzZXRMb2dnaW5nID0gKF9sb2dnaW5nKSA9PiB7XG4gIGxvZ2dpbmcgPSBfbG9nZ2luZztcbn07XG5cbmNvbnN0IHNldEN1c3RvbUxvZ2dlciA9IChsb2dnZXIpID0+IHtcbiAgY3VzdG9tTG9nZ2VyID0gbG9nZ2VyO1xufTtcblxuY29uc3QgbG9nID0gKHR5cGUsIG1lc3NhZ2UpID0+IHtcbiAgY3VzdG9tTG9nZ2VyKHsgdHlwZSwgbWVzc2FnZSB9KTtcbiAgaWYgKGxvZ2dpbmcpIHtcbiAgICBjb25zb2xlLmxvZyhgWyR7dHlwZX1dICR7bWVzc2FnZX1gKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZ2dpbmcsXG4gIHNldExvZ2dpbmcsXG4gIHNldEN1c3RvbUxvZ2dlcixcbiAgbG9nLFxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gKENvcmUsIGFyZ3MpID0+IHtcbiAgY29uc3QgYXJnc1B0ciA9IENvcmUuX21hbGxvYyhhcmdzLmxlbmd0aCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgYXJncy5mb3JFYWNoKChzLCBpZHgpID0+IHtcbiAgICBjb25zdCBidWYgPSBDb3JlLl9tYWxsb2Mocy5sZW5ndGggKyAxKTtcbiAgICBDb3JlLndyaXRlQXNjaWlUb01lbW9yeShzLCBidWYpO1xuICAgIENvcmUuc2V0VmFsdWUoYXJnc1B0ciArIChVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIGlkeCksIGJ1ZiwgJ2kzMicpO1xuICB9KTtcbiAgcmV0dXJuIFthcmdzLmxlbmd0aCwgYXJnc1B0cl07XG59O1xuIiwibGV0IGR1cmF0aW9uID0gMDtcbmxldCByYXRpbyA9IDA7XG5cbmNvbnN0IHRzMnNlYyA9ICh0cykgPT4ge1xuICBjb25zdCBbaCwgbSwgc10gPSB0cy5zcGxpdCgnOicpO1xuICByZXR1cm4gKHBhcnNlRmxvYXQoaCkgKiA2MCAqIDYwKSArIChwYXJzZUZsb2F0KG0pICogNjApICsgcGFyc2VGbG9hdChzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKG1lc3NhZ2UsIHByb2dyZXNzKSA9PiB7XG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAobWVzc2FnZS5zdGFydHNXaXRoKCcgIER1cmF0aW9uJykpIHtcbiAgICAgIGNvbnN0IHRzID0gbWVzc2FnZS5zcGxpdCgnLCAnKVswXS5zcGxpdCgnOiAnKVsxXTtcbiAgICAgIGNvbnN0IGQgPSB0czJzZWModHMpO1xuICAgICAgcHJvZ3Jlc3MoeyBkdXJhdGlvbjogZCwgcmF0aW8gfSk7XG4gICAgICBpZiAoZHVyYXRpb24gPT09IDAgfHwgZHVyYXRpb24gPiBkKSB7XG4gICAgICAgIGR1cmF0aW9uID0gZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgnZnJhbWUnKSB8fCBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3NpemUnKSkge1xuICAgICAgY29uc3QgdHMgPSBtZXNzYWdlLnNwbGl0KCd0aW1lPScpWzFdLnNwbGl0KCcgJylbMF07XG4gICAgICBjb25zdCB0ID0gdHMyc2VjKHRzKTtcbiAgICAgIHJhdGlvID0gdCAvIGR1cmF0aW9uO1xuICAgICAgcHJvZ3Jlc3MoeyByYXRpbywgdGltZTogdCB9KTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgndmlkZW86JykpIHtcbiAgICAgIHByb2dyZXNzKHsgcmF0aW86IDEgfSk7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIiFmdW5jdGlvbihlKXt2YXIgaT10aGlzO1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP21vZHVsZS5leHBvcnRzPWUoaSxyZXF1aXJlKFwiamRhdGF2aWV3XCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImpkYXRhdmlld1wiXSxmdW5jdGlvbih0KXtyZXR1cm4gZShpLHQpfSk6aS5qQmluYXJ5PWUoaSxpLmpEYXRhVmlldyl9KGZ1bmN0aW9uKGgsaSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG8sdSxuPWguZG9jdW1lbnQ7XCJhdG9iXCJpbiBoJiZcImJ0b2FcImluIGh8fChvPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLHU9Wy0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLDYyLC0xLC0xLC0xLDYzLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLC0xLC0xLC0xLC0xLC0xLC0xLC0xLDAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsLTEsLTEsLTEsLTEsLTEsLTEsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsLTEsLTEsLTEsLTEsLTFdLGguYnRvYXx8KGguYnRvYT1mdW5jdGlvbih0KXtmb3IodmFyIGUsaSxuLHI9dC5sZW5ndGgsYT0wLHM9XCJcIjthPHI7KXtpZihlPTI1NSZ0LmNoYXJDb2RlQXQoYSsrKSxhPT1yKXtzKz1vLmNoYXJBdChlPj4yKSxzKz1vLmNoYXJBdCgoMyZlKTw8NCkscys9XCI9PVwiO2JyZWFrfWlmKGk9dC5jaGFyQ29kZUF0KGErKyksYT09cil7cys9by5jaGFyQXQoZT4+Mikscys9by5jaGFyQXQoKDMmZSk8PDR8KDI0MCZpKT4+NCkscys9by5jaGFyQXQoKDE1JmkpPDwyKSxzKz1cIj1cIjticmVha31uPXQuY2hhckNvZGVBdChhKyspLHMrPW8uY2hhckF0KGU+PjIpLHMrPW8uY2hhckF0KCgzJmUpPDw0fCgyNDAmaSk+PjQpLHMrPW8uY2hhckF0KCgxNSZpKTw8MnwoMTkyJm4pPj42KSxzKz1vLmNoYXJBdCg2MyZuKX1yZXR1cm4gc30pLGguYXRvYnx8KGguYXRvYj1mdW5jdGlvbih0KXtmb3IodmFyIGUsaSxuLHIsYT10Lmxlbmd0aCxzPTAsbz1cIlwiO3M8YTspe2Zvcig7ZT11WzI1NSZ0LmNoYXJDb2RlQXQocysrKV0sczxhJiYtMT09ZTspO2lmKC0xPT1lKWJyZWFrO2Zvcig7aT11WzI1NSZ0LmNoYXJDb2RlQXQocysrKV0sczxhJiYtMT09aTspO2lmKC0xPT1pKWJyZWFrO28rPVN0cmluZy5mcm9tQ2hhckNvZGUoZTw8MnwoNDgmaSk+PjQpO2Rve2lmKDYxPT0obj0yNTUmdC5jaGFyQ29kZUF0KHMrKykpKXJldHVybiBvfXdoaWxlKG49dVtuXSxzPGEmJi0xPT1uKTtpZigtMT09bilicmVhaztvKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgxNSZpKTw8NHwoNjAmbik+PjIpO2Rve2lmKDYxPT0ocj0yNTUmdC5jaGFyQ29kZUF0KHMrKykpKXJldHVybiBvfXdoaWxlKHI9dVtyXSxzPGEmJi0xPT1yKTtpZigtMT09cilicmVhaztvKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzJm4pPDw2fHIpfXJldHVybiBvfSkpO3ZhciBjPWguUHJvbWlzZXx8ZnVuY3Rpb24odCl7dGhpcy50aGVuPXR9O2Z1bmN0aW9uIGYodCxlKXtyZXR1cm4gZSYmdCBpbnN0YW5jZW9mIGV9ZnVuY3Rpb24gcih0KXtmb3IodmFyIGU9MSxpPWFyZ3VtZW50cy5sZW5ndGg7ZTxpOysrZSl7dmFyIG4scj1hcmd1bWVudHNbZV07Zm9yKG4gaW4gcil2b2lkIDAhPT1yW25dJiYodFtuXT1yW25dKX1yZXR1cm4gdH1mdW5jdGlvbiBsKHQpe3JldHVybiBhcmd1bWVudHNbMF09ZSh0KSxyLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBhKHQsZSxpKXtyZXR1cm4gZihpLEZ1bmN0aW9uKT9pLmNhbGwodCxlLmNvbnRleHRzWzBdKTppfWZ1bmN0aW9uIHQocyl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLGU9dC5sZW5ndGgtMSxyPXMubGVuZ3RoLTEsaT10W2VdO2lmKHQubGVuZ3RoPTErciwhZihpLEZ1bmN0aW9uKSl7dmFyIGE9dGhpcztyZXR1cm4gbmV3IGMoZnVuY3Rpb24oaSxuKXt0W3JdPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ/bih0KTppKGUpfSxzLmFwcGx5KGEsdCl9KX10W2VdPXZvaWQgMCx0W3JdPWkscy5hcHBseSh0aGlzLHQpfX1mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIGYodCxzKT90LmFzKGUpOihmKHQsaSl8fCh0PW5ldyBpKHQsdm9pZCAwLHZvaWQgMCxlP2VbXCJqQmluYXJ5LmxpdHRsZUVuZGlhblwiXTp2b2lkIDApKSxmKHRoaXMscyk/KHRoaXMudmlldz10LHRoaXMudmlldy5zZWVrKDApLHRoaXMuY29udGV4dHM9W10sdGhpcy5hcyhlLCEwKSk6bmV3IHModCxlKSl9dmFyIGU9KGU9T2JqZWN0LmNyZWF0ZSl8fGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUucHJvdG90eXBlPXQsbmV3IGV9LHA9cy5wcm90b3R5cGUseT1wLnR5cGVTZXQ9e307cC50b1ZhbHVlPWZ1bmN0aW9uKHQpe3JldHVybiBhKHRoaXMsdGhpcyx0KX0scC5fbmFtZWQ9ZnVuY3Rpb24odCxlLGkpe3JldHVybiB0LmRpc3BsYXlOYW1lPWUrXCIgQCBcIisodm9pZCAwIT09aT9pOnRoaXMudmlldy50ZWxsKCkpLHR9O3ZhciBkPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTtpZigxLGQpdHJ5e2Qoe30sXCJ4XCIse30pfWNhdGNoKHQpe2Q9dm9pZCAwfWVsc2UgZD1mdW5jdGlvbih0LGUsaSxuKXtuJiYodFtlXT1pLnZhbHVlKX07dmFyIHY9XCJqQmluYXJ5LkNhY2hlXCIsYj0wO2Z1bmN0aW9uIGcodCl7cmV0dXJuIGwoZy5wcm90b3R5cGUsdCl9ZnVuY3Rpb24gdyhpKXtyZXR1cm4gbCh3LnByb3RvdHlwZSxpLHtjcmVhdGVQcm9wZXJ0eTpmdW5jdGlvbih0KXt2YXIgZT0oaS5jcmVhdGVQcm9wZXJ0eXx8dy5wcm90b3R5cGUuY3JlYXRlUHJvcGVydHkpLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gZS5nZXRCYXNlVHlwZSYmKGUuYmFzZVR5cGU9ZS5iaW5hcnkuZ2V0VHlwZShlLmdldEJhc2VUeXBlKGUuYmluYXJ5LmNvbnRleHRzWzBdKSkpLGV9fSl9cC5fZ2V0Q2FjaGVkPWZ1bmN0aW9uKHQsZSxpKXtpZih0Lmhhc093blByb3BlcnR5KHRoaXMuY2FjaGVLZXkpKXJldHVybiB0W3RoaXMuY2FjaGVLZXldO2U9ZS5jYWxsKHRoaXMsdCk7cmV0dXJuIGQodCx0aGlzLmNhY2hlS2V5LHt2YWx1ZTplfSxpKSxlfSxwLmdldENvbnRleHQ9ZnVuY3Rpb24oZSl7c3dpdGNoKHR5cGVvZiBlKXtjYXNlXCJ1bmRlZmluZWRcIjplPTA7Y2FzZVwibnVtYmVyXCI6cmV0dXJuIHRoaXMuY29udGV4dHNbZV07Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHRoaXMuZ2V0Q29udGV4dChmdW5jdGlvbih0KXtyZXR1cm4gZSBpbiB0fSk7Y2FzZVwiZnVuY3Rpb25cIjpmb3IodmFyIHQ9MCxpPXRoaXMuY29udGV4dHMubGVuZ3RoO3Q8aTt0Kyspe3ZhciBuPXRoaXMuY29udGV4dHNbdF07aWYoZS5jYWxsKHRoaXMsbikpcmV0dXJuIG59fX0scC5pbkNvbnRleHQ9ZnVuY3Rpb24odCxlKXt0aGlzLmNvbnRleHRzLnVuc2hpZnQodCk7ZT1lLmNhbGwodGhpcyk7cmV0dXJuIHRoaXMuY29udGV4dHMuc2hpZnQoKSxlfSxnLnByb3RvdHlwZT17aW5oZXJpdDpmdW5jdGlvbihuLGEpe3ZhciByLHM9dGhpcztmdW5jdGlvbiB0KHQsZSl7dmFyIGk9c1t0XTtpJiYocj1yfHxsKHMpLGUuY2FsbChyLGkpLHJbdF09bnVsbCl9cmV0dXJuIHQoXCJwYXJhbXNcIixmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxpPXQubGVuZ3RoO2U8aTtlKyspdGhpc1t0W2VdXT1uW2VdfSksdChcInNldFBhcmFtc1wiLGZ1bmN0aW9uKHQpe3QuYXBwbHkodGhpcyxuKX0pLHQoXCJ0eXBlUGFyYW1zXCIsZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsaT10Lmxlbmd0aDtlPGk7ZSsrKXt2YXIgbj10W2VdLHI9dGhpc1tuXTtyJiYodGhpc1tuXT1hKHIpKX19KSx0KFwicmVzb2x2ZVwiLGZ1bmN0aW9uKHQpe3QuY2FsbCh0aGlzLGEpfSkscnx8c30sY3JlYXRlUHJvcGVydHk6ZnVuY3Rpb24odCl7cmV0dXJuIGwodGhpcyx7YmluYXJ5OnQsdmlldzp0LnZpZXd9KX0sdG9WYWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiExIT09ZSYmXCJzdHJpbmdcIj09dHlwZW9mIHQ/dGhpcy5iaW5hcnkuZ2V0Q29udGV4dCh0KVt0XTphKHRoaXMsdGhpcy5iaW5hcnksdCl9fSx3LnByb3RvdHlwZT1sKChzLlR5cGU9ZykucHJvdG90eXBlLHtzZXRQYXJhbXM6ZnVuY3Rpb24oKXt0aGlzLmJhc2VUeXBlJiYodGhpcy50eXBlUGFyYW1zPVtcImJhc2VUeXBlXCJdLmNvbmNhdCh0aGlzLnR5cGVQYXJhbXN8fFtdKSl9LGJhc2VSZWFkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmluYXJ5LnJlYWQodGhpcy5iYXNlVHlwZSl9LGJhc2VXcml0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5iaW5hcnkud3JpdGUodGhpcy5iYXNlVHlwZSx0KX19KSxyKHcucHJvdG90eXBlLHtyZWFkOncucHJvdG90eXBlLmJhc2VSZWFkLHdyaXRlOncucHJvdG90eXBlLmJhc2VXcml0ZX0pLHMuVGVtcGxhdGU9dyxwLmFzPWZ1bmN0aW9uKHQsZSl7ZT1lP3RoaXM6bCh0aGlzKTtyZXR1cm4gZS50eXBlU2V0PSh0PXR8fHkpPT09eXx8eS5pc1Byb3RvdHlwZU9mKHQpP3Q6bCh5LHQpLGUuY2FjaGVLZXk9dixlLmNhY2hlS2V5PWUuX2dldENhY2hlZCh0LGZ1bmN0aW9uKCl7cmV0dXJuIHYrXCIuXCIrICsrYn0sITApLGV9LHAuc2Vlaz1mdW5jdGlvbih0LGUpe2lmKHQ9dGhpcy50b1ZhbHVlKHQpLHZvaWQgMD09PWUpcmV0dXJuIHRoaXMudmlldy5zZWVrKHQpO3ZhciBpPXRoaXMudmlldy50ZWxsKCk7dGhpcy52aWV3LnNlZWsodCk7ZT1lLmNhbGwodGhpcyk7cmV0dXJuIHRoaXMudmlldy5zZWVrKGkpLGV9LHAudGVsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcudGVsbCgpfSxwLnNraXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zZWVrKHRoaXMudGVsbCgpK3RoaXMudG9WYWx1ZSh0KSxlKX0scC5zbGljZT1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIG5ldyBzKHRoaXMudmlldy5zbGljZSh0LGUsaSksdGhpcy50eXBlU2V0KX0scC5fZ2V0VHlwZT1mdW5jdGlvbih0LGUpe3N3aXRjaCh0eXBlb2YgdCl7Y2FzZVwic3RyaW5nXCI6aWYoISh0IGluIHRoaXMudHlwZVNldCkpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiVW5rbm93biB0eXBlOiBcIit0KTtyZXR1cm4gdGhpcy5fZ2V0VHlwZSh0aGlzLnR5cGVTZXRbdF0sZSk7Y2FzZVwibnVtYmVyXCI6cmV0dXJuIHRoaXMuX2dldFR5cGUoeS5iaXRmaWVsZCxbdF0pO2Nhc2VcIm9iamVjdFwiOmlmKGYodCxnKSl7dmFyIGk9dGhpcztyZXR1cm4gdC5pbmhlcml0KGV8fFtdLGZ1bmN0aW9uKHQpe3JldHVybiBpLmdldFR5cGUodCl9KX1yZXR1cm4gZih0LEFycmF5KT90aGlzLl9nZXRDYWNoZWQodCxmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRUeXBlKHRbMF0sdC5zbGljZSgxKSl9LCEwKTp0aGlzLl9nZXRDYWNoZWQodCxmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRUeXBlKHkub2JqZWN0LFt0XSl9LCExKX19LHAuZ2V0VHlwZT1mdW5jdGlvbih0LGUpe2U9dGhpcy5fZ2V0VHlwZSh0LGUpO3JldHVybiBlJiYhZih0LGcpJiYoZS5uYW1lPVwib2JqZWN0XCI9PXR5cGVvZiB0P2YodCxBcnJheSk/dFswXStcIihcIit0LnNsaWNlKDEpLmpvaW4oXCIsIFwiKStcIilcIjpcIm9iamVjdFwiOlN0cmluZyh0KSksZX0scC5fYWN0aW9uPWZ1bmN0aW9uKHQsZSxpKXtpZih2b2lkIDAhPT10KXt0PXRoaXMuZ2V0VHlwZSh0KTt2YXIgbj10aGlzLl9uYW1lZChmdW5jdGlvbigpe3JldHVybiBpLmNhbGwodGhpcyx0LmNyZWF0ZVByb3BlcnR5KHRoaXMpLHRoaXMuY29udGV4dHNbMF0pfSxcIltcIit0Lm5hbWUrXCJdXCIsZSk7cmV0dXJuIHZvaWQgMCE9PWU/dGhpcy5zZWVrKGUsbik6bi5jYWxsKHRoaXMpfX0scC5yZWFkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2FjdGlvbih0LGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5yZWFkKGUpfSl9LHAucmVhZEFsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlYWQoXCJqQmluYXJ5LmFsbFwiLDApfSxwLndyaXRlPWZ1bmN0aW9uKHQsbixlKXtyZXR1cm4gdGhpcy5fYWN0aW9uKHQsZSxmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMudGVsbCgpO3JldHVybiB0LndyaXRlKG4sZSksdGhpcy50ZWxsKCktaX0pfSxwLndyaXRlQWxsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLndyaXRlKFwiakJpbmFyeS5hbGxcIix0LDApfSxmdW5jdGlvbih0LGUpe2Zvcih2YXIgaT0wLG49ZS5sZW5ndGg7aTxuO2krKyl7dmFyIHI9ZVtpXTt5W3IudG9Mb3dlckNhc2UoKV09bCh0LHtkYXRhVHlwZTpyfSl9fShnKHtwYXJhbXM6W1wibGl0dGxlRW5kaWFuXCJdLHJlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3W1wiZ2V0XCIrdGhpcy5kYXRhVHlwZV0odm9pZCAwLHRoaXMubGl0dGxlRW5kaWFuKX0sd3JpdGU6ZnVuY3Rpb24odCl7dGhpcy52aWV3W1wid3JpdGVcIit0aGlzLmRhdGFUeXBlXSh0LHRoaXMubGl0dGxlRW5kaWFuKX19KSxbXCJVaW50OFwiLFwiVWludDE2XCIsXCJVaW50MzJcIixcIlVpbnQ2NFwiLFwiSW50OFwiLFwiSW50MTZcIixcIkludDMyXCIsXCJJbnQ2NFwiLFwiRmxvYXQzMlwiLFwiRmxvYXQ2NFwiLFwiQ2hhclwiXSkscih5LHtieXRlOnkudWludDgsZmxvYXQ6eS5mbG9hdDMyLGRvdWJsZTp5LmZsb2F0NjR9KSx5LmFycmF5PXcoe3BhcmFtczpbXCJiYXNlVHlwZVwiLFwibGVuZ3RoXCJdLHJlYWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnRvVmFsdWUodGhpcy5sZW5ndGgpO2lmKHRoaXMuYmFzZVR5cGU9PT15LnVpbnQ4KXJldHVybiB0aGlzLnZpZXcuZ2V0Qnl0ZXModCx2b2lkIDAsITAsITApO2lmKHZvaWQgMCE9PXQpZm9yKHZhciBlPW5ldyBBcnJheSh0KSxpPTA7aTx0O2krKyllW2ldPXRoaXMuYmFzZVJlYWQoKTtlbHNle3ZhciBuPXRoaXMudmlldy5ieXRlTGVuZ3RoO2ZvcihlPVtdO3RoaXMuYmluYXJ5LnRlbGwoKTxuOyllLnB1c2godGhpcy5iYXNlUmVhZCgpKX1yZXR1cm4gZX0sd3JpdGU6ZnVuY3Rpb24odCl7aWYodGhpcy5iYXNlVHlwZT09PXkudWludDgpcmV0dXJuIHRoaXMudmlldy53cml0ZUJ5dGVzKHQpO2Zvcih2YXIgZT0wLGk9dC5sZW5ndGg7ZTxpO2UrKyl0aGlzLmJhc2VXcml0ZSh0W2VdKX19KSx5LmJpbmFyeT13KHtwYXJhbXM6W1wibGVuZ3RoXCIsXCJ0eXBlU2V0XCJdLHJlYWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJpbmFyeS50ZWxsKCksZT10aGlzLmJpbmFyeS5za2lwKHRoaXMudG9WYWx1ZSh0aGlzLmxlbmd0aCkpO3JldHVybiBuZXcgcyh0aGlzLnZpZXcuc2xpY2UodCxlKSx0aGlzLnR5cGVTZXQpfSx3cml0ZTpmdW5jdGlvbih0KXt0aGlzLmJpbmFyeS53cml0ZShcImJsb2JcIix0LnJlYWQoXCJibG9iXCIsMCkpfX0pLHkuYml0ZmllbGQ9Zyh7cGFyYW1zOltcImJpdFNpemVcIl0scmVhZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0VW5zaWduZWQodGhpcy5iaXRTaXplKX0sd3JpdGU6ZnVuY3Rpb24odCl7dGhpcy52aWV3LndyaXRlVW5zaWduZWQodCx0aGlzLmJpdFNpemUpfX0pLHkuYmxvYj1nKHtwYXJhbXM6W1wibGVuZ3RoXCJdLHJlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldEJ5dGVzKHRoaXMudG9WYWx1ZSh0aGlzLmxlbmd0aCkpfSx3cml0ZTpmdW5jdGlvbih0KXt0aGlzLnZpZXcud3JpdGVCeXRlcyh0LCEwKX19KSx5LmNvbnN0PXcoe3BhcmFtczpbXCJiYXNlVHlwZVwiLFwidmFsdWVcIixcInN0cmljdFwiXSxyZWFkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5iYXNlUmVhZCgpO2lmKHRoaXMuc3RyaWN0JiZ0IT09dGhpcy52YWx1ZSl7aWYoZih0aGlzLnN0cmljdCxGdW5jdGlvbikpcmV0dXJuIHRoaXMuc3RyaWN0KHQpO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlIChcIit0K1wiICE9PSBcIit0aGlzLnZhbHVlK1wiKS5cIil9cmV0dXJuIHR9LHdyaXRlOmZ1bmN0aW9uKHQpe3RoaXMuYmFzZVdyaXRlKHRoaXMuc3RyaWN0fHx2b2lkIDA9PT10P3RoaXMudmFsdWU6dCl9fSkseS5lbnVtPXcoe3BhcmFtczpbXCJiYXNlVHlwZVwiLFwibWF0Y2hlc1wiXSxzZXRQYXJhbXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGkgaW4gdGhpcy5iYWNrTWF0Y2hlcz17fSxlKXRoaXMuYmFja01hdGNoZXNbZVtpXV09aX0scmVhZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYmFzZVJlYWQoKTtyZXR1cm4gdCBpbiB0aGlzLm1hdGNoZXM/dGhpcy5tYXRjaGVzW3RdOnR9LHdyaXRlOmZ1bmN0aW9uKHQpe3RoaXMuYmFzZVdyaXRlKHQgaW4gdGhpcy5iYWNrTWF0Y2hlcz90aGlzLmJhY2tNYXRjaGVzW3RdOnQpfX0pLHkuZXh0ZW5kPWcoe3NldFBhcmFtczpmdW5jdGlvbigpe3RoaXMucGFydHM9YXJndW1lbnRzfSxyZXNvbHZlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnBhcnRzLGk9ZS5sZW5ndGgsbj1uZXcgQXJyYXkoaSkscj0wO3I8aTtyKyspbltyXT10KGVbcl0pO3RoaXMucGFydHM9bn0scmVhZDpmdW5jdGlvbigpe3ZhciBpPXRoaXMucGFydHMsbj10aGlzLmJpbmFyeS5yZWFkKGlbMF0pO3JldHVybiB0aGlzLmJpbmFyeS5pbkNvbnRleHQobixmdW5jdGlvbigpe2Zvcih2YXIgdD0xLGU9aS5sZW5ndGg7dDxlO3QrKylyKG4sdGhpcy5yZWFkKGlbdF0pKX0pLG59LHdyaXRlOmZ1bmN0aW9uKGkpe3ZhciBuPXRoaXMucGFydHM7dGhpcy5iaW5hcnkuaW5Db250ZXh0KGksZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPW4ubGVuZ3RoO3Q8ZTt0KyspdGhpcy53cml0ZShuW3RdLGkpfSl9fSkseS5pZj13KHtwYXJhbXM6W1wiY29uZGl0aW9uXCIsXCJ0cnVlVHlwZVwiLFwiZmFsc2VUeXBlXCJdLHR5cGVQYXJhbXM6W1widHJ1ZVR5cGVcIixcImZhbHNlVHlwZVwiXSxnZXRCYXNlVHlwZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50b1ZhbHVlKHRoaXMuY29uZGl0aW9uKT90aGlzLnRydWVUeXBlOnRoaXMuZmFsc2VUeXBlfX0pLHkuaWZfbm90PXkuaWZOb3Q9dyh7c2V0UGFyYW1zOmZ1bmN0aW9uKHQsZSxpKXt0aGlzLmJhc2VUeXBlPVtcImlmXCIsdCxpLGVdfX0pLHkubGF6eT13KHttYXJrZXI6XCJqQmluYXJ5LkxhenlcIixwYXJhbXM6W1wiaW5uZXJUeXBlXCIsXCJsZW5ndGhcIl0sZ2V0QmFzZVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5bXCJiaW5hcnlcIix0aGlzLmxlbmd0aCx0aGlzLmJpbmFyeS50eXBlU2V0XX0scmVhZDpmdW5jdGlvbigpe3ZhciBlPWZ1bmN0aW9uKHQpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9cInZhbHVlXCJpbiBlP2UudmFsdWU6ZS52YWx1ZT1lLmJpbmFyeS5yZWFkKGUuaW5uZXJUeXBlKTpyKGUse3dhc0NoYW5nZWQ6ITAsdmFsdWU6dH0pLnZhbHVlfTtyZXR1cm4gZVt0aGlzLm1hcmtlcl09ITAscihlLHtiaW5hcnk6cih0aGlzLmJhc2VSZWFkKCkse2NvbnRleHRzOnRoaXMuYmluYXJ5LmNvbnRleHRzLnNsaWNlKCl9KSxpbm5lclR5cGU6dGhpcy5pbm5lclR5cGV9KX0sd3JpdGU6ZnVuY3Rpb24odCl7dC53YXNDaGFuZ2VkfHwhdFt0aGlzLm1hcmtlcl0/dGhpcy5iaW5hcnkud3JpdGUodGhpcy5pbm5lclR5cGUsdCgpKTp0aGlzLmJhc2VXcml0ZSh0LmJpbmFyeSl9fSkseS5vYmplY3Q9Zyh7cGFyYW1zOltcInN0cnVjdHVyZVwiLFwicHJvdG9cIl0scmVzb2x2ZTpmdW5jdGlvbih0KXt2YXIgZSxpPXt9O2ZvcihlIGluIHRoaXMuc3RydWN0dXJlKWlbZV09Zih0aGlzLnN0cnVjdHVyZVtlXSxGdW5jdGlvbik/dGhpcy5zdHJ1Y3R1cmVbZV06dCh0aGlzLnN0cnVjdHVyZVtlXSk7dGhpcy5zdHJ1Y3R1cmU9aX0scmVhZDpmdW5jdGlvbigpe3ZhciBpPXRoaXMsbj10aGlzLnN0cnVjdHVyZSxyPXRoaXMucHJvdG8/bCh0aGlzLnByb3RvKTp7fTtyZXR1cm4gdGhpcy5iaW5hcnkuaW5Db250ZXh0KHIsZnVuY3Rpb24oKXtmb3IodmFyIGUgaW4gbil0aGlzLl9uYW1lZChmdW5jdGlvbigpe3ZhciB0PWYobltlXSxGdW5jdGlvbik/bltlXS5jYWxsKGkscik6dGhpcy5yZWFkKG5bZV0pO3ZvaWQgMCE9PXQmJihyW2VdPXQpfSxlKS5jYWxsKHRoaXMpfSkscn0sd3JpdGU6ZnVuY3Rpb24oZSl7dmFyIGk9dGhpcyxuPXRoaXMuc3RydWN0dXJlO3RoaXMuYmluYXJ5LmluQ29udGV4dChlLGZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIG4pdGhpcy5fbmFtZWQoZnVuY3Rpb24oKXtmKG5bdF0sRnVuY3Rpb24pP2VbdF09blt0XS5jYWxsKGksZSk6dGhpcy53cml0ZShuW3RdLGVbdF0pfSx0KS5jYWxsKHRoaXMpfSl9fSkseS5za2lwPWcoe3BhcmFtczpbXCJsZW5ndGhcIl0scmVhZDpmdW5jdGlvbigpe3RoaXMudmlldy5za2lwKHRoaXMudG9WYWx1ZSh0aGlzLmxlbmd0aCkpfSx3cml0ZTpmdW5jdGlvbigpe3RoaXMucmVhZCgpfX0pLHkuc3RyaW5nPXcoe3BhcmFtczpbXCJsZW5ndGhcIixcImVuY29kaW5nXCJdLHJlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldFN0cmluZyh0aGlzLnRvVmFsdWUodGhpcy5sZW5ndGgpLHZvaWQgMCx0aGlzLmVuY29kaW5nKX0sd3JpdGU6ZnVuY3Rpb24odCl7dGhpcy52aWV3LndyaXRlU3RyaW5nKHQsdGhpcy5lbmNvZGluZyl9fSkseS5zdHJpbmcwPWcoe3BhcmFtczpbXCJsZW5ndGhcIixcImVuY29kaW5nXCJdLHJlYWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnZpZXc7aWYodm9pZCAwIT09KG49dGhpcy5sZW5ndGgpKXJldHVybiB0LmdldFN0cmluZyhuLHZvaWQgMCx0aGlzLmVuY29kaW5nKS5yZXBsYWNlKC9cXDAuKiQvLFwiXCIpO2Zvcih2YXIgZT10LnRlbGwoKSxpPTAsbj10LmJ5dGVMZW5ndGgtZTtpPG4mJnQuZ2V0VWludDgoKTspaSsrO2U9dC5nZXRTdHJpbmcoaSxlLHRoaXMuZW5jb2RpbmcpO3JldHVybiBpPG4mJnQuc2tpcCgxKSxlfSx3cml0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnZpZXcsaT12b2lkIDA9PT10aGlzLmxlbmd0aD8xOnRoaXMubGVuZ3RoLXQubGVuZ3RoO2Uud3JpdGVTdHJpbmcodCx2b2lkIDAsdGhpcy5lbmNvZGluZyksMDxpJiYoZS53cml0ZVVpbnQ4KDApLGUuc2tpcChpLTEpKX19KTtzLmxvYWREYXRhPXQoZnVuY3Rpb24odCxlKXt2YXIgaTtpZihmKHQsaC5CbG9iKSlpZihcIkZpbGVSZWFkZXJcImluIGgpKGE9bmV3IEZpbGVSZWFkZXIpLm9ubG9hZD1hLm9uZXJyb3I9ZnVuY3Rpb24oKXtlKHRoaXMuZXJyb3IsdGhpcy5yZXN1bHQpfSxhLnJlYWRBc0FycmF5QnVmZmVyKHQpO2Vsc2V7dmFyIG4scixhPW5ldyBGaWxlUmVhZGVyU3luYzt0cnl7cj1hLnJlYWRBc0FycmF5QnVmZmVyKHQpfWNhdGNoKHQpe249dH1maW5hbGx5e2UobixyKX19ZWxzZSBpZigwLFwic3RyaW5nXCIhPXR5cGVvZiB0KWUobmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSB0eXBlLlwiKSk7ZWxzZSBpZihyPXQubWF0Y2goL15kYXRhOiguKz8pKDtiYXNlNjQpPywoLiopJC8pKXRyeXt2YXIgcz1yWzJdLG89clszXTtlKG51bGwsKHM/YXRvYjpkZWNvZGVVUklDb21wb25lbnQpKG8pKX1jYXRjaCh0KXtlKHQpfWVsc2VcIlhNTEh0dHBSZXF1ZXN0XCJpbiBoPygobz1uZXcgWE1MSHR0cFJlcXVlc3QpLm9wZW4oXCJHRVRcIix0LCEwKSxcInJlc3BvbnNlVHlwZVwiaW4gbz9vLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI6XCJvdmVycmlkZU1pbWVUeXBlXCJpbiBvP28ub3ZlcnJpZGVNaW1lVHlwZShcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIik6by5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0LUNoYXJzZXRcIixcIngtdXNlci1kZWZpbmVkXCIpLFwib25sb2FkXCJpbiBvfHwoby5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXs0PT09dGhpcy5yZWFkeVN0YXRlJiZ0aGlzLm9ubG9hZCgpfSksaT1mdW5jdGlvbih0KXtlKG5ldyBFcnJvcih0KSl9LG8ub25sb2FkPWZ1bmN0aW9uKCl7aWYoMCE9PXRoaXMuc3RhdHVzJiYyMDAhPT10aGlzLnN0YXR1cylyZXR1cm4gaShcIkhUVFAgRXJyb3IgI1wiK3RoaXMuc3RhdHVzK1wiOiBcIit0aGlzLnN0YXR1c1RleHQpO1wicmVzcG9uc2VcImluIHRoaXN8fCh0aGlzLnJlc3BvbnNlPW5ldyBWQkFycmF5KHRoaXMucmVzcG9uc2VCb2R5KS50b0FycmF5KCkpLGUobnVsbCx0aGlzLnJlc3BvbnNlKX0sby5vbmVycm9yPWZ1bmN0aW9uKCl7aShcIk5ldHdvcmsgZXJyb3IuXCIpfSxvLnNlbmQobnVsbCkpOmUobmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSB0eXBlLlwiKSl9KSwocy5sb2FkPXQoZnVuY3Rpb24odCxlLGkpe3ZhciBuPXMubG9hZERhdGEodCk7cy5sb2FkLmdldFR5cGVTZXQodCxlLGZ1bmN0aW9uKGUpe24udGhlbihmdW5jdGlvbih0KXtpKG51bGwsbmV3IHModCxlKSl9LGkpfSl9KSkuZ2V0VHlwZVNldD1mdW5jdGlvbih0LGUsaSl7aShlKX0scC5fdG9VUkk9XCJVUkxcImluIGgmJlwiY3JlYXRlT2JqZWN0VVJMXCJpbiBVUkw/ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zZWVrKDAsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldEJ5dGVzKCl9KTtyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbZV0se3R5cGU6dH0pKX06ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zZWVrKDAsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldFN0cmluZyh2b2lkIDAsdm9pZCAwLFwiYmluYXJ5XCIpfSk7cmV0dXJuXCJkYXRhOlwiK3QrXCI7YmFzZTY0LFwiK2J0b2EoZSl9LHAuX21pbWVUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0fHx0aGlzLnR5cGVTZXRbXCJqQmluYXJ5Lm1pbWVUeXBlXCJdfHxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifTt2YXIgbTtwLnRvVVJJPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90b1VSSSh0aGlzLl9taW1lVHlwZSh0KSl9O3JldHVybiBuJiYoKG09cy5kb3dubG9hZGVyPW4uY3JlYXRlRWxlbWVudChcImFcIikpLnN0eWxlLmRpc3BsYXk9XCJub25lXCIpLHAuc2F2ZUFzPXQoZnVuY3Rpb24odCxlLGkpe1wic3RyaW5nXCI9PXR5cGVvZiB0PyhcIm1zU2F2ZUJsb2JcImluIG5hdmlnYXRvcj9uYXZpZ2F0b3IubXNTYXZlQmxvYihuZXcgQmxvYihbdGhpcy5yZWFkKFwiYmxvYlwiLDApXSx7dHlwZTp0aGlzLl9taW1lVHlwZShlKX0pLHQpOm4/KG0ucGFyZW50Tm9kZXx8bi5ib2R5LmFwcGVuZENoaWxkKG0pLG0uaHJlZj10aGlzLnRvVVJJKGUpLG0uZG93bmxvYWQ9dCxtLmNsaWNrKCksbS5ocmVmPW0uZG93bmxvYWQ9XCJcIik6aShuZXcgVHlwZUVycm9yKFwiU2F2aW5nIGZyb20gV2ViIFdvcmtlciBpcyBub3Qgc3VwcG9ydGVkLlwiKSksaSgpKTppKG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBzdG9yYWdlIHR5cGUuXCIpKX0pLHN9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpiaW5hcnkuanMubWFwIiwiIWZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICB2YXIgZ2xvYmFsID0gdGhpcztcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZ2xvYmFsKTtcbn0oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gaXMob2JqLCBDdG9yKSB7XG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiICE9IHR5cGVvZiBvYmogfHwgbnVsbCA9PT0gb2JqID8gITEgOiBvYmouY29uc3RydWN0b3IgPT09IEN0b3IgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBcIiArIEN0b3IubmFtZSArIFwiXVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcnJheUZyb20oYXJyYXlMaWtlLCBmb3JjZUNvcHkpIHtcbiAgICAgICAgcmV0dXJuICFmb3JjZUNvcHkgJiYgaXMoYXJyYXlMaWtlLCBBcnJheSkgPyBhcnJheUxpa2UgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdmFsdWUgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gakRhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGlmIChqRGF0YVZpZXcuaXMoYnVmZmVyKSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Ll9saXR0bGVFbmRpYW4gPSBkZWZpbmVkKGxpdHRsZUVuZGlhbiwgcmVzdWx0Ll9saXR0bGVFbmRpYW4pLCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqRGF0YVZpZXcuaXModGhpcykpIHJldHVybiBuZXcgakRhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyID0gYnVmZmVyID0gakRhdGFWaWV3LndyYXBCdWZmZXIoYnVmZmVyKSwgdGhpcy5faXNBcnJheUJ1ZmZlciA9IGNvbXBhdGliaWxpdHkuQXJyYXlCdWZmZXIgJiYgaXMoYnVmZmVyLCBBcnJheUJ1ZmZlciksIFxuICAgICAgICB0aGlzLl9pc1BpeGVsRGF0YSA9ICExLCB0aGlzLl9pc0RhdGFWaWV3ID0gY29tcGF0aWJpbGl0eS5EYXRhVmlldyAmJiB0aGlzLl9pc0FycmF5QnVmZmVyLCBcbiAgICAgICAgdGhpcy5faXNOb2RlQnVmZmVyID0gITAgJiYgY29tcGF0aWJpbGl0eS5Ob2RlQnVmZmVyICYmIGlzKGJ1ZmZlciwgQnVmZmVyKSwgIXRoaXMuX2lzTm9kZUJ1ZmZlciAmJiAhdGhpcy5faXNBcnJheUJ1ZmZlciAmJiAhaXMoYnVmZmVyLCBBcnJheSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJqRGF0YVZpZXcgYnVmZmVyIGhhcyBhbiBpbmNvbXBhdGlibGUgdHlwZVwiKTtcbiAgICAgICAgdGhpcy5fbGl0dGxlRW5kaWFuID0gISFsaXR0bGVFbmRpYW47XG4gICAgICAgIHZhciBidWZmZXJMZW5ndGggPSBcImJ5dGVMZW5ndGhcIiBpbiBidWZmZXIgPyBidWZmZXIuYnl0ZUxlbmd0aCA6IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQgPSBkZWZpbmVkKGJ5dGVPZmZzZXQsIDApLCB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID0gZGVmaW5lZChieXRlTGVuZ3RoLCBidWZmZXJMZW5ndGggLSBieXRlT2Zmc2V0KSwgXG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX2JpdE9mZnNldCA9IDAsIHRoaXMuX2lzRGF0YVZpZXcgPyB0aGlzLl92aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkgOiB0aGlzLl9jaGVja0JvdW5kcyhieXRlT2Zmc2V0LCBieXRlTGVuZ3RoLCBidWZmZXJMZW5ndGgpLCBcbiAgICAgICAgdGhpcy5fZW5naW5lQWN0aW9uID0gdGhpcy5faXNEYXRhVmlldyA/IHRoaXMuX2RhdGFWaWV3QWN0aW9uIDogdGhpcy5faXNOb2RlQnVmZmVyID8gdGhpcy5fbm9kZUJ1ZmZlckFjdGlvbiA6IHRoaXMuX2lzQXJyYXlCdWZmZXIgPyB0aGlzLl9hcnJheUJ1ZmZlckFjdGlvbiA6IHRoaXMuX2FycmF5QWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGFyQ29kZXMoc3RyaW5nKSB7XG4gICAgICAgIGlmIChjb21wYXRpYmlsaXR5Lk5vZGVCdWZmZXIpIHJldHVybiBuZXcgQnVmZmVyKHN0cmluZywgXCJiaW5hcnlcIik7XG4gICAgICAgIGZvciAodmFyIFR5cGUgPSBjb21wYXRpYmlsaXR5LkFycmF5QnVmZmVyID8gVWludDhBcnJheSA6IEFycmF5LCBjb2RlcyA9IG5ldyBUeXBlKHN0cmluZy5sZW5ndGgpLCBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgbGVuZ3RoID4gaTsgaSsrKSBjb2Rlc1tpXSA9IDI1NSAmIHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICByZXR1cm4gY29kZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvdzIobikge1xuICAgICAgICByZXR1cm4gbiA+PSAwICYmIDMxID4gbiA/IDEgPDwgbiA6IHBvdzJbbl0gfHwgKHBvdzJbbl0gPSBNYXRoLnBvdygyLCBuKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVpbnQ2NChsbywgaGkpIHtcbiAgICAgICAgdGhpcy5sbyA9IGxvLCB0aGlzLmhpID0gaGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludDY0KCkge1xuICAgICAgICBVaW50NjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdmFyIGNvbXBhdGliaWxpdHkgPSB7XG4gICAgICAgIE5vZGVCdWZmZXI6ICEwICYmIFwiQnVmZmVyXCIgaW4gZ2xvYmFsLFxuICAgICAgICBEYXRhVmlldzogXCJEYXRhVmlld1wiIGluIGdsb2JhbCxcbiAgICAgICAgQXJyYXlCdWZmZXI6IFwiQXJyYXlCdWZmZXJcIiBpbiBnbG9iYWwsXG4gICAgICAgIFBpeGVsRGF0YTogITFcbiAgICB9LCBUZXh0RW5jb2RlciA9IGdsb2JhbC5UZXh0RW5jb2RlciwgVGV4dERlY29kZXIgPSBnbG9iYWwuVGV4dERlY29kZXI7XG4gICAgY29tcGF0aWJpbGl0eS5Ob2RlQnVmZmVyICYmICFmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0TEUoMS8wLCAwKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29tcGF0aWJpbGl0eS5Ob2RlQnVmZmVyID0gITE7XG4gICAgICAgIH1cbiAgICB9KG5ldyBCdWZmZXIoNCkpO1xuICAgIHZhciBkYXRhVHlwZXMgPSB7XG4gICAgICAgIEludDg6IDEsXG4gICAgICAgIEludDE2OiAyLFxuICAgICAgICBJbnQzMjogNCxcbiAgICAgICAgVWludDg6IDEsXG4gICAgICAgIFVpbnQxNjogMixcbiAgICAgICAgVWludDMyOiA0LFxuICAgICAgICBGbG9hdDMyOiA0LFxuICAgICAgICBGbG9hdDY0OiA4XG4gICAgfTtcbiAgICBqRGF0YVZpZXcud3JhcEJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBidWZmZXIpIHtcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpZiAoY29tcGF0aWJpbGl0eS5Ob2RlQnVmZmVyKSBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlciksIGJ1ZmZlci5maWxsKDApOyBlbHNlIGlmIChjb21wYXRpYmlsaXR5LkFycmF5QnVmZmVyKSBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpLmJ1ZmZlcjsgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuXG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgYnVmZmVyID0gZ2V0Q2hhckNvZGVzKGJ1ZmZlcik7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwibGVuZ3RoXCIgaW4gYnVmZmVyICYmICEoY29tcGF0aWJpbGl0eS5Ob2RlQnVmZmVyICYmIGlzKGJ1ZmZlciwgQnVmZmVyKSB8fCBjb21wYXRpYmlsaXR5LkFycmF5QnVmZmVyICYmIGlzKGJ1ZmZlciwgQXJyYXlCdWZmZXIpKSAmJiAoY29tcGF0aWJpbGl0eS5Ob2RlQnVmZmVyID8gYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIpIDogY29tcGF0aWJpbGl0eS5BcnJheUJ1ZmZlciA/IGlzKGJ1ZmZlciwgQXJyYXlCdWZmZXIpIHx8IChidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpLmJ1ZmZlciwgXG4gICAgICAgICAgICBpcyhidWZmZXIsIEFycmF5QnVmZmVyKSB8fCAoYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlGcm9tKGJ1ZmZlciwgITApKS5idWZmZXIpKSA6IGJ1ZmZlciA9IGFycmF5RnJvbShidWZmZXIpKSwgXG4gICAgICAgICAgICBidWZmZXI7XG4gICAgICAgIH1cbiAgICB9LCBqRGF0YVZpZXcuaXMgPSBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3ICYmIHZpZXcuakRhdGFWaWV3O1xuICAgIH0sIGpEYXRhVmlldy5mcm9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgakRhdGFWaWV3KGFyZ3VtZW50cyk7XG4gICAgfSwgakRhdGFWaWV3LlVpbnQ2NCA9IFVpbnQ2NCwgVWludDY0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sbyArIHBvdzIoMzIpICogdGhpcy5oaTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodGhpcy52YWx1ZU9mKCksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LCBVaW50NjQuZnJvbU51bWJlciA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKG51bWJlciAvIHBvdzIoMzIpKSwgbG8gPSBudW1iZXIgLSBoaSAqIHBvdzIoMzIpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ2NChsbywgaGkpO1xuICAgIH0sIGpEYXRhVmlldy5JbnQ2NCA9IEludDY0LCBJbnQ2NC5wcm90b3R5cGUgPSBcImNyZWF0ZVwiIGluIE9iamVjdCA/IE9iamVjdC5jcmVhdGUoVWludDY0LnByb3RvdHlwZSkgOiBuZXcgVWludDY0KCksIFxuICAgIEludDY0LnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpIDwgcG93MigzMSkgPyBVaW50NjQucHJvdG90eXBlLnZhbHVlT2YuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC0ocG93MigzMikgLSB0aGlzLmxvICsgcG93MigzMikgKiAocG93MigzMikgLSAxIC0gdGhpcy5oaSkpO1xuICAgIH0sIEludDY0LmZyb21OdW1iZXIgPSBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgdmFyIGxvLCBoaTtcbiAgICAgICAgaWYgKG51bWJlciA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgdW5zaWduZWQgPSBVaW50NjQuZnJvbU51bWJlcihudW1iZXIpO1xuICAgICAgICAgICAgbG8gPSB1bnNpZ25lZC5sbywgaGkgPSB1bnNpZ25lZC5oaTtcbiAgICAgICAgfSBlbHNlIGhpID0gTWF0aC5mbG9vcihudW1iZXIgLyBwb3cyKDMyKSksIGxvID0gbnVtYmVyIC0gaGkgKiBwb3cyKDMyKSwgaGkgKz0gcG93MigzMik7XG4gICAgICAgIHJldHVybiBuZXcgSW50NjQobG8sIGhpKTtcbiAgICB9O1xuICAgIHZhciBwcm90byA9IGpEYXRhVmlldy5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbXBhdGliaWxpdHk6IGNvbXBhdGliaWxpdHksXG4gICAgICAgIGpEYXRhVmlldzogITAsXG4gICAgICAgIF9jaGVja0JvdW5kczogZnVuY3Rpb24oYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgYnl0ZU9mZnNldCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9mZnNldCBpcyBub3QgYSBudW1iZXIuXCIpO1xuICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIGJ5dGVMZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTaXplIGlzIG5vdCBhIG51bWJlci5cIik7XG4gICAgICAgICAgICBpZiAoMCA+IGJ5dGVMZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGVuZ3RoIGlzIG5lZ2F0aXZlLlwiKTtcbiAgICAgICAgICAgIGlmICgwID4gYnl0ZU9mZnNldCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGRlZmluZWQobWF4TGVuZ3RoLCB0aGlzLmJ5dGVMZW5ndGgpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk9mZnNldHMgYXJlIG91dCBvZiBib3VuZHMuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBfYWN0aW9uOiBmdW5jdGlvbih0eXBlLCBpc1JlYWRBY3Rpb24sIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbiwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmdpbmVBY3Rpb24odHlwZSwgaXNSZWFkQWN0aW9uLCBkZWZpbmVkKGJ5dGVPZmZzZXQsIHRoaXMuX29mZnNldCksIGRlZmluZWQobGl0dGxlRW5kaWFuLCB0aGlzLl9saXR0bGVFbmRpYW4pLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9kYXRhVmlld0FjdGlvbjogZnVuY3Rpb24odHlwZSwgaXNSZWFkQWN0aW9uLCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID0gYnl0ZU9mZnNldCArIGRhdGFUeXBlc1t0eXBlXSwgaXNSZWFkQWN0aW9uID8gdGhpcy5fdmlld1tcImdldFwiICsgdHlwZV0oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSA6IHRoaXMuX3ZpZXdbXCJzZXRcIiArIHR5cGVdKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBfYXJyYXlCdWZmZXJBY3Rpb246IGZ1bmN0aW9uKHR5cGUsIGlzUmVhZEFjdGlvbiwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXksIHNpemUgPSBkYXRhVHlwZXNbdHlwZV0sIFR5cGVkQXJyYXkgPSBnbG9iYWxbdHlwZSArIFwiQXJyYXlcIl07XG4gICAgICAgICAgICBpZiAobGl0dGxlRW5kaWFuID0gZGVmaW5lZChsaXR0bGVFbmRpYW4sIHRoaXMuX2xpdHRsZUVuZGlhbiksIDEgPT09IHNpemUgfHwgKHRoaXMuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQpICUgc2l6ZSA9PT0gMCAmJiBsaXR0bGVFbmRpYW4pIHJldHVybiB0eXBlZEFycmF5ID0gbmV3IFR5cGVkQXJyYXkodGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQsIDEpLCBcbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGJ5dGVPZmZzZXQgKyBzaXplLCBpc1JlYWRBY3Rpb24gPyB0eXBlZEFycmF5WzBdIDogdHlwZWRBcnJheVswXSA9IHZhbHVlO1xuICAgICAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaXNSZWFkQWN0aW9uID8gdGhpcy5nZXRCeXRlcyhzaXplLCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sICEwKSA6IHNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXkgPSBuZXcgVHlwZWRBcnJheShieXRlcy5idWZmZXIsIDAsIDEpLCBpc1JlYWRBY3Rpb24gPyB0eXBlZEFycmF5WzBdIDogKHR5cGVkQXJyYXlbMF0gPSB2YWx1ZSwgXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3NldEJ5dGVzKGJ5dGVPZmZzZXQsIGJ5dGVzLCBsaXR0bGVFbmRpYW4pKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2FycmF5QWN0aW9uOiBmdW5jdGlvbih0eXBlLCBpc1JlYWRBY3Rpb24sIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbiwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRBY3Rpb24gPyB0aGlzW1wiX2dldFwiICsgdHlwZV0oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSA6IHRoaXNbXCJfc2V0XCIgKyB0eXBlXShieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEJ5dGVzOiBmdW5jdGlvbihsZW5ndGgsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gZGVmaW5lZChsaXR0bGVFbmRpYW4sIHRoaXMuX2xpdHRsZUVuZGlhbiksIGJ5dGVPZmZzZXQgPSBkZWZpbmVkKGJ5dGVPZmZzZXQsIHRoaXMuX29mZnNldCksIFxuICAgICAgICAgICAgbGVuZ3RoID0gZGVmaW5lZChsZW5ndGgsIHRoaXMuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQpLCB0aGlzLl9jaGVja0JvdW5kcyhieXRlT2Zmc2V0LCBsZW5ndGgpLCBcbiAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gdGhpcy5ieXRlT2Zmc2V0LCB0aGlzLl9vZmZzZXQgPSBieXRlT2Zmc2V0IC0gdGhpcy5ieXRlT2Zmc2V0ICsgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2lzQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSA6ICh0aGlzLmJ1ZmZlci5zbGljZSB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UpLmNhbGwodGhpcy5idWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGxpdHRsZUVuZGlhbiB8fCAxID49IGxlbmd0aCA/IHJlc3VsdCA6IGFycmF5RnJvbShyZXN1bHQpLnJldmVyc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Qnl0ZXM6IGZ1bmN0aW9uKGxlbmd0aCwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuLCB0b0FycmF5KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0Qnl0ZXMobGVuZ3RoLCBieXRlT2Zmc2V0LCBkZWZpbmVkKGxpdHRsZUVuZGlhbiwgITApKTtcbiAgICAgICAgICAgIHJldHVybiB0b0FycmF5ID8gYXJyYXlGcm9tKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRCeXRlczogZnVuY3Rpb24oYnl0ZU9mZnNldCwgYnl0ZXMsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgwICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGl0dGxlRW5kaWFuID0gZGVmaW5lZChsaXR0bGVFbmRpYW4sIHRoaXMuX2xpdHRsZUVuZGlhbiksIGJ5dGVPZmZzZXQgPSBkZWZpbmVkKGJ5dGVPZmZzZXQsIHRoaXMuX29mZnNldCksIFxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQm91bmRzKGJ5dGVPZmZzZXQsIGxlbmd0aCksICFsaXR0bGVFbmRpYW4gJiYgbGVuZ3RoID4gMSAmJiAoYnl0ZXMgPSBhcnJheUZyb20oYnl0ZXMsICEwKS5yZXZlcnNlKCkpLCBcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IHRoaXMuYnl0ZU9mZnNldCwgdGhpcy5faXNBcnJheUJ1ZmZlcikgbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCkuc2V0KGJ5dGVzKTsgZWxzZSBpZiAodGhpcy5faXNOb2RlQnVmZmVyKSBuZXcgQnVmZmVyKGJ5dGVzKS5jb3B5KHRoaXMuYnVmZmVyLCBieXRlT2Zmc2V0KTsgZWxzZSBmb3IgKHZhciBpID0gMDsgbGVuZ3RoID4gaTsgaSsrKSB0aGlzLmJ1ZmZlcltieXRlT2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBieXRlT2Zmc2V0IC0gdGhpcy5ieXRlT2Zmc2V0ICsgbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRCeXRlczogZnVuY3Rpb24oYnl0ZU9mZnNldCwgYnl0ZXMsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0Qnl0ZXMoYnl0ZU9mZnNldCwgYnl0ZXMsIGRlZmluZWQobGl0dGxlRW5kaWFuLCAhMCkpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTdHJpbmc6IGZ1bmN0aW9uKGJ5dGVMZW5ndGgsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNOb2RlQnVmZmVyKSByZXR1cm4gYnl0ZU9mZnNldCA9IGRlZmluZWQoYnl0ZU9mZnNldCwgdGhpcy5fb2Zmc2V0KSwgYnl0ZUxlbmd0aCA9IGRlZmluZWQoYnl0ZUxlbmd0aCwgdGhpcy5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldCksIFxuICAgICAgICAgICAgdGhpcy5fY2hlY2tCb3VuZHMoYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCksIHRoaXMuX29mZnNldCA9IGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoLCBcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nIHx8IFwiYmluYXJ5XCIsIHRoaXMuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQsIHRoaXMuYnl0ZU9mZnNldCArIHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICB2YXIgYnl0ZXMgPSB0aGlzLl9nZXRCeXRlcyhieXRlTGVuZ3RoLCBieXRlT2Zmc2V0LCAhMCk7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPSBcInV0ZjhcIiA9PT0gZW5jb2RpbmcgPyBcInV0Zi04XCIgOiBlbmNvZGluZyB8fCBcImJpbmFyeVwiLCBUZXh0RGVjb2RlciAmJiBcImJpbmFyeVwiICE9PSBlbmNvZGluZykgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZykuZGVjb2RlKHRoaXMuX2lzQXJyYXlCdWZmZXIgPyBieXRlcyA6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgYnl0ZUxlbmd0aCA+IGk7IGkrKykgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgICAgICAgICAgcmV0dXJuIFwidXRmLThcIiA9PT0gZW5jb2RpbmcgJiYgKHN0cmluZyA9IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyaW5nKSkpLCBzdHJpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFN0cmluZzogZnVuY3Rpb24oYnl0ZU9mZnNldCwgc3ViU3RyaW5nLCBlbmNvZGluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTm9kZUJ1ZmZlcikgcmV0dXJuIGJ5dGVPZmZzZXQgPSBkZWZpbmVkKGJ5dGVPZmZzZXQsIHRoaXMuX29mZnNldCksIHRoaXMuX2NoZWNrQm91bmRzKGJ5dGVPZmZzZXQsIHN1YlN0cmluZy5sZW5ndGgpLCBcbiAgICAgICAgICAgIHZvaWQgKHRoaXMuX29mZnNldCA9IGJ5dGVPZmZzZXQgKyB0aGlzLmJ1ZmZlci53cml0ZShzdWJTdHJpbmcsIHRoaXMuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQsIGVuY29kaW5nIHx8IFwiYmluYXJ5XCIpKTtcbiAgICAgICAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCIgPT09IGVuY29kaW5nID8gXCJ1dGYtOFwiIDogZW5jb2RpbmcgfHwgXCJiaW5hcnlcIjtcbiAgICAgICAgICAgIHZhciBieXRlcztcbiAgICAgICAgICAgIFRleHRFbmNvZGVyICYmIFwiYmluYXJ5XCIgIT09IGVuY29kaW5nID8gYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoZW5jb2RpbmcpLmVuY29kZShzdWJTdHJpbmcpIDogKFwidXRmLThcIiA9PT0gZW5jb2RpbmcgJiYgKHN1YlN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdWJTdHJpbmcpKSksIFxuICAgICAgICAgICAgYnl0ZXMgPSBnZXRDaGFyQ29kZXMoc3ViU3RyaW5nKSksIHRoaXMuX3NldEJ5dGVzKGJ5dGVPZmZzZXQsIGJ5dGVzLCAhMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENoYXI6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0cmluZygxLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2hhcjogZnVuY3Rpb24oYnl0ZU9mZnNldCwgY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhieXRlT2Zmc2V0LCBjaGFyYWN0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0ZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNlZWs6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0JvdW5kcyhieXRlT2Zmc2V0LCAwKSwgdGhpcy5fb2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgc2tpcDogZnVuY3Rpb24oYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vlayh0aGlzLl9vZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGZvcmNlQ29weSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwID4gb2Zmc2V0ID8gb2Zmc2V0ICsgYnl0ZUxlbmd0aCA6IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydCA9IG5vcm1hbGl6ZU9mZnNldChzdGFydCwgdGhpcy5ieXRlTGVuZ3RoKSwgZW5kID0gbm9ybWFsaXplT2Zmc2V0KGRlZmluZWQoZW5kLCB0aGlzLmJ5dGVMZW5ndGgpLCB0aGlzLmJ5dGVMZW5ndGgpLCBcbiAgICAgICAgICAgIGZvcmNlQ29weSA/IG5ldyBqRGF0YVZpZXcodGhpcy5nZXRCeXRlcyhlbmQgLSBzdGFydCwgc3RhcnQsICEwLCAhMCksIHZvaWQgMCwgdm9pZCAwLCB0aGlzLl9saXR0bGVFbmRpYW4pIDogbmV3IGpEYXRhVmlldyh0aGlzLmJ1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgc3RhcnQsIGVuZCAtIHN0YXJ0LCB0aGlzLl9saXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBhbGlnbkJ5OiBmdW5jdGlvbihieXRlQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaXRPZmZzZXQgPSAwLCAxICE9PSBkZWZpbmVkKGJ5dGVDb3VudCwgMSkgPyB0aGlzLnNraXAoYnl0ZUNvdW50IC0gKHRoaXMuX29mZnNldCAlIGJ5dGVDb3VudCB8fCBieXRlQ291bnQpKSA6IHRoaXMuX29mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEZsb2F0NjQ6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9nZXRCeXRlcyg4LCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pLCBzaWduID0gMSAtIDIgKiAoYls3XSA+PiA3KSwgZXhwb25lbnQgPSAoKGJbN10gPDwgMSAmIDI1NSkgPDwgMyB8IGJbNl0gPj4gNCkgLSAxMDIzLCBtYW50aXNzYSA9ICgxNSAmIGJbNl0pICogcG93Mig0OCkgKyBiWzVdICogcG93Mig0MCkgKyBiWzRdICogcG93MigzMikgKyBiWzNdICogcG93MigyNCkgKyBiWzJdICogcG93MigxNikgKyBiWzFdICogcG93Mig4KSArIGJbMF07XG4gICAgICAgICAgICByZXR1cm4gMTAyNCA9PT0gZXhwb25lbnQgPyAwICE9PSBtYW50aXNzYSA/IDAvMCA6IDEvMCAqIHNpZ24gOiAtMTAyMyA9PT0gZXhwb25lbnQgPyBzaWduICogbWFudGlzc2EgKiBwb3cyKC0xMDc0KSA6IHNpZ24gKiAoMSArIG1hbnRpc3NhICogcG93MigtNTIpKSAqIHBvdzIoZXhwb25lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0RmxvYXQzMjogZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuX2dldEJ5dGVzKDQsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbiksIHNpZ24gPSAxIC0gMiAqIChiWzNdID4+IDcpLCBleHBvbmVudCA9IChiWzNdIDw8IDEgJiAyNTUgfCBiWzJdID4+IDcpIC0gMTI3LCBtYW50aXNzYSA9ICgxMjcgJiBiWzJdKSA8PCAxNiB8IGJbMV0gPDwgOCB8IGJbMF07XG4gICAgICAgICAgICByZXR1cm4gMTI4ID09PSBleHBvbmVudCA/IDAgIT09IG1hbnRpc3NhID8gMC8wIDogMS8wICogc2lnbiA6IC0xMjcgPT09IGV4cG9uZW50ID8gc2lnbiAqIG1hbnRpc3NhICogcG93MigtMTQ5KSA6IHNpZ24gKiAoMSArIG1hbnRpc3NhICogcG93MigtMjMpKSAqIHBvdzIoZXhwb25lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0NjQ6IGZ1bmN0aW9uKFR5cGUsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gZGVmaW5lZChsaXR0bGVFbmRpYW4sIHRoaXMuX2xpdHRsZUVuZGlhbiksIGJ5dGVPZmZzZXQgPSBkZWZpbmVkKGJ5dGVPZmZzZXQsIHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICBmb3IgKHZhciBwYXJ0cyA9IGxpdHRsZUVuZGlhbiA/IFsgMCwgNCBdIDogWyA0LCAwIF0sIGkgPSAwOyAyID4gaTsgaSsrKSBwYXJ0c1tpXSA9IHRoaXMuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyBwYXJ0c1tpXSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPSBieXRlT2Zmc2V0ICsgOCwgbmV3IFR5cGUocGFydHNbMF0sIHBhcnRzWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SW50NjQ6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldDY0KEludDY0LCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRVaW50NjQ6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldDY0KFVpbnQ2NCwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEludDMyOiBmdW5jdGlvbihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fZ2V0Qnl0ZXMoNCwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIHJldHVybiBiWzNdIDw8IDI0IHwgYlsyXSA8PCAxNiB8IGJbMV0gPDwgOCB8IGJbMF07XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRVaW50MzI6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludDMyKGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikgPj4+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRJbnQxNjogZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VWludDE2KGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikgPDwgMTYgPj4gMTY7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRVaW50MTY6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9nZXRCeXRlcygyLCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGJbMV0gPDwgOCB8IGJbMF07XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRJbnQ4OiBmdW5jdGlvbihieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VWludDgoYnl0ZU9mZnNldCkgPDwgMjQgPj4gMjQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRVaW50ODogZnVuY3Rpb24oYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5dGVzKDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0Qml0UmFuZ2VEYXRhOiBmdW5jdGlvbihiaXRMZW5ndGgsIGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydEJpdCA9IChkZWZpbmVkKGJ5dGVPZmZzZXQsIHRoaXMuX29mZnNldCkgPDwgMykgKyB0aGlzLl9iaXRPZmZzZXQsIGVuZEJpdCA9IHN0YXJ0Qml0ICsgYml0TGVuZ3RoLCBzdGFydCA9IHN0YXJ0Qml0ID4+PiAzLCBlbmQgPSBlbmRCaXQgKyA3ID4+PiAzLCBiID0gdGhpcy5fZ2V0Qnl0ZXMoZW5kIC0gc3RhcnQsIHN0YXJ0LCAhMCksIHdpZGVWYWx1ZSA9IDA7XG4gICAgICAgICAgICAodGhpcy5fYml0T2Zmc2V0ID0gNyAmIGVuZEJpdCkgJiYgKHRoaXMuX2JpdE9mZnNldCAtPSA4KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBiLmxlbmd0aDsgbGVuZ3RoID4gaTsgaSsrKSB3aWRlVmFsdWUgPSB3aWRlVmFsdWUgPDwgOCB8IGJbaV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBieXRlczogYixcbiAgICAgICAgICAgICAgICB3aWRlVmFsdWU6IHdpZGVWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2lnbmVkOiBmdW5jdGlvbihiaXRMZW5ndGgsIGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IDMyIC0gYml0TGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VW5zaWduZWQoYml0TGVuZ3RoLCBieXRlT2Zmc2V0KSA8PCBzaGlmdCA+PiBzaGlmdDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VW5zaWduZWQ6IGZ1bmN0aW9uKGJpdExlbmd0aCwgYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0Qml0UmFuZ2VEYXRhKGJpdExlbmd0aCwgYnl0ZU9mZnNldCkud2lkZVZhbHVlID4+PiAtdGhpcy5fYml0T2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIDMyID4gYml0TGVuZ3RoID8gdmFsdWUgJiB+KC0xIDw8IGJpdExlbmd0aCkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldEJpbmFyeUZsb2F0OiBmdW5jdGlvbihieXRlT2Zmc2V0LCB2YWx1ZSwgbWFudFNpemUsIGV4cFNpemUsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFyIGV4cG9uZW50LCBtYW50aXNzYSwgc2lnbkJpdCA9IDAgPiB2YWx1ZSA/IDEgOiAwLCBlTWF4ID0gfigtMSA8PCBleHBTaXplIC0gMSksIGVNaW4gPSAxIC0gZU1heDtcbiAgICAgICAgICAgIDAgPiB2YWx1ZSAmJiAodmFsdWUgPSAtdmFsdWUpLCAwID09PSB2YWx1ZSA/IChleHBvbmVudCA9IDAsIG1hbnRpc3NhID0gMCkgOiBpc05hTih2YWx1ZSkgPyAoZXhwb25lbnQgPSAyICogZU1heCArIDEsIFxuICAgICAgICAgICAgbWFudGlzc2EgPSAxKSA6IDEvMCA9PT0gdmFsdWUgPyAoZXhwb25lbnQgPSAyICogZU1heCArIDEsIG1hbnRpc3NhID0gMCkgOiAoZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKSwgXG4gICAgICAgICAgICBleHBvbmVudCA+PSBlTWluICYmIGVNYXggPj0gZXhwb25lbnQgPyAobWFudGlzc2EgPSBNYXRoLmZsb29yKCh2YWx1ZSAqIHBvdzIoLWV4cG9uZW50KSAtIDEpICogcG93MihtYW50U2l6ZSkpLCBcbiAgICAgICAgICAgIGV4cG9uZW50ICs9IGVNYXgpIDogKG1hbnRpc3NhID0gTWF0aC5mbG9vcih2YWx1ZSAvIHBvdzIoZU1pbiAtIG1hbnRTaXplKSksIGV4cG9uZW50ID0gMCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IFtdOyBtYW50U2l6ZSA+PSA4OyApIGIucHVzaChtYW50aXNzYSAlIDI1NiksIG1hbnRpc3NhID0gTWF0aC5mbG9vcihtYW50aXNzYSAvIDI1NiksIFxuICAgICAgICAgICAgbWFudFNpemUgLT0gODtcbiAgICAgICAgICAgIGZvciAoZXhwb25lbnQgPSBleHBvbmVudCA8PCBtYW50U2l6ZSB8IG1hbnRpc3NhLCBleHBTaXplICs9IG1hbnRTaXplOyBleHBTaXplID49IDg7ICkgYi5wdXNoKDI1NSAmIGV4cG9uZW50KSwgXG4gICAgICAgICAgICBleHBvbmVudCA+Pj49IDgsIGV4cFNpemUgLT0gODtcbiAgICAgICAgICAgIGIucHVzaChzaWduQml0IDw8IGV4cFNpemUgfCBleHBvbmVudCksIHRoaXMuX3NldEJ5dGVzKGJ5dGVPZmZzZXQsIGIsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRGbG9hdDMyOiBmdW5jdGlvbihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRCaW5hcnlGbG9hdChieXRlT2Zmc2V0LCB2YWx1ZSwgMjMsIDgsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRGbG9hdDY0OiBmdW5jdGlvbihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRCaW5hcnlGbG9hdChieXRlT2Zmc2V0LCB2YWx1ZSwgNTIsIDExLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0NjQ6IGZ1bmN0aW9uKFR5cGUsIGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbHVlICYmICh2YWx1ZSA9IFR5cGUuZnJvbU51bWJlcih2YWx1ZSkpLCBsaXR0bGVFbmRpYW4gPSBkZWZpbmVkKGxpdHRsZUVuZGlhbiwgdGhpcy5fbGl0dGxlRW5kaWFuKSwgXG4gICAgICAgICAgICBieXRlT2Zmc2V0ID0gZGVmaW5lZChieXRlT2Zmc2V0LCB0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gbGl0dGxlRW5kaWFuID8ge1xuICAgICAgICAgICAgICAgIGxvOiAwLFxuICAgICAgICAgICAgICAgIGhpOiA0XG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGxvOiA0LFxuICAgICAgICAgICAgICAgIGhpOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgcGFydE5hbWUgaW4gcGFydHMpIHRoaXMuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBwYXJ0c1twYXJ0TmFtZV0sIHZhbHVlW3BhcnROYW1lXSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGJ5dGVPZmZzZXQgKyA4O1xuICAgICAgICB9LFxuICAgICAgICBzZXRJbnQ2NDogZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0NjQoSW50NjQsIGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRVaW50NjQ6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldDY0KFVpbnQ2NCwgYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRVaW50MzI6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEJ5dGVzKGJ5dGVPZmZzZXQsIFsgMjU1ICYgdmFsdWUsIHZhbHVlID4+PiA4ICYgMjU1LCB2YWx1ZSA+Pj4gMTYgJiAyNTUsIHZhbHVlID4+PiAyNCBdLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0VWludDE2OiBmdW5jdGlvbihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRCeXRlcyhieXRlT2Zmc2V0LCBbIDI1NSAmIHZhbHVlLCB2YWx1ZSA+Pj4gOCAmIDI1NSBdLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0VWludDg6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRCeXRlcyhieXRlT2Zmc2V0LCBbIDI1NSAmIHZhbHVlIF0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRVbnNpZ25lZDogZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUsIGJpdExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9nZXRCaXRSYW5nZURhdGEoYml0TGVuZ3RoLCBieXRlT2Zmc2V0KSwgd2lkZVZhbHVlID0gZGF0YS53aWRlVmFsdWUsIGIgPSBkYXRhLmJ5dGVzO1xuICAgICAgICAgICAgd2lkZVZhbHVlICY9IH4ofigtMSA8PCBiaXRMZW5ndGgpIDw8IC10aGlzLl9iaXRPZmZzZXQpLCB3aWRlVmFsdWUgfD0gKDMyID4gYml0TGVuZ3RoID8gdmFsdWUgJiB+KC0xIDw8IGJpdExlbmd0aCkgOiB2YWx1ZSkgPDwgLXRoaXMuX2JpdE9mZnNldDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBiLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBiW2ldID0gMjU1ICYgd2lkZVZhbHVlLCB3aWRlVmFsdWUgPj4+PSA4O1xuICAgICAgICAgICAgdGhpcy5fc2V0Qnl0ZXMoZGF0YS5zdGFydCwgYiwgITApO1xuICAgICAgICB9XG4gICAgfSwgbm9kZU5hbWluZyA9IHtcbiAgICAgICAgSW50ODogXCJJbnQ4XCIsXG4gICAgICAgIEludDE2OiBcIkludDE2XCIsXG4gICAgICAgIEludDMyOiBcIkludDMyXCIsXG4gICAgICAgIFVpbnQ4OiBcIlVJbnQ4XCIsXG4gICAgICAgIFVpbnQxNjogXCJVSW50MTZcIixcbiAgICAgICAgVWludDMyOiBcIlVJbnQzMlwiLFxuICAgICAgICBGbG9hdDMyOiBcIkZsb2F0XCIsXG4gICAgICAgIEZsb2F0NjQ6IFwiRG91YmxlXCJcbiAgICB9O1xuICAgIHByb3RvLl9ub2RlQnVmZmVyQWN0aW9uID0gZnVuY3Rpb24odHlwZSwgaXNSZWFkQWN0aW9uLCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGJ5dGVPZmZzZXQgKyBkYXRhVHlwZXNbdHlwZV07XG4gICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGVOYW1pbmdbdHlwZV0gKyAoXCJJbnQ4XCIgPT09IHR5cGUgfHwgXCJVaW50OFwiID09PSB0eXBlID8gXCJcIiA6IGxpdHRsZUVuZGlhbiA/IFwiTEVcIiA6IFwiQkVcIik7XG4gICAgICAgIHJldHVybiBieXRlT2Zmc2V0ICs9IHRoaXMuYnl0ZU9mZnNldCwgaXNSZWFkQWN0aW9uID8gdGhpcy5idWZmZXJbXCJyZWFkXCIgKyBub2RlTmFtZV0oYnl0ZU9mZnNldCkgOiB0aGlzLmJ1ZmZlcltcIndyaXRlXCIgKyBub2RlTmFtZV0odmFsdWUsIGJ5dGVPZmZzZXQpO1xuICAgIH07XG4gICAgZm9yICh2YXIgdHlwZSBpbiBkYXRhVHlwZXMpICFmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHByb3RvW1wiZ2V0XCIgKyB0eXBlXSA9IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbih0eXBlLCAhMCwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgfSwgcHJvdG9bXCJzZXRcIiArIHR5cGVdID0gZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uKHR5cGUsICExLCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9KHR5cGUpO1xuICAgIHByb3RvLl9zZXRJbnQzMiA9IHByb3RvLl9zZXRVaW50MzIsIHByb3RvLl9zZXRJbnQxNiA9IHByb3RvLl9zZXRVaW50MTYsIHByb3RvLl9zZXRJbnQ4ID0gcHJvdG8uX3NldFVpbnQ4LCBcbiAgICBwcm90by5zZXRTaWduZWQgPSBwcm90by5zZXRVbnNpZ25lZDtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gcHJvdG8pIFwic2V0XCIgPT09IG1ldGhvZC5zbGljZSgwLCAzKSAmJiAhZnVuY3Rpb24odHlwZSkge1xuICAgICAgICBwcm90b1tcIndyaXRlXCIgKyB0eXBlXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbChhcmd1bWVudHMsIHZvaWQgMCksIHRoaXNbXCJzZXRcIiArIHR5cGVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfShtZXRob2Quc2xpY2UoMykpO1xuICAgIHJldHVybiBqRGF0YVZpZXc7XG59KTsiLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5BRFRTID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0cmV0dXJuIHtcblx0XHRBRFRTUGFja2V0OiB7XG5cdFx0XHRfc3RhcnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuYmluYXJ5LnRlbGwoKSB9LFxuXHRcdFx0X3N5bmNXb3JkOiBbJ2NvbnN0JywgMTIsIDB4ZmZmLCB0cnVlXSxcblx0XHRcdHZlcnNpb246IFsnZW51bScsIDEsIFsnbXBlZy00JywgJ21wZWctMiddXSxcblx0XHRcdGxheWVyOiBbJ2NvbnN0JywgMiwgMF0sXG5cdFx0XHRpc1Byb3RlY3Rpb25BYnNlbnQ6IDEsXG5cdFx0XHRwcm9maWxlTWludXNPbmU6IDIsIC8vIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19PYmplY3RfVHlwZXMgbWludXMgb25lXG5cdFx0XHRzYW1wbGluZ0ZyZXE6IFsnZW51bScsIDQsIFs5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLCAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsIDgwMDAsIDczNTBdXSwgLy8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI1NhbXBsaW5nX0ZyZXF1ZW5jaWVzXG5cdFx0XHRfcHJpdmF0ZVN0cmVhbTogMSxcblx0XHRcdGNoYW5uZWxDb25maWc6IDMsIC8vIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNDaGFubmVsX0NvbmZpZ3VyYXRpb25zXG5cdFx0XHRfcmVzZXJ2ZWQ6IDQsIC8vIG9yaWdpbmFsaXR5LCBob21lLCBjb3B5cmlnaHRlZCwgY29weXJpZ2h0IHN0YXJ0IGJpdHNcblx0XHRcdGZyYW1lTGVuZ3RoOiAxMyxcblx0XHRcdGJ1ZmZlckZ1bGxuZXNzOiAxMSxcblx0XHRcdGFhY0ZyYW1lc0NvdW50TWludXNPbmU6IDIsXG5cdFx0XHRkYXRhOiBbJ2Jsb2InLCBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gY29udGV4dC5mcmFtZUxlbmd0aCAtICh0aGlzLmJpbmFyeS50ZWxsKCkgLSBjb250ZXh0Ll9zdGFydCkgfV1cblx0XHR9XG5cdH07XG59KSk7IiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbJ2piaW5hcnknXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqYmluYXJ5JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QuSDI2NCA9IGZhY3Rvcnkocm9vdC5qQmluYXJ5KTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChqQmluYXJ5KSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRyZXR1cm4ge1xuXHRcdEV4cEdvbG9tYjogakJpbmFyeS5UeXBlKHtcblx0XHRcdHBhcmFtczogWydpc1NpZ25lZCddLFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgY291bnQgPSAwO1xuXHRcdFx0XHR3aGlsZSAoIXRoaXMuYmluYXJ5LnJlYWQoMSkpIGNvdW50Kys7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICgxIDw8IGNvdW50KSB8IHRoaXMuYmluYXJ5LnJlYWQoY291bnQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pc1NpZ25lZCA/ICh2YWx1ZSAmIDEgPyAtKHZhbHVlID4+IDEpIDogdmFsdWUgPj4gMSkgOiB2YWx1ZSAtIDE7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5pc1NpZ25lZCkge1xuXHRcdFx0XHRcdHZhbHVlIDw8PSAxO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA8PSAwKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IC12YWx1ZSB8IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGxlbmd0aCA9IHZhbHVlLnRvU3RyaW5nKDIpLmxlbmd0aDtcblx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUobGVuZ3RoIC0gMSwgMCk7XG5cdFx0XHRcdHRoaXMuYmluYXJ5LndyaXRlKGxlbmd0aCwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0T3B0aW9uYWw6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdCAgICBwYXJhbXM6IFsnYmFzZVR5cGUnXSxcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHRoaXMuYmluYXJ5LnJlYWQoMSkpIHJldHVybiB0aGlzLmJhc2VSZWFkKCk7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmJpbmFyeS53cml0ZSh2YWx1ZSAhPSBudWxsID8gMSA6IDApO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0U2NhbGluZ0xpc3Q6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAoc2l6ZSkge1xuXHRcdFx0XHR0aGlzLmJhc2VUeXBlID0gWydhcnJheScsIHsgLyogVE9ETzogaW1wbGVtZW50IHNjYWxpbmcgbGlzdCAqLyB9LCBzaXplXTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdFNQUzogW1xuXHRcdFx0J2V4dGVuZCcsXG5cdFx0XHR7XG5cdFx0XHRcdHByb2ZpbGVfaWRjOiAndWludDgnLFxuXHRcdFx0XHRjb25zdHJhaW50X3NldF9mbGFnczogWydhcnJheScsIDEsIDhdLFxuXHRcdFx0XHRsZXZlbF9pZGM6ICd1aW50OCcsXG5cdFx0XHRcdHNlcV9wYXJhbWV0ZXJfc2V0X2lkOiAnRXhwR29sb21iJ1xuXHRcdFx0fSxcblx0XHRcdFsnaWYnLCBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gWzEwMCwgMTEwLCAxMjIsIDI0NCwgNDQsIDgzLCA4NiwgMTE4XS5pbmRleE9mKGNvbnRleHQucHJvZmlsZV9pZGMpID49IDAgfSwge1xuXHRcdFx0XHRjaHJvbWFfZm9ybWF0OiBbJ2VudW0nLCAnRXhwR29sb21iJywgWydNT05PJywgJ1lVVjQyMCcsICdZVVY0MjInLCAnWVVWNDQ0J11dLFxuXHRcdFx0XHRzZXBhcmF0ZV9jb2xvcl9wbGFuZV9mbGFnOiBbJ2lmJywgZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIGNvbnRleHQuY2hyb21hX2Zvcm1hdCA9PT0gJ1lVVjQ0NCcgfSwgMV0sXG5cdFx0XHRcdGJpdF9kZXB0aF9sdW1hX21pbnVzODogJ0V4cEdvbG9tYicsXG5cdFx0XHRcdGJpdF9kZXB0aF9jaHJvbWFfbWludXM4OiAnRXhwR29sb21iJyxcblx0XHRcdFx0cXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnOiAxLFxuXHRcdFx0XHRzY2FsaW5nX21hdHJpeDogWydPcHRpb25hbCcsIHtcblx0XHRcdFx0XHRzY2FsaW5nTGlzdDR4NDogWydhcnJheScsIFsnU2NhbGluZ0xpc3QnLCAxNl0sIDZdLFxuXHRcdFx0XHRcdHNjYWxpbmdMaXN0OHg4OiBbJ2FycmF5JywgWydTY2FsaW5nTGlzdCcsIDY0XSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5iaW5hcnkuZ2V0Q29udGV4dCgxKS5jaHJvbWFfZm9ybWF0ICE9PSAnWVVWNDQ0JyA/IDIgOiA2IH1dXG5cdFx0XHRcdH1dXG5cdFx0XHR9XSxcblx0XHRcdHtcblx0XHRcdFx0bG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNDogJ0V4cEdvbG9tYicsXG5cdFx0XHRcdHBpY19vcmRlcl9jbnRfdHlwZTogJ0V4cEdvbG9tYicsXG5cdFx0XHRcdHBpY19vcmRlcjogWydpZl9ub3QnLCAncGljX29yZGVyX2NudF90eXBlJywge2xvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNDogJ0V4cEdvbG9tYid9LCBbXG5cdFx0XHRcdFx0J2lmJyxcblx0XHRcdFx0XHRmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gY29udGV4dC5waWNfb3JkZXJfY250X3R5cGUgPT09IDEgfSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZzogMSxcblx0XHRcdFx0XHRcdG9mZnNldF9mb3Jfbm9uX3JlZl9waWM6IFsnRXhwR29sb21iJywgdHJ1ZV0sXG5cdFx0XHRcdFx0XHRvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGQ6IFsnRXhwR29sb21iJywgdHJ1ZV0sXG5cdFx0XHRcdFx0XHRfbnVtX3JlZl9mcmFtZXNfaW5fcGljX29yZGVyX2NudF9jeWNsZTogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRcdFx0XHRcdGJhc2VUeXBlOiAnRXhwR29sb21iJyxcblx0XHRcdFx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyB0aGlzLmJhc2VXcml0ZShjb250ZXh0Lm9mZnNldF9mb3JfcmVmX2ZyYW1lLmxlbmd0aCkgfVxuXHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0XHRvZmZzZXRfZm9yX3JlZl9mcmFtZTogWydhcnJheScsIFsnRXhwR29sb21iJywgdHJ1ZV0sIGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0Ll9udW1fcmVmX2ZyYW1lc19pbl9waWNfb3JkZXJfY250X2N5Y2xlIH1dXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRdXSxcblx0XHRcdFx0bWF4X251bV9yZWZfZnJhbWVzOiAnRXhwR29sb21iJyxcblx0XHRcdFx0Z2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnOiAxLFxuXHRcdFx0XHRwaWNfd2lkdGhfaW5fbWJzX21pbnVzXzE6ICdFeHBHb2xvbWInLFxuXHRcdFx0XHRwaWNfaGVpZ2h0X2luX21hcF91bml0c19taW51c18xOiAnRXhwR29sb21iJyxcblx0XHRcdFx0ZnJhbWVfbWJzX29ubHlfZmxhZzogMSxcblx0XHRcdFx0bWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZzogWydpZl9ub3QnLCAnZnJhbWVfbWJzX29ubHlfZmxhZycsIDFdLFxuXHRcdFx0XHRkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnOiAxLFxuXHRcdFx0XHRmcmFtZV9jcm9wcGluZzogWydPcHRpb25hbCcsIHtcblx0XHRcdFx0XHRsZWZ0OiAnRXhwR29sb21iJyxcblx0XHRcdFx0XHRyaWdodDogJ0V4cEdvbG9tYicsXG5cdFx0XHRcdFx0dG9wOiAnRXhwR29sb21iJyxcblx0XHRcdFx0XHRib3R0b206ICdFeHBHb2xvbWInXG5cdFx0XHRcdH1dXG5cdFx0XHRcdC8vIFRPRE86IGFkZCBWVUkgcGFyYW1ldGVyc1xuXHRcdFx0fVxuXHRcdF0sXG5cblx0XHROQUxVbml0OiBqQmluYXJ5LlR5cGUoe1xuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgc3luYyA9IHRoaXMuYmluYXJ5LnJlYWQoWydibG9iJywgM10pOyAvLyBbMCwgMCwgMV0gb3IgWzAsIDAsIDAsIDFdXG5cdFx0XHRcdGlmIChzeW5jWzJdID09PSAwKSB0aGlzLmJpbmFyeS5za2lwKDEpO1xuXHRcdFx0XHR2YXIgZW5kID0gdGhpcy5iaW5hcnkudmlldy5ieXRlTGVuZ3RoLCBwb3MgPSB0aGlzLmJpbmFyeS50ZWxsKCk7XG5cdFx0XHRcdHZhciBieXRlcyA9IHRoaXMuYmluYXJ5LnNraXAoMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52aWV3LmdldEJ5dGVzKCkgfSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBieXRlcy5sZW5ndGggLSAzOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYnl0ZXNbaV0gPT09IDAgJiYgYnl0ZXNbaSArIDFdID09PSAwICYmIChieXRlc1tpICsgMl0gPT09IDEgfHwgKGJ5dGVzW2kgKyAyXSA9PT0gMCAmJiBieXRlc1tpICsgM10gPT09IDEpKSkge1xuXHRcdFx0XHRcdFx0ZW5kID0gcG9zICsgaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZGF0YSA9IHRoaXMuYmluYXJ5LnJlYWQoWydibG9iJywgZW5kIC0gcG9zXSk7XG5cdFx0XHRcdC8vIFRPRE86IGlkZWFsbHkgdGhlcmUgc2hvdWxkIGJlIEFubmV4LkIgY29udmVyc2lvbiBmcm9tIFswLCAwLCAzLCBYPTAuLjNdIHRvIFswLCAwLCBYXVxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH1cblx0XHR9KVxuXHR9O1xufSkpOyIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoWydqZGF0YXZpZXcnLCAnamJpbmFyeScsICcuL21wNCcsICcuL2gyNjQnLCAnLi9wZXMnLCAnLi9hZHRzJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnamRhdGF2aWV3JyksIHJlcXVpcmUoJ2piaW5hcnknKSwgcmVxdWlyZSgnLi9tcDQnKSwgcmVxdWlyZSgnLi9oMjY0JyksIHJlcXVpcmUoJy4vcGVzJyksIHJlcXVpcmUoJy4vYWR0cycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290Lm1wZWd0c190b19tcDQgPSBmYWN0b3J5KHJvb3QuakRhdGFWaWV3LCByb290LmpCaW5hcnksIHJvb3QuTVA0LCByb290LkgyNjQsIHJvb3QuUEVTLCByb290LkFEVFMpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGpEYXRhVmlldywgakJpbmFyeSwgTVA0LCBIMjY0LCBQRVMsIEFEVFMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cblx0LyoqXG5cdCAqIENvcGllZCBmcm9tIG11eC5qcyA9PiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy9tdXguanMvYmxvYi85NTc0NDFkNDQzMDdhNDdkODAxYWYzZGI1YzUxMDcyZWQyNDFmOGMyL2xpYi9jb2RlY3MvaDI2NC5qcyNMMjY2XG5cdCAqIEV4cHVuZ2UgYW55IFwiRW11bGF0aW9uIFByZXZlbnRpb25cIiBieXRlcyBmcm9tIGEgXCJSYXcgQnl0ZVxuXHQgKiBTZXF1ZW5jZSBQYXlsb2FkXCJcblx0ICogQHBhcmFtIGRhdGEge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiBhIFJCU1AgZnJvbSBhIE5BTFxuXHQgKiB1bml0XG5cdCAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSBSQlNQIHdpdGhvdXQgYW55IEVtdWxhdGlvblxuXHQgKiBQcmV2ZW50aW9uIEJ5dGVzXG5cdCAqL1xuXHR2YXIgZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR2YXJcblx0XHRsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGgsXG5cdFx0ZW11bGF0aW9uUHJldmVudGlvbkJ5dGVzUG9zaXRpb25zID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bmV3TGVuZ3RoLCBuZXdEYXRhO1xuXG5cdFx0Ly8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuXHRcdHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuXHRcdGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG5cdFx0XHRlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMucHVzaChpICsgMik7XG5cdFx0XHRpICs9IDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGkrKztcblx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcblx0XHQvLyBhcnJheVxuXHRcdGlmIChlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcblx0XHRuZXdMZW5ndGggPSBsZW5ndGggLSBlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMubGVuZ3RoO1xuXHRcdG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuXHRcdHZhciBzb3VyY2VJbmRleCA9IDA7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcblx0XHRpZiAoc291cmNlSW5kZXggPT09IGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9uc1swXSkge1xuXHRcdFx0Ly8gU2tpcCB0aGlzIGJ5dGVcblx0XHRcdHNvdXJjZUluZGV4Kys7XG5cdFx0XHQvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuXHRcdFx0ZW11bGF0aW9uUHJldmVudGlvbkJ5dGVzUG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0fVxuXHRcdG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3RGF0YTtcblx0fTtcblxuXG5cdHJldHVybiBmdW5jdGlvbiAobXBlZ3RzKSB7XG5cdFx0dmFyIHBhY2tldHMgPSBtcGVndHMucmVhZCgnRmlsZScpO1xuXHRcdFxuXHRcdC8vIGV4dHJhY3RpbmcgYW5kIGNvbmNhdGVuYXRpbmcgcmF3IHN0cmVhbSBwYXJ0c1xuXHRcdHZhciBzdHJlYW0gPSBuZXcgakRhdGFWaWV3KG1wZWd0cy52aWV3LmJ5dGVMZW5ndGgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwYWNrZXRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFja2V0ID0gcGFja2V0c1tpXSwgYWRhcHRhdGlvbiA9IHBhY2tldC5hZGFwdGF0aW9uRmllbGQsIHBheWxvYWQgPSBwYWNrZXQucGF5bG9hZDtcblx0XHRcdGlmIChwYXlsb2FkICYmIHBheWxvYWQuX3Jhd1N0cmVhbSkge1xuXHRcdFx0XHRzdHJlYW0ud3JpdGVCeXRlcyhwYXlsb2FkLl9yYXdTdHJlYW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR2YXIgcGVzU3RyZWFtID0gbmV3IGpCaW5hcnkoc3RyZWFtLnNsaWNlKDAsIHN0cmVhbS50ZWxsKCkpLCBQRVMpLFxuXHRcdFx0YXVkaW9TdHJlYW0gPSBuZXcgakJpbmFyeShzdHJlYW0uYnl0ZUxlbmd0aCwgQURUUyksXG5cdFx0XHRzYW1wbGVzID0gW10sXG5cdFx0XHRhdWRpb1NhbXBsZXMgPSBbXTtcblxuXHRcdHN0cmVhbSA9IG5ldyBqRGF0YVZpZXcoc3RyZWFtLmJ5dGVMZW5ndGgpO1xuXHRcdFxuXHRcdHdoaWxlIChwZXNTdHJlYW0udGVsbCgpIDwgcGVzU3RyZWFtLnZpZXcuYnl0ZUxlbmd0aCkge1xuXHRcdFx0dmFyIHBhY2tldCA9IHBlc1N0cmVhbS5yZWFkKCdQRVNQYWNrZXQnKTtcblxuXHRcdFx0aWYgKHBhY2tldC5zdHJlYW1JZCA9PT0gMHhDMCkge1xuXHRcdFx0XHQvLyAweEMwIG1lYW5zIHdlIGhhdmUgZ290IGZpcnN0IGF1ZGlvIHN0cmVhbVxuXHRcdFx0XHRhdWRpb1N0cmVhbS53cml0ZSgnYmxvYicsIHBhY2tldC5kYXRhKTtcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYgKHBhY2tldC5zdHJlYW1JZCA9PT0gMHhFMCkge1xuXHRcdFx0XHR2YXIgbmFsU3RyZWFtID0gbmV3IGpCaW5hcnkocGFja2V0LmRhdGEsIEgyNjQpLFxuXHRcdFx0XHRcdHB0cyA9IHBhY2tldC5wdHMsXG5cdFx0XHRcdFx0ZHRzID0gcGFja2V0LmR0cyxcblx0XHRcdFx0XHRjdXJTYW1wbGUgPSB7b2Zmc2V0OiBzdHJlYW0udGVsbCgpLCBwdHM6IHB0cywgZHRzOiBkdHMgIT09IHVuZGVmaW5lZCA/IGR0cyA6IHB0c307XG5cdFx0XHRcdFxuXHRcdFx0XHRzYW1wbGVzLnB1c2goY3VyU2FtcGxlKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNvbGxlY3RpbmcgaW5mbyBmcm9tIEguMjY0IE5BTCB1bml0c1xuXHRcdFx0XHR3aGlsZSAobmFsU3RyZWFtLnRlbGwoKSA8IG5hbFN0cmVhbS52aWV3LmJ5dGVMZW5ndGgpIHtcblx0XHRcdFx0XHR2YXIgbmFsVW5pdCA9IG5hbFN0cmVhbS5yZWFkKCdOQUxVbml0Jyk7XG5cdFx0XHRcdFx0c3dpdGNoIChuYWxVbml0WzBdICYgMHgxRikge1xuXHRcdFx0XHRcdFx0Y2FzZSA3OlxuXHRcdFx0XHRcdFx0XHRpZiAoIXNwcykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBzcHMgPSBuYWxVbml0O1xuXHRcdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB0byBnZXQgY29ycmVjdCB3aWR0aCAmIGhlaWdodFxuXHRcdFx0XHRcdFx0XHRcdC8vIFNlZSBodHRwOi8vYmxvZy41MWN0by5jb20vZGFuaWVsbGxmLzE3NTgxMTVcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3BzSW5mbyA9IG5ldyBqQmluYXJ5KGRpc2NhcmRFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMoc3BzLnN1YmFycmF5KDEpKSwgSDI2NCkucmVhZCgnU1BTJyk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHdpZHRoID0gKHNwc0luZm8ucGljX3dpZHRoX2luX21ic19taW51c18xICsgMSkgKiAxNjtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaGVpZ2h0ID0gKDIgLSBzcHNJbmZvLmZyYW1lX21ic19vbmx5X2ZsYWcpICogKHNwc0luZm8ucGljX2hlaWdodF9pbl9tYXBfdW5pdHNfbWludXNfMSArIDEpICogMTY7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNyb3BwaW5nID0gc3BzSW5mby5mcmFtZV9jcm9wcGluZztcblx0XHRcdFx0XHRcdFx0XHRpZiAoY3JvcHBpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoIC09IDIgKiAoY3JvcHBpbmcubGVmdCArIGNyb3BwaW5nLnJpZ2h0KTtcblx0XHRcdFx0XHRcdFx0XHRcdGhlaWdodCAtPSAyICogKGNyb3BwaW5nLnRvcCArIGNyb3BwaW5nLmJvdHRvbSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0XHRcdGlmICghcHBzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHBwcyA9IG5hbFVuaXQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgNTpcblx0XHRcdFx0XHRcdFx0Y3VyU2FtcGxlLmlzSURSID0gdHJ1ZTtcblx0XHRcdFx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHN0cmVhbS53cml0ZVVpbnQzMihuYWxVbml0Lmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdHN0cmVhbS53cml0ZUJ5dGVzKG5hbFVuaXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRzYW1wbGVzLnB1c2goe29mZnNldDogc3RyZWFtLnRlbGwoKX0pO1xuXG5cdFx0dmFyIHNpemVzID0gW10sXG5cdFx0XHRkdHNEaWZmcyA9IFtdLFxuXHRcdFx0YWNjZXNzSW5kZXhlcyA9IFtdLFxuXHRcdFx0cHRzX2R0c19EaWZmcyA9IFtdLFxuXHRcdFx0Y3VycmVudCA9IHNhbXBsZXNbMF0sXG5cdFx0XHRmcmFtZVJhdGUgPSB7c3VtOiAwLCBjb3VudDogMH0sXG5cdFx0XHRkdXJhdGlvbiA9IDA7XG5cdFx0XG5cdFx0Ly8gY2FsY3VsYXRpbmcgUFRTL0RUUyBkaWZmZXJlbmNlcyBhbmQgY29sbGVjdGluZyBrZXlmcmFtZXNcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2FtcGxlcy5sZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBuZXh0ID0gc2FtcGxlc1tpICsgMV07XG5cdFx0XHRzaXplcy5wdXNoKG5leHQub2Zmc2V0IC0gY3VycmVudC5vZmZzZXQpO1xuXHRcdFx0dmFyIGR0c0RpZmYgPSBuZXh0LmR0cyAtIGN1cnJlbnQuZHRzO1xuXHRcdFx0aWYgKGR0c0RpZmYpIHtcblx0XHRcdFx0ZHRzRGlmZnMucHVzaCh7c2FtcGxlX2NvdW50OiAxLCBzYW1wbGVfZGVsdGE6IGR0c0RpZmZ9KTtcblx0XHRcdFx0ZHVyYXRpb24gKz0gZHRzRGlmZjtcblx0XHRcdFx0ZnJhbWVSYXRlLnN1bSArPSBkdHNEaWZmO1xuXHRcdFx0XHRmcmFtZVJhdGUuY291bnQrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGR0c0RpZmZzLmxlbmd0aCsrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnQuaXNJRFIpIHtcblx0XHRcdFx0YWNjZXNzSW5kZXhlcy5wdXNoKGkgKyAxKTtcblx0XHRcdH1cblx0XHRcdHB0c19kdHNfRGlmZnMucHVzaCh7XG5cdFx0XHRcdGZpcnN0X2NodW5rOiBwdHNfZHRzX0RpZmZzLmxlbmd0aCArIDEsXG5cdFx0XHRcdHNhbXBsZV9jb3VudDogMSxcblx0XHRcdFx0c2FtcGxlX29mZnNldDogY3VycmVudC5kdHNGaXggPSBjdXJyZW50LnB0cyAtIGN1cnJlbnQuZHRzXG5cdFx0XHR9KTtcblx0XHRcdGN1cnJlbnQgPSBuZXh0O1xuXHRcdH1cblx0XHRcblx0XHRmcmFtZVJhdGUgPSBNYXRoLnJvdW5kKGZyYW1lUmF0ZS5zdW0gLyBmcmFtZVJhdGUuY291bnQpO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBkdHNEaWZmcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGR0c0RpZmZzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZHRzRGlmZnNbaV0gPSB7Zmlyc3RfY2h1bms6IGkgKyAxLCBzYW1wbGVfY291bnQ6IDEsIHNhbXBsZV9kZWx0YTogZnJhbWVSYXRlfTtcblx0XHRcdFx0ZHVyYXRpb24gKz0gZnJhbWVSYXRlO1xuXHRcdFx0XHQvL3NhbXBsZXNbaSArIDFdLmR0cyA9IHNhbXBsZXNbaV0uZHRzICsgZnJhbWVSYXRlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNoZWNraW5nIGlmIERUUyBkaWZmZXJlbmNlcyBhcmUgc2FtZSBldmVyeXdoZXJlIHRvIHBhY2sgdGhlbSBpbnRvIG9uZSBpdGVtXG5cdFx0XG5cdFx0dmFyIGR0c0RpZmZzU2FtZSA9IHRydWU7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGR0c0RpZmZzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZHRzRGlmZnNbaV0uc2FtcGxlX2RlbHRhICE9PSBkdHNEaWZmc1swXS5zYW1wbGVfZGVsdGEpIHtcblx0XHRcdFx0ZHRzRGlmZnNTYW1lID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAoZHRzRGlmZnNTYW1lKSB7XG5cdFx0XHRkdHNEaWZmcyA9IFt7Zmlyc3RfY2h1bms6IDEsIHNhbXBsZV9jb3VudDogc2l6ZXMubGVuZ3RoLCBzYW1wbGVfZGVsdGE6IGR0c0RpZmZzWzBdLnNhbXBsZV9kZWx0YX1dO1xuXHRcdH1cblxuXHRcdC8vIGJ1aWxkaW5nIGF1ZGlvIG1ldGFkYXRhXG5cblx0XHR2YXIgYXVkaW9TdGFydCA9IHN0cmVhbS50ZWxsKCksXG5cdFx0XHRhdWRpb1NpemUgPSBhdWRpb1N0cmVhbS50ZWxsKCksXG5cdFx0XHRhdWRpb1NpemVzID0gW10sXG5cdFx0XHRhdWRpb0hlYWRlcixcblx0XHRcdG1heEF1ZGlvU2l6ZSA9IDA7XG5cdFx0XHRcblx0XHRhdWRpb1N0cmVhbS5zZWVrKDApO1xuXHRcdFxuXHRcdHdoaWxlIChhdWRpb1N0cmVhbS50ZWxsKCkgPCBhdWRpb1NpemUpIHtcblx0XHRcdGF1ZGlvSGVhZGVyID0gYXVkaW9TdHJlYW0ucmVhZCgnQURUU1BhY2tldCcpO1xuXHRcdFx0YXVkaW9TaXplcy5wdXNoKGF1ZGlvSGVhZGVyLmRhdGEubGVuZ3RoKTtcblx0XHRcdGlmIChhdWRpb0hlYWRlci5kYXRhLmxlbmd0aCA+IG1heEF1ZGlvU2l6ZSkge1xuXHRcdFx0XHRtYXhBdWRpb1NpemUgPSBhdWRpb0hlYWRlci5kYXRhLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHN0cmVhbS53cml0ZUJ5dGVzKGF1ZGlvSGVhZGVyLmRhdGEpO1xuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRpbmcgcmVzdWx0aW5nIE1QNFxuXG5cdFx0dmFyIG1wNCA9IG5ldyBqQmluYXJ5KHN0cmVhbS5ieXRlTGVuZ3RoLCBNUDQpO1xuXHRcdFxuXHRcdHZhciB0cmFrID0gW3tcblx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdHRraGQ6IFt7XG5cdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRmbGFnczogMTUsXG5cdFx0XHRcdFx0dHJhY2tfSUQ6IDEsXG5cdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRcdGxheWVyOiAwLFxuXHRcdFx0XHRcdGFsdGVybmF0ZV9ncm91cDogMCxcblx0XHRcdFx0XHR2b2x1bWU6IDEsXG5cdFx0XHRcdFx0bWF0cml4OiB7XG5cdFx0XHRcdFx0XHRhOiAxLCBiOiAwLCB4OiAwLFxuXHRcdFx0XHRcdFx0YzogMCwgZDogMSwgeTogMCxcblx0XHRcdFx0XHRcdHU6IDAsIHY6IDAsIHc6IDFcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRpbWVuc2lvbnM6IHtcblx0XHRcdFx0XHRcdGhvcno6IHdpZHRoLFxuXHRcdFx0XHRcdFx0dmVydDogaGVpZ2h0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XSxcblx0XHRcdFx0bWRpYTogW3tcblx0XHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdFx0bWRoZDogW3tcblx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdHRpbWVzY2FsZTogOTAwMDAsXG5cdFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0bGFuZzogJ3VuZCdcblx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0aGRscjogW3tcblx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdGhhbmRsZXJfdHlwZTogJ3ZpZGUnLFxuXHRcdFx0XHRcdFx0XHRuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuXHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRtaW5mOiBbe1xuXHRcdFx0XHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdFx0XHRcdHZtaGQ6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRncmFwaGljc21vZGU6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRvcGNvbG9yOiB7cjogMCwgZzogMCwgYjogMH1cblx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRkaW5mOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0YXRvbXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZHJlZjogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiAndXJsICcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsb2NhdGlvbjogJydcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRcdHN0Ymw6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHNkOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW50cmllczogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICdhdmMxJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGFfcmVmZXJlbmNlX2luZGV4OiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGltZW5zaW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRob3J6OiB3aWR0aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVydDogaGVpZ2h0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x1dGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRob3J6OiA3Mixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVydDogNzJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmcmFtZV9jb3VudDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXByZXNzb3JuYW1lOiAnJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcHRoOiAyNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGF2Y0M6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9maWxlSW5kaWNhdGlvbjogc3BzSW5mby5wcm9maWxlX2lkYyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9maWxlQ29tcGF0aWJpbGl0eTogcGFyc2VJbnQoc3BzSW5mby5jb25zdHJhaW50X3NldF9mbGFncy5qb2luKCcnKSwgMiksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGV2ZWxJbmRpY2F0aW9uOiBzcHNJbmZvLmxldmVsX2lkYyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsZW5ndGhTaXplTWludXNPbmU6IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2VxUGFyYW1TZXRzOiBbc3BzXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwaWN0UGFyYW1TZXRzOiBbcHBzXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHRzOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW50cmllczogZHRzRGlmZnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0c3M6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbnRyaWVzOiBhY2Nlc3NJbmRleGVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdHRzOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW50cmllczogcHRzX2R0c19EaWZmc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RzYzogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaXJzdF9jaHVuazogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZXNfcGVyX2NodW5rOiBzaXplcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGVfZGVzY3JpcHRpb25faW5kZXg6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RzejogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZV9zaXplOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZV9jb3VudDogc2l6ZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZV9zaXplczogc2l6ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0Y286IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbnRyaWVzOiBbMHgyOF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fV1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fV1cblx0XHRcdH1cblx0XHR9XTtcblxuXHRcdGlmIChhdWRpb1NpemUgPiAwKSB7XG5cdFx0XHR0cmFrLnB1c2goe1xuXHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdHRraGQ6IFt7XG5cdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0ZmxhZ3M6IDE1LFxuXHRcdFx0XHRcdFx0dHJhY2tfSUQ6IDIsXG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRsYXllcjogMCxcblx0XHRcdFx0XHRcdGFsdGVybmF0ZV9ncm91cDogMSxcblx0XHRcdFx0XHRcdHZvbHVtZTogMSxcblx0XHRcdFx0XHRcdG1hdHJpeDoge1xuXHRcdFx0XHRcdFx0XHRhOiAxLCBiOiAwLCB4OiAwLFxuXHRcdFx0XHRcdFx0XHRjOiAwLCBkOiAxLCB5OiAwLFxuXHRcdFx0XHRcdFx0XHR1OiAwLCB2OiAwLCB3OiAxXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uczoge1xuXHRcdFx0XHRcdFx0XHRob3J6OiAwLFxuXHRcdFx0XHRcdFx0XHR2ZXJ0OiAwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0bWRpYTogW3tcblx0XHRcdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0XHRcdG1kaGQ6IFt7XG5cdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHR0aW1lc2NhbGU6IDkwMDAwLFxuXHRcdFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0XHRsYW5nOiAnZW5nJ1xuXHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0aGRscjogW3tcblx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdGhhbmRsZXJfdHlwZTogJ3NvdW4nLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6ICdTb3VuZEhhbmRsZXInXG5cdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRtaW5mOiBbe1xuXHRcdFx0XHRcdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzbWhkOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YmFsYW5jZTogMFxuXHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkaW5mOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRyZWY6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbnRyaWVzOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiAndXJsICcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsb2NhdGlvbjogJydcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGJsOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN0c2Q6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbnRyaWVzOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiAnbXA0YScsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGFfcmVmZXJlbmNlX2luZGV4OiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGFubmVsY291bnQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZXNpemU6IDE2LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGVyYXRlOiAyMjA1MCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXRvbXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlc2RzOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2VjdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JfdHlwZTogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleHRfdHlwZTogMTI4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxlbmd0aDogMzQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXNfaWQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtX3ByaW9yaXR5OiAwXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXNjcmlwdG9yX3R5cGU6IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXh0X3R5cGU6IDEyOCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsZW5ndGg6IDIwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICdtcGVnNF9hdWRpbycsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtX3R5cGU6ICdhdWRpbycsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dXBzdHJlYW1fZmxhZzogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidWZmZXJfc2l6ZTogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhCaXRyYXRlOiBNYXRoLnJvdW5kKG1heEF1ZGlvU2l6ZSAvIChkdXJhdGlvbiAvIDkwMDAwIC8gYXVkaW9TaXplcy5sZW5ndGgpKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhdmdCaXRyYXRlOiBNYXRoLnJvdW5kKChzdHJlYW0udGVsbCgpIC0gYXVkaW9TdGFydCkgLyAoZHVyYXRpb24gLyA5MDAwMCkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXNjcmlwdG9yX3R5cGU6IDUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXh0X3R5cGU6IDEyOCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsZW5ndGg6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXVkaW9fcHJvZmlsZTogYXVkaW9IZWFkZXIucHJvZmlsZU1pbnVzT25lICsgMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGluZ19mcmVxOiBhdWRpb0hlYWRlci5zYW1wbGluZ0ZyZXEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hhbm5lbENvbmZpZzogYXVkaW9IZWFkZXIuY2hhbm5lbENvbmZpZ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRvcl90eXBlOiA2LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV4dF90eXBlOiAxMjgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGVuZ3RoOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNsOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN0dHM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbnRyaWVzOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGVfY291bnQ6IGF1ZGlvU2l6ZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGVfZGVsdGE6IE1hdGgucm91bmQoZHVyYXRpb24gLyBhdWRpb1NpemVzLmxlbmd0aClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RzYzogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpcnN0X2NodW5rOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGVzX3Blcl9jaHVuazogYXVkaW9TaXplcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHN6OiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtcGxlX3NpemU6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGVfY291bnQ6IGF1ZGlvU2l6ZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtcGxlX3NpemVzOiBhdWRpb1NpemVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RjbzogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IFsweDI4ICsgYXVkaW9TdGFydF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fV1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBjcmVhdGlvblRpbWUgPSBuZXcgRGF0ZSgpO1xuXG5cdFx0bXA0LndyaXRlKCdGaWxlJywge1xuXHRcdFx0ZnR5cDogW3tcblx0XHRcdFx0bWFqb3JfYnJhbmQ6ICdpc29tJyxcblx0XHRcdFx0bWlub3JfdmVyc2lvbjogNTEyLFxuXHRcdFx0XHRjb21wYXRpYmxlX2JyYW5kczogWydpc29tJywgJ2lzbzInLCAnYXZjMScsICdtcDQxJ11cblx0XHRcdH1dLFxuXHRcdFx0bWRhdDogW3tcblx0XHRcdFx0X3Jhd0RhdGE6IHN0cmVhbS5nZXRCeXRlcyhzdHJlYW0udGVsbCgpLCAwKVxuXHRcdFx0fV0sXG5cdFx0XHRtb292OiBbe1xuXHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdG12aGQ6IFt7XG5cdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRjcmVhdGlvbl90aW1lOiBjcmVhdGlvblRpbWUsXG5cdFx0XHRcdFx0XHRtb2RpZmljYXRpb25fdGltZTogY3JlYXRpb25UaW1lLFxuXHRcdFx0XHRcdFx0dGltZXNjYWxlOiA5MDAwMCxcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0XHRcdHJhdGU6IDEsXG5cdFx0XHRcdFx0XHR2b2x1bWU6IDEsXG5cdFx0XHRcdFx0XHRtYXRyaXg6IHtcblx0XHRcdFx0XHRcdFx0YTogMSwgYjogMCwgeDogMCxcblx0XHRcdFx0XHRcdFx0YzogMCwgZDogMSwgeTogMCxcblx0XHRcdFx0XHRcdFx0dTogMCwgdjogMCwgdzogMVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5leHRfdHJhY2tfSUQ6IDJcblx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHR0cmFrOiB0cmFrXG5cdFx0XHRcdH1cblx0XHRcdH1dXG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIG1wNC5zbGljZSgwLCBtcDQudGVsbCgpKTtcblx0fTtcbn0pKTsiLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsnamJpbmFyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2piaW5hcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5NUDQgPSBmYWN0b3J5KHJvb3QuakJpbmFyeSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoakJpbmFyeSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHRpbWVCYXNpcyA9IG5ldyBEYXRlKDE5NzAsIDAsIDEpIC0gbmV3IERhdGUoMTkwNCwgMCwgMSk7XG5cblx0ZnVuY3Rpb24gYXRvbUZpbHRlcih0eXBlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChhdG9tKSB7XG5cdFx0XHRyZXR1cm4gYXRvbS50eXBlID09PSB0eXBlO1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdFNob3J0TmFtZTogWydzdHJpbmcwJywgNF0sXG5cdFx0XG5cdFx0UmF0ZTogWydGaXhlZFBvaW50JywgJ2ludDMyJywgMTZdLFxuXG5cdFx0RGltZW5zaW9uczogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChpdGVtVHlwZSkge1xuXHRcdFx0XHR0aGlzLmJhc2VUeXBlID0ge1xuXHRcdFx0XHRcdGhvcno6IGl0ZW1UeXBlLFxuXHRcdFx0XHRcdHZlcnQ6IGl0ZW1UeXBlXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRCb3hIZWFkZXI6IHtcblx0XHRcdF9iZWdpbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW5hcnkudGVsbCgpO1xuXHRcdFx0fSxcblx0XHRcdF9zaXplOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdFx0YmFzZVR5cGU6ICd1aW50MzInLFxuXHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBjb250ZXh0LnNpemU7XG5cdFx0XHRcdFx0dGhpcy5iYXNlV3JpdGUoc2l6ZSA/IChzaXplIDwgTWF0aC5wb3coMiwgMzIpID8gc2l6ZSA6IDEpIDogMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdFx0dHlwZTogJ1Nob3J0TmFtZScsXG5cdFx0XHRzaXplOiBqQmluYXJ5LlR5cGUoe1xuXHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHRcdFx0XHRcdHZhciBfc2l6ZSA9IGNvbnRleHQuX3NpemU7XG5cdFx0XHRcdFx0c3dpdGNoIChfc2l6ZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy5iaW5hcnkudmlldy5ieXRlTGVuZ3RoIC0gdGhpcy5iaW5hcnkudGVsbCgpICsgODtcblx0XHRcdFx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMuYmluYXJ5LnJlYWQoJ3VpbnQ2NCcpO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIF9zaXplO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA+PSBNYXRoLnBvdygyLCAzMikpIHtcblx0XHRcdFx0XHRcdHRoaXMuYmluYXJ5LndyaXRlKCd1aW50NjQnLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHRcdF9lbmQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0Ll9iZWdpbiArIGNvbnRleHQuc2l6ZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0RnVsbEJveDogWydleHRlbmQnLCAnQm94SGVhZGVyJywge1xuXHRcdFx0dmVyc2lvbjogJ3VpbnQ4Jyxcblx0XHRcdGZsYWdzOiAyNFxuXHRcdH1dLFxuXG5cdFx0Qm94OiBqQmluYXJ5LlR5cGUoe1xuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgaGVhZGVyID0gdGhpcy5iaW5hcnkuc2tpcCgwLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMucmVhZCgnQm94SGVhZGVyJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR2YXIgYm94ID0gdGhpcy5iaW5hcnkucmVhZChoZWFkZXIudHlwZSkgfHwgaGVhZGVyO1xuXHRcdFx0XHRpZiAoYm94ID09PSBoZWFkZXIpIGNvbnNvbGUubG9nKGhlYWRlci50eXBlKTtcblx0XHRcdFx0dGhpcy5iaW5hcnkuc2VlayhoZWFkZXIuX2VuZCk7XG5cdFx0XHRcdHJldHVybiBib3g7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChib3gpIHtcblx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUoYm94LnR5cGUsIGJveCk7XG5cdFx0XHRcdHZhciBzaXplID0gdGhpcy5iaW5hcnkudGVsbCgpIC0gYm94Ll9iZWdpbjtcblx0XHRcdFx0dGhpcy5iaW5hcnkuc2Vlayhib3guX2JlZ2luLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy53cml0ZSgndWludDMyJywgc2l6ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0VGltZTogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRwYXJhbXM6IFsnYmFzZVR5cGUnXSxcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGludFRpbWUgPSB0aGlzLmJhc2VSZWFkKCk7XG5cdFx0XHRcdGlmIChpbnRUaW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBEYXRlKGludFRpbWUgKyB0aW1lQmFzaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVdyaXRlKCh0aW1lIC0gdGltZUJhc2lzKSA+Pj4gMCk7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRGaXhlZFBvaW50OiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdHBhcmFtczogWydiYXNlVHlwZSddLFxuXHRcdFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAoYmFzZVR5cGUsIHNoaWZ0KSB7XG5cdFx0XHRcdHRoaXMuY29lZiA9IDEgPDwgc2hpZnQ7XG5cdFx0XHR9LFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iYXNlUmVhZCgpIC8gdGhpcy5jb2VmO1xuXHRcdFx0fSxcblx0XHRcdHdyaXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0dGhpcy5iYXNlV3JpdGUodmFsdWUgKiB0aGlzLmNvZWYpO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0QXRvbXM6IGpCaW5hcnkuVHlwZSh7XG5cdFx0XHRwYXJhbXM6IFsnZW5kJ10sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBhdG9tcyA9IHt9LCBlbmQgPSB0aGlzLnRvVmFsdWUodGhpcy5lbmQpIHx8IHRoaXMuYmluYXJ5LmdldENvbnRleHQoJ19lbmQnKS5fZW5kO1xuXHRcdFx0XHR3aGlsZSAodGhpcy5iaW5hcnkudGVsbCgpIDwgZW5kKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0aGlzLmJpbmFyeS5yZWFkKCdCb3gnKTtcblx0XHRcdFx0XHQoYXRvbXNbaXRlbS50eXBlXSB8fCAoYXRvbXNbaXRlbS50eXBlXSA9IFtdKSkucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYXRvbXM7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChwYXJlbnQpIHtcblx0XHRcdFx0Zm9yICh2YXIgdHlwZSBpbiBwYXJlbnQpIHtcblx0XHRcdFx0XHR2YXIgYXRvbXMgPSBwYXJlbnRbdHlwZV07XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGF0b21zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRhdG9tc1tpXS50eXBlID0gdHlwZTtcblx0XHRcdFx0XHRcdHRoaXMuYmluYXJ5LndyaXRlKCdCb3gnLCBhdG9tc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRDaGlsZEF0b21zOiB7XG5cdFx0XHRhdG9tczogJ0F0b21zJ1xuXHRcdH0sXG5cblx0XHRNdWx0aUJveDogWydleHRlbmQnLCAnQm94SGVhZGVyJywgJ0NoaWxkQXRvbXMnXSxcblxuXHRcdFRyYW5zZm9ybWF0aW9uTWF0cml4OiB7XG5cdFx0XHRhOiBbJ0ZpeGVkUG9pbnQnLCAndWludDMyJywgMTZdLFxuXHRcdFx0YjogWydGaXhlZFBvaW50JywgJ3VpbnQzMicsIDE2XSxcblx0XHRcdHU6IFsnRml4ZWRQb2ludCcsICd1aW50MzInLCAzMF0sXG5cdFx0XHRjOiBbJ0ZpeGVkUG9pbnQnLCAndWludDMyJywgMTZdLFxuXHRcdFx0ZDogWydGaXhlZFBvaW50JywgJ3VpbnQzMicsIDE2XSxcblx0XHRcdHY6IFsnRml4ZWRQb2ludCcsICd1aW50MzInLCAzMF0sXG5cdFx0XHR4OiBbJ0ZpeGVkUG9pbnQnLCAndWludDMyJywgMTZdLFxuXHRcdFx0eTogWydGaXhlZFBvaW50JywgJ3VpbnQzMicsIDE2XSxcblx0XHRcdHc6IFsnRml4ZWRQb2ludCcsICd1aW50MzInLCAzMF1cblx0XHR9LFxuXG5cdFx0Vm9sdW1lOiBbJ0ZpeGVkUG9pbnQnLCAndWludDE2JywgOF0sXG5cblx0XHRGQlZlcnNpb25hYmxlOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdHNldFBhcmFtczogZnVuY3Rpb24gKHR5cGUwLCB0eXBlMSkge1xuXHRcdFx0XHR0aGlzLmJhc2VUeXBlID0gWydpZicsICd2ZXJzaW9uJywgdHlwZTEsIHR5cGUwXTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdEZCVWludDogWydGQlZlcnNpb25hYmxlJywgJ3VpbnQzMicsICd1aW50NjQnXSxcblxuXHRcdEZCVGltZTogWydUaW1lJywgJ0ZCVWludCddLFxuXG5cdFx0VGltZXN0YW1wQm94OiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0Y3JlYXRpb25fdGltZTogJ0ZCVGltZScsXG5cdFx0XHRtb2RpZmljYXRpb25fdGltZTogJ0ZCVGltZSdcblx0XHR9XSxcblxuXHRcdER1cmF0aW9uQm94OiBbJ2V4dGVuZCcsICdUaW1lc3RhbXBCb3gnLCB7XG5cdFx0XHR0aW1lc2NhbGU6ICd1aW50MzInLFxuXHRcdFx0ZHVyYXRpb246ICdGQlVpbnQnXG5cdFx0fV0sXG5cblx0XHRmdHlwOiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCB7XG5cdFx0XHRtYWpvcl9icmFuZDogJ1Nob3J0TmFtZScsXG5cdFx0XHRtaW5vcl92ZXJzaW9uOiAndWludDMyJyxcblx0XHRcdGNvbXBhdGlibGVfYnJhbmRzOiBbJ2FycmF5JywgJ1Nob3J0TmFtZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmJpbmFyeS5nZXRDb250ZXh0KDEpLl9lbmQgLSB0aGlzLmJpbmFyeS50ZWxsKCkpIC8gNCB9XVxuXHRcdH1dLFxuXG5cdFx0ZnJlZTogJ0JveEhlYWRlcicsXG5cblx0XHRSYXdEYXRhOiB7XG5cdFx0XHRfcmF3RGF0YTogWydibG9iJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5iaW5hcnkuZ2V0Q29udGV4dCgnX2VuZCcpLl9lbmQgLSB0aGlzLmJpbmFyeS50ZWxsKCkgfV1cblx0XHR9LFxuXG5cdFx0bWRhdDogWydleHRlbmQnLCAnQm94SGVhZGVyJywgJ1Jhd0RhdGEnXSxcblxuXHRcdFBhcmFtU2V0czogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChudW1UeXBlKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVR5cGUgPSBbJ0R5bmFtaWNBcnJheScsIG51bVR5cGUsIGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0XHRcdGJhc2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRsZW5ndGg6ICd1aW50MTYnLFxuXHRcdFx0XHRcdFx0cGFyYW1TZXQ6IFsnYmxvYicsICdsZW5ndGgnXVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmFzZVJlYWQoKS5wYXJhbVNldDtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAocGFyYW1TZXQpIHtcblx0XHRcdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHtcblx0XHRcdFx0XHRcdFx0bGVuZ3RoOiBwYXJhbVNldC5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdHBhcmFtU2V0OiBwYXJhbVNldFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KV07XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRhdmNDOiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCB7XG5cdFx0XHR2ZXJzaW9uOiBbJ2NvbnN0JywgJ3VpbnQ4JywgMV0sXG5cdFx0XHRwcm9maWxlSW5kaWNhdGlvbjogJ3VpbnQ4Jyxcblx0XHRcdHByb2ZpbGVDb21wYXRpYmlsaXR5OiAndWludDgnLFxuXHRcdFx0bGV2ZWxJbmRpY2F0aW9uOiAndWludDgnLFxuXHRcdFx0X3Jlc2VydmVkOiBbJ2NvbnN0JywgNiwgLTFdLFxuXHRcdFx0bGVuZ3RoU2l6ZU1pbnVzT25lOiAyLFxuXHRcdFx0X3Jlc2VydmVkMjogWydjb25zdCcsIDMsIC0xXSxcblx0XHRcdHNlcVBhcmFtU2V0czogWydQYXJhbVNldHMnLCA1XSxcblx0XHRcdHBpY3RQYXJhbVNldHM6IFsnUGFyYW1TZXRzJywgJ3VpbnQ4J11cblx0XHR9XSxcblxuXHRcdG1vb3Y6ICdNdWx0aUJveCcsXG5cblx0XHRtdmhkOiBbJ2V4dGVuZCcsICdEdXJhdGlvbkJveCcsIHtcblx0XHRcdHJhdGU6ICdSYXRlJyxcblx0XHRcdHZvbHVtZTogJ1ZvbHVtZScsXG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDEwXSxcblx0XHRcdG1hdHJpeDogJ1RyYW5zZm9ybWF0aW9uTWF0cml4Jyxcblx0XHRcdF9yZXNlcnZlZDI6IFsnc2tpcCcsIDI0XSxcblx0XHRcdG5leHRfdHJhY2tfSUQ6ICd1aW50MzInXG5cdFx0fV0sXG5cblx0XHR0cmFrOiAnTXVsdGlCb3gnLFxuXG5cdFx0dGtoZDogWydleHRlbmQnLCAnVGltZXN0YW1wQm94Jywge1xuXHRcdFx0dHJhY2tfSUQ6ICd1aW50MzInLFxuXHRcdFx0X3Jlc2VydmVkOiBbJ3NraXAnLCA0XSxcblx0XHRcdGR1cmF0aW9uOiAnRkJVaW50Jyxcblx0XHRcdF9yZXNlcnZlZDI6IFsnc2tpcCcsIDhdLFxuXHRcdFx0bGF5ZXI6ICdpbnQxNicsXG5cdFx0XHRhbHRlcm5hdGVfZ3JvdXA6ICd1aW50MTYnLFxuXHRcdFx0dm9sdW1lOiAnVm9sdW1lJyxcblx0XHRcdF9yZXNlcnZlZDM6IFsnc2tpcCcsIDJdLFxuXHRcdFx0bWF0cml4OiAnVHJhbnNmb3JtYXRpb25NYXRyaXgnLFxuXHRcdFx0ZGltZW5zaW9uczogWydEaW1lbnNpb25zJywgJ1JhdGUnXVxuXHRcdH1dLFxuXG5cdFx0dHJlZjogJ011bHRpQm94JyxcblxuXHRcdFRyYWNrUmVmZXJlbmNlVHlwZUJveDogWydleHRlbmQnLCAnQm94SGVhZGVyJywge1xuXHRcdFx0dHJhY2tfSURzOiBbJ2FycmF5JywgJ3VpbnQzMicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmJpbmFyeS5nZXRDb250ZXh0KDEpLl9lbmQgLSB0aGlzLmJpbmFyeS50ZWxsKCkpIC8gNCB9XVxuXHRcdH1dLFxuXG5cdFx0aGludDogJ1RyYWNrUmVmZXJlbmNlVHlwZUJveCcsXG5cblx0XHRjZHNjOiAnVHJhY2tSZWZlcmVuY2VUeXBlQm94JyxcblxuXHRcdGhpbmQ6ICdUcmFja1JlZmVyZW5jZVR5cGVCb3gnLFxuXG5cdFx0bWRpYTogJ011bHRpQm94JyxcblxuXHRcdG1kaGQ6IFsnZXh0ZW5kJywgJ0R1cmF0aW9uQm94Jywge1xuXHRcdFx0X3BhZGRpbmc6IDEsXG5cdFx0XHRsYW5nOiBqQmluYXJ5LlR5cGUoe1xuXHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG5cdFx0XHRcdFx0XHRTdHJpbmcsXG5cdFx0XHRcdFx0XHR0aGlzLmJpbmFyeS5yZWFkKFsnYXJyYXknLCA1LCAzXSkubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiBjb2RlICsgMHg2MCB9KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUoNSwgdmFsdWUuY2hhckNvZGVBdChpKSAtIDB4NjApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDJdXG5cdFx0fV0sXG5cblx0XHRoZGxyOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0X3Jlc2VydmVkOiBbJ3NraXAnLCA0XSxcblx0XHRcdGhhbmRsZXJfdHlwZTogJ1Nob3J0TmFtZScsXG5cdFx0XHRfc2V0X2hhbmRsZXJfdHlwZTogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0XHRcdFx0dGhpcy5iaW5hcnkuZ2V0Q29udGV4dChhdG9tRmlsdGVyKCd0cmFrJykpLl9oYW5kbGVyX3R5cGUgPSBjb250ZXh0LmhhbmRsZXJfdHlwZTtcblx0XHRcdH0sXG5cdFx0XHRfcmVzZXJ2ZWQyOiBbJ3NraXAnLCAxMl0sXG5cdFx0XHRuYW1lOiAnc3RyaW5nMCdcblx0XHR9XSxcblxuXHRcdG1pbmY6ICdNdWx0aUJveCcsXG5cblx0XHR2bWhkOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0Z3JhcGhpY3Ntb2RlOiAndWludDE2Jyxcblx0XHRcdG9wY29sb3I6IHtcblx0XHRcdFx0cjogJ3VpbnQxNicsXG5cdFx0XHRcdGc6ICd1aW50MTYnLFxuXHRcdFx0XHRiOiAndWludDE2J1xuXHRcdFx0fVxuXHRcdH1dLFxuXG5cdFx0c21oZDogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdGJhbGFuY2U6IFsnRml4ZWRQb2ludCcsICdpbnQxNicsIDhdLFxuXHRcdFx0X3Jlc2VydmVkOiBbJ3NraXAnLCAyXVxuXHRcdH1dLFxuXG5cdFx0aG1oZDogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdG1heFBEVXNpemU6ICd1aW50MTYnLFxuXHRcdFx0YXZnUERVc2l6ZTogJ3VpbnQxNicsXG5cdFx0XHRtYXhiaXRyYXRlOiAndWludDMyJyxcblx0XHRcdGF2Z2JpdHJhdGU6ICd1aW50MzInLFxuXHRcdFx0X3Jlc2VydmVkOiBbJ3NraXAnLCA0XVxuXHRcdH1dLFxuXG5cdFx0c3RibDogJ011bHRpQm94JyxcblxuXHRcdFNhbXBsZUVudHJ5OiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCB7XG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDZdLFxuXHRcdFx0ZGF0YV9yZWZlcmVuY2VfaW5kZXg6ICd1aW50MTYnXG5cdFx0fV0sXG5cblx0XHRidHJ0OiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCB7XG5cdFx0XHRidWZmZXJTaXplREI6ICd1aW50MzInLFxuXHRcdFx0bWF4Qml0cmF0ZTogJ3VpbnQzMicsXG5cdFx0XHRhdmdCaXRyYXRlOiAndWludDMyJ1xuXHRcdH1dLFxuXG5cdFx0bWV0eDogWydleHRlbmQnLCAnU2FtcGxlRW50cnknLCB7XG5cdFx0XHRjb250ZW50X2VuY29kaW5nOiAnc3RyaW5nMCcsXG5cdFx0XHRuYW1lc3BhY2U6ICdzdHJpbmcwJyxcblx0XHRcdHNjaGVtYV9sb2NhdGlvbjogJ3N0cmluZzAnLFxuXHRcdFx0Yml0cmF0ZWJveDogJ2J0cnQnXG5cdFx0fV0sXG5cblx0XHRtZXR0OiBbJ2V4dGVuZCcsICdTYW1wbGVFbnRyeScsIHtcblx0XHRcdGNvbnRlbnRfZW5jb2Rpbmc6ICdzdHJpbmcwJyxcblx0XHRcdG1pbWVfZm9ybWF0OiAnc3RyaW5nMCcsXG5cdFx0XHRiaXRyYXRlYm94OiAnYnRydCdcblx0XHR9XSxcblxuXHRcdHBhc3A6IFsnZXh0ZW5kJywgJ0JveEhlYWRlcicsIHtcblx0XHRcdHNwYWNpbmc6IFsnRGltZW5zaW9ucycsICd1aW50MzInXVxuXHRcdH1dLFxuXG5cdFx0Q2xhcElubmVyRm9ybWF0OiBbJ0RpbWVuc2lvbnMnLCB7XG5cdFx0XHROOiAndWludDMyJyxcblx0XHRcdEQ6ICd1aW50MzInXG5cdFx0fV0sXG5cblx0XHRjbGFwOiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCB7XG5cdFx0XHRjbGVhbkFwZXJ0dXJlOiAnQ2xhcElubmVyRm9ybWF0Jyxcblx0XHRcdG9mZjogJ0NsYXBJbm5lckZvcm1hdCdcblx0XHR9XSxcblxuXHRcdFZpc3VhbFNhbXBsZUVudHJ5OiBbJ2V4dGVuZCcsICdTYW1wbGVFbnRyeScsIHtcblx0XHRcdF9yZXNlcnZlZDogWydza2lwJywgMTZdLFxuXHRcdFx0ZGltZW5zaW9uczogWydEaW1lbnNpb25zJywgJ3VpbnQxNiddLFxuXHRcdFx0cmVzb2x1dGlvbjogWydEaW1lbnNpb25zJywgJ1JhdGUnXSxcblx0XHRcdF9yZXNlcnZlZDI6IFsnc2tpcCcsIDRdLFxuXHRcdFx0ZnJhbWVfY291bnQ6IFsnY29uc3QnLCAndWludDE2JywgMV0sXG5cdFx0XHRjb21wcmVzc29ybmFtZTogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRcdGJhc2VUeXBlOiB7XG5cdFx0XHRcdFx0bGVuZ3RoOiAndWludDgnLFxuXHRcdFx0XHRcdHN0cmluZzogWydzdHJpbmcnLCAnbGVuZ3RoJ10sXG5cdFx0XHRcdFx0X3NraXA6IFsnc2tpcCcsIGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiAzMiAtIDEgLSBjb250ZXh0Lmxlbmd0aCB9XVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmFzZVJlYWQoKS5zdHJpbmc7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHR0aGlzLmJhc2VXcml0ZSh7XG5cdFx0XHRcdFx0XHRsZW5ndGg6IHZhbHVlLmxlbmd0aCxcblx0XHRcdFx0XHRcdHN0cmluZzogdmFsdWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRkZXB0aDogJ3VpbnQxNicsXG5cdFx0XHRfcmVzZXJ2ZWQzOiBbJ2NvbnN0JywgJ2ludDE2JywgLTFdXG5cdFx0fSwgakJpbmFyeS5UeXBlKHtcblx0XHRcdHNldFBhcmFtczogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbmFsID0ge1xuXHRcdFx0XHRcdGNsZWFuYXBlcnR1cmU6ICdjbGFwJyxcblx0XHRcdFx0XHRwaXhlbGFzcGVjdHJhdGlvOiAncGFzcCdcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBleHRlbnNpb24gPSB7fTtcblxuXHRcdFx0XHRmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLm9wdGlvbmFsKSB7XG5cdFx0XHRcdFx0dmFyIHR5cGUgPSB0aGlzLm9wdGlvbmFsW3Byb3BOYW1lXTtcblx0XHRcdFx0XHR2YXIgYXRvbSA9IHRoaXMuYmluYXJ5LnNraXAoMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yZWFkKCdCb3hIZWFkZXInKSB9KTtcblx0XHRcdFx0XHRpZiAoYXRvbS50eXBlID09PSB0eXBlKSB7XG5cdFx0XHRcdFx0XHRleHRlbnNpb25bcHJvcE5hbWVdID0gdGhpcy5iaW5hcnkucmVhZCh0eXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xuXHRcdFx0fSxcblx0XHRcdHdyaXRlOiBmdW5jdGlvbiAoYm94KSB7XG5cdFx0XHRcdGZvciAodmFyIHByb3BOYW1lIGluIHRoaXMub3B0aW9uYWwpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBib3hbcHJvcE5hbWVdO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUodGhpcy5vcHRpb25hbFtwcm9wTmFtZV0sIHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KSwgJ0NoaWxkQXRvbXMnXSxcblxuXHRcdEF1ZGlvU2FtcGxlRW50cnk6IFsnZXh0ZW5kJywgJ1NhbXBsZUVudHJ5Jywge1xuXHRcdFx0X3Jlc2VydmVkOiBbJ3NraXAnLCA4XSxcblx0XHRcdGNoYW5uZWxjb3VudDogJ3VpbnQxNicsXG5cdFx0XHRzYW1wbGVzaXplOiAndWludDE2Jyxcblx0XHRcdF9yZXNlcnZlZDI6IFsnc2tpcCcsIDRdLFxuXHRcdFx0c2FtcGxlcmF0ZTogJ1JhdGUnXG5cdFx0fSwgJ0NoaWxkQXRvbXMnXSxcblxuXHRcdER5bmFtaWNBcnJheTogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChsZW5ndGhUeXBlLCBpdGVtVHlwZSkge1xuXHRcdFx0XHR0aGlzLmJhc2VUeXBlID0ge1xuXHRcdFx0XHRcdGxlbmd0aDogbGVuZ3RoVHlwZSxcblx0XHRcdFx0XHRhcnJheTogWydhcnJheScsIGl0ZW1UeXBlLCAnbGVuZ3RoJ11cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJhc2VSZWFkKCkuYXJyYXk7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChhcnJheSkge1xuXHRcdFx0XHR0aGlzLmJhc2VXcml0ZSh7XG5cdFx0XHRcdFx0bGVuZ3RoOiBhcnJheS5sZW5ndGgsXG5cdFx0XHRcdFx0YXJyYXk6IGFycmF5XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0QXJyYXlCb3g6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAoZW50cnlUeXBlKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVR5cGUgPSBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0XHRcdGVudHJpZXM6IFsnRHluYW1pY0FycmF5JywgJ3VpbnQzMicsIGVudHJ5VHlwZV1cblx0XHRcdFx0fV07XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRzdHNkOiBbJ0FycmF5Qm94JywgakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRnZXRCYXNlVHlwZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4ge3NvdW46ICdBdWRpb1NhbXBsZUVudHJ5JywgdmlkZTogJ1Zpc3VhbFNhbXBsZUVudHJ5JywgbWV0YTogJ0JveCd9W3RoaXMuYmluYXJ5LmdldENvbnRleHQoYXRvbUZpbHRlcigndHJhaycpKS5faGFuZGxlcl90eXBlXSB8fCAnU2FtcGxlRW50cnknO1xuXHRcdFx0fSxcblx0XHRcdHdyaXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0dmFyIHBvcyA9IHRoaXMuYmluYXJ5LnRlbGwoKTtcblx0XHRcdFx0dGhpcy5iYXNlV3JpdGUodmFsdWUpO1xuXHRcdFx0XHR2YXIgc2l6ZSA9IHRoaXMuYmluYXJ5LnRlbGwoKSAtIHBvcztcblx0XHRcdFx0dGhpcy5iaW5hcnkuc2Vlayhwb3MsIGZ1bmN0aW9uICgpIHsgdGhpcy53cml0ZSgndWludDMyJywgc2l6ZSkgfSk7XG5cdFx0XHR9XG5cdFx0fSldLFxuXG5cdFx0c3RkcDogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdHByaW9yaXRpZXM6IFsnYXJyYXknLCAndWludDE2JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5iaW5hcnkuZ2V0Q29udGV4dChhdG9tRmlsdGVyKCdzdGJsJykpLl9zYW1wbGVfY291bnQgfV1cblx0XHR9XSxcblxuXHRcdHN0c2w6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRfcmVzZXJ2ZWQ6IDcsXG5cdFx0XHRjb25zdHJhaW50X2ZsYWc6ICdib29sJyxcblx0XHRcdHNjYWxlX21ldGhvZDogWydlbnVtJywgJ3VpbnQ4JywgW2ZhbHNlLCAnZmlsbCcsICdoaWRkZW4nLCAnbWVldCcsICdzbGljZS14JywgJ3NsaWNlLXknXV0sXG5cdFx0XHRkaXNwbGF5X2NlbnRlcjogWydEaW1lbnNpb25zJywgJ2ludDE2J11cblx0XHR9XSxcblxuXHRcdHN0dHM6IFsnQXJyYXlCb3gnLCB7XG5cdFx0XHRzYW1wbGVfY291bnQ6ICd1aW50MzInLFxuXHRcdFx0c2FtcGxlX2RlbHRhOiAndWludDMyJ1xuXHRcdH1dLFxuXG5cdFx0Y3R0czogWydBcnJheUJveCcsIHtcblx0XHRcdHNhbXBsZV9jb3VudDogJ3VpbnQzMicsXG5cdFx0XHRzYW1wbGVfb2Zmc2V0OiAndWludDMyJ1xuXHRcdH1dLFxuXG5cdFx0c3RzczogWydBcnJheUJveCcsICd1aW50MzInXSxcblxuXHRcdHN0c2g6IFsnQXJyYXlCb3gnLCB7XG5cdFx0XHRzaGFkb3dlZF9zYW1wbGVfbnVtYmVyOiAndWludDMyJyxcblx0XHRcdHN5bmNfc2FtcGxlX251bWJlcjogJ3VpbnQzMidcblx0XHR9XSxcblxuXHRcdEV4dGVuZGVkQm9vbGVhbjogWydlbnVtJywgMiwgW3VuZGVmaW5lZCwgdHJ1ZSwgZmFsc2VdXSxcblxuXHRcdHNkdHA6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRkZXBlbmRlbmNpZXM6IFsnYXJyYXknLCB7XG5cdFx0XHRcdF9yZXNlcnZlZDogMixcblx0XHRcdFx0c2FtcGxlX2RlcGVuZHNfb246ICdFeHRlbmRlZEJvb2xlYW4nLFxuXHRcdFx0XHRzYW1wbGVfaXNfZGVwZW5kZWRfb246ICdFeHRlbmRlZEJvb2xlYW4nLFxuXHRcdFx0XHRzYW1wbGVfaGFzX3JlZHVuZGFuY3k6ICdFeHRlbmRlZEJvb2xlYW4nXG5cdFx0XHR9LCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJpbmFyeS5nZXRDb250ZXh0KGF0b21GaWx0ZXIoJ3N0YmwnKSkuX3NhbXBsZV9jb3VudCB9XVxuXHRcdH1dLFxuXG5cdFx0ZWR0czogJ011bHRpQm94JyxcblxuXHRcdGVsc3Q6IFsnQXJyYXlCb3gnLCB7XG5cdFx0XHRzZWdtZW50X2R1cmF0aW9uOiAnRkJVaW50Jyxcblx0XHRcdG1lZGlhX3RpbWU6IFsnRkJWZXJzaW9uYWJsZScsICdpbnQzMicsICdpbnQ2NCddLFxuXHRcdFx0bWVkaWFfcmF0ZTogJ1JhdGUnXG5cdFx0fV0sXG5cblx0XHRkaW5mOiAnTXVsdGlCb3gnLFxuXG5cdFx0J3VybCAnOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0bG9jYXRpb246ICdzdHJpbmcwJ1xuXHRcdH1dLFxuXG5cdFx0J3VybiAnOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0bmFtZTogJ3N0cmluZzAnLFxuXHRcdFx0bG9jYXRpb246ICdzdHJpbmcwJ1xuXHRcdH1dLFxuXG5cdFx0ZHJlZjogWydBcnJheUJveCcsICdCb3gnXSxcblxuXHRcdHN0c3o6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRzYW1wbGVfc2l6ZTogJ3VpbnQzMicsXG5cdFx0XHRzYW1wbGVfY291bnQ6ICd1aW50MzInLFxuXHRcdFx0X3NhbXBsZV9jb3VudF90b19zdGJsOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHRcdFx0XHR0aGlzLmJpbmFyeS5nZXRDb250ZXh0KGF0b21GaWx0ZXIoJ3N0YmwnKSkuX3NhbXBsZV9jb3VudCA9IGNvbnRleHQuc2FtcGxlX2NvdW50O1xuXHRcdFx0fSxcblx0XHRcdHNhbXBsZV9zaXplczogWydpZl9ub3QnLCAnc2FtcGxlX3NpemUnLFxuXHRcdFx0XHRbJ2FycmF5JywgJ3VpbnQzMicsICdzYW1wbGVfY291bnQnXVxuXHRcdFx0XVxuXHRcdH1dLFxuXG5cdFx0c3R6MjogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdF9yZXNlcnZlZDogWydza2lwJywgM10sXG5cdFx0XHRmaWVsZF9zaXplOiAndWludDgnLFxuXHRcdFx0c2FtcGxlX2NvdW50OiAndWludDMyJyxcblx0XHRcdF9zYW1wbGVfY291bnRfdG9fc3RibDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0XHRcdFx0dGhpcy5iaW5hcnkuZ2V0Q29udGV4dChhdG9tRmlsdGVyKCdzdGJsJykpLl9zYW1wbGVfY291bnQgPSBjb250ZXh0LnNhbXBsZV9jb3VudDtcblx0XHRcdH0sXG5cdFx0XHRzYW1wbGVfc2l6ZXM6IFtcblx0XHRcdFx0J2FycmF5Jyxcblx0XHRcdFx0akJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRcdFx0Z2V0QmFzZVR5cGU6IGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0LmZpZWxkX3NpemUgfVxuXHRcdFx0XHR9KSxcblx0XHRcdFx0J3NhbXBsZV9jb3VudCdcblx0XHRcdF1cblx0XHR9XSxcblxuXHRcdHN0c2M6IFsnQXJyYXlCb3gnLCB7XG5cdFx0XHRmaXJzdF9jaHVuazogJ3VpbnQzMicsXG5cdFx0XHRzYW1wbGVzX3Blcl9jaHVuazogJ3VpbnQzMicsXG5cdFx0XHRzYW1wbGVfZGVzY3JpcHRpb25faW5kZXg6ICd1aW50MzInXG5cdFx0fV0sXG5cblx0XHRzdGNvOiBbJ0FycmF5Qm94JywgJ3VpbnQzMiddLFxuXG5cdFx0Y282NDogWydBcnJheUJveCcsICd1aW50NjQnXSxcblxuXHRcdHBhZGI6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRwYWRzOiBbJ0R5bmFtaWNBcnJheScsICd1aW50MzInLCBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdFx0YmFzZVR5cGU6IHtcblx0XHRcdFx0XHRfc2tpcDogWydjb25zdCcsIDEsIDBdLFxuXHRcdFx0XHRcdHBhZDogM1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmFzZVJlYWQoKS5wYWQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAocGFkKSB7XG5cdFx0XHRcdFx0dGhpcy5iYXNlV3JpdGUoe3BhZDogcGFkfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXVxuXHRcdH1dLFxuXG5cdFx0c3ViczogWydBcnJheUJveCcsIHtcblx0XHRcdHNhbXBsZV9kZWx0YTogJ3VpbnQzMicsXG5cdFx0XHRzdWJzYW1wbGVzOiBbJ0R5bmFtaWNBcnJheScsICd1aW50MTYnLCB7XG5cdFx0XHRcdHN1YnNhbXBsZV9zaXplOiBbJ0ZCVmVyc2lvbmFibGUnLCAndWludDE2JywgJ3VpbnQzMiddLFxuXHRcdFx0XHRzdWJzYW1wbGVfcHJpb3JpdHk6ICd1aW50OCcsXG5cdFx0XHRcdGRpc2NhcmRhYmxlOiAndWludDgnLFxuXHRcdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDRdXG5cdFx0XHR9XVxuXHRcdH1dLFxuXG5cdFx0bXZleDogJ011bHRpQm94JyxcblxuXHRcdG1laGQ6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRmcmFnbWVudF9kdXJhdGlvbjogJ0ZCVWludCdcblx0XHR9XSxcblxuXHRcdGVzZHNfc2VjdGlvbjogWydleHRlbmQnLCB7XG5cdFx0XHRkZXNjcmlwdG9yX3R5cGU6ICd1aW50OCcsXG5cdFx0XHRleHRfdHlwZTogakJpbmFyeS5UeXBlKHtcblx0XHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBuZXh0X2J5dGUgPSB0aGlzLmJpbmFyeS5yZWFkKCd1aW50OCcpO1xuXHRcdFx0XHRcdGlmIChuZXh0X2J5dGUgPT09IDB4ODAgfHwgbmV4dF9ieXRlID09PSAweDgxIHx8IG5leHRfYnl0ZSA9PT0gMHhGRSkge1xuXHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkuc2tpcCgyKTtcblx0XHRcdFx0XHRcdHJldHVybiBuZXh0X2J5dGU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuYmluYXJ5LnNraXAoLTEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChmaWxsZXIpIHtcblx0XHRcdFx0XHRpZiAoZmlsbGVyICE9PSB1bmRlZmluZWQpIHRoaXMuYmluYXJ5LndyaXRlKCdibG9iJywgW2ZpbGxlciwgZmlsbGVyLCBmaWxsZXJdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRsZW5ndGg6ICd1aW50OCdcblx0XHR9LCBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdGdldEJhc2VUeXBlOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHRcdFx0XHRzd2l0Y2ggKGNvbnRleHQuZGVzY3JpcHRvcl90eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAzOiByZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXNfaWQ6ICd1aW50MTYnLFxuXHRcdFx0XHRcdFx0c3RyZWFtX3ByaW9yaXR5OiAndWludDgnXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNhc2UgNDogcmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IFsnZW51bScsICd1aW50OCcsIHtcblx0XHRcdFx0XHRcdFx0MTogJ3YxJyxcblx0XHRcdFx0XHRcdFx0MjogJ3YyJyxcblx0XHRcdFx0XHRcdFx0MzI6ICdtcGVnNF92aWRlbycsXG5cdFx0XHRcdFx0XHRcdDMzOiAnbXBlZzRfYXZjX3NwcycsXG5cdFx0XHRcdFx0XHRcdDM0OiAnbXBlZzRfYXZjX3BwcycsXG5cdFx0XHRcdFx0XHRcdDY0OiAnbXBlZzRfYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQ5NjogJ21wZWcyX3NpbXBsZV92aWRlbycsXG5cdFx0XHRcdFx0XHRcdDk3OiAnbXBlZzJfbWFpbl92aWRlbycsXG5cdFx0XHRcdFx0XHRcdDk4OiAnbXBlZzJfc25yX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0OTk6ICdtcGVnMl9zcGF0aWFsX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0MTAwOiAnbXBlZzJfaGlnaF92aWRlbycsXG5cdFx0XHRcdFx0XHRcdDEwMTogJ21wZWcyXzQyMl92aWRlbycsXG5cdFx0XHRcdFx0XHRcdDEwMjogJ21wZWc0X2FkdHNfbWFpbicsXG5cdFx0XHRcdFx0XHRcdDEwMzogJ21wZWc0X2FkdHNfbG93X2NvbXBsZXhpdHknLFxuXHRcdFx0XHRcdFx0XHQxMDQ6ICdtcGVnNF9hZHRzX3NjYWxlYWJsZV9zYW1wbGluZycsXG5cdFx0XHRcdFx0XHRcdDEwNTogJ21wZWcyX2FkdHNfbWFpbicsXG5cdFx0XHRcdFx0XHRcdDEwNjogJ21wZWcxX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0MTA3OiAnbXBlZzFfYWR0cycsXG5cdFx0XHRcdFx0XHRcdDEwODogJ2pwZWdfdmlkZW8nLFxuXHRcdFx0XHRcdFx0XHQxOTI6ICdwcml2YXRlX2F1ZGlvJyxcblx0XHRcdFx0XHRcdFx0MjA4OiAncHJpdmF0ZV92aWRlbycsXG5cdFx0XHRcdFx0XHRcdDIyNDogJ3BjbV9saXR0bGVfZW5kaWFuX2F1ZGlvJyxcblx0XHRcdFx0XHRcdFx0MjI1OiAndm9yYmlzX2F1ZGlvJyxcblx0XHRcdFx0XHRcdFx0MjI2OiAnZG9sYnlfdjNfYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQyMjc6ICdhbGF3X2F1ZGlvJyxcblx0XHRcdFx0XHRcdFx0MjI4OiAnbXVsYXdfYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQyMjk6ICdhZHBjbV9hdWRpbycsXG5cdFx0XHRcdFx0XHRcdDIzMDogJ3BjbV9iaWdfZW5kaWFuX2F1ZGlvJyxcblx0XHRcdFx0XHRcdFx0MjQwOiAneXYxMl92aWRlbycsXG5cdFx0XHRcdFx0XHRcdDI0MTogJ2gyNjRfdmlkZW8nLFxuXHRcdFx0XHRcdFx0XHQyNDI6ICdoMjYzX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0MjQzOiAnaDI2MV92aWRlbydcblx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0c3RyZWFtX3R5cGU6IFsnZW51bScsIDYsIFtcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0J29iamVjdCcsXG5cdFx0XHRcdFx0XHRcdCdjbG9jaycsXG5cdFx0XHRcdFx0XHRcdCdzY2VuZScsXG5cdFx0XHRcdFx0XHRcdCd2aXN1YWwnLFxuXHRcdFx0XHRcdFx0XHQnYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQnbXBlZy03Jyxcblx0XHRcdFx0XHRcdFx0J2lwbXAnLFxuXHRcdFx0XHRcdFx0XHQnb2NpJyxcblx0XHRcdFx0XHRcdFx0J21wZWctamF2YSdcblx0XHRcdFx0XHRcdF1dLFxuXHRcdFx0XHRcdFx0dXBzdHJlYW1fZmxhZzogMSxcblx0XHRcdFx0XHRcdF9yZXNlcnZlZDogWydjb25zdCcsIDEsIDFdLFxuXHRcdFx0XHRcdFx0YnVmZmVyX3NpemU6IDI0LFxuXHRcdFx0XHRcdFx0bWF4Qml0cmF0ZTogJ3VpbnQzMicsXG5cdFx0XHRcdFx0XHRhdmdCaXRyYXRlOiAndWludDMyJ1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjYXNlIDU6IHJldHVybiB7XG5cdFx0XHRcdFx0XHRhdWRpb19wcm9maWxlOiBbJ2VudW0nLCA1LCBbXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdCdhYWMtbWFpbicsXG5cdFx0XHRcdFx0XHRcdCdhYWMtbGMnLFxuXHRcdFx0XHRcdFx0XHQnYWFjLXNzcicsXG5cdFx0XHRcdFx0XHRcdCdhYWMtbHRwJyxcblx0XHRcdFx0XHRcdFx0J3NicicsXG5cdFx0XHRcdFx0XHRcdCdhYWMtc2NhbGFibGUnLFxuXHRcdFx0XHRcdFx0XHQndHdpbnZxJyxcblx0XHRcdFx0XHRcdFx0J2NlbHAnLFxuXHRcdFx0XHRcdFx0XHQnaHh2YycsXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdCd0dHNpJyxcblx0XHRcdFx0XHRcdFx0J21haW4tc3ludGhlc2lzJyxcblx0XHRcdFx0XHRcdFx0J3dhdmV0YWJsZS1zeW50aGVzaXMnLFxuXHRcdFx0XHRcdFx0XHQnZ2VuZXJhbC1taWRpJyxcblx0XHRcdFx0XHRcdFx0J2FsZ29yaXRobWljLXN5bnRoZXNpcy1hbmQtYXVkaW8tZWZmZWN0cycsXG5cdFx0XHRcdFx0XHRcdCdlci1hYWMtbGMnLFxuXHRcdFx0XHRcdFx0XHQncmVzZXJ2ZWQnLFxuXHRcdFx0XHRcdFx0XHQnZXItYWFjLWx0cCcsXG5cdFx0XHRcdFx0XHRcdCdlci1hYWMtc2NhbGFibGUnLFxuXHRcdFx0XHRcdFx0XHQnZXItdHdpbnZxJyxcblx0XHRcdFx0XHRcdFx0J2VyLWJzYWMnLFxuXHRcdFx0XHRcdFx0XHQnZXItYWFjLWxkJyxcblx0XHRcdFx0XHRcdFx0J2VyLWNlbHAnLFxuXHRcdFx0XHRcdFx0XHQnZXItaHZ4YycsXG5cdFx0XHRcdFx0XHRcdCdlci1oaWxuJyxcblx0XHRcdFx0XHRcdFx0J2VyLXBhcmFtZXRyaWMnLFxuXHRcdFx0XHRcdFx0XHQnc3NjJyxcblx0XHRcdFx0XHRcdFx0J3BzJyxcblx0XHRcdFx0XHRcdFx0J21wZWctc3Vycm91bmQnXG5cdFx0XHRcdFx0XHRdXSxcblx0XHRcdFx0XHRcdHNhbXBsaW5nX2ZyZXE6IGpCaW5hcnkuVHlwZSh7XG5cdFx0XHRcdFx0XHRcdHNldFBhcmFtczogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZnJlcUxpc3QgPSBbOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwXTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBmcmVxSW5kZXggPSB0aGlzLmJpbmFyeS5yZWFkKDQpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmcmVxSW5kZXggIT09IDE1ID8gdGhpcy5mcmVxTGlzdFtmcmVxSW5kZXhdIDogdGhpcy5iaW5hcnkucmVhZCgyNCk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZnJlcUluZGV4ID0gdGhpcy5mcmVxTGlzdC5pbmRleE9mKHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZnJlcUluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUoNCwgZnJlcUluZGV4KTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUoNCwgMTUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUoMjQsIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdFx0Y2hhbm5lbENvbmZpZzogNCxcblx0XHRcdFx0XHRcdGZyYW1lTGVuZ3RoOiBbJ2VudW0nLCAxLCBbMTAyNCwgOTYwXV0sXG5cdFx0XHRcdFx0XHRkZXBlbmRzT25Db3JlQ29kZXI6IDEsXG5cdFx0XHRcdFx0XHRleHRlbnNpb25GbGFnOiAxXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNhc2UgNjogcmV0dXJuIHtcblx0XHRcdFx0XHRcdHNsOiBbJ2NvbnN0JywgJ3VpbnQ4JywgMl1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSldLFxuXG5cdFx0ZXNkczogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdHNlY3Rpb25zOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdFx0YmFzZVR5cGU6ICdlc2RzX3NlY3Rpb24nLFxuXHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIGVuZCA9IHRoaXMuYmluYXJ5LmdldENvbnRleHQoJ19lbmQnKS5fZW5kLCBzZWN0aW9ucyA9IFtdO1xuXHRcdFx0XHRcdHdoaWxlICh0aGlzLmJpbmFyeS50ZWxsKCkgPCBlbmQpIHtcblx0XHRcdFx0XHRcdHNlY3Rpb25zLnB1c2godGhpcy5iYXNlUmVhZCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHNlY3Rpb25zO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKHNlY3Rpb25zKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlY3Rpb25zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmJhc2VXcml0ZShzZWN0aW9uc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1dLFxuXG5cdFx0RmlsZTogWydBdG9tcycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuYmluYXJ5LnZpZXcuYnl0ZUxlbmd0aCB9XVxuXHR9O1xufSkpO1xuIiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbJ2piaW5hcnknXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqYmluYXJ5JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QuTVBFR1RTID0gZmFjdG9yeShyb290LmpCaW5hcnkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGpCaW5hcnkpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHJldHVybiB7XG5cdFx0UENSOiB7XG5cdFx0XHRwdHM6IDMzLFxuXHRcdFx0X3Jlc2VydmVkOiA2LFxuXHRcdFx0ZXh0ZW5zaW9uOiA5XG5cdFx0fSxcblxuXHRcdER5bmFtaWNBcnJheTogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChsZW5ndGhUeXBlLCBpdGVtVHlwZSkge1xuXHRcdFx0XHR0aGlzLmJhc2VUeXBlID0ge1xuXHRcdFx0XHRcdGxlbmd0aDogbGVuZ3RoVHlwZSxcblx0XHRcdFx0XHRhcnJheTogWydhcnJheScsIGl0ZW1UeXBlLCAnbGVuZ3RoJ11cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJhc2VSZWFkKCkuYXJyYXk7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChhcnJheSkge1xuXHRcdFx0XHR0aGlzLmJhc2VXcml0ZSh7XG5cdFx0XHRcdFx0bGVuZ3RoOiBhcnJheS5sZW5ndGgsXG5cdFx0XHRcdFx0YXJyYXk6IGFycmF5XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0RmllbGQ6IFsnRHluYW1pY0FycmF5JywgJ3VpbnQ4JywgJ3VpbnQ4J10sXG5cblx0XHRGbGFnOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdGJhc2VUeXBlOiAxLFxuXHRcdFx0cGFyYW1zOiBbJ2RlcGVuZGVudEZpZWxkJ10sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG5cdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHRoaXMuZGVwZW5kZW50RmllbGQgaW4gY29udGV4dCA/IDEgOiAwKTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdEZsYWdEZXBlbmRlbnQ6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0cGFyYW1zOiBbJ2ZsYWdGaWVsZCcsICdiYXNlVHlwZSddLFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW5hcnkucmVhZChbJ2lmJywgdGhpcy5mbGFnRmllbGQsIHRoaXMuYmFzZVR5cGVdKTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdEFkYXB0YXRpb25GaWVsZDoge1xuXHRcdFx0bGVuZ3RoOiAndWludDgnLFxuXHRcdFx0X2VuZE9mOiBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gdGhpcy5iaW5hcnkudGVsbCgpICsgY29udGV4dC5sZW5ndGggfSxcblx0XHRcdGRpc2NvbnRpbnVpdHk6IDEsXG5cdFx0XHRyYW5kb21BY2Nlc3M6IDEsXG5cdFx0XHRwcmlvcml0eTogMSxcblx0XHRcdF9oYXNQQ1I6IFsnRmxhZycsICdwY3InXSxcblx0XHRcdF9oYXNPUENSOiBbJ0ZsYWcnLCAnb3BjciddLFxuXHRcdFx0X2hhc1NwbGljaW5nUG9pbnQ6IFsnRmxhZycsICdzcGxpY2VDb3VudGRvd24nXSxcblx0XHRcdF9oYXNUcmFuc3BvcnRQcml2YXRlRGF0YTogWydGbGFnJywgJ3ByaXZhdGVEYXRhJ10sXG5cdFx0XHRfaGFzRXh0ZW5zaW9uOiBbJ0ZsYWcnLCAnZXh0ZW5zaW9uJ10sXG5cdFx0XHRwY3I6IFsnRmxhZ0RlcGVuZGVudCcsICdfaGFzUENSJywgJ1BDUiddLFxuXHRcdFx0b3BjcjogWydGbGFnRGVwZW5kZW50JywgJ19oYXNPUENSJywgJ1BDUiddLFxuXHRcdFx0c3BsaWNlQ291bnRkb3duOiBbJ0ZsYWdEZXBlbmRlbnQnLCAnX2hhc1NwbGljaW5nUG9pbnQnLCAndWludDgnXSxcblx0XHRcdHByaXZhdGVEYXRhOiBbJ0ZsYWdEZXBlbmRlbnQnLCAnX2hhc1RyYW5zcG9ydFByaXZhdGVEYXRhJywgJ0ZpZWxkJ10sXG5cdFx0XHRleHRlbnNpb246IFsnRmxhZ0RlcGVuZGVudCcsICdfaGFzRXh0ZW5zaW9uJywgJ0ZpZWxkJ10sXG5cdFx0XHRfdG9FbmQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7IHRoaXMuYmluYXJ5LnNlZWsoY29udGV4dC5fZW5kT2YpIH1cblx0XHR9LFxuXG5cdFx0RVM6IHtcblx0XHRcdF9yYXdTdHJlYW06IFsnYmxvYicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuYmluYXJ5LmdldENvbnRleHQoMSkuX2VuZG9mIC0gdGhpcy5iaW5hcnkudGVsbCgpIH1dXG5cdFx0fSxcblxuXHRcdFBBVEl0ZW06IFsnYXJyYXknLCB7XG5cdFx0XHRwcm9ncmFtTnVtYmVyOiAndWludDE2Jyxcblx0XHRcdF9yZXNlcnZlZDogMyxcblx0XHRcdHBpZDogMTNcblx0XHR9LCBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gY29udGV4dC5fZGF0YUxlbmd0aCAvIDQgfV0sXG5cblx0XHRQTVRIZWFkZXI6IHtcblx0XHRcdF9yZXNlcnZlZDogMyxcblx0XHRcdHBjclBJRDogMTMsXG5cdFx0XHRfcmVzZXJ2ZWQyOiA0LFxuXHRcdFx0cHJvZ3JhbURlc2NyaXB0b3JzOiBbJ0R5bmFtaWNBcnJheScsIDEyLCAndWludDgnXVxuXHRcdH0sXG5cblx0XHRQTVRJdGVtOiB7XG5cdFx0XHRzdHJlYW1UeXBlOiAndWludDgnLFxuXHRcdFx0X3Jlc2VydmVkOiAzLFxuXHRcdFx0ZWxlbWVudGFyeVBJRDogMTMsXG5cdFx0XHRfcmVzZXJ2ZWQyOiA0LFxuXHRcdFx0ZXNJbmZvOiBbJ0R5bmFtaWNBcnJheScsIDEyLCAndWludDgnXVxuXHRcdH0sXG5cblx0XHRQcml2YXRlU2VjdGlvbjogWydleHRlbmQnLCB7XG5cdFx0XHRwb2ludGVyRmllbGQ6IFsnaWYnLCAncGF5bG9hZFN0YXJ0JywgJ3VpbnQ4J10sXG5cdFx0XHR0YWJsZUlkOiBbJ2VudW0nLCAndWludDgnLCBbJ1BBVCcsICdDQVQnLCAnUE1UJ11dLFxuXHRcdFx0aXNMb25nU2VjdGlvbjogMSxcblx0XHRcdGlzUHJpdmF0ZTogMSxcblx0XHRcdF9yZXNlcnZlZDogMixcblx0XHRcdF9zZWN0aW9uTGVuZ3RoOiAxMlxuXHRcdH0sIFsnaWYnLCAnaXNMb25nU2VjdGlvbicsIHtcblx0XHRcdFx0dGFibGVJZEV4dDogJ3VpbnQxNicsXG5cdFx0XHRcdF9yZXNlcnZlZDogMixcblx0XHRcdFx0dmVyc2lvbk51bWJlcjogNSxcblx0XHRcdFx0Y3VycmVudE5leHRJbmRpY2F0b3I6IDEsXG5cdFx0XHRcdHNlY3Rpb25OdW1iZXI6ICd1aW50OCcsXG5cdFx0XHRcdGxhc3RTZWN0aW9uTnVtYmVyOiAndWludDgnLFxuXG5cdFx0XHRcdF9kYXRhTGVuZ3RoOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJpbmFyeS5nZXRDb250ZXh0KDEpLl9zZWN0aW9uTGVuZ3RoIC0gOSB9LFxuXG5cdFx0XHRcdGRhdGE6IGpCaW5hcnkuVHlwZSh7XG5cdFx0XHRcdFx0cmVhZDogZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0XHRcdFx0dmFyIGRhdGEsIGZpbGUgPSB0aGlzLmJpbmFyeS5nZXRDb250ZXh0KDMpLCBkYXRhTGVuZ3RoID0gaGVhZGVyLl9kYXRhTGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKHRoaXMuYmluYXJ5LmdldENvbnRleHQoMSkudGFibGVJZCkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdQQVQnOlxuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSB0aGlzLmJpbmFyeS5yZWFkKCdQQVRJdGVtJyk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoaGVhZGVyLnNlY3Rpb25OdW1iZXIgPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsZS5wYXQgPSB7fTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpbGUucGF0W2RhdGFbaV0ucGlkXSA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnUE1UJzpcblx0XHRcdFx0XHRcdFx0XHRkYXRhID0gdGhpcy5iaW5hcnkucmVhZCgnUE1USGVhZGVyJyk7XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhLm1hcHBpbmdzID0gW107XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhTGVuZ3RoIC09IDQgKyBkYXRhLnByb2dyYW1EZXNjcmlwdG9ycy5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoZGF0YUxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtYXBwaW5nID0gdGhpcy5iaW5hcnkucmVhZCgnUE1USXRlbScpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5tYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YUxlbmd0aCAtPSA1ICsgbWFwcGluZy5lc0luZm8ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlmIChoZWFkZXIuc2VjdGlvbk51bWJlciA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWxlLnBtdCA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5tYXBwaW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1hcHBpbmcgPSBkYXRhLm1hcHBpbmdzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsZS5wbXRbbWFwcGluZy5lbGVtZW50YXJ5UElEXSA9IG1hcHBpbmc7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSksXG5cblx0XHRcdFx0Y3JjMzI6ICd1aW50MzInXG5cdFx0XHR9LFxuXHRcdFx0WydibG9iJywgJ19zZWN0aW9uTGVuZ3RoJ11cblx0XHRdXSxcblxuXHRcdFBhY2tldDoge1xuXHRcdFx0X3N0YXJ0b2Y6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuYmluYXJ5LnRlbGwoKSB9LFxuXHRcdFx0X2VuZG9mOiBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gY29udGV4dC5fc3RhcnRvZiArIDE4OCB9LFxuXG5cdFx0XHRfc3luY0J5dGU6IFsnY29uc3QnLCAndWludDgnLCAweDQ3LCB0cnVlXSxcblxuXHRcdFx0dHJhbnNwb3J0RXJyb3I6IDEsXG5cdFx0XHRwYXlsb2FkU3RhcnQ6IDEsXG5cdFx0XHR0cmFuc3BvcnRQcmlvcml0eTogMSxcblx0XHRcdHBpZDogMTMsXG5cblx0XHRcdHNjcmFtYmxpbmdDb250cm9sOiAyLFxuXHRcdFx0X2hhc0FkYXB0YXRpb25GaWVsZDogWydGbGFnJywgJ2FkYXB0YXRpb25GaWVsZCddLFxuXHRcdFx0X2hhc1BheWxvYWQ6IFsnRmxhZycsICdwYXlsb2FkJ10sXG5cdFx0XHRjb250Q291bnRlcjogNCxcblxuXHRcdFx0YWRhcHRhdGlvbkZpZWxkOiBbJ0ZsYWdEZXBlbmRlbnQnLCAnX2hhc0FkYXB0YXRpb25GaWVsZCcsICdBZGFwdGF0aW9uRmllbGQnXSxcblxuXHRcdFx0cGF5bG9hZDogWydGbGFnRGVwZW5kZW50JywgJ19oYXNQYXlsb2FkJywgakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRcdGdldEJhc2VUeXBlOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHRcdFx0XHRcdHZhciBwaWQgPSBjb250ZXh0LnBpZCwgZmlsZSA9IHRoaXMuYmluYXJ5LmdldENvbnRleHQoMSk7XG5cdFx0XHRcdFx0aWYgKHBpZCA8IDIgfHwgcGlkIGluIGZpbGUucGF0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ1ByaXZhdGVTZWN0aW9uJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBpZCBpbiBmaWxlLnBtdCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICdFUyc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KV0sXG5cblx0XHRcdF90b0VuZDogZnVuY3Rpb24gKGNvbnRleHQpIHsgdGhpcy5iaW5hcnkuc2Vlayhjb250ZXh0Ll9lbmRvZikgfVxuXHRcdH0sXG5cblx0XHRGaWxlOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdGJhc2VUeXBlOiBbJ2FycmF5JywgJ1BhY2tldCddLFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLnBhdCA9IHt9O1xuXHRcdFx0XHR0aGlzLnBtdCA9IHt9O1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbmFyeS5pbkNvbnRleHQodGhpcywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBzZWxmLmJhc2VSZWFkKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdHdyaXRlOiBmdW5jdGlvbiAocGFja2V0cykge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuYmluYXJ5LmluQ29udGV4dCh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0c2VsZi5iYXNlV3JpdGUocGFja2V0cyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pXG5cdH07XG59KSk7IiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbJ2piaW5hcnknXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqYmluYXJ5JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QuUEVTID0gZmFjdG9yeShyb290LmpCaW5hcnkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGpCaW5hcnkpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHJldHVybiB7XG5cdFx0RmxhZzogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRiYXNlVHlwZTogMSxcblx0XHRcdHBhcmFtczogWydkZXBlbmRlbnRGaWVsZCddLFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuXHRcdFx0XHR0aGlzLmJhc2VXcml0ZSh0aGlzLmRlcGVuZGVudEZpZWxkIGluIGNvbnRleHQgPyAxIDogMCk7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRGbGFnRGVwZW5kZW50OiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdHBhcmFtczogWydmbGFnRmllbGQnLCAnYmFzZVR5cGUnXSxcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmluYXJ5LnJlYWQoWydpZicsIHRoaXMuZmxhZ0ZpZWxkLCB0aGlzLmJhc2VUeXBlXSk7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRQRVNUaW1lU3RhbXA6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocHJlZml4KSB7XG5cdFx0XHRcdHZhciBza2lwQml0ID0gWydjb25zdCcsIDEsIDEsIHRydWVdO1xuXHRcdFx0XHR0aGlzLmJhc2VUeXBlID0ge1xuXHRcdFx0XHRcdF9wcmVmaXg6IFsnY29uc3QnLCA0LCBwcmVmaXgsIHRydWVdLFxuXHRcdFx0XHRcdGhpUGFydDogMyxcblx0XHRcdFx0XHRfc2tpcDE6IHNraXBCaXQsXG5cdFx0XHRcdFx0bWlkUGFydDogMTUsXG5cdFx0XHRcdFx0X3NraXAyOiBza2lwQml0LFxuXHRcdFx0XHRcdGxvUGFydDogMTUsXG5cdFx0XHRcdFx0X3NraXAzOiBza2lwQml0XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcGFydHMgPSB0aGlzLmJhc2VSZWFkKCk7XG5cdFx0XHRcdHJldHVybiBwYXJ0cy5sb1BhcnQgfCAocGFydHMubWlkUGFydCA8PCAxNSkgfCAocGFydHMuaGlQYXJ0IDw8IDMwKTtcblx0XHRcdH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHtcblx0XHRcdFx0XHRoaVBhcnQ6IHZhbHVlID4+PiAzMCxcblx0XHRcdFx0XHRtaWRQYXJ0OiAodmFsdWUgPj4+IDE1KSAmIH4oLTEgPDwgMTUpLFxuXHRcdFx0XHRcdGxvUGFydDogdmFsdWUgJiB+KC0xIDw8IDE1KVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdFBFU1BhY2tldDogWydleHRlbmQnLCB7XG5cdFx0XHRfc3RhcnRDb2RlMDogWydjb25zdCcsICd1aW50OCcsIDAsIHRydWVdLFxuXHRcdFx0X3N0YXJ0Q29kZTE6IFsnY29uc3QnLCAndWludDgnLCAwLCB0cnVlXSxcblx0XHRcdF9zdGFydENvZGUyOiBbJ2NvbnN0JywgJ3VpbnQ4JywgMSwgdHJ1ZV0sXG5cdFx0XHRzdHJlYW1JZDogJ3VpbnQ4Jyxcblx0XHRcdGxlbmd0aDogJ3VpbnQxNicsXG5cdFx0XHRfZW5kOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHRcdFx0XHR2YXIgcG9zID0gdGhpcy5iaW5hcnkudGVsbCgpLCBsZW5ndGggPSBjb250ZXh0Lmxlbmd0aDtcblxuXHRcdFx0XHRpZiAobGVuZ3RoKSB7XG5cdFx0XHRcdFx0cG9zICs9IGxlbmd0aDtcblx0XHRcdFx0XHRpZiAocG9zID4gdGhpcy52aWV3LmJ5dGVMZW5ndGggLSA0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcG9zO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgYnl0ZXMgPSB0aGlzLmJpbmFyeS5yZWFkKFsnYmxvYicsIDRdLCBwb3MpO1xuXHRcdFx0XHRcdGlmIChieXRlc1swXSA9PT0gMCAmJiBieXRlc1sxXSA9PT0gMCAmJiBieXRlc1syXSA9PT0gMSAmJiAoYnl0ZXNbM10gJiAweDgwKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHBvcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zIC09IGxlbmd0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qXG5cdFx0XHRcdG5vdCBzdXJlIGlmIGl0IGNvcnJlY3RseSBjb3ZlcnMgY2FzZXMgd2hlcmUgYGxlbmd0aGA9PTBcblx0XHRcdFx0KGFjY29yZGluZyB0byBzcGVjaWZpY2F0aW9uLCBpdCBtYXkgYmUgd3JpdHRlbiBhcyB6ZXJvIGZvciB2aWRlbyBzdHJlYW1zIG9mIHVuZGVmaW5lZCBsZW5ndGgpXG5cdFx0XHRcdGJ1dCBzaG91bGQgd29yayBmb3IgSC4yNjQgc3RyZWFtcyBzaW5jZSBOQUwgdW5pdCB0eXBlcyBhbHdheXMgaGF2ZSBjbGVhciBoaWdoZXN0IGJpdCAoYGZvcmJpZGRlbl96ZXJvX2JpdGApXG5cdFx0XHRcdCovXG5cdFx0XHRcdHZhciBmaWxlRW5kID0gdGhpcy52aWV3LmJ5dGVMZW5ndGgsIGJ5dGVzID0gdGhpcy5iaW5hcnkucmVhZCgnYmxvYicsIHBvcyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gNDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGJ5dGVzW2ldID09PSAwICYmIGJ5dGVzW2kgKyAxXSA9PT0gMCAmJiBieXRlc1tpICsgMl0gPT09IDEgJiYgKGJ5dGVzW2kgKyAzXSAmIDB4ODApKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcG9zICsgaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZpbGVFbmQ7XG5cdFx0XHR9XG5cdFx0fSwgakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRiYXNlVHlwZToge1xuXHRcdFx0XHRfbWFya2VyOiBbJ2NvbnN0JywgMiwgMiwgdHJ1ZV0sXG5cdFx0XHRcdHNjcmFtYmxpbmdDb250cm9sOiBbJ2VudW0nLCAyLCBbJ25vdF9zY3JhbWJsZWQnXV0sXG5cdFx0XHRcdHByaW9yaXR5OiAxLFxuXHRcdFx0XHRkYXRhQWxpZ25tZW50SW5kaWNhdG9yOiAxLFxuXHRcdFx0XHRoYXNDb3B5cmlnaHQ6IDEsXG5cdFx0XHRcdGlzT3JpZ2luYWw6IDEsXG5cdFx0XHRcdF9oYXNQVFM6IFsnRmxhZycsICdwdHMnXSxcblx0XHRcdFx0X2hhc0RUUzogWydGbGFnJywgJ2R0cyddLFxuXHRcdFx0XHRfaGFzRVNDUjogWydGbGFnJywgJ2VzY3InXSxcblx0XHRcdFx0X2hhc0VTUmF0ZTogWydGbGFnJywgJ2VzUmF0ZSddLFxuXHRcdFx0XHRkc21Ucmlja01vZGU6IDEsXG5cdFx0XHRcdF9oYXNBZGRpdGlvbmFsQ29weUluZm86IFsnRmxhZycsICdhZGRpdGlvbmFsQ29weUluZm8nXSxcblx0XHRcdFx0X2hhc1BFU0NSQzogWydGbGFnJywgJ3Blc0NSQyddLFxuXHRcdFx0XHRfaGFzRXh0ZW5zaW9uOiBbJ0ZsYWcnLCAnZXh0ZW5zaW9uJ10sXG5cdFx0XHRcdGRhdGFMZW5ndGg6ICd1aW50OCcsXG5cdFx0XHRcdF9oZWFkZXJFbmQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiB0aGlzLmJpbmFyeS50ZWxsKCkgKyBjb250ZXh0LmRhdGFMZW5ndGggfSxcblx0XHRcdFx0cHRzOiBbJ0ZsYWdEZXBlbmRlbnQnLCAnX2hhc1BUUycsIFsnaWYnLCAnX2hhc0RUUycsIFsnUEVTVGltZVN0YW1wJywgM10sIFsnUEVTVGltZVN0YW1wJywgMl1dXSxcblx0XHRcdFx0ZHRzOiBbJ0ZsYWdEZXBlbmRlbnQnLCAnX2hhc0RUUycsIFsnUEVTVGltZVN0YW1wJywgMV1dLFxuXHRcdFx0XHRfdG9IZWFkZXJFbmQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7IHRoaXMuYmluYXJ5LnNlZWsoY29udGV4dC5faGVhZGVyRW5kKSB9XG5cdFx0XHR9LFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcG9zID0gdGhpcy5iaW5hcnkudGVsbCgpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmJhc2VSZWFkKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHR0aGlzLmJpbmFyeS5zZWVrKHBvcyk7XG5cdFx0XHRcdFx0dGhpcy5iaW5hcnkudmlldy5hbGlnbkJ5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KSwge1xuXHRcdFx0ZGF0YTogWydibG9iJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5iaW5hcnkuZ2V0Q29udGV4dCgnX2VuZCcpLl9lbmQgLSB0aGlzLmJpbmFyeS50ZWxsKCkgfV1cblx0XHR9XVxuXHR9O1xufSkpOyIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDE0IFNpbW9uIEx5ZGVsbFxyXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXHJcblxyXG52b2lkIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZmFjdG9yeSlcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290LnJlc29sdmVVcmwgPSBmYWN0b3J5KClcclxuICB9XHJcbn0odGhpcywgZnVuY3Rpb24oKSB7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoLyogLi4udXJscyAqLykge1xyXG4gICAgdmFyIG51bVVybHMgPSBhcmd1bWVudHMubGVuZ3RoXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZVVybCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQ7IGdvdCBub25lLlwiKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJhc2VcIilcclxuICAgIGJhc2UuaHJlZiA9IGFyZ3VtZW50c1swXVxyXG5cclxuICAgIGlmIChudW1VcmxzID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBiYXNlLmhyZWZcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXVxyXG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoYmFzZSwgaGVhZC5maXJzdENoaWxkKVxyXG5cclxuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIilcclxuICAgIHZhciByZXNvbHZlZFxyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBudW1VcmxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGEuaHJlZiA9IGFyZ3VtZW50c1tpbmRleF1cclxuICAgICAgcmVzb2x2ZWQgPSBhLmhyZWZcclxuICAgICAgYmFzZS5ocmVmID0gcmVzb2x2ZWRcclxuICAgIH1cclxuXHJcbiAgICBoZWFkLnJlbW92ZUNoaWxkKGJhc2UpXHJcblxyXG4gICAgcmV0dXJuIHJlc29sdmVkXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzb2x2ZVVybFxyXG5cclxufSkpO1xyXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsImltcG9ydCAnIy9jb21tb24vYnJvd3Nlcic7XG5pbXBvcnQgeyBnZXRBY3RpdmVUYWIsIG1ha2VQYXVzZSwgc2VuZENtZCwgcmVxdWVzdCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IEJVSUxEX0lOX1NDUklQVF9TUkMsIFRJTUVPVVRfMjRIT1VSUywgVElNRU9VVF9NQVgsIElTX0RFViB9IGZyb20gJyMvY29tbW9uL2NvbnN0cyc7XG5pbXBvcnQgeyBkZWVwQ29weSB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgKiBhcyB0bGQgZnJvbSAnIy9jb21tb24vdGxkJztcbmltcG9ydCAqIGFzIHN5bmMgZnJvbSAnLi9zeW5jJztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBnZXREYXRhLCBjaGVja1JlbW92ZSB9IGZyb20gJy4vdXRpbHMvZGInO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZSB9IGZyb20gJy4vdXRpbHMvaW5pdCc7XG5pbXBvcnQgeyBnZXRPcHRpb24sIGhvb2tPcHRpb25zIH0gZnJvbSAnLi91dGlscy9vcHRpb25zJztcbmltcG9ydCB7IHBvcHVwVGFicyB9IGZyb20gJy4vdXRpbHMvcG9wdXAtdHJhY2tlcic7XG5pbXBvcnQgeyBnZXRJbmplY3RlZFNjcmlwdHMgfSBmcm9tICcuL3V0aWxzL3ByZWluamVjdCc7XG5pbXBvcnQgeyBTQ1JJUFRfVEVNUExBVEUsIHJlc2V0U2NyaXB0VGVtcGxhdGUgfSBmcm9tICcuL3V0aWxzL3RlbXBsYXRlLWhvb2snO1xuaW1wb3J0IHsgcmVzZXRWYWx1ZU9wZW5lciwgYWRkVmFsdWVPcGVuZXIgfSBmcm9tICcuL3V0aWxzL3ZhbHVlcyc7XG5pbXBvcnQgeyBjbGVhclJlcXVlc3RzQnlUYWJJZCB9IGZyb20gJy4vdXRpbHMvcmVxdWVzdHMnO1xuaW1wb3J0ICcuL3V0aWxzL2NsaXBib2FyZCc7XG5pbXBvcnQgJy4vdXRpbHMvaG90a2V5cyc7XG5pbXBvcnQgJy4vdXRpbHMvaWNvbic7XG5pbXBvcnQgJy4vdXRpbHMvbm90aWZpY2F0aW9ucyc7XG5pbXBvcnQgJy4vdXRpbHMvc2NyaXB0JztcbmltcG9ydCAnLi91dGlscy90YWJzJztcbmltcG9ydCAnLi91dGlscy90ZXN0ZXInO1xuaW1wb3J0ICcuL3V0aWxzL3VwZGF0ZSc7XG5cbmhvb2tPcHRpb25zKChjaGFuZ2VzKSA9PiB7XG4gIGlmICgnYXV0b1VwZGF0ZScgaW4gY2hhbmdlcykge1xuICAgIGF1dG9VcGRhdGUoKTtcbiAgfVxuICBpZiAoU0NSSVBUX1RFTVBMQVRFIGluIGNoYW5nZXMpIHtcbiAgICByZXNldFNjcmlwdFRlbXBsYXRlKGNoYW5nZXMpO1xuICB9XG4gIHNlbmRDbWQoJ1VwZGF0ZU9wdGlvbnMnLCBjaGFuZ2VzKTtcbn0pO1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPHsgc2NyaXB0czogVk1TY3JpcHRbXSwgY2FjaGU6IE9iamVjdCwgc3luYzogT2JqZWN0IH0+fSAqL1xuICBhc3luYyBHZXREYXRhKGlkcykge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXREYXRhKGlkcyk7XG4gICAgZGF0YS5zeW5jID0gc3luYy5nZXRTdGF0ZXMoKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gKi9cbiAgYXN5bmMgR2V0SW5qZWN0ZWQoeyB1cmwsIGZvcmNlQ29udGVudCB9LCBzcmMpIHtcbiAgICBjb25zdCB7IGZyYW1lSWQsIHRhYiB9ID0gc3JjO1xuICAgIGNvbnN0IHRhYklkID0gdGFiLmlkO1xuICAgIGlmICghdXJsKSB1cmwgPSBzcmMudXJsIHx8IHRhYi51cmw7XG4gICAgaWYgKCFmcmFtZUlkKSB7XG4gICAgICByZXNldFZhbHVlT3BlbmVyKHRhYklkKTtcbiAgICAgIGNsZWFyUmVxdWVzdHNCeVRhYklkKHRhYklkKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0SW5qZWN0ZWRTY3JpcHRzKHVybCwgdGFiSWQsIGZyYW1lSWQsIGZvcmNlQ29udGVudCk7XG4gICAgY29uc3QgeyBmZWVkYmFjaywgaW5qZWN0LCB2YWxPcElkcyB9ID0gcmVzO1xuICAgIGluamVjdC5pc1BvcHVwU2hvd24gPSBwb3B1cFRhYnNbdGFiSWRdO1xuICAgIC8vIEluamVjdGluZyBrbm93biBjb250ZW50IHNjcmlwdHMgd2l0aG91dCB3YWl0aW5nIGZvciBJbmplY3Rpb25GZWVkYmFjayBtZXNzYWdlLlxuICAgIC8vIFJ1bm5pbmcgaW4gYSBzZXBhcmF0ZSB0YXNrIGJlY2F1c2UgaXQgbWF5IHRha2UgYSBsb25nIHRpbWUgdG8gc2VyaWFsaXplIGRhdGEuXG4gICAgaWYgKGZlZWRiYWNrLmxlbmd0aCkge1xuICAgICAgc2V0VGltZW91dChjb21tYW5kcy5JbmplY3Rpb25GZWVkYmFjaywgMCwgeyBmZWVkYmFjayB9LCBzcmMpO1xuICAgIH1cbiAgICBhZGRWYWx1ZU9wZW5lcih0YWJJZCwgZnJhbWVJZCwgdmFsT3BJZHMpO1xuICAgIHJldHVybiBpbmplY3Q7XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59ICovXG4gIGFzeW5jIEdldFRhYkRvbWFpbigpIHtcbiAgICBjb25zdCB0YWIgPSBhd2FpdCBnZXRBY3RpdmVUYWIoKSB8fCB7fTtcbiAgICBjb25zdCB1cmwgPSB0YWIucGVuZGluZ1VybCB8fCB0YWIudXJsIHx8ICcnO1xuICAgIGNvbnN0IGhvc3QgPSB1cmwubWF0Y2goL15odHRwcz86XFwvXFwvKFteL10rKXwkLylbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhYixcbiAgICAgIGRvbWFpbjogaG9zdCAmJiB0bGQuZ2V0RG9tYWluKGhvc3QpIHx8IGhvc3QsXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqIFRpbWVycyBpbiBjb250ZW50IHNjcmlwdHMgYXJlIHNoYXJlZCB3aXRoIHRoZSB3ZWIgcGFnZSBzbyBpdCBjYW4gY2xlYXIgdGhlbS5cbiAgICogYXdhaXQgc2VuZENtZCgnU2V0VGltZW91dCcsIDEwMCkgaW4gaW5qZWN0ZWQvY29udGVudFxuICAgKiBhd2FpdCBicmlkZ2Uuc2VuZCgnU2V0VGltZW91dCcsIDEwMCkgaW4gaW5qZWN0ZWQvd2ViXG4gICAqL1xuICBTZXRUaW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG1zID4gMCAmJiBtYWtlUGF1c2UobXMpO1xuICB9LFxufSk7XG5cbi8vIGNvbW1hbmRzIHRvIHN5bmMgdW5jb25kaXRpb25hbGx5IHJlZ2FyZGxlc3Mgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gdGhlIGhhbmRsZXJcbmNvbnN0IGNvbW1hbmRzVG9TeW5jID0gW1xuICAnTWFya1JlbW92ZWQnLFxuICAnTW92ZScsXG4gICdQYXJzZVNjcmlwdCcsXG4gICdSZW1vdmVTY3JpcHQnLFxuICAnVXBkYXRlU2NyaXB0SW5mbycsXG5dO1xuLy8gY29tbWFuZHMgdG8gc3luYyBvbmx5IGlmIHRoZSBoYW5kbGVyIHJldHVybnMgYSB0cnV0aHkgdmFsdWVcbmNvbnN0IGNvbW1hbmRzVG9TeW5jSWZUcnV0aHkgPSBbXG4gICdDaGVja1JlbW92ZScsXG4gICdDaGVja1VwZGF0ZScsXG4gICdDaGVja1VwZGF0ZUFsbCcsXG5dO1xuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVDb21tYW5kTWVzc2FnZShyZXEsIHNyYykge1xuICBjb25zdCB7IGNtZCB9ID0gcmVxO1xuICBjb25zdCByZXMgPSBhd2FpdCBjb21tYW5kc1tjbWRdPy4ocmVxLmRhdGEsIHNyYyk7XG4gIGlmIChjb21tYW5kc1RvU3luYy5pbmNsdWRlcyhjbWQpXG4gIHx8IHJlcyAmJiBjb21tYW5kc1RvU3luY0lmVHJ1dGh5LmluY2x1ZGVzKGNtZCkpIHtcbiAgICBzeW5jLnN5bmMoKTtcbiAgfVxuICAvLyBgdW5kZWZpbmVkYCBpcyBub3QgdHJhbnNmZXJhYmxlLCBidXQgYG51bGxgIGlzXG4gIHJldHVybiByZXMgPz8gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXV0b1VwZGF0ZSgpIHtcbiAgY29uc3QgaW50ZXJ2YWwgPSBJU19ERVYgPyAxMDAwIDogKCtnZXRPcHRpb24oJ2F1dG9VcGRhdGUnKSB8fCAwKSAqIFRJTUVPVVRfMjRIT1VSUztcbiAgaWYgKCFpbnRlcnZhbCkgcmV0dXJuO1xuICBsZXQgZWxhcHNlZCA9IERhdGUubm93KCkgLSBnZXRPcHRpb24oJ2xhc3RVcGRhdGUnKTtcbiAgaWYgKGVsYXBzZWQgPj0gaW50ZXJ2YWwpIHtcbiAgICBoYW5kbGVDb21tYW5kTWVzc2FnZSh7IGNtZDogJ0NoZWNrVXBkYXRlQWxsJyB9KTtcbiAgICBlbGFwc2VkID0gMDtcbiAgfVxuICBjbGVhclRpbWVvdXQoYXV0b1VwZGF0ZS50aW1lcik7XG4gIGF1dG9VcGRhdGUudGltZXIgPSBzZXRUaW1lb3V0KGF1dG9VcGRhdGUsIE1hdGgubWluKFRJTUVPVVRfTUFYLCBpbnRlcnZhbCAtIGVsYXBzZWQpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdEJ1aWxkaW4oKSB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgcmVxdWVzdChCVUlMRF9JTl9TQ1JJUFRfU1JDLCB7XG4gICAgY2FjaGU6ICduby1jYWNoZScsXG4gICAgaGVhZGVyczogeyBBY2NlcHQ6ICd0ZXh0L3gtdXNlcnNjcmlwdC1tZXRhLCovKicgfSxcbiAgfSk7XG5cbiAgY29uc3QgcmVzID0gYXdhaXQgY29tbWFuZHMuUGFyc2VTY3JpcHQoe1xuICAgIHVybDogQlVJTERfSU5fU0NSSVBUX1NSQyxcbiAgICBjb2RlOiBkYXRhLFxuICAgIGN1c3RvbTogeyBidWlsZEluOiB0cnVlIH0sXG4gIH0pO1xuICBzeW5jLnN5bmMoKTtcblxuICBpZiAocmVzLndoZXJlLmlkICE9PSAxKSB7XG4gICAgdGhyb3cgYHdyb25nIGlkOiAke3Jlcy53aGVyZS5pZH1gO1xuICB9XG59XG5cbmluaXRpYWxpemUoKCkgPT4ge1xuICBnbG9iYWwuaGFuZGxlQ29tbWFuZE1lc3NhZ2UgPSBoYW5kbGVDb21tYW5kTWVzc2FnZTtcbiAgZ2xvYmFsLmRlZXBDb3B5ID0gZGVlcENvcHk7XG4gIGJyb3dzZXIucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoXG4gICAgSVNfRklSRUZPWCAvLyBpbiBGRiBhIHJlamVjdGVkIFByb21pc2UgdmFsdWUgaXMgdHJhbnNmZXJyZWQgb25seSBpZiBpdCdzIGFuIEVycm9yIG9iamVjdFxuICAgICAgPyAoLi4uYXJncykgPT4gaGFuZGxlQ29tbWFuZE1lc3NhZ2UoLi4uYXJncykuY2F0Y2goZSA9PiAoXG4gICAgICAgIFByb21pc2UucmVqZWN0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoZSkpXG4gICAgICApKSAvLyBEaWRuJ3QgdXNlIGB0aHJvd2AgdG8gYXZvaWQgaW50ZXJydXB0aW9uIGluIGRldnRvb2xzIHdpdGggcGF1c2Utb24tZXhjZXB0aW9uIGVuYWJsZWQuXG4gICAgICA6IGhhbmRsZUNvbW1hbmRNZXNzYWdlLFxuICApO1xuXG4gIC8vIGNoZWNrIGFuZCBpbnN0YWxsIHRoZSBidWlsZC1pbiBzY3JpcHRcbiAgaW5pdEJ1aWxkaW4oKTtcbiAgY29uc29sZS5pbmZvKCdpbml0QnVpbGRpbi4uLicpO1xuICBzZXRUaW1lb3V0KGF1dG9VcGRhdGUsIElTX0RFViA/IDEgOiAyZTQpO1xuICBzeW5jLmluaXRpYWxpemUoKTtcbiAgY2hlY2tSZW1vdmUoKTtcbiAgc2V0SW50ZXJ2YWwoY2hlY2tSZW1vdmUsIFRJTUVPVVRfMjRIT1VSUyk7XG4gIGNvbnN0IGFwaSA9IGdsb2JhbC5jaHJvbWUuZGVjbGFyYXRpdmVDb250ZW50O1xuICBpZiAoYXBpKSB7XG4gICAgLy8gVXNpbmcgZGVjbGFyYXRpdmVDb250ZW50IHRvIHJ1biBjb250ZW50IHNjcmlwdHMgZWFybGllciB0aGFuIGRvY3VtZW50X3N0YXJ0XG4gICAgYXBpLm9uUGFnZUNoYW5nZWQuZ2V0UnVsZXMoYXN5bmMgKFtydWxlXSkgPT4ge1xuICAgICAgY29uc3QgaWQgPSBydWxlPy5pZDtcbiAgICAgIGNvbnN0IG5ld0lkID0gcHJvY2Vzcy5lbnYuSU5JVF9GVU5DX05BTUU7XG4gICAgICBpZiAoaWQgPT09IG5ld0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpZCkge1xuICAgICAgICBhd2FpdCBicm93c2VyLmRlY2xhcmF0aXZlQ29udGVudC5vblBhZ2VDaGFuZ2VkLnJlbW92ZVJ1bGVzKFtpZF0pO1xuICAgICAgfVxuICAgICAgYXBpLm9uUGFnZUNoYW5nZWQuYWRkUnVsZXMoW3tcbiAgICAgICAgaWQ6IG5ld0lkLFxuICAgICAgICBjb25kaXRpb25zOiBbXG4gICAgICAgICAgbmV3IGFwaS5QYWdlU3RhdGVNYXRjaGVyKHtcbiAgICAgICAgICAgIHBhZ2VVcmw6IHsgdXJsQ29udGFpbnM6ICc6Ly8nIH0sIC8vIGVzc2VudGlhbGx5IGxpa2UgPGFsbF91cmxzPlxuICAgICAgICAgIH0pLFxuICAgICAgICBdLFxuICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgbmV3IGFwaS5SZXF1ZXN0Q29udGVudFNjcmlwdCh7XG4gICAgICAgICAgICBqczogYnJvd3Nlci5ydW50aW1lLmdldE1hbmlmZXN0KCkuY29udGVudF9zY3JpcHRzWzBdLmpzLFxuICAgICAgICAgICAgLy8gTm90IHVzaW5nIGBhbGxGcmFtZXM6dHJ1ZWAgYXMgdGhlcmUncyBubyBpbXByb3ZlbWVudCBpbiBmcmFtZXNcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICAgIH1dKTtcbiAgICB9KTtcbiAgfVxufSk7XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJyMvY29tbW9uL2V2ZW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBFdmVudEVtaXR0ZXIoW1xuICAnc2NyaXB0RWRpdCcsXG4gICdzY3JpcHRDaGFuZ2VkJyxcbl0pO1xuIiwiaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuLi91dGlscy9tZXNzYWdlJztcbmltcG9ydCB7IGdldFNjcmlwdHMgfSBmcm9tICcuLi91dGlscy9kYic7XG5cbmV4cG9ydCBjb25zdCBzY3JpcHQgPSB7XG4gIC8qKlxuICAgKiBVcGRhdGUgYW4gZXhpc3Rpbmcgc2NyaXB0IGlkZW50aWZpZWQgYnkgdGhlIHByb3ZpZGVkIGlkXG4gICAqIEBwYXJhbSB7eyBpZCwgY29kZSwgbWVzc2FnZSwgaXNOZXcsIGNvbmZpZywgY3VzdG9tLCBwcm9wcywgdXBkYXRlIH19IGRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZTx7IGlzTmV3PywgdXBkYXRlLCB3aGVyZSB9Pn1cbiAgICovXG4gIHVwZGF0ZTogY29tbWFuZHMuUGFyc2VTY3JpcHQsXG4gIC8qKlxuICAgKiBMaXN0IGFsbCBhdmFpbGFibGUgc2NyaXB0cywgd2l0aG91dCBzY3JpcHQgY29kZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFZNU2NyaXB0W10+fVxuICAgKi9cbiAgbGlzdDogYXN5bmMgKCkgPT4gZ2V0U2NyaXB0cygpLFxuICAvKipcbiAgICogR2V0IHNjcmlwdCBjb2RlIG9mIGFuIGV4aXN0aW5nIHNjcmlwdFxuICAgKiBAcGFyYW0ge251bWJlcn0gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0OiBjb21tYW5kcy5HZXRTY3JpcHRDb2RlLFxuICAvKipcbiAgICogUmVtb3ZlIHNjcmlwdFxuICAgKiBAcGFyYW0ge251bWJlcn0gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIHJlbW92ZTogaWQgPT4gY29tbWFuZHMuTWFya1JlbW92ZWQoeyBpZCwgcmVtb3ZlZDogdHJ1ZSB9KSxcbn07XG4iLCJpbXBvcnQge1xuICBkZWJvdW5jZSwgbm9ybWFsaXplS2V5cywgcmVxdWVzdCwgbm9vcCwgbWFrZVBhdXNlLCBlbnN1cmVBcnJheSwgc2VuZENtZCxcbn0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgVElNRU9VVF9IT1VSIH0gZnJvbSAnIy9jb21tb24vY29uc3RzJztcbmltcG9ydCB7XG4gIGZvckVhY2hFbnRyeSwgb2JqZWN0U2V0LCBvYmplY3RQaWNrLFxufSBmcm9tICcjL2NvbW1vbi9vYmplY3QnO1xuaW1wb3J0IHtcbiAgZ2V0RXZlbnRFbWl0dGVyLCBnZXRPcHRpb24sIHNldE9wdGlvbiwgaG9va09wdGlvbnMsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIHNvcnRTY3JpcHRzLFxuICB1cGRhdGVTY3JpcHRJbmZvLFxufSBmcm9tICcuLi91dGlscy9kYic7XG5pbXBvcnQgeyBzY3JpcHQgYXMgcGx1Z2luU2NyaXB0IH0gZnJvbSAnLi4vcGx1Z2luJztcblxuY29uc3Qgc2VydmljZU5hbWVzID0gW107XG5jb25zdCBzZXJ2aWNlQ2xhc3NlcyA9IFtdO1xuY29uc3Qgc2VydmljZXMgPSB7fTtcbmNvbnN0IGF1dG9TeW5jID0gZGVib3VuY2Uoc3luYywgVElNRU9VVF9IT1VSKTtcbmxldCB3b3JraW5nID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgc3luY0NvbmZpZztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEl0ZW1GaWxlbmFtZSh7IG5hbWUsIHVyaSB9KSB7XG4gIC8vIFdoZW4gZ2V0IG9yIHJlbW92ZSwgY3VycmVudCBuYW1lIHNob3VsZCBiZSBwcmVmZXJlZFxuICBpZiAobmFtZSkgcmV0dXJuIG5hbWU7XG4gIC8vIG90aGVyd2lzZSB1cmkgZGVyaXZlZCBuYW1lIHNob3VsZCBiZSBwcmVmZXJlZFxuICAvLyB1cmkgaXMgYWxyZWFkeSBlbmNvZGVkIGJ5IGBlbmNvZGVGaWxlbmFtZWBcbiAgcmV0dXJuIGB2bUAyLSR7dXJpfWA7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTY3JpcHRGaWxlKG5hbWUpIHtcbiAgcmV0dXJuIC9edm0oPzpAXFxkKyk/LS8udGVzdChuYW1lKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkkobmFtZSkge1xuICBjb25zdCBpID0gbmFtZS5pbmRleE9mKCctJyk7XG4gIGNvbnN0IFssIHZlcnNpb25dID0gbmFtZS5zbGljZSgwLCBpKS5zcGxpdCgnQCcpO1xuICBpZiAodmVyc2lvbiA9PT0gJzInKSB7XG4gICAgLy8gdXJpIGlzIGVuY29kZWQgYnkgYGVuY29kZWRGaWxlbmFtZWAsIHNvIHdlIHNob3VsZCBub3QgZGVjb2RlIGl0IGhlcmVcbiAgICByZXR1cm4gbmFtZS5zbGljZShpICsgMSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUuc2xpY2UoMykpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbmFtZS5zbGljZSgzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKCkge1xuICBmdW5jdGlvbiBnZXQoa2V5LCBkZWYpIHtcbiAgICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5cyhrZXkpO1xuICAgIGtleXMudW5zaGlmdCgnc3luYycpO1xuICAgIHJldHVybiBnZXRPcHRpb24oa2V5cywgZGVmKTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlzKGtleSk7XG4gICAga2V5cy51bnNoaWZ0KCdzeW5jJyk7XG4gICAgc2V0T3B0aW9uKGtleXMsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGxldCBjb25maWcgPSBnZXRPcHRpb24oJ3N5bmMnKTtcbiAgICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLnNlcnZpY2VzKSB7XG4gICAgICBjb25maWcgPSB7XG4gICAgICAgIHNlcnZpY2VzOiB7fSxcbiAgICAgIH07XG4gICAgICBzZXQoW10sIGNvbmZpZyk7XG4gICAgfVxuICB9XG4gIGluaXQoKTtcbiAgcmV0dXJuIHsgZ2V0LCBzZXQgfTtcbn1cbmZ1bmN0aW9uIHNlcnZpY2VDb25maWcobmFtZSkge1xuICBmdW5jdGlvbiBnZXRLZXlzKGtleSkge1xuICAgIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlzKGtleSk7XG4gICAga2V5cy51bnNoaWZ0KCdzZXJ2aWNlcycsIG5hbWUpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG4gIGZ1bmN0aW9uIGdldChrZXksIGRlZikge1xuICAgIHJldHVybiBzeW5jQ29uZmlnLmdldChnZXRLZXlzKGtleSksIGRlZik7XG4gIH1cbiAgZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICBrZXk6OmZvckVhY2hFbnRyeSgoW2ssIHZdKSA9PiB7XG4gICAgICAgIHN5bmNDb25maWcuc2V0KGdldEtleXMoayksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5bmNDb25maWcuc2V0KGdldEtleXMoa2V5KSwgdmFsKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgc3luY0NvbmZpZy5zZXQoZ2V0S2V5cygpLCB7fSk7XG4gIH1cbiAgcmV0dXJuIHsgZ2V0LCBzZXQsIGNsZWFyIH07XG59XG5mdW5jdGlvbiBzZXJ2aWNlU3RhdGUodmFsaWRTdGF0ZXMsIGluaXRpYWxTdGF0ZSwgb25DaGFuZ2UpIHtcbiAgbGV0IHN0YXRlID0gaW5pdGlhbFN0YXRlIHx8IHZhbGlkU3RhdGVzWzBdO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuZXdTdGF0ZSkge1xuICAgIGlmICh2YWxpZFN0YXRlcy5pbmNsdWRlcyhuZXdTdGF0ZSkpIHtcbiAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBpZiAob25DaGFuZ2UpIG9uQ2hhbmdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBzdGF0ZTonLCBuZXdTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBnZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBpcyhzdGF0ZXMpIHtcbiAgICByZXR1cm4gZW5zdXJlQXJyYXkoc3RhdGVzKS5pbmNsdWRlcyhzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHsgZ2V0LCBzZXQsIGlzIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGVzKCkge1xuICByZXR1cm4gc2VydmljZU5hbWVzLm1hcCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IHNlcnZpY2UgPSBzZXJ2aWNlc1tuYW1lXTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogc2VydmljZS5uYW1lLFxuICAgICAgZGlzcGxheU5hbWU6IHNlcnZpY2UuZGlzcGxheU5hbWUsXG4gICAgICBhdXRoU3RhdGU6IHNlcnZpY2UuYXV0aFN0YXRlLmdldCgpLFxuICAgICAgc3luY1N0YXRlOiBzZXJ2aWNlLnN5bmNTdGF0ZS5nZXQoKSxcbiAgICAgIGxhc3RTeW5jOiBzZXJ2aWNlLmNvbmZpZy5nZXQoJ21ldGEnLCB7fSkubGFzdFN5bmMsXG4gICAgICBwcm9ncmVzczogc2VydmljZS5wcm9ncmVzcyxcbiAgICAgIHByb3BlcnRpZXM6IHNlcnZpY2UucHJvcGVydGllcyxcbiAgICAgIHVzZXJDb25maWc6IHNlcnZpY2UuZ2V0VXNlckNvbmZpZygpLFxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JpcHREYXRhKHNjcmlwdCwgc3luY1ZlcnNpb24sIGV4dHJhKSB7XG4gIGxldCBkYXRhO1xuICBpZiAoc3luY1ZlcnNpb24gPT09IDIpIHtcbiAgICBkYXRhID0ge1xuICAgICAgdmVyc2lvbjogc3luY1ZlcnNpb24sXG4gICAgICBjdXN0b206IHNjcmlwdC5jdXN0b20sXG4gICAgICBjb25maWc6IHNjcmlwdC5jb25maWcsXG4gICAgICBwcm9wczogb2JqZWN0UGljayhzY3JpcHQucHJvcHMsIFsnbGFzdFVwZGF0ZWQnXSksXG4gICAgfTtcbiAgfSBlbHNlIGlmIChzeW5jVmVyc2lvbiA9PT0gMSkge1xuICAgIGRhdGEgPSB7XG4gICAgICB2ZXJzaW9uOiBzeW5jVmVyc2lvbixcbiAgICAgIG1vcmU6IHtcbiAgICAgICAgY3VzdG9tOiBzY3JpcHQuY3VzdG9tLFxuICAgICAgICBlbmFibGVkOiBzY3JpcHQuY29uZmlnLmVuYWJsZWQsXG4gICAgICAgIHVwZGF0ZTogc2NyaXB0LmNvbmZpZy5zaG91bGRVcGRhdGUsXG4gICAgICAgIGxhc3RVcGRhdGVkOiBzY3JpcHQucHJvcHMubGFzdFVwZGF0ZWQsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGF0YSwgZXh0cmEpO1xufVxuZnVuY3Rpb24gcGFyc2VTY3JpcHREYXRhKHJhdykge1xuICBjb25zdCBkYXRhID0ge307XG4gIHRyeSB7XG4gICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShyYXcpO1xuICAgIGRhdGEuY29kZSA9IG9iai5jb2RlO1xuICAgIGlmIChvYmoudmVyc2lvbiA9PT0gMikge1xuICAgICAgZGF0YS5jb25maWcgPSBvYmouY29uZmlnO1xuICAgICAgZGF0YS5jdXN0b20gPSBvYmouY3VzdG9tO1xuICAgICAgZGF0YS5wcm9wcyA9IG9iai5wcm9wcztcbiAgICB9IGVsc2UgaWYgKG9iai52ZXJzaW9uID09PSAxKSB7XG4gICAgICBpZiAob2JqLm1vcmUpIHtcbiAgICAgICAgZGF0YS5jdXN0b20gPSBvYmoubW9yZS5jdXN0b207XG4gICAgICAgIGRhdGEuY29uZmlnID0gb2JqZWN0UHVyaWZ5KHtcbiAgICAgICAgICBlbmFibGVkOiBvYmoubW9yZS5lbmFibGVkLFxuICAgICAgICAgIHNob3VsZFVwZGF0ZTogb2JqLm1vcmUudXBkYXRlLFxuICAgICAgICB9KTtcbiAgICAgICAgZGF0YS5wcm9wcyA9IG9iamVjdFB1cmlmeSh7XG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IG9iai5tb3JlLmxhc3RVcGRhdGVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkYXRhLmNvZGUgPSByYXc7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFB1cmlmeShvYmopIHtcbiAgLy8gUmVtb3ZlIGtleXMgd2l0aCB1bmRlZmluZWQgdmFsdWVzXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBvYmouZm9yRWFjaChvYmplY3RQdXJpZnkpO1xuICB9IGVsc2UgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIG9iajo6Zm9yRWFjaEVudHJ5KChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSBkZWxldGUgb2JqW2tleV07XG4gICAgICBlbHNlIG9iamVjdFB1cmlmeSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gc2VydmljZUZhY3RvcnkoYmFzZSkge1xuICBjb25zdCBTZXJ2aWNlID0gZnVuY3Rpb24gY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH07XG4gIFNlcnZpY2UucHJvdG90eXBlID0gYmFzZTtcbiAgU2VydmljZS5leHRlbmQgPSBleHRlbmRTZXJ2aWNlO1xuICByZXR1cm4gU2VydmljZTtcbn1cbmZ1bmN0aW9uIGV4dGVuZFNlcnZpY2Uob3B0aW9ucykge1xuICByZXR1cm4gc2VydmljZUZhY3RvcnkoT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlKSwgb3B0aW9ucykpO1xufVxuXG5jb25zdCBvblN0YXRlQ2hhbmdlID0gZGVib3VuY2UoKCkgPT4ge1xuICBzZW5kQ21kKCdVcGRhdGVTeW5jJywgZ2V0U3RhdGVzKCkpO1xufSk7XG5cbmV4cG9ydCBjb25zdCBCYXNlU2VydmljZSA9IHNlcnZpY2VGYWN0b3J5KHtcbiAgbmFtZTogJ2Jhc2UnLFxuICBkaXNwbGF5TmFtZTogJ0Jhc2VTZXJ2aWNlJyxcbiAgZGVsYXlUaW1lOiAxMDAwLFxuICB1cmxQcmVmaXg6ICcnLFxuICBtZXRhRmlsZTogJ1Zpb2xlbnRtb25rZXknLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYXV0aFR5cGU6ICdvYXV0aCcsXG4gIH0sXG4gIGdldFVzZXJDb25maWc6IG5vb3AsXG4gIHNldFVzZXJDb25maWc6IG5vb3AsXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5wcm9ncmVzcyA9IHtcbiAgICAgIGZpbmlzaGVkOiAwLFxuICAgICAgdG90YWw6IDAsXG4gICAgfTtcbiAgICB0aGlzLmNvbmZpZyA9IHNlcnZpY2VDb25maWcodGhpcy5uYW1lKTtcbiAgICB0aGlzLmF1dGhTdGF0ZSA9IHNlcnZpY2VTdGF0ZShbXG4gICAgICAnaWRsZScsXG4gICAgICAnbm8tYXV0aCcsXG4gICAgICAnaW5pdGlhbGl6aW5nJyxcbiAgICAgICdhdXRob3JpemluZycsIC8vIGluIGNhc2Ugc29tZSBzZXJ2aWNlcyByZXF1aXJlIGFzeW5jaHJvbm91cyByZXF1ZXN0cyB0byBnZXQgYWNjZXNzX3Rva2Vuc1xuICAgICAgJ2F1dGhvcml6ZWQnLFxuICAgICAgJ3VuYXV0aG9yaXplZCcsXG4gICAgICAnZXJyb3InLFxuICAgIF0sIG51bGwsIG9uU3RhdGVDaGFuZ2UpO1xuICAgIHRoaXMuc3luY1N0YXRlID0gc2VydmljZVN0YXRlKFtcbiAgICAgICdpZGxlJyxcbiAgICAgICdyZWFkeScsXG4gICAgICAnc3luY2luZycsXG4gICAgICAnZXJyb3InLFxuICAgIF0sIG51bGwsIG9uU3RhdGVDaGFuZ2UpO1xuICAgIHRoaXMubGFzdEZldGNoID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5zdGFydFN5bmMgPSB0aGlzLnN5bmNGYWN0b3J5KCk7XG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RXZlbnRFbWl0dGVyKCk7XG4gICAgWydvbicsICdvZmYnLCAnZmlyZSddXG4gICAgLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpc1trZXldID0gKC4uLmFyZ3MpID0+IHsgZXZlbnRzW2tleV0oLi4uYXJncyk7IH07XG4gICAgfSk7XG4gIH0sXG4gIGxvZyguLi5hcmdzKSB7XG4gICAgY29uc29sZS5sb2coLi4uYXJncyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICB9LFxuICBzeW5jRmFjdG9yeSgpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgZGVib3VuY2VkUmVzb2x2ZTtcbiAgICBjb25zdCBzaG91bGRTeW5jID0gKCkgPT4gdGhpcy5hdXRoU3RhdGUuaXMoJ2F1dGhvcml6ZWQnKSAmJiBnZXRDdXJyZW50KCkgPT09IHRoaXMubmFtZTtcbiAgICBjb25zdCBnZXRSZWFkeSA9ICgpID0+IHtcbiAgICAgIGlmICghc2hvdWxkU3luYygpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLmxvZygnUmVhZHkgdG8gc3luYzonLCB0aGlzLmRpc3BsYXlOYW1lKTtcbiAgICAgIHRoaXMuc3luY1N0YXRlLnNldCgncmVhZHknKTtcbiAgICAgIHdvcmtpbmcgPSB3b3JraW5nLnRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgZGVib3VuY2VkUmVzb2x2ZSA9IGRlYm91bmNlKHJlc29sdmUsIDEwICogMTAwMCk7XG4gICAgICAgIGRlYm91bmNlZFJlc29sdmUoKTtcbiAgICAgIH0pKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkU3luYygpKSByZXR1cm4gdGhpcy5zeW5jKCk7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlLnNldCgnaWRsZScpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGRlYm91bmNlZFJlc29sdmUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gd29ya2luZztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHN0YXJ0U3luYygpIHtcbiAgICAgIGlmICghcHJvbWlzZSkgZ2V0UmVhZHkoKTtcbiAgICAgIGlmIChkZWJvdW5jZWRSZXNvbHZlKSBkZWJvdW5jZWRSZXNvbHZlKCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0U3luYztcbiAgfSxcbiAgcHJlcGFyZUhlYWRlcnMoKSB7XG4gICAgdGhpcy5oZWFkZXJzID0ge307XG4gIH0sXG4gIHByZXBhcmUoKSB7XG4gICAgdGhpcy5hdXRoU3RhdGUuc2V0KCdpbml0aWFsaXppbmcnKTtcbiAgICByZXR1cm4gKHRoaXMuaW5pdFRva2VuKCkgPyBQcm9taXNlLnJlc29sdmUodGhpcy51c2VyKCkpIDogUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgdHlwZTogJ25vLWF1dGgnLFxuICAgIH0pKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuYXV0aFN0YXRlLnNldCgnYXV0aG9yaXplZCcpO1xuICAgIH0sIChlcnIpID0+IHtcbiAgICAgIGlmIChbJ25vLWF1dGgnLCAndW5hdXRob3JpemVkJ10uaW5jbHVkZXMoZXJyPy50eXBlKSkge1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zZXQoZXJyLnR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zZXQoJ2Vycm9yJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN5bmNTdGF0ZS5zZXQoJ2lkbGUnKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfSxcbiAgY2hlY2tTeW5jKCkge1xuICAgIHJldHVybiB0aGlzLnByZXBhcmUoKVxuICAgIC50aGVuKCgpID0+IHRoaXMuc3RhcnRTeW5jKCkpO1xuICB9LFxuICB1c2VyOiBub29wLFxuICBhY3F1aXJlTG9jazogbm9vcCxcbiAgcmVsZWFzZUxvY2s6IG5vb3AsXG4gIGhhbmRsZU1ldGFFcnJvcihlcnIpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH0sXG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHsgbmFtZTogdGhpcy5tZXRhRmlsZSB9KVxuICAgIC50aGVuKGRhdGEgPT4gSlNPTi5wYXJzZShkYXRhKSlcbiAgICAuY2F0Y2goZXJyID0+IHRoaXMuaGFuZGxlTWV0YUVycm9yKGVycikpXG4gICAgLnRoZW4oZGF0YSA9PiAoe1xuICAgICAgbmFtZTogdGhpcy5tZXRhRmlsZSxcbiAgICAgIGRhdGEsXG4gICAgfSkpO1xuICB9LFxuICBpbml0VG9rZW4oKSB7XG4gICAgdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5jb25maWcuZ2V0KCd0b2tlbicpO1xuICAgIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gdG9rZW4gPyBgQmVhcmVyICR7dG9rZW59YCA6IG51bGw7XG4gICAgcmV0dXJuICEhdG9rZW47XG4gIH0sXG4gIGxvYWREYXRhKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHByb2dyZXNzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZGVsYXkgPSB0aGlzLmRlbGF5VGltZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgbGFzdEZldGNoID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBsYXN0RmV0Y2ggPSB0aGlzLmxhc3RGZXRjaFxuICAgICAgLnRoZW4odHMgPT4gbWFrZVBhdXNlKGRlbGF5IC0gKERhdGUubm93KCkgLSB0cykpKVxuICAgICAgLnRoZW4oKCkgPT4gRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLmxhc3RGZXRjaCA9IGxhc3RGZXRjaDtcbiAgICB9XG4gICAgcHJvZ3Jlc3MudG90YWwgKz0gMTtcbiAgICBvblN0YXRlQ2hhbmdlKCk7XG4gICAgcmV0dXJuIGxhc3RGZXRjaC50aGVuKCgpID0+IHtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgIGxldCB7IHVybCB9ID0gb3B0aW9ucztcbiAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpKSB1cmwgPSAob3B0aW9ucy5wcmVmaXggPz8gdGhpcy51cmxQcmVmaXgpICsgdXJsO1xuICAgICAgcmV0dXJuIHJlcXVlc3QodXJsLCBvcHRpb25zKTtcbiAgICB9KVxuICAgIC50aGVuKCh7IGRhdGEgfSkgPT4gKHsgZGF0YSB9KSwgZXJyb3IgPT4gKHsgZXJyb3IgfSkpXG4gICAgLnRoZW4oKHsgZGF0YSwgZXJyb3IgfSkgPT4ge1xuICAgICAgcHJvZ3Jlc3MuZmluaXNoZWQgKz0gMTtcbiAgICAgIG9uU3RhdGVDaGFuZ2UoKTtcbiAgICAgIGlmIChlcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pO1xuICB9LFxuICBnZXRMb2NhbERhdGEoKSB7XG4gICAgcmV0dXJuIHBsdWdpblNjcmlwdC5saXN0KCk7XG4gIH0sXG4gIGdldFN5bmNEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1ldGEoKVxuICAgIC50aGVuKHJlbW90ZU1ldGEgPT4gUHJvbWlzZS5hbGwoW1xuICAgICAgcmVtb3RlTWV0YSxcbiAgICAgIHRoaXMubGlzdCgpLFxuICAgICAgdGhpcy5nZXRMb2NhbERhdGEoKSxcbiAgICBdKSk7XG4gIH0sXG4gIHN5bmMoKSB7XG4gICAgdGhpcy5wcm9ncmVzcyA9IHtcbiAgICAgIGZpbmlzaGVkOiAwLFxuICAgICAgdG90YWw6IDAsXG4gICAgfTtcbiAgICB0aGlzLnN5bmNTdGF0ZS5zZXQoJ3N5bmNpbmcnKTtcbiAgICAvLyBBdm9pZCBzaW11bHRhbmVvdXMgcmVxdWVzdHNcbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlKClcbiAgICAudGhlbigoKSA9PiB0aGlzLmdldFN5bmNEYXRhKCkpXG4gICAgLnRoZW4oZGF0YSA9PiBQcm9taXNlLnJlc29sdmUodGhpcy5hY3F1aXJlTG9jaygpKS50aGVuKCgpID0+IGRhdGEpKVxuICAgIC50aGVuKChbcmVtb3RlTWV0YSwgcmVtb3RlRGF0YSwgbG9jYWxEYXRhXSkgPT4ge1xuICAgICAgY29uc3QgcmVtb3RlTWV0YURhdGEgPSByZW1vdGVNZXRhLmRhdGEgfHwge307XG4gICAgICBjb25zdCByZW1vdGVNZXRhSW5mbyA9IHJlbW90ZU1ldGFEYXRhLmluZm8gfHwge307XG4gICAgICBjb25zdCByZW1vdGVUaW1lc3RhbXAgPSByZW1vdGVNZXRhRGF0YS50aW1lc3RhbXAgfHwgMDtcbiAgICAgIGxldCByZW1vdGVDaGFuZ2VkID0gIXJlbW90ZVRpbWVzdGFtcFxuICAgICAgICB8fCBPYmplY3Qua2V5cyhyZW1vdGVNZXRhSW5mbykubGVuZ3RoICE9PSByZW1vdGVEYXRhLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBnbG9iYWxMYXN0TW9kaWZpZWQgPSBnZXRPcHRpb24oJ2xhc3RNb2RpZmllZCcpO1xuICAgICAgY29uc3QgcmVtb3RlSXRlbU1hcCA9IHt9O1xuICAgICAgY29uc3QgbG9jYWxNZXRhID0gdGhpcy5jb25maWcuZ2V0KCdtZXRhJywge30pO1xuICAgICAgY29uc3QgZmlyc3RTeW5jID0gIWxvY2FsTWV0YS50aW1lc3RhbXA7XG4gICAgICBjb25zdCBvdXRkYXRlZCA9IGZpcnN0U3luYyB8fCByZW1vdGVUaW1lc3RhbXAgPiBsb2NhbE1ldGEudGltZXN0YW1wO1xuICAgICAgdGhpcy5sb2coJ0ZpcnN0IHN5bmM6JywgZmlyc3RTeW5jKTtcbiAgICAgIHRoaXMubG9nKCdPdXRkYXRlZDonLCBvdXRkYXRlZCwgJygnLCAnbG9jYWw6JywgbG9jYWxNZXRhLnRpbWVzdGFtcCwgJ3JlbW90ZTonLCByZW1vdGVUaW1lc3RhbXAsICcpJyk7XG4gICAgICBjb25zdCBwdXRMb2NhbCA9IFtdO1xuICAgICAgY29uc3QgcHV0UmVtb3RlID0gW107XG4gICAgICBjb25zdCBkZWxSZW1vdGUgPSBbXTtcbiAgICAgIGNvbnN0IGRlbExvY2FsID0gW107XG4gICAgICBjb25zdCB1cGRhdGVMb2NhbCA9IFtdO1xuICAgICAgcmVtb3RlTWV0YURhdGEuaW5mbyA9IHJlbW90ZURhdGEucmVkdWNlKChpbmZvLCBpdGVtKSA9PiB7XG4gICAgICAgIHJlbW90ZUl0ZW1NYXBbaXRlbS51cmldID0gaXRlbTtcbiAgICAgICAgbGV0IGl0ZW1JbmZvID0gcmVtb3RlTWV0YUluZm9baXRlbS51cmldO1xuICAgICAgICBpZiAoIWl0ZW1JbmZvKSB7XG4gICAgICAgICAgaXRlbUluZm8gPSB7fTtcbiAgICAgICAgICByZW1vdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvW2l0ZW0udXJpXSA9IGl0ZW1JbmZvO1xuICAgICAgICBpZiAoIWl0ZW1JbmZvLm1vZGlmaWVkKSB7XG4gICAgICAgICAgaXRlbUluZm8ubW9kaWZpZWQgPSBub3c7XG4gICAgICAgICAgcmVtb3RlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9LCB7fSk7XG4gICAgICBsb2NhbERhdGEuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCB7IHByb3BzOiB7IHVyaSwgcG9zaXRpb24sIGxhc3RNb2RpZmllZCB9IH0gPSBpdGVtO1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gcmVtb3RlTWV0YURhdGEuaW5mb1t1cmldO1xuICAgICAgICBjb25zdCByZW1vdGVJdGVtID0gcmVtb3RlSXRlbU1hcFt1cmldO1xuICAgICAgICBpZiAocmVtb3RlSW5mbyAmJiByZW1vdGVJdGVtKSB7XG4gICAgICAgICAgaWYgKGZpcnN0U3luYyB8fCAhbGFzdE1vZGlmaWVkIHx8IHJlbW90ZUluZm8ubW9kaWZpZWQgPiBsYXN0TW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHB1dExvY2FsLnB1c2goeyBsb2NhbDogaXRlbSwgcmVtb3RlOiByZW1vdGVJdGVtLCBpbmZvOiByZW1vdGVJbmZvIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVtb3RlSW5mby5tb2RpZmllZCA8IGxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgICBwdXRSZW1vdGUucHVzaCh7IGxvY2FsOiBpdGVtLCByZW1vdGU6IHJlbW90ZUl0ZW0gfSk7XG4gICAgICAgICAgICAgIHJlbW90ZUluZm8ubW9kaWZpZWQgPSBsYXN0TW9kaWZpZWQ7XG4gICAgICAgICAgICAgIHJlbW90ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbW90ZUluZm8ucG9zaXRpb24gIT09IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChyZW1vdGVJbmZvLnBvc2l0aW9uICYmIGdsb2JhbExhc3RNb2RpZmllZCA8PSByZW1vdGVUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVMb2NhbC5wdXNoKHsgbG9jYWw6IGl0ZW0sIHJlbW90ZTogcmVtb3RlSXRlbSwgaW5mbzogcmVtb3RlSW5mbyB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdGVJbmZvLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgcmVtb3RlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHJlbW90ZUl0ZW1NYXBbdXJpXTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdFN5bmMgfHwgIW91dGRhdGVkIHx8IGxhc3RNb2RpZmllZCA+IHJlbW90ZVRpbWVzdGFtcCkge1xuICAgICAgICAgIHB1dFJlbW90ZS5wdXNoKHsgbG9jYWw6IGl0ZW0gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsTG9jYWwucHVzaCh7IGxvY2FsOiBpdGVtIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlbW90ZUl0ZW1NYXA6OmZvckVhY2hFbnRyeSgoW3VyaSwgaXRlbV0pID0+IHtcbiAgICAgICAgY29uc3QgaW5mbyA9IHJlbW90ZU1ldGFEYXRhLmluZm9bdXJpXTtcbiAgICAgICAgaWYgKG91dGRhdGVkKSB7XG4gICAgICAgICAgcHV0TG9jYWwucHVzaCh7IHJlbW90ZTogaXRlbSwgaW5mbyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxSZW1vdGUucHVzaCh7IHJlbW90ZTogaXRlbSB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm9taXNlUXVldWUgPSBbXG4gICAgICAgIC4uLnB1dExvY2FsLm1hcCgoeyByZW1vdGUsIGluZm8gfSkgPT4ge1xuICAgICAgICAgIHRoaXMubG9nKCdEb3dubG9hZCBzY3JpcHQ6JywgcmVtb3RlLnVyaSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHJlbW90ZSlcbiAgICAgICAgICAudGhlbigocmF3KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcGFyc2VTY3JpcHREYXRhKHJhdyk7XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGRhdGFcbiAgICAgICAgICAgIGlmICghZGF0YS5jb2RlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoaW5mby5tb2RpZmllZCkgb2JqZWN0U2V0KGRhdGEsICdwcm9wcy5sYXN0TW9kaWZpZWQnLCBpbmZvLm1vZGlmaWVkKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gK2luZm8ucG9zaXRpb247XG4gICAgICAgICAgICBpZiAocG9zaXRpb24pIGRhdGEucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICghZ2V0T3B0aW9uKCdzeW5jU2NyaXB0U3RhdHVzJykgJiYgZGF0YS5jb25maWcpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuY29uZmlnLmVuYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luU2NyaXB0LnVwZGF0ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIC4uLnB1dFJlbW90ZS5tYXAoKHsgbG9jYWwsIHJlbW90ZSB9KSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2coJ1VwbG9hZCBzY3JpcHQ6JywgbG9jYWwucHJvcHMudXJpKTtcbiAgICAgICAgICByZXR1cm4gcGx1Z2luU2NyaXB0LmdldChsb2NhbC5wcm9wcy5pZClcbiAgICAgICAgICAudGhlbigoY29kZSkgPT4ge1xuICAgICAgICAgICAgLy8gWFhYIHVzZSB2ZXJzaW9uIDEgdG8gYmUgY29tcGF0aWJsZSB3aXRoIFZpb2xlbnRtb25rZXkgb24gb3RoZXIgcGxhdGZvcm1zXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZ2V0U2NyaXB0RGF0YShsb2NhbCwgMSwgeyBjb2RlIH0pO1xuICAgICAgICAgICAgcmVtb3RlTWV0YURhdGEuaW5mb1tsb2NhbC5wcm9wcy51cmldID0ge1xuICAgICAgICAgICAgICBtb2RpZmllZDogbG9jYWwucHJvcHMubGFzdE1vZGlmaWVkLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogbG9jYWwucHJvcHMucG9zaXRpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVtb3RlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXQoXG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHJlbW90ZSwge1xuICAgICAgICAgICAgICAgIHVyaTogbG9jYWwucHJvcHMudXJpLFxuICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsIC8vIHByZWZlciB1c2luZyB1cmkgb24gUFVUXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5kZWxSZW1vdGUubWFwKCh7IHJlbW90ZSB9KSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2coJ1JlbW92ZSByZW1vdGUgc2NyaXB0OicsIHJlbW90ZS51cmkpO1xuICAgICAgICAgIGRlbGV0ZSByZW1vdGVNZXRhRGF0YS5pbmZvW3JlbW90ZS51cmldO1xuICAgICAgICAgIHJlbW90ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShyZW1vdGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgLi4uZGVsTG9jYWwubWFwKCh7IGxvY2FsIH0pID0+IHtcbiAgICAgICAgICB0aGlzLmxvZygnUmVtb3ZlIGxvY2FsIHNjcmlwdDonLCBsb2NhbC5wcm9wcy51cmkpO1xuICAgICAgICAgIHJldHVybiBwbHVnaW5TY3JpcHQucmVtb3ZlKGxvY2FsLnByb3BzLmlkKTtcbiAgICAgICAgfSksXG4gICAgICAgIC4uLnVwZGF0ZUxvY2FsLm1hcCgoeyBsb2NhbCwgaW5mbyB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgdXBkYXRlcyA9IHt9O1xuICAgICAgICAgIGlmIChpbmZvLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB1cGRhdGVzLnByb3BzID0geyBwb3NpdGlvbjogaW5mby5wb3NpdGlvbiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdXBkYXRlU2NyaXB0SW5mbyhsb2NhbC5wcm9wcy5pZCwgdXBkYXRlcyk7XG4gICAgICAgIH0pLFxuICAgICAgXTtcbiAgICAgIHByb21pc2VRdWV1ZS5wdXNoKFByb21pc2UuYWxsKHByb21pc2VRdWV1ZSkudGhlbigoKSA9PiBzb3J0U2NyaXB0cygpKS50aGVuKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgIGlmICghY2hhbmdlZCkgcmV0dXJuO1xuICAgICAgICByZW1vdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHBsdWdpblNjcmlwdC5saXN0KClcbiAgICAgICAgLnRoZW4oKHNjcmlwdHMpID0+IHtcbiAgICAgICAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlSW5mbyA9IHJlbW90ZU1ldGFEYXRhLmluZm9bc2NyaXB0LnByb3BzLnVyaV07XG4gICAgICAgICAgICBpZiAocmVtb3RlSW5mbykgcmVtb3RlSW5mby5wb3NpdGlvbiA9IHNjcmlwdC5wcm9wcy5wb3NpdGlvbjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgICBwcm9taXNlUXVldWUucHVzaChQcm9taXNlLmFsbChwcm9taXNlUXVldWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBpZiAocmVtb3RlQ2hhbmdlZCkge1xuICAgICAgICAgIHJlbW90ZU1ldGFEYXRhLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnB1dChyZW1vdGVNZXRhLCBKU09OLnN0cmluZ2lmeShyZW1vdGVNZXRhRGF0YSkpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhbE1ldGEudGltZXN0YW1wID0gcmVtb3RlTWV0YURhdGEudGltZXN0YW1wO1xuICAgICAgICBsb2NhbE1ldGEubGFzdFN5bmMgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmNvbmZpZy5zZXQoJ21ldGEnLCBsb2NhbE1ldGEpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgfSkpO1xuICAgICAgLy8gaWdub3JlIGVycm9ycyB0byBlbnN1cmUgYWxsIHByb21pc2VzIGFyZSBmdWxmaWxsZWRcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlUXVldWUubWFwKHByb21pc2UgPT4gcHJvbWlzZS50aGVuKG5vb3AsIGVyciA9PiBlcnIgfHwgdHJ1ZSkpKVxuICAgICAgLnRoZW4oZXJyb3JzID0+IGVycm9ycy5maWx0ZXIoQm9vbGVhbikpXG4gICAgICAudGhlbigoZXJyb3JzKSA9PiB7IGlmIChlcnJvcnMubGVuZ3RoKSB0aHJvdyBlcnJvcnM7IH0pO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5zeW5jU3RhdGUuc2V0KCdpZGxlJyk7XG4gICAgICB0aGlzLmxvZygnU3luYyBmaW5pc2hlZDonLCB0aGlzLmRpc3BsYXlOYW1lKTtcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICB0aGlzLnN5bmNTdGF0ZS5zZXQoJ2Vycm9yJyk7XG4gICAgICB0aGlzLmxvZygnRmFpbGVkIHN5bmNpbmc6JywgdGhpcy5kaXNwbGF5TmFtZSk7XG4gICAgICB0aGlzLmxvZyhlcnIpO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVsZWFzZUxvY2soKSkuY2F0Y2gobm9vcCkpO1xuICB9LFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcihGYWN0b3J5KSB7XG4gIHNlcnZpY2VDbGFzc2VzLnB1c2goRmFjdG9yeSk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50KCkge1xuICByZXR1cm4gc3luY0NvbmZpZy5nZXQoJ2N1cnJlbnQnKTtcbn1cbmZ1bmN0aW9uIGdldFNlcnZpY2UobmFtZSkge1xuICByZXR1cm4gc2VydmljZXNbbmFtZSB8fCBnZXRDdXJyZW50KCldO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gIGlmICghc3luY0NvbmZpZykge1xuICAgIHN5bmNDb25maWcgPSBpbml0Q29uZmlnKCk7XG4gICAgc2VydmljZUNsYXNzZXMuZm9yRWFjaCgoRmFjdG9yeSkgPT4ge1xuICAgICAgY29uc3Qgc2VydmljZSA9IG5ldyBGYWN0b3J5KCk7XG4gICAgICBjb25zdCB7IG5hbWUgfSA9IHNlcnZpY2U7XG4gICAgICBzZXJ2aWNlTmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHNlcnZpY2VzW25hbWVdID0gc2VydmljZTtcbiAgICB9KTtcbiAgfVxuICBzeW5jKCk7XG59XG5cbmZ1bmN0aW9uIHN5bmNPbmUoc2VydmljZSkge1xuICBpZiAoc2VydmljZS5zeW5jU3RhdGUuaXMoWydyZWFkeScsICdzeW5jaW5nJ10pKSByZXR1cm47XG4gIGlmIChzZXJ2aWNlLmF1dGhTdGF0ZS5pcyhbJ2lkbGUnLCAnZXJyb3InXSkpIHJldHVybiBzZXJ2aWNlLmNoZWNrU3luYygpO1xuICBpZiAoc2VydmljZS5hdXRoU3RhdGUuaXMoJ2F1dGhvcml6ZWQnKSkgcmV0dXJuIHNlcnZpY2Uuc3RhcnRTeW5jKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzeW5jKCkge1xuICBjb25zdCBzZXJ2aWNlID0gZ2V0U2VydmljZSgpO1xuICByZXR1cm4gc2VydmljZSAmJiBQcm9taXNlLnJlc29sdmUoc3luY09uZShzZXJ2aWNlKSkudGhlbihhdXRvU3luYyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdXRob3JpemUoKSB7XG4gIGNvbnN0IHNlcnZpY2UgPSBnZXRTZXJ2aWNlKCk7XG4gIGlmIChzZXJ2aWNlKSBzZXJ2aWNlLmF1dGhvcml6ZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV2b2tlKCkge1xuICBjb25zdCBzZXJ2aWNlID0gZ2V0U2VydmljZSgpO1xuICBpZiAoc2VydmljZSkgc2VydmljZS5yZXZva2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldENvbmZpZyhjb25maWcpIHtcbiAgY29uc3Qgc2VydmljZSA9IGdldFNlcnZpY2UoKTtcbiAgaWYgKHNlcnZpY2UpIHtcbiAgICBzZXJ2aWNlLnNldFVzZXJDb25maWcoY29uZmlnKTtcbiAgICByZXR1cm4gc2VydmljZS5jaGVja1N5bmMoKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb3BlbkF1dGhQYWdlKHVybCwgcmVkaXJlY3RVcmkpIHtcbiAgdW5yZWdpc3RlcldlYlJlcXVlc3QoKTsgLy8gb3RoZXJ3aXNlIG91ciBuZXcgdGFiSWQgd2lsbCBiZSBpZ25vcmVkXG4gIGJyb3dzZXIud2ViUmVxdWVzdC5vbkJlZm9yZVJlcXVlc3QuYWRkTGlzdGVuZXIob25CZWZvcmVSZXF1ZXN0LCB7XG4gICAgdXJsczogW2Ake3JlZGlyZWN0VXJpfSpgXSxcbiAgICB0eXBlczogWydtYWluX2ZyYW1lJ10sXG4gICAgdGFiSWQ6IChhd2FpdCBicm93c2VyLnRhYnMuY3JlYXRlKHsgdXJsIH0pKS5pZCxcbiAgfSwgWydibG9ja2luZyddKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Nocm9tZS53ZWJSZXF1ZXN0LldlYlJlc3BvbnNlRGV0YWlsc30gaW5mb1xuICogQHJldHVybnMge2Nocm9tZS53ZWJSZXF1ZXN0LkJsb2NraW5nUmVzcG9uc2V9XG4gKi9cbmZ1bmN0aW9uIG9uQmVmb3JlUmVxdWVzdChpbmZvKSB7XG4gIGlmIChnZXRTZXJ2aWNlKCkuY2hlY2tBdXRoPy4oaW5mby51cmwpKSB7XG4gICAgYnJvd3Nlci50YWJzLnJlbW92ZShpbmZvLnRhYklkKTtcbiAgICAvLyBJZiB3ZSB1bnJlZ2lzdGVyIHdpdGhvdXQgc2V0VGltZW91dCwgQVBJIHdpbGwgaWdub3JlIHsgY2FuY2VsOiB0cnVlIH1cbiAgICBzZXRUaW1lb3V0KHVucmVnaXN0ZXJXZWJSZXF1ZXN0LCAwKTtcbiAgICByZXR1cm4geyBjYW5jZWw6IHRydWUgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnJlZ2lzdGVyV2ViUmVxdWVzdCgpIHtcbiAgYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uQmVmb3JlUmVxdWVzdC5yZW1vdmVMaXN0ZW5lcihvbkJlZm9yZVJlcXVlc3QpO1xufVxuXG5ob29rT3B0aW9ucygoZGF0YSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IGRhdGE/Llsnc3luYy5jdXJyZW50J107XG4gIGlmICh2YWx1ZSkgaW5pdGlhbGl6ZSgpO1xufSk7XG4iLCJpbXBvcnQgeyBsb2FkUXVlcnksIGR1bXBRdWVyeSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIGdldFVSSSwgZ2V0SXRlbUZpbGVuYW1lLCBCYXNlU2VydmljZSwgaXNTY3JpcHRGaWxlLCByZWdpc3RlcixcbiAgb3BlbkF1dGhQYWdlLFxufSBmcm9tICcuL2Jhc2UnO1xuXG5jb25zdCBjb25maWcgPSB7XG4gIGNsaWVudF9pZDogJ2YwcTEyenVwMnV5czV3OCcsXG4gIHJlZGlyZWN0X3VyaTogJ2h0dHBzOi8vdmlvbGVudG1vbmtleS5naXRodWIuaW8vYXV0aF9kcm9wYm94Lmh0bWwnLFxufTtcblxuY29uc3QgZXNjUkUgPSAvW1xcdTAwN2YtXFx1ZmZmZl0vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG5jb25zdCBlc2NGdW5jID0gbSA9PiBgXFxcXHUkeyhtLmNoYXJDb2RlQXQoMCkgKyAweDEwMDAwKS50b1N0cmluZygxNikuc2xpY2UoMSl9YDtcblxuZnVuY3Rpb24ganNvblN0cmluZ2lmeVNhZmUob2JqKSB7XG4gIGNvbnN0IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShlc2NSRSwgZXNjRnVuYyk7XG59XG5cbmNvbnN0IERyb3Bib3ggPSBCYXNlU2VydmljZS5leHRlbmQoe1xuICBuYW1lOiAnZHJvcGJveCcsXG4gIGRpc3BsYXlOYW1lOiAnRHJvcGJveCcsXG4gIHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6ICdodHRwczovL2FwaS5kcm9wYm94YXBpLmNvbS8yL3VzZXJzL2dldF9jdXJyZW50X2FjY291bnQnLFxuICAgIH0pXG4gICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgICB0eXBlOiAndW5hdXRob3JpemVkJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICBkYXRhOiBlcnIsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgaGFuZGxlTWV0YUVycm9yKHJlcykge1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSA0MDkpIHRocm93IHJlcztcbiAgfSxcbiAgbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogJ2h0dHBzOi8vYXBpLmRyb3Bib3hhcGkuY29tLzIvZmlsZXMvbGlzdF9mb2xkZXInLFxuICAgICAgYm9keToge1xuICAgICAgICBwYXRoOiAnJyxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KVxuICAgIC50aGVuKGRhdGEgPT4gKFxuICAgICAgZGF0YS5lbnRyaWVzLmZpbHRlcihpdGVtID0+IGl0ZW1bJy50YWcnXSA9PT0gJ2ZpbGUnICYmIGlzU2NyaXB0RmlsZShpdGVtLm5hbWUpKS5tYXAobm9ybWFsaXplKVxuICAgICkpO1xuICB9LFxuICBnZXQoaXRlbSkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJdGVtRmlsZW5hbWUoaXRlbSk7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6ICdodHRwczovL2NvbnRlbnQuZHJvcGJveGFwaS5jb20vMi9maWxlcy9kb3dubG9hZCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdEcm9wYm94LUFQSS1BcmcnOiBqc29uU3RyaW5naWZ5U2FmZSh7XG4gICAgICAgICAgcGF0aDogYC8ke25hbWV9YCxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBwdXQoaXRlbSwgZGF0YSkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJdGVtRmlsZW5hbWUoaXRlbSk7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6ICdodHRwczovL2NvbnRlbnQuZHJvcGJveGFwaS5jb20vMi9maWxlcy91cGxvYWQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnRHJvcGJveC1BUEktQXJnJzoganNvblN0cmluZ2lmeVNhZmUoe1xuICAgICAgICAgIHBhdGg6IGAvJHtuYW1lfWAsXG4gICAgICAgICAgbW9kZTogJ292ZXJ3cml0ZScsXG4gICAgICAgIH0pLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICB9LFxuICAgICAgYm9keTogZGF0YSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pXG4gICAgLnRoZW4obm9ybWFsaXplKTtcbiAgfSxcbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0SXRlbUZpbGVuYW1lKGl0ZW0pO1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiAnaHR0cHM6Ly9hcGkuZHJvcGJveGFwaS5jb20vMi9maWxlcy9kZWxldGUnLFxuICAgICAgYm9keToge1xuICAgICAgICBwYXRoOiBgLyR7bmFtZX1gLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pXG4gICAgLnRoZW4obm9ybWFsaXplKTtcbiAgfSxcbiAgYXV0aG9yaXplKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHJlc3BvbnNlX3R5cGU6ICd0b2tlbicsXG4gICAgICBjbGllbnRfaWQ6IGNvbmZpZy5jbGllbnRfaWQsXG4gICAgICByZWRpcmVjdF91cmk6IGNvbmZpZy5yZWRpcmVjdF91cmksXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly93d3cuZHJvcGJveC5jb20vb2F1dGgyL2F1dGhvcml6ZT8ke2R1bXBRdWVyeShwYXJhbXMpfWA7XG4gICAgb3BlbkF1dGhQYWdlKHVybCwgY29uZmlnLnJlZGlyZWN0X3VyaSk7XG4gIH0sXG4gIGF1dGhvcml6ZWQocmF3KSB7XG4gICAgY29uc3QgZGF0YSA9IGxvYWRRdWVyeShyYXcpO1xuICAgIGlmIChkYXRhLmFjY2Vzc190b2tlbikge1xuICAgICAgdGhpcy5jb25maWcuc2V0KHtcbiAgICAgICAgdWlkOiBkYXRhLnVpZCxcbiAgICAgICAgdG9rZW46IGRhdGEuYWNjZXNzX3Rva2VuLFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBjaGVja0F1dGgodXJsKSB7XG4gICAgY29uc3QgcmVkaXJlY3RVcmkgPSBgJHtjb25maWcucmVkaXJlY3RfdXJpfSNgO1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aChyZWRpcmVjdFVyaSkpIHtcbiAgICAgIHRoaXMuYXV0aG9yaXplZCh1cmwuc2xpY2UocmVkaXJlY3RVcmkubGVuZ3RoKSk7XG4gICAgICB0aGlzLmNoZWNrU3luYygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuICByZXZva2UoKSB7XG4gICAgdGhpcy5jb25maWcuc2V0KHtcbiAgICAgIHVpZDogbnVsbCxcbiAgICAgIHRva2VuOiBudWxsLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByZXBhcmUoKTtcbiAgfSxcbn0pO1xucmVnaXN0ZXIoRHJvcGJveCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogaXRlbS5uYW1lLFxuICAgIHNpemU6IGl0ZW0uc2l6ZSxcbiAgICB1cmk6IGdldFVSSShpdGVtLm5hbWUpLFxuICAgIC8vIG1vZGlmaWVkOiBuZXcgRGF0ZShpdGVtLnNlcnZlcl9tb2RpZmllZCkuZ2V0VGltZSgpLFxuICAgIC8vIGlzRGVsZXRlZDogaXRlbS5pc19kZWxldGVkLFxuICB9O1xufVxuIiwiLy8gUmVmZXJlbmNlOlxuLy8gLSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9kcml2ZS92My9yZWZlcmVuY2UvZmlsZXNcbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9nb29nbGUtYXBpLW5vZGVqcy1jbGllbnRcbmltcG9ydCB7IGdldFVuaXFJZCwgbm9vcCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IG9iamVjdEdldCB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgeyBkdW1wUXVlcnksIG5vdGlmeSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIGdldFVSSSwgZ2V0SXRlbUZpbGVuYW1lLCBCYXNlU2VydmljZSwgcmVnaXN0ZXIsIGlzU2NyaXB0RmlsZSxcbiAgb3BlbkF1dGhQYWdlLFxufSBmcm9tICcuL2Jhc2UnO1xuXG5jb25zdCBjb25maWcgPSB7XG4gIGNsaWVudF9pZDogcHJvY2Vzcy5lbnYuU1lOQ19HT09HTEVfQ0xJRU5UX0lELFxuICBjbGllbnRfc2VjcmV0OiBwcm9jZXNzLmVudi5TWU5DX0dPT0dMRV9DTElFTlRfU0VDUkVULFxuICByZWRpcmVjdF91cmk6ICdodHRwczovL3Zpb2xlbnRtb25rZXkuZ2l0aHViLmlvL2F1dGhfZ29vZ2xlZHJpdmUuaHRtbCcsXG4gIHNjb3BlOiAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9kcml2ZS5hcHBkYXRhJyxcbn07XG5jb25zdCBVTkFVVEhPUklaRUQgPSB7IHN0YXR1czogJ1VOQVVUSE9SSVpFRCcgfTtcblxuY29uc3QgR29vZ2xlRHJpdmUgPSBCYXNlU2VydmljZS5leHRlbmQoe1xuICBuYW1lOiAnZ29vZ2xlZHJpdmUnLFxuICBkaXNwbGF5TmFtZTogJ0dvb2dsZSBEcml2ZScsXG4gIHVybFByZWZpeDogJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2RyaXZlL3YzJyxcbiAgcmVmcmVzaFRva2VuKCkge1xuICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHRoaXMuY29uZmlnLmdldCgncmVmcmVzaF90b2tlbicpO1xuICAgIGlmICghcmVmcmVzaFRva2VuKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoeyB0eXBlOiAndW5hdXRob3JpemVkJyB9KTtcbiAgICByZXR1cm4gdGhpcy5hdXRob3JpemVkKHtcbiAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHRoaXMucHJlcGFyZSgpKTtcbiAgfSxcbiAgdXNlcigpIHtcbiAgICBjb25zdCByZXF1ZXN0VXNlciA9ICgpID0+IHRoaXMubG9hZERhdGEoe1xuICAgICAgdXJsOiBgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YzL3Rva2VuaW5mbz8ke2R1bXBRdWVyeSh7XG4gICAgICAgIGFjY2Vzc190b2tlbjogdGhpcy5jb25maWcuZ2V0KCd0b2tlbicpLFxuICAgICAgfSl9YCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pO1xuICAgIHJldHVybiByZXF1ZXN0VXNlcigpXG4gICAgLnRoZW4oKGluZm8pID0+IHtcbiAgICAgIC8vIElmIGFjY2VzcyB3YXMgZ3JhbnRlZCB3aXRoIGFjY2Vzc190eXBlPW9ubGluZSwgcmV2b2tlIGl0LlxuICAgICAgaWYgKGluZm8uYWNjZXNzX3R5cGUgPT09ICdvbmxpbmUnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICB1cmw6IGBodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20vby9vYXV0aDIvcmV2b2tlP3Rva2VuPSR7dGhpcy5jb25maWcuZ2V0KCd0b2tlbicpfWAsXG4gICAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIG5vdGlmeSh7XG4gICAgICAgICAgICB0aXRsZTogJ1N5bmMgVXBncmFkZWQnLFxuICAgICAgICAgICAgYm9keTogJ1BsZWFzZSByZWF1dGhvcml6ZSBhY2Nlc3MgdG8geW91ciBHb29nbGUgRHJpdmUgdG8gY29tcGxldGUgdGhlIHVwZ3JhZGF0aW9uLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdPbmxpbmUgYWNjZXNzIHJldm9rZWQuJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8uc2NvcGUgIT09IGNvbmZpZy5zY29wZSkgcmV0dXJuIFByb21pc2UucmVqZWN0KFVOQVVUSE9SSVpFRCk7XG4gICAgfSlcbiAgICAuY2F0Y2goKHJlcykgPT4ge1xuICAgICAgaWYgKHJlcyA9PT0gVU5BVVRIT1JJWkVEIHx8IHJlcy5zdGF0dXMgPT09IDQwMCAmJiBvYmplY3RHZXQocmVzLCAnZGF0YS5lcnJvcl9kZXNjcmlwdGlvbicpID09PSAnSW52YWxpZCBWYWx1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaFRva2VuKCkudGhlbihyZXF1ZXN0VXNlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICBkYXRhOiByZXMsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0U3luY0RhdGEoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgc3BhY2VzOiAnYXBwRGF0YUZvbGRlcicsXG4gICAgICBmaWVsZHM6ICdmaWxlcyhpZCxuYW1lLHNpemUpJyxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIHVybDogYC9maWxlcz8ke2R1bXBRdWVyeShwYXJhbXMpfWAsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KVxuICAgIC50aGVuKCh7IGZpbGVzIH0pID0+IHtcbiAgICAgIGxldCBtZXRhRmlsZTtcbiAgICAgIGNvbnN0IHJlbW90ZURhdGEgPSBmaWxlcy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGlzU2NyaXB0RmlsZShpdGVtLm5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCFtZXRhRmlsZSAmJiBpdGVtLm5hbWUgPT09IHRoaXMubWV0YUZpbGUpIHtcbiAgICAgICAgICBtZXRhRmlsZSA9IGl0ZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSlcbiAgICAgIC5tYXAobm9ybWFsaXplKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBpZiAoIWl0ZW0uc2l6ZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbWV0YUl0ZW0gPSBtZXRhRmlsZSA/IG5vcm1hbGl6ZShtZXRhRmlsZSkgOiB7fTtcbiAgICAgIGNvbnN0IGdvdE1ldGEgPSB0aGlzLmdldChtZXRhSXRlbSlcbiAgICAgIC50aGVuKGRhdGEgPT4gSlNPTi5wYXJzZShkYXRhKSlcbiAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5oYW5kbGVNZXRhRXJyb3IoZXJyKSlcbiAgICAgIC50aGVuKGRhdGEgPT4gT2JqZWN0LmFzc2lnbih7fSwgbWV0YUl0ZW0sIHtcbiAgICAgICAgbmFtZTogdGhpcy5tZXRhRmlsZSxcbiAgICAgICAgdXJpOiBudWxsLFxuICAgICAgICBkYXRhLFxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtnb3RNZXRhLCByZW1vdGVEYXRhLCB0aGlzLmdldExvY2FsRGF0YSgpXSk7XG4gICAgfSk7XG4gIH0sXG4gIGF1dGhvcml6ZSgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICByZXNwb25zZV90eXBlOiAnY29kZScsXG4gICAgICBhY2Nlc3NfdHlwZTogJ29mZmxpbmUnLFxuICAgICAgY2xpZW50X2lkOiBjb25maWcuY2xpZW50X2lkLFxuICAgICAgcmVkaXJlY3RfdXJpOiBjb25maWcucmVkaXJlY3RfdXJpLFxuICAgICAgc2NvcGU6IGNvbmZpZy5zY29wZSxcbiAgICB9O1xuICAgIGlmICghdGhpcy5jb25maWcuZ2V0KCdyZWZyZXNoX3Rva2VuJykpIHBhcmFtcy5wcm9tcHQgPSAnY29uc2VudCc7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi92Mi9hdXRoPyR7ZHVtcFF1ZXJ5KHBhcmFtcyl9YDtcbiAgICBvcGVuQXV0aFBhZ2UodXJsLCBjb25maWcucmVkaXJlY3RfdXJpKTtcbiAgfSxcbiAgY2hlY2tBdXRoKHVybCkge1xuICAgIGNvbnN0IHJlZGlyZWN0VXJpID0gYCR7Y29uZmlnLnJlZGlyZWN0X3VyaX0/Y29kZT1gO1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aChyZWRpcmVjdFVyaSkpIHtcbiAgICAgIHRoaXMuYXV0aFN0YXRlLnNldCgnYXV0aG9yaXppbmcnKTtcbiAgICAgIHRoaXMuYXV0aG9yaXplZCh7XG4gICAgICAgIGNvZGU6IGRlY29kZVVSSUNvbXBvbmVudCh1cmwuc3BsaXQoJyMnKVswXS5zbGljZShyZWRpcmVjdFVyaS5sZW5ndGgpKSxcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNoZWNrU3luYygpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcbiAgcmV2b2tlKCkge1xuICAgIHRoaXMuY29uZmlnLnNldCh7XG4gICAgICB0b2tlbjogbnVsbCxcbiAgICAgIHJlZnJlc2hfdG9rZW46IG51bGwsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucHJlcGFyZSgpO1xuICB9LFxuICBhdXRob3JpemVkKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3Y0L3Rva2VuJyxcbiAgICAgIHByZWZpeDogJycsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBkdW1wUXVlcnkoT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBjbGllbnRfaWQ6IGNvbmZpZy5jbGllbnRfaWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IGNvbmZpZy5jbGllbnRfc2VjcmV0LFxuICAgICAgICByZWRpcmVjdF91cmk6IGNvbmZpZy5yZWRpcmVjdF91cmksXG4gICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgfSwgcGFyYW1zKSksXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KVxuICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoZGF0YS5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgY29uc3QgdXBkYXRlID0ge1xuICAgICAgICAgIHRva2VuOiBkYXRhLmFjY2Vzc190b2tlbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRhdGEucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgIHVwZGF0ZS5yZWZyZXNoX3Rva2VuID0gZGF0YS5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLnNldCh1cGRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZGF0YTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgaGFuZGxlTWV0YUVycm9yOiBub29wLFxuICBsaXN0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCcpO1xuICB9LFxuICBnZXQoeyBpZCB9KSB7XG4gICAgaWYgKCFpZCkgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgdXJsOiBgL2ZpbGVzLyR7aWR9P2FsdD1tZWRpYWAsXG4gICAgfSk7XG4gIH0sXG4gIHB1dChpdGVtLCBkYXRhKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldEl0ZW1GaWxlbmFtZShpdGVtKTtcbiAgICBjb25zdCB7IGlkIH0gPSBpdGVtO1xuICAgIGNvbnN0IGJvdW5kYXJ5ID0gZ2V0VW5pcUlkKCd2aW9sZW50bW9ua2V5LWlzLWdyZWF0LScpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAnQ29udGVudC1UeXBlJzogYG11bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWAsXG4gICAgfTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGlkID8ge1xuICAgICAgbmFtZSxcbiAgICB9IDoge1xuICAgICAgbmFtZSxcbiAgICAgIHBhcmVudHM6IFsnYXBwRGF0YUZvbGRlciddLFxuICAgIH07XG4gICAgY29uc3QgYm9keSA9IFtcbiAgICAgIGAtLSR7Ym91bmRhcnl9YCxcbiAgICAgICdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnLFxuICAgICAgJycsXG4gICAgICBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSksXG4gICAgICBgLS0ke2JvdW5kYXJ5fWAsXG4gICAgICAnQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluJyxcbiAgICAgICcnLFxuICAgICAgZGF0YSxcbiAgICAgIGAtLSR7Ym91bmRhcnl9LS1gLFxuICAgICAgJycsXG4gICAgXS5qb2luKCdcXHJcXG4nKTtcbiAgICBjb25zdCB1cmwgPSBpZFxuICAgICAgPyBgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vdXBsb2FkL2RyaXZlL3YzL2ZpbGVzLyR7aWR9P3VwbG9hZFR5cGU9bXVsdGlwYXJ0YFxuICAgICAgOiAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vdXBsb2FkL2RyaXZlL3YzL2ZpbGVzP3VwbG9hZFR5cGU9bXVsdGlwYXJ0JztcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICB1cmwsXG4gICAgICBib2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIG1ldGhvZDogaWQgPyAnUEFUQ0gnIDogJ1BPU1QnLFxuICAgIH0pO1xuICB9LFxuICByZW1vdmUoeyBpZCB9KSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIHVybDogYC9maWxlcy8ke2lkfWAsXG4gICAgfSk7XG4gIH0sXG59KTtcbnJlZ2lzdGVyKEdvb2dsZURyaXZlKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplKGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogaXRlbS5pZCxcbiAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgc2l6ZTogK2l0ZW0uc2l6ZSxcbiAgICB1cmk6IGdldFVSSShpdGVtLm5hbWUpLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgaW5pdGlhbGl6ZSxcbiAgc3luYyxcbiAgZ2V0U3RhdGVzLFxuICBhdXRob3JpemUsXG4gIHJldm9rZSxcbiAgc2V0Q29uZmlnLFxufSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICcuL2Ryb3Bib3gnO1xuaW1wb3J0ICcuL29uZWRyaXZlJztcbmltcG9ydCAnLi9nb29nbGVkcml2ZSc7XG5pbXBvcnQgJy4vd2ViZGF2JztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi4vdXRpbHMvbWVzc2FnZSc7XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgU3luY0F1dGhvcml6ZTogYXV0aG9yaXplLFxuICBTeW5jUmV2b2tlOiByZXZva2UsXG4gIFN5bmNTdGFydDogc3luYyxcbiAgU3luY1NldENvbmZpZzogc2V0Q29uZmlnLFxufSk7XG5cbmV4cG9ydCB7XG4gIGluaXRpYWxpemUsXG4gIHN5bmMsXG4gIGdldFN0YXRlcyxcbiAgYXV0aG9yaXplLFxuICByZXZva2UsXG59O1xuIiwiLy8gUmVmZXJlbmNlOiBodHRwczovL2Rldi5vbmVkcml2ZS5jb20vUkVBRE1FLmh0bVxuaW1wb3J0IHsgbm9vcCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IG9iamVjdEdldCB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgeyBkdW1wUXVlcnkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1xuICBnZXRVUkksIGdldEl0ZW1GaWxlbmFtZSwgQmFzZVNlcnZpY2UsIGlzU2NyaXB0RmlsZSwgcmVnaXN0ZXIsXG4gIG9wZW5BdXRoUGFnZSxcbn0gZnJvbSAnLi9iYXNlJztcblxuY29uc3QgY29uZmlnID0ge1xuICBjbGllbnRfaWQ6IHByb2Nlc3MuZW52LlNZTkNfT05FRFJJVkVfQ0xJRU5UX0lELFxuICBjbGllbnRfc2VjcmV0OiBwcm9jZXNzLmVudi5TWU5DX09ORURSSVZFX0NMSUVOVF9TRUNSRVQsXG4gIHJlZGlyZWN0X3VyaTogJ2h0dHBzOi8vdmlvbGVudG1vbmtleS5naXRodWIuaW8vYXV0aF9vbmVkcml2ZS5odG1sJyxcbn07XG5cbmNvbnN0IE9uZURyaXZlID0gQmFzZVNlcnZpY2UuZXh0ZW5kKHtcbiAgbmFtZTogJ29uZWRyaXZlJyxcbiAgZGlzcGxheU5hbWU6ICdPbmVEcml2ZScsXG4gIHVybFByZWZpeDogJ2h0dHBzOi8vYXBpLm9uZWRyaXZlLmNvbS92MS4wJyxcbiAgcmVmcmVzaFRva2VuKCkge1xuICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHRoaXMuY29uZmlnLmdldCgncmVmcmVzaF90b2tlbicpO1xuICAgIHJldHVybiB0aGlzLmF1dGhvcml6ZWQoe1xuICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4gdGhpcy5wcmVwYXJlKCkpO1xuICB9LFxuICB1c2VyKCkge1xuICAgIGNvbnN0IHJlcXVlc3RVc2VyID0gKCkgPT4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICB1cmw6ICcvZHJpdmUnLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcXVlc3RVc2VyKClcbiAgICAuY2F0Y2goKHJlcykgPT4ge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW4oKS50aGVuKHJlcXVlc3RVc2VyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IHJlcztcbiAgICB9KVxuICAgIC5jYXRjaCgocmVzKSA9PiB7XG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAwICYmIG9iamVjdEdldChyZXMsICdkYXRhLmVycm9yJykgPT09ICdpbnZhbGlkX2dyYW50Jykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICAgIHR5cGU6ICd1bmF1dGhvcml6ZWQnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgIGRhdGE6IHJlcyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBoYW5kbGVNZXRhRXJyb3IocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgY29uc3QgaGVhZGVyID0gcmVzLmhlYWRlcnMuZ2V0KCdXV1ctQXV0aGVudGljYXRlJyk/LlswXSB8fCAnJztcbiAgICAgIGlmICgvXkJlYXJlciByZWFsbT1cIk9uZURyaXZlQVBJXCIvLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW4oKS50aGVuKCgpID0+IHRoaXMuZ2V0TWV0YSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgcmVzO1xuICB9LFxuICBsaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIHVybDogJy9kcml2ZS9zcGVjaWFsL2FwcHJvb3QvY2hpbGRyZW4nLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSlcbiAgICAudGhlbihkYXRhID0+IGRhdGEudmFsdWUuZmlsdGVyKGl0ZW0gPT4gaXRlbS5maWxlICYmIGlzU2NyaXB0RmlsZShpdGVtLm5hbWUpKS5tYXAobm9ybWFsaXplKSk7XG4gIH0sXG4gIGdldChpdGVtKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldEl0ZW1GaWxlbmFtZShpdGVtKTtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICB1cmw6IGAvZHJpdmUvc3BlY2lhbC9hcHByb290Oi8ke2VuY29kZVVSSUNvbXBvbmVudChuYW1lKX1gLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSlcbiAgICAudGhlbihkYXRhID0+IHRoaXMubG9hZERhdGEoe1xuICAgICAgdXJsOiBkYXRhWydAY29udGVudC5kb3dubG9hZFVybCddLFxuICAgICAgZGVsYXk6IGZhbHNlLFxuICAgIH0pKTtcbiAgfSxcbiAgcHV0KGl0ZW0sIGRhdGEpIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0SXRlbUZpbGVuYW1lKGl0ZW0pO1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICB1cmw6IGAvZHJpdmUvc3BlY2lhbC9hcHByb290Oi8ke2VuY29kZVVSSUNvbXBvbmVudChuYW1lKX06L2NvbnRlbnRgLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICB9LFxuICAgICAgYm9keTogZGF0YSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pXG4gICAgLnRoZW4obm9ybWFsaXplKTtcbiAgfSxcbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICAvLyByZXR1cm4gMjA0XG4gICAgY29uc3QgbmFtZSA9IGdldEl0ZW1GaWxlbmFtZShpdGVtKTtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgdXJsOiBgL2RyaXZlL3NwZWNpYWwvYXBwcm9vdDovJHtlbmNvZGVVUklDb21wb25lbnQobmFtZSl9YCxcbiAgICB9KVxuICAgIC5jYXRjaChub29wKTtcbiAgfSxcbiAgYXV0aG9yaXplKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGNsaWVudF9pZDogY29uZmlnLmNsaWVudF9pZCxcbiAgICAgIHNjb3BlOiAnb25lZHJpdmUuYXBwZm9sZGVyIHdsLm9mZmxpbmVfYWNjZXNzJyxcbiAgICAgIHJlc3BvbnNlX3R5cGU6ICdjb2RlJyxcbiAgICAgIHJlZGlyZWN0X3VyaTogY29uZmlnLnJlZGlyZWN0X3VyaSxcbiAgICB9O1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovL2xvZ2luLmxpdmUuY29tL29hdXRoMjBfYXV0aG9yaXplLnNyZj8ke2R1bXBRdWVyeShwYXJhbXMpfWA7XG4gICAgb3BlbkF1dGhQYWdlKHVybCwgY29uZmlnLnJlZGlyZWN0X3VyaSk7XG4gIH0sXG4gIGNoZWNrQXV0aCh1cmwpIHtcbiAgICBjb25zdCByZWRpcmVjdFVyaSA9IGAke2NvbmZpZy5yZWRpcmVjdF91cml9P2NvZGU9YDtcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgocmVkaXJlY3RVcmkpKSB7XG4gICAgICB0aGlzLmF1dGhTdGF0ZS5zZXQoJ2F1dGhvcml6aW5nJyk7XG4gICAgICB0aGlzLmF1dGhvcml6ZWQoe1xuICAgICAgICBjb2RlOiB1cmwuc2xpY2UocmVkaXJlY3RVcmkubGVuZ3RoKSxcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNoZWNrU3luYygpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcbiAgcmV2b2tlKCkge1xuICAgIHRoaXMuY29uZmlnLnNldCh7XG4gICAgICB1aWQ6IG51bGwsXG4gICAgICB0b2tlbjogbnVsbCxcbiAgICAgIHJlZnJlc2hfdG9rZW46IG51bGwsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucHJlcGFyZSgpO1xuICB9LFxuICBhdXRob3JpemVkKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiAnaHR0cHM6Ly9sb2dpbi5saXZlLmNvbS9vYXV0aDIwX3Rva2VuLnNyZicsXG4gICAgICBwcmVmaXg6ICcnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICB9LFxuICAgICAgYm9keTogZHVtcFF1ZXJ5KE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgY2xpZW50X2lkOiBjb25maWcuY2xpZW50X2lkLFxuICAgICAgICBjbGllbnRfc2VjcmV0OiBjb25maWcuY2xpZW50X3NlY3JldCxcbiAgICAgICAgcmVkaXJlY3RfdXJpOiBjb25maWcucmVkaXJlY3RfdXJpLFxuICAgICAgICBncmFudF90eXBlOiAnYXV0aG9yaXphdGlvbl9jb2RlJyxcbiAgICAgIH0sIHBhcmFtcykpLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSlcbiAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGRhdGEuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnNldCh7XG4gICAgICAgICAgdWlkOiBkYXRhLnVzZXJfaWQsXG4gICAgICAgICAgdG9rZW46IGRhdGEuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIHJlZnJlc2hfdG9rZW46IGRhdGEucmVmcmVzaF90b2tlbixcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBkYXRhO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufSk7XG5yZWdpc3RlcihPbmVEcml2ZSk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogaXRlbS5uYW1lLFxuICAgIHNpemU6IGl0ZW0uc2l6ZSxcbiAgICB1cmk6IGdldFVSSShpdGVtLm5hbWUpLFxuICAgIC8vIG1vZGlmaWVkOiBuZXcgRGF0ZShpdGVtLmxhc3RNb2RpZmllZERhdGVUaW1lKS5nZXRUaW1lKCksXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBnZXRVUkksIGdldEl0ZW1GaWxlbmFtZSwgQmFzZVNlcnZpY2UsIGlzU2NyaXB0RmlsZSwgcmVnaXN0ZXIsXG59IGZyb20gJy4vYmFzZSc7XG5cbmNvbnN0IEtFWV9DSElMRFJFTiA9IFN5bWJvbCgnY2hpbGRyZW4nKTtcblxuY2xhc3MgWE5vZGUge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBuc01hcCkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5uc01hcCA9IHsgLi4ubnNNYXAgfTtcbiAgICB0aGlzLnBhcnNlQXR0cnMoKTtcbiAgICB0aGlzLnBhcnNlTmFtZSgpO1xuICB9XG5cbiAgc3RhdGljIGZyb21YTUwoeG1sKSB7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIGNvbnN0IGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgcmV0dXJuIG5ldyBYTm9kZShkb2MpO1xuICB9XG5cbiAgcGFyc2VBdHRycygpIHtcbiAgICBjb25zdCB7IG5vZGUsIG5zTWFwIH0gPSB0aGlzO1xuICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBub2RlO1xuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2Ygbm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUgfSA9IGF0dHI7XG4gICAgICAgIGlmIChuYW1lID09PSAneG1sbnMnKSBuc01hcC4kID0gdmFsdWU7XG4gICAgICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgneG1sbnM6JykpIG5zTWFwW25hbWUuc2xpY2UoNildID0gdmFsdWU7XG4gICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgfVxuXG4gIHBhcnNlTmFtZSgpIHtcbiAgICBjb25zdCB7IG5vZGUsIG5zTWFwIH0gPSB0aGlzO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBsZXQgbmFtZSA9IG5vZGUudGFnTmFtZTtcbiAgICAgIGxldCBucyA9IG5zTWFwLiQ7XG4gICAgICBpZiAobmFtZS5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgIFtwcmVmaXgsIG5hbWVdID0gbmFtZS5zcGxpdCgnOicpO1xuICAgICAgICBucyA9IG5zTWFwW3ByZWZpeF07XG4gICAgICAgIGlmICghbnMpIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBuYW1lc3BhY2U6ICR7cHJlZml4fWApO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gbnMgKyBuYW1lO1xuICAgIH1cbiAgfVxuXG4gIHRleHQoKSB7XG4gICAgY29uc3QgeyBub2RlIH0gPSB0aGlzO1xuICAgIGlmIChub2RlKSByZXR1cm4gKG5vZGUudGV4dENvbnRlbnQgfHwgJycpLnRyaW0oKTtcbiAgfVxuXG4gIGNoaWxkcmVuKCkge1xuICAgIGlmICghdGhpc1tLRVlfQ0hJTERSRU5dKSB7XG4gICAgICBjb25zdCB7IG5vZGUsIG5zTWFwIH0gPSB0aGlzO1xuICAgICAgdGhpc1tLRVlfQ0hJTERSRU5dID0gWy4uLm5vZGUuY2hpbGRyZW5dXG4gICAgICAubWFwKGNoaWxkID0+IG5ldyBYTm9kZShjaGlsZCwgbnNNYXApKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbS0VZX0NISUxEUkVOXTtcbiAgfVxuXG4gIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuKCkubWFwKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGdldENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAodGFnTmFtZSA9PiBub2RlID0+IG5vZGUubmFtZSA9PT0gdGFnTmFtZSkoY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH1cblxuICBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbigpLmZpbHRlcih0aGlzLmdldENhbGxiYWNrKGNhbGxiYWNrKSk7XG4gIH1cblxuICBmaW5kKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4oKS5maW5kKHRoaXMuZ2V0Q2FsbGJhY2soY2FsbGJhY2spKTtcbiAgfVxuXG4gIGF0dHIoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnNba2V5XTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX0NPTkZJRyA9IHtcbiAgc2VydmVyVXJsOiAnJyxcbiAgYW5vbnltb3VzOiBmYWxzZSxcbiAgdXNlcm5hbWU6ICcnLFxuICBwYXNzd29yZDogJycsXG59O1xuXG5jb25zdCBXZWJEQVYgPSBCYXNlU2VydmljZS5leHRlbmQoe1xuICBuYW1lOiAnd2ViZGF2JyxcbiAgZGlzcGxheU5hbWU6ICdXZWJEQVYnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYXV0aFR5cGU6ICdwYXNzd29yZCcsXG4gICAgc2VydmVyVXJsOiBudWxsLFxuICB9LFxuICBnZXRVc2VyQ29uZmlnKCkge1xuICAgIGlmICghdGhpcy51c2VyQ29uZmlnKSB7XG4gICAgICB0aGlzLnVzZXJDb25maWcgPSB7XG4gICAgICAgIC4uLkRFRkFVTFRfQ09ORklHLFxuICAgICAgICAuLi50aGlzLmNvbmZpZy5nZXQoJ3VzZXJDb25maWcnKSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVzZXJDb25maWc7XG4gIH0sXG4gIHNldFVzZXJDb25maWcoY29uZmlnKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnVzZXJDb25maWcsIGNvbmZpZyk7XG4gICAgdGhpcy5jb25maWcuc2V0KCd1c2VyQ29uZmlnJywgdGhpcy51c2VyQ29uZmlnKTtcbiAgfSxcbiAgaW5pdFRva2VuKCkge1xuICAgIHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldFVzZXJDb25maWcoKTtcbiAgICBsZXQgdXJsID0gY29uZmlnLnNlcnZlclVybD8udHJpbSgpIHx8ICcnO1xuICAgIGlmICghdXJsLmluY2x1ZGVzKCc6Ly8nKSkgdXJsID0gYGh0dHA6Ly8ke3VybH1gO1xuICAgIGlmICghdXJsLmVuZHNXaXRoKCcvJykpIHVybCArPSAnLyc7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBVUkwodXJsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuc2VydmVyVXJsID0gbnVsbDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wcm9wZXJ0aWVzLnNlcnZlclVybCA9IGAke3VybH1WaW9sZW50bW9ua2V5L2A7XG4gICAgY29uc3QgeyBhbm9ueW1vdXMsIHVzZXJuYW1lLCBwYXNzd29yZCB9ID0gY29uZmlnO1xuICAgIGlmIChhbm9ueW1vdXMpIHJldHVybiB0cnVlO1xuICAgIGlmICghdXNlcm5hbWUgfHwgIXBhc3N3b3JkKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYXV0aCA9IHdpbmRvdy5idG9hKGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWApO1xuICAgIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJhc2ljICR7YXV0aH1gO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBsb2FkRGF0YShvcHRpb25zKSB7XG4gICAgLy8gQnlwYXNzaW5nIGxvZ2luIENTUkYgcHJvdGVjdGlvbiBpbiBOZXh0Y2xvdWQgLyBPd25jbG91ZCBieSBub3Qgc2VuZGluZyBjb29raWVzLlxuICAgIC8vIFdlIGFyZSBub3QgdXNpbmcgd2ViIFVJIGFuZCBjb29raWUgYXV0aGVudGljYXRpb24sIHNvIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhhdC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Zpb2xlbnRtb25rZXkvdmlvbGVudG1vbmtleS9pc3N1ZXMvOTc2XG4gICAgcmV0dXJuIEJhc2VTZXJ2aWNlLnByb3RvdHlwZS5sb2FkRGF0YS5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY3JlZGVudGlhbHM6ICdvbWl0JyxcbiAgICB9LCBvcHRpb25zKSk7XG4gIH0sXG4gIGhhbmRsZU1ldGFFcnJvcihyZXMpIHtcbiAgICBpZiAoIVtcbiAgICAgIDQwNCwgLy8gRmlsZSBub3QgZXhpc3RzXG4gICAgICA0MDksIC8vIERpcmVjdG9yeSBub3QgZXhpc3RzXG4gICAgXS5pbmNsdWRlcyhyZXMuc3RhdHVzKSkgdGhyb3cgcmVzO1xuICB9LFxuICAvLyBTb21lIFdlYkRBViBzZXJ2ZXJzIGRvIG5vdCBhbGxvdyBMT0NLIC8gVU5MT0NLXG4gIC8qXG4gIGFjcXVpcmVMb2NrKCkge1xuICAgIGNvbnN0IHsgc2VydmVyVXJsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY3JlYXRlTG9jayA9ICgpID0+IHtcbiAgICAgIHRoaXMubG9nKCdBY3F1aXJlIGxvY2suLi4nKTtcbiAgICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgICAgbWV0aG9kOiAnTE9DSycsXG4gICAgICAgIHVybDogc2VydmVyVXJsLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgVGltZW91dDogYFNlY29uZC0kezMwICogNjB9YCxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogYFxcXG48P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJ1dGYtOFwiID8+XG48RDpsb2NraW5mbyB4bWxuczpEPSdEQVY6Jz5cbiAgPEQ6bG9ja3Njb3BlPjxEOmV4Y2x1c2l2ZS8+PC9EOmxvY2tzY29wZT5cbiAgPEQ6bG9ja3R5cGU+PEQ6d3JpdGUvPjwvRDpsb2NrdHlwZT5cbjwvRDpsb2NraW5mbz5gLFxuICAgICAgfSlcbiAgICAgIC50aGVuKHhtbCA9PiB7XG4gICAgICAgIGNvbnN0IGRvYyA9IFhOb2RlLmZyb21YTUwoeG1sKTtcbiAgICAgICAgY29uc3QgbG9jayA9IGRvYy5maW5kKCdEQVY6cHJvcCcpXG4gICAgICAgIC5maW5kKCdEQVY6bG9ja2Rpc2NvdmVyeScpXG4gICAgICAgIC5maW5kKCdEQVY6YWN0aXZlbG9jaycpXG4gICAgICAgIC5maW5kKCdEQVY6bG9ja3Rva2VuJylcbiAgICAgICAgLmZpbmQoJ0RBVjpocmVmJylcbiAgICAgICAgLnRleHQoKTtcbiAgICAgICAgdGhpcy5sb2coJ0FjcXVpcmVkIGxvY2s6JywgbG9jayk7XG4gICAgICAgIHRoaXMuY29uZmlnLnNldCh7XG4gICAgICAgICAgbG9jayxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGxvY2sgPSB0aGlzLmNvbmZpZy5nZXQoJ2xvY2snKTtcbiAgICBpZiAobG9jaykge1xuICAgICAgdGhpcy5sb2coJ1JlZnJlc2ggbG9jazonLCBsb2NrKTtcbiAgICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgICAgbWV0aG9kOiAnTE9DSycsXG4gICAgICAgIHVybDogc2VydmVyVXJsLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgSWY6IGAoPCR7bG9ja30+KWAsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZygnUmVmcmVzaGVkIGxvY2s6JywgbG9jayk7XG4gICAgICB9LCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyLnN0YXR1cyA9PT0gNDEyKSB7XG4gICAgICAgICAgdGhpcy5sb2coJ1JlZnJlc2ggbG9jayBlcnJvcicpO1xuICAgICAgICAgIHRoaXMuY29uZmlnLnNldCh7IGxvY2s6IG51bGwgfSk7XG4gICAgICAgICAgLy8gUHJlY29uZGl0aW9uIEZhaWxlZFxuICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVMb2NrKCk7XG4gIH0sXG4gIHJlbGVhc2VMb2NrKCkge1xuICAgIGNvbnN0IGxvY2sgPSB0aGlzLmNvbmZpZy5nZXQoJ2xvY2snKTtcbiAgICBpZiAobG9jaykge1xuICAgICAgY29uc3QgeyBzZXJ2ZXJVcmwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICAgIHRoaXMubG9nKCdSZWxlYXNlIGxvY2s6JywgbG9jayk7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICAgIG1ldGhvZDogJ1VOTE9DSycsXG4gICAgICAgIHVybDogc2VydmVyVXJsLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0xvY2stVG9rZW4nOiBgPCR7bG9ja30+YCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdSZWxlYXNlZCBsb2NrJyk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdSZWxlYXNlIGxvY2sgZXJyb3InKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuY29uZmlnLnNldCh7IGxvY2s6IG51bGwgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gICovXG4gIGxpc3QoKSB7XG4gICAgY29uc3QgeyBzZXJ2ZXJVcmwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBta2RpciA9ICgpID0+IHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnTUtDT0wnLFxuICAgICAgdXJsOiBzZXJ2ZXJVcmwsXG4gICAgfSk7XG4gICAgY29uc3QgcmVhZGRpciA9ICgpID0+IHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUFJPUEZJTkQnLFxuICAgICAgdXJsOiBzZXJ2ZXJVcmwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIGRlcHRoOiAnMScsXG4gICAgICB9LFxuICAgIH0pXG4gICAgLnRoZW4oKHhtbCkgPT4ge1xuICAgICAgY29uc3QgZG9jID0gWE5vZGUuZnJvbVhNTCh4bWwpO1xuICAgICAgY29uc3QgaXRlbXMgPSBkb2MuY2hpbGRyZW4oKVswXVxuICAgICAgLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wID0gbm9kZS5maW5kKCdEQVY6cHJvcHN0YXQnKS5maW5kKCdEQVY6cHJvcCcpO1xuICAgICAgICBjb25zdCB0eXBlID0gcHJvcC5maW5kKCdEQVY6cmVzb3VyY2V0eXBlJykuZmluZCgnREFWOmNvbGxlY3Rpb24nKSA/ICdkaXJlY3RvcnknIDogJ2ZpbGUnO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgbGV0IGRpc3BsYXlOYW1lO1xuICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lTm9kZSA9IHByb3AuZmluZCgnREFWOmRpc3BsYXluYW1lJyk7XG5cbiAgICAgICAgICBpZiAoZGlzcGxheU5hbWVOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWVOb2RlLnRleHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IG5vZGUuZmluZCgnREFWOmhyZWYnKS50ZXh0KCk7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChocmVmLnN1YnN0cmluZyhocmVmLmxhc3RJbmRleE9mKCcvJykgKyAxKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU2NyaXB0RmlsZShkaXNwbGF5TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwcm9wLmZpbmQoJ0RBVjpnZXRjb250ZW50bGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKHtcbiAgICAgICAgICAgICAgbmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgIHNpemU6IHNpemUgPyArc2l6ZS50ZXh0KCkgOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlYWRkaXIoKVxuICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBta2RpcigpLnRoZW4ocmVhZGRpcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH0sXG4gIGdldChpdGVtKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldEl0ZW1GaWxlbmFtZShpdGVtKTtcbiAgICBjb25zdCB7IHNlcnZlclVybCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIHVybDogc2VydmVyVXJsICsgbmFtZSxcbiAgICB9KTtcbiAgfSxcbiAgcHV0KGl0ZW0sIGRhdGEpIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0SXRlbUZpbGVuYW1lKGl0ZW0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nLFxuICAgIH07XG4gICAgY29uc3QgbG9jayA9IHRoaXMuY29uZmlnLmdldCgnbG9jaycpO1xuICAgIGlmIChsb2NrKSBoZWFkZXJzLklmID0gYCg8JHtsb2NrfT4pYDtcbiAgICBjb25zdCB7IHNlcnZlclVybCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICB1cmw6IHNlcnZlclVybCArIG5hbWUsXG4gICAgICBib2R5OiBkYXRhLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcbiAgfSxcbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0SXRlbUZpbGVuYW1lKGl0ZW0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBjb25zdCBsb2NrID0gdGhpcy5jb25maWcuZ2V0KCdsb2NrJyk7XG4gICAgaWYgKGxvY2spIGhlYWRlcnMuSWYgPSBgKDwke2xvY2t9PilgO1xuICAgIGNvbnN0IHsgc2VydmVyVXJsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIHVybDogc2VydmVyVXJsICsgbmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSk7XG4gIH0sXG59KTtcbnJlZ2lzdGVyKFdlYkRBVik7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogaXRlbS5uYW1lLFxuICAgIHNpemU6IGl0ZW0uc2l6ZSxcbiAgICB1cmk6IGdldFVSSShpdGVtLm5hbWUpLFxuICB9O1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLy8gcmVmZXIgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanNcblxuZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyhidWZmZXIpIHtcbiAgY29uc3Qgb3V0cHV0Qnl0ZXMgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgY29uc3QgcGFkZGluZ0J5dGVzID0gb3V0cHV0Qnl0ZXMgJiYgKG5ldyBEYXRhVmlldyhidWZmZXIpKS5nZXRVaW50OChvdXRwdXRCeXRlcyAtIDEpO1xuICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRCeXRlcyAtIHBhZGRpbmdCeXRlcyk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZXhwb3J0IGNvbnN0IEFFU0RlY3J5cHRvciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG4gICAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgICB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuXG4gICAgICAvLyBDaGFuZ2VzIGR1cmluZyBydW50aW1lXG4gICAgICB0aGlzLmtleSA9IG5ldyBVaW50MzJBcnJheSgwKTtcblxuICAgICAgdGhpcy5pbml0VGFibGUoKTtcbiAgICB9LFxuXG4gICAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICAgIHVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhcnJheUJ1ZmZlcikge1xuICAgICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgICAgbGV0IG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgbmV3QXJyYXlbaV0gPSB2aWV3LmdldFVpbnQzMihpICogNCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9LFxuXG4gICAgaW5pdFRhYmxlKCkge1xuICAgICAgbGV0IHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgICBsZXQgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICAgIGxldCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICAgIGxldCBzdWJNaXgwID0gc3ViTWl4WzBdO1xuICAgICAgbGV0IHN1Yk1peDEgPSBzdWJNaXhbMV07XG4gICAgICBsZXQgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICAgIGxldCBzdWJNaXgzID0gc3ViTWl4WzNdO1xuICAgICAgbGV0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgICBsZXQgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICAgIGxldCBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgICBsZXQgeCA9IDA7XG4gICAgICBsZXQgeGkgPSAwO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgICAgZFtpXSA9IGkgPDwgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgbGV0IHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG4gICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcbiAgICAgICAgc0JveFt4XSA9IHN4O1xuICAgICAgICBpbnZTQm94W3N4XSA9IHg7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgICBsZXQgeDIgPSBkW3hdO1xuICAgICAgICBsZXQgeDQgPSBkW3gyXTtcbiAgICAgICAgbGV0IHg4ID0gZFt4NF07XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgICAgbGV0IHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuICAgICAgICBzdWJNaXgwW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgICBzdWJNaXgxW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgICAgc3ViTWl4Mlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG4gICAgICAgIGludlN1Yk1peDBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgICBpbnZTdWJNaXgxW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICAgIGludlN1Yk1peDJbc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcbiAgICAgICAgaWYgKCF4KSB7XG4gICAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGV4cGFuZEtleShrZXlCdWZmZXIpIHtcbiAgICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgICBsZXQga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICAgIGxldCBzYW1lS2V5ID0gdHJ1ZTtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICAgIHNhbWVLZXkgPSAoa2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF0pO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cblxuICAgICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIGxldCBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcblxuICAgICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgICAgfVxuXG4gICAgICBsZXQga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgICBsZXQga3NSb3c7XG4gICAgICBsZXQgaW52S3NSb3c7XG5cbiAgICAgIGxldCBrZXlTY2hlZHVsZSA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICAgIGxldCBzYm94ID0gdGhpcy5zQm94O1xuICAgICAgbGV0IHJjb24gPSB0aGlzLnJjb247XG5cbiAgICAgIGxldCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgICBsZXQgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgICBsZXQgcHJldjtcbiAgICAgIGxldCB0O1xuXG4gICAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHQgPSBwcmV2O1xuXG4gICAgICAgIGlmIChrc1JvdyAlIGtleVNpemUgPT09IDApIHtcbiAgICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cbiAgICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgIHQgXj0gcmNvblsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF4gaW52U3ViTWl4MVtzYm94Wyh0ID4+PiAxNikgJiAweGZmXV0gXiBpbnZTdWJNaXgyW3Nib3hbKHQgPj4+IDgpICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICAgIH1cblxuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gICAgbmV0d29ya1RvSG9zdE9yZGVyU3dhcCh3b3JkKSB7XG4gICAgICByZXR1cm4gKHdvcmQgPDwgMjQpIHwgKCh3b3JkICYgMHhmZjAwKSA8PCA4KSB8ICgod29yZCAmIDB4ZmYwMDAwKSA+PiA4KSB8ICh3b3JkID4+PiAyNCk7XG4gICAgfSxcblxuICAgIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJViwgcmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICBsZXQgblJvdW5kcyA9IHRoaXMua2V5U2l6ZSArIDY7XG4gICAgICBsZXQgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgICAgbGV0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XG5cbiAgICAgIGxldCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgICBsZXQgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgICBsZXQgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICAgIGxldCBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICAgIGxldCBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG5cbiAgICAgIGxldCBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgICBsZXQgb3V0cHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEludDMyLmxlbmd0aCk7XG5cbiAgICAgIGxldCB0MCwgdDEsIHQyLCB0MztcbiAgICAgIGxldCBzMCwgczEsIHMyLCBzMztcbiAgICAgIGxldCBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcblxuICAgICAgbGV0IGtzUm93LCBpO1xuICAgICAgbGV0IHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuXG4gICAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgICAgaW5wdXRXb3JkczAgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldF0pO1xuICAgICAgICBpbnB1dFdvcmRzMSA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMV0pO1xuICAgICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgICBpbnB1dFdvcmRzMyA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgM10pO1xuXG4gICAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgICBzMiA9IGlucHV0V29yZHMyIF4gaW52S2V5U2NoZWR1bGVbMl07XG4gICAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcblxuICAgICAgICBrc1JvdyA9IDQ7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgICAgdDAgPSBpbnZTdWJNaXgwW3MwID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMSA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMyID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgICAgdDEgPSBpbnZTdWJNaXgwW3MxID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMiA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMzID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICAgIHQyID0gaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczMgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMCA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgICB0MyA9IGludlN1Yk1peDBbczMgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMwID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczEgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICAgICAgczAgPSB0MDtcbiAgICAgICAgICBzMSA9IHQxO1xuICAgICAgICAgIHMyID0gdDI7XG4gICAgICAgICAgczMgPSB0MztcblxuICAgICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICAgIHQwID0gKChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMyAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgdDEgPSAoKGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczIgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMzID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MwICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSAoKGludlNCT1hbczIgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczMgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMwID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MxICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSAoKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MyICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAga3NSb3cgPSBrc1JvdyArIDM7XG5cbiAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAxXSA9IHN3YXBXb3JkKHQzIF4gaW5pdFZlY3RvcjEpO1xuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxuICAgICAgICBpbml0VmVjdG9yMCA9IGlucHV0V29yZHMwO1xuICAgICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xuICAgICAgICBpbml0VmVjdG9yMyA9IGlucHV0V29yZHMzO1xuXG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmVQS0NTN1BhZGRpbmcgPyByZW1vdmVQYWRkaW5nKG91dHB1dEludDMyLmJ1ZmZlcikgOiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gICAgfSxcblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMua2V5U2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMua3NSb3dzID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnNCb3ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmludlNCb3ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnN1Yk1peCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW52U3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5rZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW52S2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMucmNvbiA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICB9XG59XG5cbiIsImltcG9ydCBpbml0Q2FjaGUgZnJvbSAnIy9jb21tb24vY2FjaGUnO1xuaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuL21lc3NhZ2UnO1xuXG5jb25zdCBjYWNoZSA9IGluaXRDYWNoZSh7XG4gIC8qIEtlZXBpbmcgdGhlIGRhdGEgZm9yIG9uZSBob3VyIHNpbmNlIGNocm9tZS5zdG9yYWdlLmxvY2FsIGlzIGluc2FuZWx5IHNsb3cgaW4gQ2hyb21lLFxuICAgICBpdCBjYW4gdGFrZXMgc2Vjb25kcyB0byByZWFkIGl0IHdoZW4gaW5qZWN0aW5nIHRhYnMgd2l0aCBhIGJpZyBzY3JpcHQvdmFsdWUsIHdoaWNoIGRlbGF5c1xuICAgICBhbGwgb3RoZXIgc2NyaXB0cyBpbiB0aGlzIHRhYiBhbmQgdGhleSB3aWxsIG5ldmVyIGJlIGFibGUgdG8gcnVuIGF0IGRvY3VtZW50LXN0YXJ0LiAqL1xuICBsaWZldGltZTogNjAgKiA2MCAqIDEwMDAsXG59KTtcblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICBDYWNoZUxvYWQoZGF0YSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQoZGF0YSkgfHwgbnVsbDtcbiAgfSxcbiAgQ2FjaGVIaXQoZGF0YSkge1xuICAgIGNhY2hlLmhpdChkYXRhLmtleSwgZGF0YS5saWZldGltZSk7XG4gIH0sXG4gIENhY2hlUG9wKGtleSkge1xuICAgIHJldHVybiBjYWNoZS5wb3Aoa2V5KSB8fCBudWxsO1xuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNhY2hlO1xuIiwiaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuL21lc3NhZ2UnO1xuXG5jb25zdCB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5sZXQgY2xpcGJvYXJkRGF0YTtcblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICBTZXRDbGlwYm9hcmQoZGF0YSkge1xuICAgIGNsaXBib2FyZERhdGEgPSBkYXRhO1xuICAgIHRleHRhcmVhLmZvY3VzKCk7XG4gICAgY29uc3QgcmV0ID0gZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknLCBmYWxzZSwgbnVsbCk7XG4gICAgaWYgKCFyZXQgJiYgcHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ29weSBmYWlsZWQhJyk7XG4gICAgfVxuICB9LFxufSk7XG5cbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dGFyZWEpO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb3B5JywgZSA9PiB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBjbGlwYm9hcmREYXRhO1xuICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSh0eXBlIHx8ICd0ZXh0L3BsYWluJywgZGF0YSk7XG59KTtcbiIsImltcG9ydCB7XG4gIGNvbXBhcmVWZXJzaW9uLCBpMThuLCBnZXRGdWxsVXJsLCBnZXRTY3JpcHROYW1lLCBpc1JlbW90ZSwgc2VuZENtZCwgdHJ1ZUpvaW4sXG59IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7XG4gIENNRF9TQ1JJUFRfQURELCBDTURfU0NSSVBUX1VQREFURSwgSU5KRUNUX1BBR0UsIElOSkVDVF9BVVRPLCBUSU1FT1VUX1dFRUssXG59IGZyb20gJyMvY29tbW9uL2NvbnN0cyc7XG5pbXBvcnQgeyBmb3JFYWNoRW50cnksIGZvckVhY2hLZXksIGZvckVhY2hWYWx1ZSB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgc3RvcmFnZSBmcm9tICcjL2NvbW1vbi9zdG9yYWdlJztcbmltcG9ydCBwbHVnaW5FdmVudHMgZnJvbSAnLi4vcGx1Z2luL2V2ZW50cyc7XG5pbXBvcnQgeyBnZXROYW1lVVJJLCBwYXJzZU1ldGEsIG5ld1NjcmlwdCwgZ2V0RGVmYXVsdEN1c3RvbSB9IGZyb20gJy4vc2NyaXB0JztcbmltcG9ydCB7IHRlc3RTY3JpcHQsIHRlc3RCbGFja2xpc3QgfSBmcm9tICcuL3Rlc3Rlcic7XG5pbXBvcnQgeyBwcmVJbml0aWFsaXplIH0gZnJvbSAnLi9pbml0JztcbmltcG9ydCB7IGNvbW1hbmRzLCBub3RpZnkgfSBmcm9tICcuL21lc3NhZ2UnO1xuaW1wb3J0IHBhdGNoREIgZnJvbSAnLi9wYXRjaC1kYic7XG5pbXBvcnQgeyBzZXRPcHRpb24gfSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0ICcuL3N0b3JhZ2UtZmV0Y2gnO1xuaW1wb3J0IGRhdGFDYWNoZSBmcm9tICcuL2NhY2hlJztcblxuY29uc3Qgc3RvcmUgPSB7fTtcbnN0b3JhZ2UuYmFzZS5zZXREYXRhQ2FjaGUoZGF0YUNhY2hlKTtcbnN0b3JhZ2Uuc2NyaXB0Lm9uRHVtcCA9IChpdGVtKSA9PiB7XG4gIHN0b3JlLnNjcmlwdE1hcFtpdGVtLnByb3BzLmlkXSA9IGl0ZW07XG59O1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIENoZWNrUG9zaXRpb246IHNvcnRTY3JpcHRzLFxuICBDaGVja1JlbW92ZTogY2hlY2tSZW1vdmUsXG4gIC8qKiBAcmV0dXJuIHtWTVNjcmlwdH0gKi9cbiAgR2V0U2NyaXB0OiBnZXRTY3JpcHQsXG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPHsgaXRlbXM6IFZNU2NyaXB0W10sIHZhbHVlcz8gfT59ICovXG4gIGFzeW5jIEV4cG9ydFppcCh7IHZhbHVlcyB9KSB7XG4gICAgY29uc3Qgc2NyaXB0cyA9IGdldFNjcmlwdHMoKTtcbiAgICBjb25zdCBpZHMgPSBzY3JpcHRzLm1hcChnZXRQcm9wc0lkKTtcbiAgICBjb25zdCBjb2RlTWFwID0gYXdhaXQgc3RvcmFnZS5jb2RlLmdldE11bHRpKGlkcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1zOiBzY3JpcHRzLm1hcChzY3JpcHQgPT4gKHsgc2NyaXB0LCBjb2RlOiBjb2RlTWFwW3NjcmlwdC5wcm9wcy5pZF0gfSkpLFxuICAgICAgdmFsdWVzOiB2YWx1ZXMgPyBhd2FpdCBzdG9yYWdlLnZhbHVlLmdldE11bHRpKGlkcykgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn0gKi9cbiAgR2V0U2NyaXB0Q29kZShpZCkge1xuICAgIHJldHVybiBzdG9yYWdlLmNvZGUuZ2V0T25lKGlkKTtcbiAgfSxcbiAgR2V0U2NyaXB0VmVyKG9wdHMpIHtcbiAgICBjb25zdCBzY3JpcHQgPSBnZXRTY3JpcHQob3B0cyk7XG4gICAgcmV0dXJuIHNjcmlwdCAmJiAhc2NyaXB0LmNvbmZpZy5yZW1vdmVkXG4gICAgICA/IHNjcmlwdC5tZXRhLnZlcnNpb25cbiAgICAgIDogbnVsbDtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59ICovXG4gIE1hcmtSZW1vdmVkKHsgaWQsIHJlbW92ZWQgfSkge1xuICAgIHJldHVybiB1cGRhdGVTY3JpcHRJbmZvKGlkLCB7XG4gICAgICBjb25maWc6IHsgcmVtb3ZlZDogcmVtb3ZlZCA/IDEgOiAwIH0sXG4gICAgICBwcm9wczogeyBsYXN0TW9kaWZpZWQ6IERhdGUubm93KCkgfSxcbiAgICB9KTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gKi9cbiAgTW92ZSh7IGlkLCBvZmZzZXQgfSkge1xuICAgIGNvbnN0IHNjcmlwdCA9IGdldFNjcmlwdEJ5SWQoaWQpO1xuICAgIGNvbnN0IGluZGV4ID0gc3RvcmUuc2NyaXB0cy5pbmRleE9mKHNjcmlwdCk7XG4gICAgc3RvcmUuc2NyaXB0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHN0b3JlLnNjcmlwdHMuc3BsaWNlKGluZGV4ICsgb2Zmc2V0LCAwLCBzY3JpcHQpO1xuICAgIHJldHVybiBub3JtYWxpemVQb3NpdGlvbigpO1xuICB9LFxuICAvKiogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gKi9cbiAgYXN5bmMgUmVtb3ZlU2NyaXB0KGlkKSB7XG4gICAgY29uc3QgaSA9IHN0b3JlLnNjcmlwdHMuaW5kZXhPZihnZXRTY3JpcHRCeUlkKGlkKSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgc3RvcmUuc2NyaXB0cy5zcGxpY2UoaSwgMSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHN0b3JhZ2Uuc2NyaXB0LnJlbW92ZShpZCksXG4gICAgICAgIHN0b3JhZ2UuY29kZS5yZW1vdmUoaWQpLFxuICAgICAgICBzdG9yYWdlLnZhbHVlLnJlbW92ZShpZCksXG4gICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbmRDbWQoJ1JlbW92ZVNjcmlwdCcsIGlkKTtcbiAgfSxcbiAgUGFyc2VNZXRhOiBwYXJzZU1ldGEsXG4gIFBhcnNlU2NyaXB0OiBwYXJzZVNjcmlwdCxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59ICovXG4gIFVwZGF0ZVNjcmlwdEluZm8oeyBpZCwgY29uZmlnLCBjdXN0b20gfSkge1xuICAgIHJldHVybiB1cGRhdGVTY3JpcHRJbmZvKGlkLCB7XG4gICAgICBjb25maWcsXG4gICAgICBjdXN0b20sXG4gICAgICBwcm9wczogeyBsYXN0TW9kaWZpZWQ6IERhdGUubm93KCkgfSxcbiAgICB9KTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gKi9cbiAgVmFjdXVtOiB2YWN1dW0sXG59KTtcblxucHJlSW5pdGlhbGl6ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyB2ZXJzaW9uOiBsYXN0VmVyc2lvbiB9ID0gYXdhaXQgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmdldCgndmVyc2lvbicpO1xuICBjb25zdCB2ZXJzaW9uID0gcHJvY2Vzcy5lbnYuVk1fVkVSO1xuICBpZiAoIWxhc3RWZXJzaW9uKSBhd2FpdCBwYXRjaERCKCk7XG4gIGlmICh2ZXJzaW9uICE9PSBsYXN0VmVyc2lvbikgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldCh7IHZlcnNpb24gfSk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBicm93c2VyLnN0b3JhZ2UubG9jYWwuZ2V0KCk7XG4gIGNvbnN0IHNjcmlwdHMgPSBbXTtcbiAgY29uc3Qgc3RvcmVJbmZvID0ge1xuICAgIGlkOiAwLFxuICAgIHBvc2l0aW9uOiAwLFxuICB9O1xuICBjb25zdCBpZE1hcCA9IHt9O1xuICBjb25zdCB1cmlNYXAgPSB7fTtcbiAgY29uc3QgbW9kcyA9IFtdO1xuICBjb25zdCByZXNVcmxzID0gW107XG4gIC8qKiBAdGhpcyBWTVNjcmlwdEN1c3RvbS5wYXRoTWFwICovXG4gIGNvbnN0IHJlbWVtYmVyVXJsID0gZnVuY3Rpb24gXyh1cmwpIHsgcmVzVXJscy5wdXNoKHRoaXNbdXJsXSB8fCB1cmwpOyB9O1xuICBkYXRhOjpmb3JFYWNoRW50cnkoKFtrZXksIHNjcmlwdF0pID0+IHtcbiAgICBkYXRhQ2FjaGUucHV0KGtleSwgc2NyaXB0KTtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoc3RvcmFnZS5zY3JpcHQucHJlZml4KSkge1xuICAgICAgLy8ge1xuICAgICAgLy8gICBtZXRhLFxuICAgICAgLy8gICBjdXN0b20sXG4gICAgICAvLyAgIHByb3BzOiB7IGlkLCBwb3NpdGlvbiwgdXJpIH0sXG4gICAgICAvLyAgIGNvbmZpZzogeyBlbmFibGVkLCBzaG91bGRVcGRhdGUgfSxcbiAgICAgIC8vIH1cbiAgICAgIGNvbnN0IGlkID0gZ2V0SW50KGtleS5zbGljZShzdG9yYWdlLnNjcmlwdC5wcmVmaXgubGVuZ3RoKSk7XG4gICAgICBpZiAoIWlkIHx8IGlkTWFwW2lkXSkge1xuICAgICAgICAvLyBJRCBjb25mbGljdHMhXG4gICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuLCBkaXNjYXJkIGR1cGxpY2F0ZXMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlkTWFwW2lkXSA9IHNjcmlwdDtcbiAgICAgIGNvbnN0IHVyaSA9IGdldE5hbWVVUkkoc2NyaXB0KTtcbiAgICAgIGlmICh1cmlNYXBbdXJpXSkge1xuICAgICAgICAvLyBOYW1lc3BhY2UgY29uZmxpY3RzIVxuICAgICAgICAvLyBTaG91bGQgbm90IGhhcHBlbiwgZGlzY2FyZCBkdXBsaWNhdGVzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1cmlNYXBbdXJpXSA9IHNjcmlwdDtcbiAgICAgIHNjcmlwdC5wcm9wcyA9IHtcbiAgICAgICAgLi4uc2NyaXB0LnByb3BzLFxuICAgICAgICBpZCxcbiAgICAgICAgdXJpLFxuICAgICAgfTtcbiAgICAgIHNjcmlwdC5jdXN0b20gPSB7XG4gICAgICAgIC4uLmdldERlZmF1bHRDdXN0b20oKSxcbiAgICAgICAgLi4uc2NyaXB0LmN1c3RvbSxcbiAgICAgIH07XG4gICAgICBzdG9yZUluZm8uaWQgPSBNYXRoLm1heChzdG9yZUluZm8uaWQsIGlkKTtcbiAgICAgIHN0b3JlSW5mby5wb3NpdGlvbiA9IE1hdGgubWF4KHN0b3JlSW5mby5wb3NpdGlvbiwgZ2V0SW50KHNjcmlwdC5wcm9wcy5wb3NpdGlvbikpO1xuICAgICAgc2NyaXB0cy5wdXNoKHNjcmlwdCk7XG4gICAgICAvLyBsaXN0aW5nIGFsbCBrbm93biByZXNvdXJjZSB1cmxzIGluIG9yZGVyIHRvIHJlbW92ZSB1bnVzZWQgbW9kIGtleXNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VzdG9tOiB7IHBhdGhNYXAgPSB7fSB9ID0ge30sXG4gICAgICAgIG1ldGEgPSBzY3JpcHQubWV0YSA9IHt9LFxuICAgICAgfSA9IHNjcmlwdDtcbiAgICAgIG1ldGEuZ3JhbnQgPSBbLi4ubmV3IFNldChtZXRhLmdyYW50IHx8IFtdKV07IC8vIGRlZHVwbGljYXRlXG4gICAgICBtZXRhLnJlcXVpcmU/LmZvckVhY2gocmVtZW1iZXJVcmwsIHBhdGhNYXApO1xuICAgICAgT2JqZWN0LnZhbHVlcyhtZXRhLnJlc291cmNlcyB8fCB7fSkuZm9yRWFjaChyZW1lbWJlclVybCwgcGF0aE1hcCk7XG4gICAgICBwYXRoTWFwOjpyZW1lbWJlclVybChtZXRhLmljb24pO1xuICAgIH0gZWxzZSBpZiAoa2V5LnN0YXJ0c1dpdGgoc3RvcmFnZS5tb2QucHJlZml4KSkge1xuICAgICAgbW9kcy5wdXNoKGtleS5zbGljZShzdG9yYWdlLm1vZC5wcmVmaXgubGVuZ3RoKSk7XG4gICAgfVxuICB9KTtcbiAgc3RvcmFnZS5tb2QucmVtb3ZlTXVsdGkobW9kcy5maWx0ZXIodXJsID0+ICFyZXNVcmxzLmluY2x1ZGVzKHVybCkpKTtcbiAgT2JqZWN0LmFzc2lnbihzdG9yZSwge1xuICAgIHNjcmlwdHMsXG4gICAgc3RvcmVJbmZvLFxuICAgIHNjcmlwdE1hcDogc2NyaXB0cy5yZWR1Y2UoKG1hcCwgaXRlbSkgPT4ge1xuICAgICAgbWFwW2l0ZW0ucHJvcHMuaWRdID0gaXRlbTtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pLFxuICB9KTtcbiAgLy8gU3dpdGNoIGRlZmF1bHRJbmplY3RJbnRvIGZyb20gYHBhZ2VgIHRvIGBhdXRvYCB3aGVuIHVwZ3JhZGluZyBWTTIuMTIuNyBvciBvbGRlclxuICBpZiAodmVyc2lvbiAhPT0gbGFzdFZlcnNpb25cbiAgJiYgSVNfRklSRUZPWFxuICAmJiBkYXRhLm9wdGlvbnM/LmRlZmF1bHRJbmplY3RJbnRvID09PSBJTkpFQ1RfUEFHRVxuICAmJiBjb21wYXJlVmVyc2lvbihsYXN0VmVyc2lvbiwgJzIuMTIuNycpIDw9IDApIHtcbiAgICBzZXRPcHRpb24oJ2RlZmF1bHRJbmplY3RJbnRvJywgSU5KRUNUX0FVVE8pO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGNvbnNvbGUubG9nKCdzdG9yZTonLCBzdG9yZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICB9XG4gIHZhY3V1bShkYXRhKTtcbiAgcmV0dXJuIHNvcnRTY3JpcHRzKCk7XG59KTtcblxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbmZ1bmN0aW9uIGdldEludCh2YWwpIHtcbiAgcmV0dXJuICt2YWwgfHwgMDtcbn1cblxuLyoqIEByZXR1cm4gez9udW1iZXJ9ICovXG5mdW5jdGlvbiBnZXRQcm9wc0lkKHNjcmlwdCkge1xuICByZXR1cm4gc2NyaXB0Py5wcm9wcy5pZDtcbn1cblxuLyoqIEByZXR1cm4ge3ZvaWR9ICovXG5mdW5jdGlvbiB1cGRhdGVMYXN0TW9kaWZpZWQoKSB7XG4gIHNldE9wdGlvbignbGFzdE1vZGlmaWVkJywgRGF0ZS5ub3coKSk7XG59XG5cbi8qKiBAcmV0dXJuIHtQcm9taXNlPG51bWJlcj59ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24oKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBzdG9yZS5zY3JpcHRzLmZpbHRlcigoeyBwcm9wcyB9LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggKyAxO1xuICAgIGNvbnN0IHJlcyA9IHByb3BzLnBvc2l0aW9uICE9PSBwb3NpdGlvbjtcbiAgICBpZiAocmVzKSBwcm9wcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHJldHVybiByZXM7XG4gIH0pO1xuICBzdG9yZS5zdG9yZUluZm8ucG9zaXRpb24gPSBzdG9yZS5zY3JpcHRzLmxlbmd0aDtcbiAgaWYgKHVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgYXdhaXQgc3RvcmFnZS5zY3JpcHQuZHVtcCh1cGRhdGVzKTtcbiAgICB1cGRhdGVMYXN0TW9kaWZpZWQoKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlcy5sZW5ndGg7XG59XG5cbi8qKiBAcmV0dXJuIHtQcm9taXNlPG51bWJlcj59ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc29ydFNjcmlwdHMoKSB7XG4gIHN0b3JlLnNjcmlwdHMuc29ydCgoYSwgYikgPT4gZ2V0SW50KGEucHJvcHMucG9zaXRpb24pIC0gZ2V0SW50KGIucHJvcHMucG9zaXRpb24pKTtcbiAgY29uc3QgY2hhbmdlZCA9IGF3YWl0IG5vcm1hbGl6ZVBvc2l0aW9uKCk7XG4gIHNlbmRDbWQoJ1NjcmlwdHNVcGRhdGVkJywgbnVsbCk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuXG4vKiogQHJldHVybiB7P1ZNU2NyaXB0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcmlwdEJ5SWQoaWQpIHtcbiAgcmV0dXJuIHN0b3JlLnNjcmlwdE1hcFtpZF07XG59XG5cbi8qKiBAcmV0dXJuIHs/Vk1TY3JpcHR9ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NyaXB0KHsgaWQsIHVyaSwgbWV0YSB9KSB7XG4gIGxldCBzY3JpcHQ7XG4gIGlmIChpZCkge1xuICAgIHNjcmlwdCA9IGdldFNjcmlwdEJ5SWQoaWQpO1xuICB9IGVsc2Uge1xuICAgIGlmICghdXJpKSB1cmkgPSBnZXROYW1lVVJJKHsgbWV0YSwgaWQ6ICdAQHNob3VsZC1oYXZlLW5hbWUnIH0pO1xuICAgIHNjcmlwdCA9IHN0b3JlLnNjcmlwdHMuZmluZCgoeyBwcm9wcyB9KSA9PiB1cmkgPT09IHByb3BzLnVyaSk7XG4gIH1cbiAgcmV0dXJuIHNjcmlwdDtcbn1cblxuLyoqIEByZXR1cm4ge1ZNU2NyaXB0W119ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NyaXB0cygpIHtcbiAgcmV0dXJuIHN0b3JlLnNjcmlwdHMuZmlsdGVyKHNjcmlwdCA9PiAhc2NyaXB0LmNvbmZpZy5yZW1vdmVkKTtcbn1cblxuLyoqXG4gKiBAZGVzYyBMb2FkIHZhbHVlcyBmb3IgYmF0Y2ggdXBkYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGlkc1xuICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVTdG9yZXNCeUlkcyhpZHMpIHtcbiAgcmV0dXJuIHN0b3JhZ2UudmFsdWUuZ2V0TXVsdGkoaWRzKTtcbn1cblxuLyoqXG4gKiBAZGVzYyBEdW1wIHZhbHVlcyBmb3IgYmF0Y2ggdXBkYXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZURpY3QgeyBpZDE6IHZhbHVlMSwgaWQyOiB2YWx1ZTIsIC4uLiB9XG4gKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkdW1wVmFsdWVTdG9yZXModmFsdWVEaWN0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5ERUJVRykgY29uc29sZS5pbmZvKCdVcGRhdGUgdmFsdWUgc3RvcmVzJywgdmFsdWVEaWN0KTtcbiAgYXdhaXQgc3RvcmFnZS52YWx1ZS5kdW1wKHZhbHVlRGljdCk7XG4gIHJldHVybiB2YWx1ZURpY3Q7XG59XG5cbmV4cG9ydCBjb25zdCBFTlZfQ0FDSEVfS0VZUyA9ICdjYWNoZUtleXMnO1xuZXhwb3J0IGNvbnN0IEVOVl9SRVFfS0VZUyA9ICdyZXFLZXlzJztcbmV4cG9ydCBjb25zdCBFTlZfVkFMVUVfSURTID0gJ3ZhbHVlSWRzJztcbmNvbnN0IEdNVkFMVUVTX1JFID0gL15HTVtfLl0obGlzdFZhbHVlc3woW2dzXWV0fGRlbGV0ZSlWYWx1ZSkkLztcbmNvbnN0IFJVTl9BVF9SRSA9IC9eZG9jdW1lbnQtKHN0YXJ0fGJvZHl8ZW5kfGlkbGUpJC87XG4vKipcbiAqIEBkZXNjIEdldCBzY3JpcHRzIHRvIGJlIGluamVjdGVkIHRvIHBhZ2Ugd2l0aCBzcGVjaWZpYyBVUkwuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTY3JpcHRzQnlVUkwodXJsLCBpc1RvcCkge1xuICBjb25zdCBhbGxTY3JpcHRzID0gdGVzdEJsYWNrbGlzdCh1cmwpXG4gICAgPyBbXVxuICAgIDogc3RvcmUuc2NyaXB0cy5maWx0ZXIoc2NyaXB0ID0+IChcbiAgICAgICFzY3JpcHQuY29uZmlnLnJlbW92ZWRcbiAgICAgICYmIChpc1RvcCB8fCAhKHNjcmlwdC5jdXN0b20ubm9mcmFtZXMgPz8gc2NyaXB0Lm1ldGEubm9mcmFtZXMpKVxuICAgICAgJiYgdGVzdFNjcmlwdCh1cmwsIHNjcmlwdClcbiAgICApKTtcbiAgY29uc3QgZGlzYWJsZWRJZHMgPSBbXTtcbiAgLyoqIEBuYW1lc3BhY2UgVk1TY3JpcHRCeVVybERhdGEgKi9cbiAgY29uc3QgW2VudlN0YXJ0LCBlbnZEZWxheWVkXSA9IFswLCAxXS5tYXAoKCkgPT4gKHtcbiAgICBpZHM6IFtdLFxuICAgIC8qKiBAdHlwZSB7KFZNU2NyaXB0ICYgVk1JbmplY3RlZFNjcmlwdClbXX0gKi9cbiAgICBzY3JpcHRzOiBbXSxcbiAgICBbRU5WX0NBQ0hFX0tFWVNdOiBbXSxcbiAgICBbRU5WX1JFUV9LRVlTXTogW10sXG4gICAgW0VOVl9WQUxVRV9JRFNdOiBbXSxcbiAgfSkpO1xuICBhbGxTY3JpcHRzLmZvckVhY2goKHNjcmlwdCkgPT4ge1xuICAgIGNvbnN0IHsgaWQgfSA9IHNjcmlwdC5wcm9wcztcbiAgICBpZiAoIXNjcmlwdC5jb25maWcuZW5hYmxlZCkge1xuICAgICAgZGlzYWJsZWRJZHMucHVzaChpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgbWV0YSwgY3VzdG9tIH0gPSBzY3JpcHQ7XG4gICAgY29uc3QgeyBwYXRoTWFwID0gYnVpbGRQYXRoTWFwKHNjcmlwdCkgfSA9IGN1c3RvbTtcbiAgICBjb25zdCBydW5BdCA9IGAke2N1c3RvbS5ydW5BdCB8fCBtZXRhLnJ1bkF0IHx8ICcnfWAubWF0Y2goUlVOX0FUX1JFKT8uWzFdIHx8ICdlbmQnO1xuICAgIGNvbnN0IGVudiA9IHJ1bkF0ID09PSAnc3RhcnQnIHx8IHJ1bkF0ID09PSAnYm9keScgPyBlbnZTdGFydCA6IGVudkRlbGF5ZWQ7XG4gICAgZW52Lmlkcy5wdXNoKGlkKTtcbiAgICBpZiAobWV0YS5ncmFudC5zb21lKEdNVkFMVUVTX1JFLnRlc3QsIEdNVkFMVUVTX1JFKSkge1xuICAgICAgZW52W0VOVl9WQUxVRV9JRFNdLnB1c2goaWQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtsaXN0LCBuYW1lXSBvZiBbXG4gICAgICBbbWV0YS5yZXF1aXJlLCBFTlZfUkVRX0tFWVNdLFxuICAgICAgW09iamVjdC52YWx1ZXMobWV0YS5yZXNvdXJjZXMpLCBFTlZfQ0FDSEVfS0VZU10sXG4gICAgXSkge1xuICAgICAgbGlzdC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGtleSA9IHBhdGhNYXBba2V5XSB8fCBrZXk7XG4gICAgICAgIGlmICghZW52U3RhcnRbbmFtZV0uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGVudltuYW1lXS5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQG5hbWVzcGFjZSBWTUluamVjdGVkU2NyaXB0ICovXG4gICAgZW52LnNjcmlwdHMucHVzaCh7IC4uLnNjcmlwdCwgcnVuQXQgfSk7XG4gIH0pO1xuICBpZiAoZW52RGVsYXllZC5pZHMubGVuZ3RoKSB7XG4gICAgZW52RGVsYXllZC5wcm9taXNlID0gcmVhZEVudmlyb25tZW50RGF0YShlbnZEZWxheWVkKTtcbiAgfVxuICAvKiogQG5hbWVzcGFjZSBWTVNjcmlwdEJ5VXJsRGF0YSAqL1xuICByZXR1cm4ge1xuICAgIC4uLmVudlN0YXJ0LFxuICAgIC4uLmF3YWl0IHJlYWRFbnZpcm9ubWVudERhdGEoZW52U3RhcnQpLFxuICAgIGRpc2FibGVkSWRzLFxuICAgIGVudkRlbGF5ZWQsXG4gIH07XG59XG5cbi8qKlxuICogT2JqZWN0IGtleXMgPT0gYXJlYXMgaW4gYHN0b3JhZ2VgIG1vZHVsZS5cbiAqIEBuYW1lc3BhY2UgVk1TY3JpcHRCeVVybERhdGFcbiAqL1xuY29uc3QgU1RPUkFHRV9ST1VURVMgPSBPYmplY3QuZW50cmllcyh7XG4gIGNhY2hlOiBFTlZfQ0FDSEVfS0VZUyxcbiAgY29kZTogJ2lkcycsXG4gIHJlcXVpcmU6IEVOVl9SRVFfS0VZUyxcbiAgdmFsdWU6IEVOVl9WQUxVRV9JRFMsXG59KTtcbmNvbnN0IHJldHJpZWRTdG9yYWdlS2V5cyA9IHt9O1xuXG5hc3luYyBmdW5jdGlvbiByZWFkRW52aXJvbm1lbnREYXRhKGVudiwgaXNSZXRyeSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIFNUT1JBR0VfUk9VVEVTLmZvckVhY2goKFthcmVhLCBzcmNJZHNdKSA9PiB7XG4gICAgZW52W3NyY0lkc10uZm9yRWFjaChpZCA9PiB7XG4gICAgICBrZXlzLnB1c2goc3RvcmFnZVthcmVhXS5nZXRLZXkoaWQpKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBzdG9yYWdlLmJhc2UuZ2V0TXVsdGkoa2V5cyk7XG4gIGZvciAoY29uc3QgW2FyZWEsIHNyY0lkc10gb2YgU1RPUkFHRV9ST1VURVMpIHtcbiAgICBlbnZbYXJlYV0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGVudltzcmNJZHNdKSB7XG4gICAgICBjb25zdCB2YWwgPSBkYXRhW3N0b3JhZ2VbYXJlYV0uZ2V0S2V5KGlkKV07XG4gICAgICBlbnZbYXJlYV1baWRdID0gdmFsO1xuICAgICAgaWYgKHZhbCA9PSBudWxsICYmIGFyZWEgIT09ICd2YWx1ZScgJiYgcmV0cmllZFN0b3JhZ2VLZXlzW2FyZWEgKyBpZF0gIT09IDIpIHtcbiAgICAgICAgY29uc3QgZXJyID0gYFRoZSBcIiR7YXJlYX1cIiBzdG9yYWdlIGlzIG1pc3NpbmcgXCIke2lkfVwiIWA7XG4gICAgICAgIGNvbnN0IGVycjIgPSAnVmFjdXVtaW5nIGRpZCBub3QgaGVscC4gUGxlYXNlIHJlaW5zdGFsbCB0aGUgYWZmZWN0ZWQgc2NyaXB0cy4nO1xuICAgICAgICByZXRyaWVkU3RvcmFnZUtleXNbYXJlYSArIGlkXSA9IGlzUmV0cnkgPyAyIDogMTtcbiAgICAgICAgaWYgKCFpc1JldHJ5KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGVyciwgJ1ZhY3V1bWluZy4uLicpO1xuICAgICAgICAgIGlmIChhd2FpdCB2YWN1dW0oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRFbnZpcm9ubWVudERhdGEoZW52LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIsIGVycjIpO1xuICAgICAgICBub3RpZnkoeyB0aXRsZTogZXJyLCBib2R5OiBlcnIyIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZW52O1xufVxuXG4vKipcbiAqIEBkZXNjIEdldCBkYXRhIGZvciBkYXNoYm9hcmQuXG4gKiBAcmV0dXJuIHtQcm9taXNlPHsgc2NyaXB0czogVk1TY3JpcHRbXSwgY2FjaGU6IE9iamVjdCB9Pn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERhdGEoaWRzKSB7XG4gIGNvbnN0IHNjcmlwdHMgPSBpZHMgPyBpZHMubWFwKGdldFNjcmlwdEJ5SWQpIDogc3RvcmUuc2NyaXB0cztcbiAgcmV0dXJuIHtcbiAgICBzY3JpcHRzLFxuICAgIGNhY2hlOiBhd2FpdCBnZXRJY29uQ2FjaGUoc2NyaXB0cyksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEljb25DYWNoZShzY3JpcHRzKSB7XG4gIGNvbnN0IGljb25VcmxzID0gW107XG4gIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KSA9PiB7XG4gICAgY29uc3QgeyBpY29uIH0gPSBzY3JpcHQubWV0YTtcbiAgICBpZiAoaXNSZW1vdGUoaWNvbikpIHtcbiAgICAgIGljb25VcmxzLnB1c2goc2NyaXB0LmN1c3RvbS5wYXRoTWFwPy5baWNvbl0gfHwgaWNvbik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGljb25VcmxzLmxlbmd0aFxuICAgID8gc3RvcmFnZS5jYWNoZS5nZXRNdWx0aShpY29uVXJscywgdW5kZWZpbmVkLCBzdG9yYWdlLmNhY2hlLm1ha2VEYXRhVXJpKVxuICAgIDoge307XG59XG5cbi8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZW1vdmUoeyBmb3JjZSB9ID0ge30pIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgdG9SZW1vdmUgPSBzdG9yZS5zY3JpcHRzLmZpbHRlcihzY3JpcHQgPT4gc2NyaXB0LmNvbmZpZy5yZW1vdmVkICYmIChcbiAgICBmb3JjZSB8fCBub3cgLSBnZXRJbnQoc2NyaXB0LnByb3BzLmxhc3RNb2RpZmllZCkgPiBUSU1FT1VUX1dFRUtcbiAgKSk7XG4gIGlmICh0b1JlbW92ZS5sZW5ndGgpIHtcbiAgICBzdG9yZS5zY3JpcHRzID0gc3RvcmUuc2NyaXB0cy5maWx0ZXIoc2NyaXB0ID0+ICFzY3JpcHQuY29uZmlnLnJlbW92ZWQpO1xuICAgIGNvbnN0IGlkcyA9IHRvUmVtb3ZlLm1hcChnZXRQcm9wc0lkKTtcbiAgICBzdG9yYWdlLnNjcmlwdC5yZW1vdmVNdWx0aShpZHMpO1xuICAgIHN0b3JhZ2UuY29kZS5yZW1vdmVNdWx0aShpZHMpO1xuICAgIHN0b3JhZ2UudmFsdWUucmVtb3ZlTXVsdGkoaWRzKTtcbiAgfVxuICByZXR1cm4gdG9SZW1vdmUubGVuZ3RoO1xufVxuXG4vKiogQHJldHVybiB7c3RyaW5nfSAqL1xuZnVuY3Rpb24gZ2V0VVVJRCgpIHtcbiAgY29uc3Qgcm5kID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhybmQpO1xuICAvLyB4eHh4eHh4eC14eHh4LU14eHgtTnh4eC14eHh4eHh4eHh4eHhcbiAgLy8gV2UncmUgdXNpbmcgVVVJRHY0IHZhcmlhbnQgMSBzbyBOPTQgYW5kIE09OFxuICAvLyBTZWUgZm9ybWF0X3V1aWRfdjNvcjUgaW4gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHRcbiAgcm5kWzNdID0gcm5kWzNdICYgMHgwRkZGIHwgMHg0MDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcbiAgcm5kWzRdID0gcm5kWzRdICYgMHgzRkZGIHwgMHg4MDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcbiAgcmV0dXJuICcwMS0yLTMtNC01NjcnLnJlcGxhY2UoL1xcZC9nLCBpID0+IChybmRbaV0gKyAweDFfMDAwMCkudG9TdHJpbmcoMTYpLnNsaWNlKC00KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWTVNjcmlwdH0gc2NyaXB0XG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHJldHVybiB7UHJvbWlzZTxWTVNjcmlwdFtdPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2F2ZVNjcmlwdChzY3JpcHQsIGNvZGUpIHtcbiAgY29uc3QgY29uZmlnID0gc2NyaXB0LmNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLmVuYWJsZWQgPSBnZXRJbnQoY29uZmlnLmVuYWJsZWQpO1xuICBjb25maWcuc2hvdWxkVXBkYXRlID0gZ2V0SW50KGNvbmZpZy5zaG91bGRVcGRhdGUpO1xuICBjb25zdCBwcm9wcyA9IHNjcmlwdC5wcm9wcyB8fCB7fTtcbiAgbGV0IG9sZFNjcmlwdDtcbiAgaWYgKCFwcm9wcy5pZCkge1xuICAgIHN0b3JlLnN0b3JlSW5mby5pZCArPSAxO1xuICAgIHByb3BzLmlkID0gc3RvcmUuc3RvcmVJbmZvLmlkO1xuICB9IGVsc2Uge1xuICAgIG9sZFNjcmlwdCA9IHN0b3JlLnNjcmlwdE1hcFtwcm9wcy5pZF07XG4gIH1cbiAgcHJvcHMudXJpID0gZ2V0TmFtZVVSSShzY3JpcHQpO1xuICBwcm9wcy51dWlkID0gcHJvcHMudXVpZCB8fCBjcnlwdG8ucmFuZG9tVVVJRD8uKCkgfHwgZ2V0VVVJRCgpO1xuICAvLyBEbyBub3QgYWxsb3cgc2NyaXB0IHdpdGggc2FtZSBuYW1lIGFuZCBuYW1lc3BhY2VcbiAgaWYgKHN0b3JlLnNjcmlwdHMuc29tZSgoeyBwcm9wczogeyBpZCwgdXJpIH0gPSB7fSB9KSA9PiBwcm9wcy5pZCAhPT0gaWQgJiYgcHJvcHMudXJpID09PSB1cmkpKSB7XG4gICAgdGhyb3cgaTE4bignbXNnTmFtZXNwYWNlQ29uZmxpY3QnKTtcbiAgfVxuICBpZiAob2xkU2NyaXB0KSB7XG4gICAgc2NyaXB0LmNvbmZpZyA9IHsgLi4ub2xkU2NyaXB0LmNvbmZpZywgLi4uY29uZmlnIH07XG4gICAgc2NyaXB0LnByb3BzID0geyAuLi5vbGRTY3JpcHQucHJvcHMsIC4uLnByb3BzIH07XG4gICAgY29uc3QgaW5kZXggPSBzdG9yZS5zY3JpcHRzLmluZGV4T2Yob2xkU2NyaXB0KTtcbiAgICBzdG9yZS5zY3JpcHRzW2luZGV4XSA9IHNjcmlwdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXByb3BzLnBvc2l0aW9uKSB7XG4gICAgICBzdG9yZS5zdG9yZUluZm8ucG9zaXRpb24gKz0gMTtcbiAgICAgIHByb3BzLnBvc2l0aW9uID0gc3RvcmUuc3RvcmVJbmZvLnBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoc3RvcmUuc3RvcmVJbmZvLnBvc2l0aW9uIDwgcHJvcHMucG9zaXRpb24pIHtcbiAgICAgIHN0b3JlLnN0b3JlSW5mby5wb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uO1xuICAgIH1cbiAgICBzY3JpcHQuY29uZmlnID0gY29uZmlnO1xuICAgIHNjcmlwdC5wcm9wcyA9IHByb3BzO1xuICAgIHN0b3JlLnNjcmlwdHMucHVzaChzY3JpcHQpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgc3RvcmFnZS5zY3JpcHQuZHVtcChzY3JpcHQpLFxuICAgIHN0b3JhZ2UuY29kZS5zZXQocHJvcHMuaWQsIGNvZGUpLFxuICBdKTtcbn1cblxuLyoqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlU2NyaXB0SW5mbyhpZCwgZGF0YSkge1xuICBjb25zdCBzY3JpcHQgPSBzdG9yZS5zY3JpcHRNYXBbaWRdO1xuICBpZiAoIXNjcmlwdCkgdGhyb3cgbnVsbDtcbiAgc2NyaXB0LnByb3BzID0geyAuLi5zY3JpcHQucHJvcHMsIC4uLmRhdGEucHJvcHMgfTtcbiAgc2NyaXB0LmNvbmZpZyA9IHsgLi4uc2NyaXB0LmNvbmZpZywgLi4uZGF0YS5jb25maWcgfTtcbiAgc2NyaXB0LmN1c3RvbSA9IHsgLi4uc2NyaXB0LmN1c3RvbSwgLi4uZGF0YS5jdXN0b20gfTtcbiAgYXdhaXQgc3RvcmFnZS5zY3JpcHQuZHVtcChzY3JpcHQpO1xuICByZXR1cm4gc2VuZENtZChDTURfU0NSSVBUX1VQREFURSwgeyB3aGVyZTogeyBpZCB9LCB1cGRhdGU6IHNjcmlwdCB9KTtcbn1cblxuLyoqIEByZXR1cm4ge1Byb21pc2U8eyBpc05ldz8sIHVwZGF0ZSwgd2hlcmUgfT59ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VTY3JpcHQoc3JjKSB7XG4gIGNvbnN0IG1ldGEgPSBwYXJzZU1ldGEoc3JjLmNvZGUpO1xuICBpZiAoIW1ldGEubmFtZSkgdGhyb3cgYCR7aTE4bignbXNnSW52YWxpZFNjcmlwdCcpfVxcbiR7aTE4bignbGFiZWxOb05hbWUnKX1gO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgdXBkYXRlOiB7XG4gICAgICBtZXNzYWdlOiBzcmMubWVzc2FnZSA9PSBudWxsID8gaTE4bignbXNnVXBkYXRlZCcpIDogc3JjLm1lc3NhZ2UgfHwgJycsXG4gICAgfSxcbiAgfTtcbiAgbGV0IGNtZCA9IENNRF9TQ1JJUFRfVVBEQVRFO1xuICBsZXQgc2NyaXB0O1xuICBjb25zdCBvbGRTY3JpcHQgPSBhd2FpdCBnZXRTY3JpcHQoeyBpZDogc3JjLmlkLCBtZXRhIH0pO1xuICBpZiAob2xkU2NyaXB0KSB7XG4gICAgaWYgKHNyYy5pc05ldykgdGhyb3cgaTE4bignbXNnTmFtZXNwYWNlQ29uZmxpY3QnKTtcbiAgICBzY3JpcHQgPSB7IC4uLm9sZFNjcmlwdCB9O1xuICB9IGVsc2Uge1xuICAgICh7IHNjcmlwdCB9ID0gbmV3U2NyaXB0KCkpO1xuICAgIGNtZCA9IENNRF9TQ1JJUFRfQUREO1xuICAgIHJlc3VsdC5pc05ldyA9IHRydWU7XG4gICAgcmVzdWx0LnVwZGF0ZS5tZXNzYWdlID0gaTE4bignbXNnSW5zdGFsbGVkJyk7XG4gIH1cbiAgc2NyaXB0LmNvbmZpZyA9IHtcbiAgICAuLi5zY3JpcHQuY29uZmlnLFxuICAgIC4uLnNyYy5jb25maWcsXG4gICAgcmVtb3ZlZDogMCwgLy8gZm9yY2UgcmVzZXQgYHJlbW92ZWRgIHNpbmNlIHRoaXMgaXMgYW4gaW5zdGFsbGF0aW9uXG4gIH07XG4gIHNjcmlwdC5jdXN0b20gPSB7XG4gICAgLi4uc2NyaXB0LmN1c3RvbSxcbiAgICAuLi5zcmMuY3VzdG9tLFxuICB9O1xuICBzY3JpcHQucHJvcHMgPSB7XG4gICAgLi4uc2NyaXB0LnByb3BzLFxuICAgIGxhc3RNb2RpZmllZDogRGF0ZS5ub3coKSxcbiAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKSxcbiAgICAuLi5zcmMucHJvcHMsXG4gIH07XG4gIHNjcmlwdC5tZXRhID0gbWV0YTtcbiAgaWYgKCFtZXRhLmhvbWVwYWdlVVJMICYmICFzY3JpcHQuY3VzdG9tLmhvbWVwYWdlVVJMICYmIGlzUmVtb3RlKHNyYy5mcm9tKSkge1xuICAgIHNjcmlwdC5jdXN0b20uaG9tZXBhZ2VVUkwgPSBzcmMuZnJvbTtcbiAgfVxuICBpZiAoaXNSZW1vdGUoc3JjLnVybCkpIHNjcmlwdC5jdXN0b20ubGFzdEluc3RhbGxVUkwgPSBzcmMudXJsO1xuICBpZiAoc3JjLnBvc2l0aW9uKSBzY3JpcHQucHJvcHMucG9zaXRpb24gPSArc3JjLnBvc2l0aW9uO1xuICBidWlsZFBhdGhNYXAoc2NyaXB0LCBzcmMudXJsKTtcbiAgYXdhaXQgc2F2ZVNjcmlwdChzY3JpcHQsIHNyYy5jb2RlKTtcbiAgZmV0Y2hSZXNvdXJjZXMoc2NyaXB0LCBzcmMpO1xuICBPYmplY3QuYXNzaWduKHJlc3VsdC51cGRhdGUsIHNjcmlwdCwgc3JjLnVwZGF0ZSk7XG4gIHJlc3VsdC53aGVyZSA9IHsgaWQ6IHNjcmlwdC5wcm9wcy5pZCB9O1xuICBzZW5kQ21kKGNtZCwgcmVzdWx0KTtcbiAgcGx1Z2luRXZlbnRzLmVtaXQoJ3NjcmlwdENoYW5nZWQnLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybiB7T2JqZWN0fSAqL1xuZnVuY3Rpb24gYnVpbGRQYXRoTWFwKHNjcmlwdCwgYmFzZSkge1xuICBjb25zdCB7IG1ldGEgfSA9IHNjcmlwdDtcbiAgY29uc3QgYmFzZVVybCA9IGJhc2UgfHwgc2NyaXB0LmN1c3RvbS5sYXN0SW5zdGFsbFVSTDtcbiAgY29uc3QgcGF0aE1hcCA9IGJhc2VVcmwgPyBbXG4gICAgLi4ubWV0YS5yZXF1aXJlLFxuICAgIC4uLk9iamVjdC52YWx1ZXMobWV0YS5yZXNvdXJjZXMpLFxuICAgIG1ldGEuaWNvbixcbiAgXS5yZWR1Y2UoKG1hcCwga2V5KSA9PiB7XG4gICAgaWYgKGtleSkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGdldEZ1bGxVcmwoa2V5LCBiYXNlVXJsKTtcbiAgICAgIGlmIChmdWxsVXJsICE9PSBrZXkpIG1hcFtrZXldID0gZnVsbFVybDtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwge30pIDoge307XG4gIHNjcmlwdC5jdXN0b20ucGF0aE1hcCA9IHBhdGhNYXA7XG4gIHJldHVybiBwYXRoTWFwO1xufVxuXG4vKiogQHJldHVybiB7UHJvbWlzZTw/c3RyaW5nPn0gcmVzb2x2ZXMgdG8gZXJyb3IgdGV4dCBpZiBgcmVzb3VyY2VDYWNoZWAgaXMgYWJzZW50ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXNvdXJjZXMoc2NyaXB0LCByZXNvdXJjZUNhY2hlLCByZXFPcHRpb25zKSB7XG4gIGNvbnN0IHsgY3VzdG9tOiB7IHBhdGhNYXAgfSwgbWV0YSB9ID0gc2NyaXB0O1xuICBjb25zdCBzbmF0Y2ggPSAodXJsLCB0eXBlLCB2YWxpZGF0b3IpID0+IHtcbiAgICB1cmwgPSBwYXRoTWFwW3VybF0gfHwgdXJsO1xuICAgIGNvbnN0IGNvbnRlbnRzID0gcmVzb3VyY2VDYWNoZT8uW3R5cGVdPy5bdXJsXTtcbiAgICByZXR1cm4gY29udGVudHMgIT0gbnVsbCAmJiAhdmFsaWRhdG9yXG4gICAgICA/IHN0b3JhZ2VbdHlwZV0uc2V0KHVybCwgY29udGVudHMpICYmIG51bGxcbiAgICAgIDogc3RvcmFnZVt0eXBlXS5mZXRjaCh1cmwsIHJlcU9wdGlvbnMsIHZhbGlkYXRvcikuY2F0Y2goZXJyID0+IGVycik7XG4gIH07XG4gIGNvbnN0IGVycm9ycyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAuLi5tZXRhLnJlcXVpcmUubWFwKHVybCA9PiBzbmF0Y2godXJsLCAncmVxdWlyZScpKSxcbiAgICAuLi5PYmplY3QudmFsdWVzKG1ldGEucmVzb3VyY2VzKS5tYXAodXJsID0+IHNuYXRjaCh1cmwsICdjYWNoZScpKSxcbiAgICBpc1JlbW90ZShtZXRhLmljb24pICYmIHNuYXRjaChtZXRhLmljb24sICdjYWNoZScsIHZhbGlkYXRlSW1hZ2UpLFxuICBdKTtcbiAgaWYgKCFyZXNvdXJjZUNhY2hlPy5pZ25vcmVEZXBzRXJyb3JzKSB7XG4gICAgY29uc3QgZXJyb3IgPSBlcnJvcnMubWFwKGZvcm1hdEh0dHBFcnJvcik6OnRydWVKb2luKCdcXG4nKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpMThuKCdtc2dFcnJvckZldGNoaW5nUmVzb3VyY2UnKTtcbiAgICAgIHNlbmRDbWQoQ01EX1NDUklQVF9VUERBVEUsIHtcbiAgICAgICAgdXBkYXRlOiB7IGVycm9yLCBtZXNzYWdlIH0sXG4gICAgICAgIHdoZXJlOiB7IGlkOiBzY3JpcHQucHJvcHMuaWQgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGAke21lc3NhZ2V9XFxuJHtlcnJvcn1gO1xuICAgIH1cbiAgfVxufVxuXG4vKiogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gcmVzb2x2ZXMgb24gc3VjY2VzcywgcmVqZWN0cyBvbiBlcnJvciAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJbWFnZSh1cmwsIGJ1ZiwgdHlwZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtidWZdLCB7IHR5cGUgfSkpO1xuICAgIGNvbnN0IG9uRG9uZSA9IChlKSA9PiB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVcmwpO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ2xvYWQnKSByZXNvbHZlKCk7XG4gICAgICBlbHNlIHJlamVjdChgSU1BR0VfRVJST1I6ICR7dXJsfWApO1xuICAgIH07XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBvbkRvbmU7XG4gICAgaW1hZ2Uub25lcnJvciA9IG9uRG9uZTtcbiAgICBpbWFnZS5zcmMgPSBibG9iVXJsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SHR0cEVycm9yKGUpIHtcbiAgcmV0dXJuIGUgJiYgW2Uuc3RhdHVzICYmIGBIVFRQJHtlLnN0YXR1c31gLCBlLnVybF06OnRydWVKb2luKCcgJykgfHwgZTtcbn1cblxubGV0IF92YWN1dW1pbmc7XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV1cbiAqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhY3V1bShkYXRhKSB7XG4gIGlmIChfdmFjdXVtaW5nKSByZXR1cm4gX3ZhY3V1bWluZztcbiAgbGV0IG51bUZpeGVzID0gMDtcbiAgbGV0IHJlc29sdmVTZWxmO1xuICBfdmFjdXVtaW5nID0gbmV3IFByb21pc2UociA9PiB7IHJlc29sdmVTZWxmID0gcjsgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCB0b0ZldGNoID0gW107XG4gIGNvbnN0IGtleXNUb1JlbW92ZSA9IFtdO1xuICBjb25zdCB2YWx1ZUtleXMgPSB7fTtcbiAgY29uc3QgY2FjaGVLZXlzID0ge307XG4gIGNvbnN0IHJlcXVpcmVLZXlzID0ge307XG4gIGNvbnN0IGNvZGVLZXlzID0ge307XG4gIGNvbnN0IG1hcHBpbmdzID0gW1xuICAgIFtzdG9yYWdlLnZhbHVlLCB2YWx1ZUtleXNdLFxuICAgIFtzdG9yYWdlLmNhY2hlLCBjYWNoZUtleXNdLFxuICAgIFtzdG9yYWdlLnJlcXVpcmUsIHJlcXVpcmVLZXlzXSxcbiAgICBbc3RvcmFnZS5jb2RlLCBjb2RlS2V5c10sXG4gIF07XG4gIGlmICghZGF0YSkgZGF0YSA9IGF3YWl0IGJyb3dzZXIuc3RvcmFnZS5sb2NhbC5nZXQoKTtcbiAgZGF0YTo6Zm9yRWFjaEtleSgoa2V5KSA9PiB7XG4gICAgbWFwcGluZ3Muc29tZSgoW3N1YnN0b3JlLCBtYXBdKSA9PiB7XG4gICAgICBjb25zdCB7IHByZWZpeCB9ID0gc3Vic3RvcmU7XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAvLyAtMSBmb3IgdW50b3VjaGVkLCAxIGZvciB0b3VjaGVkLCAyIGZvciBtaXNzaW5nXG4gICAgICAgIG1hcFtrZXkuc2xpY2UocHJlZml4Lmxlbmd0aCldID0gLTE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgdG91Y2ggPSAob2JqLCBrZXksIHNjcmlwdElkKSA9PiB7XG4gICAgaWYgKG9ialtrZXldIDwgMCkge1xuICAgICAgb2JqW2tleV0gPSAxO1xuICAgIH0gZWxzZSBpZiAoIW9ialtrZXldKSB7XG4gICAgICBvYmpba2V5XSA9IDIgKyBzY3JpcHRJZDtcbiAgICB9XG4gIH07XG4gIHN0b3JlLnNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KSA9PiB7XG4gICAgY29uc3QgeyBpZCB9ID0gc2NyaXB0LnByb3BzO1xuICAgIHRvdWNoKGNvZGVLZXlzLCBpZCwgaWQpO1xuICAgIHRvdWNoKHZhbHVlS2V5cywgaWQsIGlkKTtcbiAgICBpZiAoIXNjcmlwdC5jdXN0b20ucGF0aE1hcCkgYnVpbGRQYXRoTWFwKHNjcmlwdCk7XG4gICAgY29uc3QgeyBwYXRoTWFwIH0gPSBzY3JpcHQuY3VzdG9tO1xuICAgIHNjcmlwdC5tZXRhLnJlcXVpcmUuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICB0b3VjaChyZXF1aXJlS2V5cywgcGF0aE1hcFt1cmxdIHx8IHVybCwgaWQpO1xuICAgIH0pO1xuICAgIHNjcmlwdC5tZXRhLnJlc291cmNlczo6Zm9yRWFjaFZhbHVlKCh1cmwpID0+IHtcbiAgICAgIHRvdWNoKGNhY2hlS2V5cywgcGF0aE1hcFt1cmxdIHx8IHVybCwgaWQpO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgaWNvbiB9ID0gc2NyaXB0Lm1ldGE7XG4gICAgaWYgKGlzUmVtb3RlKGljb24pKSB7XG4gICAgICBjb25zdCBmdWxsVXJsID0gcGF0aE1hcFtpY29uXSB8fCBpY29uO1xuICAgICAgdG91Y2goY2FjaGVLZXlzLCBmdWxsVXJsLCBpZCk7XG4gICAgfVxuICB9KTtcbiAgbWFwcGluZ3MuZm9yRWFjaCgoW3N1YnN0b3JlLCBtYXBdKSA9PiB7XG4gICAgbWFwOjpmb3JFYWNoRW50cnkoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAvLyByZWR1bmRhbnQgdmFsdWVcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goc3Vic3RvcmUuZ2V0S2V5KGtleSkpO1xuICAgICAgICBudW1GaXhlcyArPSAxO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+PSAyICYmIHN1YnN0b3JlLmZldGNoKSB7XG4gICAgICAgIC8vIG1pc3NpbmcgcmVzb3VyY2VcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goc3RvcmFnZS5tb2QuZ2V0S2V5KGtleSkpO1xuICAgICAgICB0b0ZldGNoLnB1c2goc3Vic3RvcmUuZmV0Y2goa2V5KS5jYXRjaChlcnIgPT4gYCR7XG4gICAgICAgICAgZ2V0U2NyaXB0TmFtZShnZXRTY3JpcHRCeUlkKHZhbHVlIC0gMikpXG4gICAgICAgIH06ICR7XG4gICAgICAgICAgZm9ybWF0SHR0cEVycm9yKGVycilcbiAgICAgICAgfWApKTtcbiAgICAgICAgbnVtRml4ZXMgKz0gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGlmIChudW1GaXhlcykge1xuICAgIGF3YWl0IHN0b3JhZ2UuYmFzZS5yZW1vdmVNdWx0aShrZXlzVG9SZW1vdmUpOyAvLyBSZW1vdmluZyBgbW9kYCBiZWZvcmUgZmV0Y2hpbmdcbiAgICByZXN1bHQuZXJyb3JzID0gKGF3YWl0IFByb21pc2UuYWxsKHRvRmV0Y2gpKS5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbiAgX3ZhY3V1bWluZyA9IG51bGw7XG4gIHJlc3VsdC5maXhlcyA9IG51bUZpeGVzO1xuICByZXNvbHZlU2VsZihyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHR5cGVkZWYgVk1TY3JpcHRcbiAqIEBwcm9wZXJ0eSB7Vk1TY3JpcHRDb25maWd9IGNvbmZpZ1xuICogQHByb3BlcnR5IHtWTVNjcmlwdEN1c3RvbX0gY3VzdG9tXG4gKiBAcHJvcGVydHkge1ZNU2NyaXB0TWV0YX0gbWV0YVxuICogQHByb3BlcnR5IHtWTVNjcmlwdFByb3BzfSBwcm9wc1xuICovXG4vKiogQHR5cGVkZWYgVk1TY3JpcHRDb25maWcgKlxuICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVkIC0gc3RvcmVkIGFzIDAgb3IgMVxuICogQHByb3BlcnR5IHtCb29sZWFufSByZW1vdmVkIC0gc3RvcmVkIGFzIDAgb3IgMVxuICogQHByb3BlcnR5IHtCb29sZWFufSBzaG91bGRVcGRhdGUgLSBzdG9yZWQgYXMgMCBvciAxXG4gKiBAcHJvcGVydHkge0Jvb2xlYW4gfCBudWxsfSBub3RpZnlVcGRhdGVzIC0gc3RvcmVkIGFzIDAgb3IgMSBvciBudWxsIChkZWZhdWx0KSB3aGljaCBtZWFucyBcInVzZSBnbG9iYWwgc2V0dGluZ1wiXG4gKi9cbi8qKiBAdHlwZWRlZiBWTVNjcmlwdEN1c3RvbSAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRvd25sb2FkVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9tZXBhZ2VVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYXN0SW5zdGFsbFVSTFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVwZGF0ZVVSTFxuICogQHByb3BlcnR5IHsnYXV0bycgfCAncGFnZScgfCAnY29udGVudCd9IGluamVjdEludG9cbiAqIEBwcm9wZXJ0eSB7bnVsbCB8IDEgfCAwfSBub2ZyYW1lcyAtIG51bGwgb3IgYWJzZW5jZSA9PSBkZWZhdWx0IChzY3JpcHQncyB2YWx1ZSlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGV4Y2x1ZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGV4Y2x1ZGVNYXRjaFxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gaW5jbHVkZVxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gbWF0Y2hcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3JpZ0V4Y2x1ZGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3JpZ0V4Y2x1ZGVNYXRjaFxuICogQHByb3BlcnR5IHtib29sZWFufSBvcmlnSW5jbHVkZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvcmlnTWF0Y2hcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwYXRoTWFwXG4gKiBAcHJvcGVydHkge1ZNU2NyaXB0UnVuQXR9IHJ1bkF0XG4gKi9cbi8qKiBAdHlwZWRlZiBWTVNjcmlwdE1ldGEgKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZG93bmxvYWRVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGV4Y2x1ZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGV4Y2x1ZGVNYXRjaFxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZ3JhbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBob21lcGFnZVVSTFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGljb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGluY2x1ZGVcbiAqIEBwcm9wZXJ0eSB7J2F1dG8nIHwgJ3BhZ2UnIHwgJ2NvbnRlbnQnfSBpbmplY3RJbnRvXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBtYXRjaFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbm9mcmFtZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHJlcXVpcmVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSByZXNvdXJjZXNcbiAqIEBwcm9wZXJ0eSB7Vk1TY3JpcHRSdW5BdH0gcnVuQXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdXBwb3J0VVJMXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvblxuICovXG4vKiogQHR5cGVkZWYgVk1TY3JpcHRQcm9wcyAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0TW9kaWZpZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0VXBkYXRlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBvc2l0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXVpZFxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtcbiAgICdkb2N1bWVudC1zdGFydCcgfCAnZG9jdW1lbnQtYm9keScgfCAnZG9jdW1lbnQtZW5kJyB8ICdkb2N1bWVudC1pZGxlJ1xuIH0gVk1TY3JpcHRSdW5BdFxuICovXG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRFdmVudEVtaXR0ZXIoKSB7XG4gIGNvbnN0IGV2ZW50cyA9IHt9O1xuICByZXR1cm4geyBvbiwgb2ZmLCBmaXJlIH07XG5cbiAgZnVuY3Rpb24gb24odHlwZSwgZnVuYykge1xuICAgIGxldCBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdDtcbiAgICB9XG4gICAgbGlzdC5wdXNoKGZ1bmMpO1xuICB9XG4gIGZ1bmN0aW9uIG9mZih0eXBlLCBmdW5jKSB7XG4gICAgY29uc3QgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAobGlzdCkge1xuICAgICAgY29uc3QgaSA9IGxpc3QuaW5kZXhPZihmdW5jKTtcbiAgICAgIGlmIChpID49IDApIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmaXJlKHR5cGUsIGRhdGEpIHtcbiAgICBjb25zdCBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmIChsaXN0KSB7XG4gICAgICBsaXN0LmZvckVhY2goKGZ1bmMpID0+IHtcbiAgICAgICAgZnVuYyhkYXRhLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgcG9zdEluaXRpYWxpemUgfSBmcm9tICcuL2luaXQnO1xuaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuL21lc3NhZ2UnO1xuXG5wb3N0SW5pdGlhbGl6ZS5wdXNoKCgpID0+IHtcbiAgYnJvd3Nlci5jb21tYW5kcy5vbkNvbW1hbmQuYWRkTGlzdGVuZXIoKGNtZCkgPT4ge1xuICAgIGlmIChjbWQgPT09ICduZXdTY3JpcHQnKSB7XG4gICAgICBjb21tYW5kcy5PcGVuRWRpdG9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdXRlID0gY21kID09PSAnc2V0dGluZ3MnID8gYCMke2NtZH1gIDogJyc7XG4gICAgICBjb21tYW5kcy5UYWJPcGVuKHsgdXJsOiBgL29wdGlvbnMvaW5kZXguaHRtbCR7cm91dGV9YCB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCJpbXBvcnQgeyBpMThuLCBub29wIH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgSU5KRUNUQUJMRV9UQUJfVVJMX1JFIH0gZnJvbSAnIy9jb21tb24vY29uc3RzJztcbmltcG9ydCB7IG9iamVjdFBpY2sgfSBmcm9tICcjL2NvbW1vbi9vYmplY3QnO1xuaW1wb3J0IGNhY2hlIGZyb20gJy4vY2FjaGUnO1xuaW1wb3J0IHsgcG9zdEluaXRpYWxpemUgfSBmcm9tICcuL2luaXQnO1xuaW1wb3J0IHsgY29tbWFuZHMsIGZvckVhY2hUYWIgfSBmcm9tICcuL21lc3NhZ2UnO1xuaW1wb3J0IHsgZ2V0T3B0aW9uLCBob29rT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyB0ZXN0QmxhY2tsaXN0IH0gZnJvbSAnLi90ZXN0ZXInO1xuXG4vLyBzdG9yaW5nIGluIGBjYWNoZWAgb25seSBmb3IgdGhlIGR1cmF0aW9uIG9mIHBhZ2UgbG9hZCBpbiBjYXNlIHRoZXJlIGFyZSAyKyBpZGVudGljYWwgdXJsc1xuY29uc3QgQ0FDSEVfRFVSQVRJT04gPSAxMDAwO1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIGFzeW5jIEdldEltYWdlRGF0YSh1cmwpIHtcbiAgICBjb25zdCBrZXkgPSBgR2V0SW1hZ2VEYXRhOiR7dXJsfWA7XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpXG4gICAgICB8fCBjYWNoZS5wdXQoa2V5LCBsb2FkSW1hZ2VEYXRhKHVybCwgeyBiYXNlNjQ6IHRydWUgfSkuY2F0Y2gobm9vcCksIENBQ0hFX0RVUkFUSU9OKTtcbiAgfSxcbiAgU2V0QmFkZ2U6IHNldEJhZGdlLFxufSk7XG5cbi8vIEZpcmVmb3ggQW5kcm9pZCBkb2VzIG5vdCBzdXBwb3J0IHN1Y2ggQVBJcywgdXNlIG5vb3BcblxuY29uc3QgYnJvd3NlckFjdGlvbiA9ICgoKSA9PiB7XG4gIGNvbnN0IHsgY2hyb21lIH0gPSBnbG9iYWw7XG4gIC8vIFVzaW5nIGBjaHJvbWVgIG5hbWVzcGFjZSBpbiBvcmRlciB0byBza2lwIG91ciBicm93c2VyLmpzIHBvbHlmaWxsIGluIENocm9tZVxuICBjb25zdCBhcGkgPSBjaHJvbWUuYnJvd3NlckFjdGlvbjtcbiAgLy8gU3VwcHJlc3MgdGhlIFwibm8gdGFiIGlkXCIgZXJyb3Igd2hlbiBzZXR0aW5nIGFuIGljb24vYmFkZ2UgYXMgaXQgY2Fubm90IGJlIHJlbGlhYmx5IHByZXZlbnRlZFxuICBjb25zdCBpZ25vcmVFcnJvcnMgPSAoKSA9PiBjaHJvbWUucnVudGltZS5sYXN0RXJyb3I7XG4gIC8vIFNvbWUgbWV0aG9kcyBsaWtlIHNldEJhZGdlVGV4dCBhZGRlZCBjYWxsYmFja3Mgb25seSBpbiBDaHJvbWUgNjcrLlxuICBjb25zdCBtYWtlTWV0aG9kID0gZm4gPT4gKC4uLmFyZ3MpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXBpOjpmbiguLi5hcmdzLCBpZ25vcmVFcnJvcnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGFwaTo6Zm4oLi4uYXJncyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gb2JqZWN0UGljayhhcGksIFtcbiAgICAnc2V0SWNvbicsXG4gICAgJ3NldEJhZGdlVGV4dCcsXG4gICAgJ3NldEJhZGdlQmFja2dyb3VuZENvbG9yJyxcbiAgICAnc2V0VGl0bGUnLFxuICBdLCBmbiA9PiAoZm4gPyBtYWtlTWV0aG9kKGZuKSA6IG5vb3ApKTtcbn0pKCk7XG5cbmNvbnN0IGJhZGdlcyA9IHt9O1xuY29uc3QgS0VZX0lTX0FQUExJRUQgPSAnaXNBcHBsaWVkJztcbmNvbnN0IEtFWV9TSE9XX0JBREdFID0gJ3Nob3dCYWRnZSc7XG5jb25zdCBLRVlfQkFER0VfQ09MT1IgPSAnYmFkZ2VDb2xvcic7XG5jb25zdCBLRVlfQkFER0VfQ09MT1JfQkxPQ0tFRCA9ICdiYWRnZUNvbG9yQmxvY2tlZCc7XG4vKiogQHR5cGUgYm9vbGVhbiAqL1xubGV0IGlzQXBwbGllZDtcbi8qKiBAdHlwZSBWTUJhZGdlTW9kZSAqL1xubGV0IHNob3dCYWRnZTtcbi8qKiBAdHlwZSBzdHJpbmcgKi9cbmxldCBiYWRnZUNvbG9yO1xuLyoqIEB0eXBlIHN0cmluZyAqL1xubGV0IGJhZGdlQ29sb3JCbG9ja2VkO1xuLyoqIEB0eXBlIHN0cmluZyAqL1xubGV0IHRpdGxlQmxhY2tsaXN0ZWQ7XG4vKiogQHR5cGUgc3RyaW5nICovXG5sZXQgdGl0bGVOb25pbmplY3RhYmxlO1xuXG4vLyBXZSdsbCBjYWNoZSB0aGUgaWNvbiBkYXRhIGluIENocm9tZSBhcyBpdCBkb2Vzbid0IGNhY2hlIHRoZSBkYXRhIGFuZCB0YWtlcyB1cCB0byA0MG1zXG4vLyBpbiBvdXIgYmFja2dyb3VuZCBwYWdlIGNvbnRleHQgdG8gc2V0IHRoZSA0IGljb24gc2l6ZXMgZm9yIGVhY2ggbmV3IHRhYiBvcGVuZWRcbmNvbnN0IGljb25DYWNoZSA9ICFJU19GSVJFRk9YICYmIHt9O1xuXG5ob29rT3B0aW9ucygoY2hhbmdlcykgPT4ge1xuICBsZXQgdjtcbiAgY29uc3Qgam9icyA9IFtdO1xuICBpZiAoKHYgPSBjaGFuZ2VzW0tFWV9JU19BUFBMSUVEXSkgIT0gbnVsbCkge1xuICAgIGlzQXBwbGllZCA9IHY7XG4gICAgc2V0SWNvbigpOyAvLyBjaGFuZ2UgdGhlIGRlZmF1bHQgaWNvblxuICAgIGpvYnMucHVzaChzZXRJY29uKTsgLy8gY2hhbmdlIHRoZSBjdXJyZW50IHRhYnMnIGljb25zXG4gIH1cbiAgaWYgKCh2ID0gY2hhbmdlc1tLRVlfU0hPV19CQURHRV0pICE9IG51bGwpIHtcbiAgICBzaG93QmFkZ2UgPSB2O1xuICAgIGpvYnMucHVzaCh1cGRhdGVCYWRnZSk7XG4gIH1cbiAgaWYgKCh2ID0gY2hhbmdlc1tLRVlfQkFER0VfQ09MT1JdKSAmJiAoYmFkZ2VDb2xvciA9IHYpXG4gIHx8ICh2ID0gY2hhbmdlc1tLRVlfQkFER0VfQ09MT1JfQkxPQ0tFRF0pICYmIChiYWRnZUNvbG9yQmxvY2tlZCA9IHYpKSB7XG4gICAgam9icy5wdXNoKHVwZGF0ZUJhZGdlQ29sb3IpO1xuICB9XG4gIGlmICgnYmxhY2tsaXN0JyBpbiBjaGFuZ2VzKSB7XG4gICAgam9icy5wdXNoKHVwZGF0ZVN0YXRlKTtcbiAgfVxuICBpZiAoam9icy5sZW5ndGgpIHtcbiAgICBmb3JFYWNoVGFiKHRhYiA9PiBqb2JzLmZvckVhY2goZm4gPT4gZm4odGFiKSkpO1xuICB9XG59KTtcblxucG9zdEluaXRpYWxpemUucHVzaCgoKSA9PiB7XG4gIGlzQXBwbGllZCA9IGdldE9wdGlvbihLRVlfSVNfQVBQTElFRCk7XG4gIHNob3dCYWRnZSA9IGdldE9wdGlvbihLRVlfU0hPV19CQURHRSk7XG4gIGJhZGdlQ29sb3IgPSBnZXRPcHRpb24oS0VZX0JBREdFX0NPTE9SKTtcbiAgYmFkZ2VDb2xvckJsb2NrZWQgPSBnZXRPcHRpb24oS0VZX0JBREdFX0NPTE9SX0JMT0NLRUQpO1xuICB0aXRsZUJsYWNrbGlzdGVkID0gaTE4bignZmFpbHVyZVJlYXNvbkJsYWNrbGlzdGVkJyk7XG4gIHRpdGxlTm9uaW5qZWN0YWJsZSA9IGkxOG4oJ2ZhaWx1cmVSZWFzb25Ob25pbmplY3RhYmxlJyk7XG4gIGZvckVhY2hUYWIodXBkYXRlU3RhdGUpO1xuICBpZiAoIWlzQXBwbGllZCkgc2V0SWNvbigpOyAvLyBzZXRzIHRoZSBkaW1tZWQgaWNvbiBhcyBkZWZhdWx0XG59KTtcblxuYnJvd3Nlci50YWJzLm9uUmVtb3ZlZC5hZGRMaXN0ZW5lcigoaWQpID0+IHtcbiAgZGVsZXRlIGJhZGdlc1tpZF07XG59KTtcblxuYnJvd3Nlci50YWJzLm9uVXBkYXRlZC5hZGRMaXN0ZW5lcigodGFiSWQsIGluZm8sIHRhYikgPT4ge1xuICBjb25zdCB7IHVybCB9ID0gaW5mbztcbiAgaWYgKGluZm8uc3RhdHVzID09PSAnbG9hZGluZydcbiAgICAgIC8vIGF0IGxlYXN0IGFib3V0Om5ld3RhYiBpbiBGaXJlZm94IG1heSBvcGVuIHdpdGhvdXQgJ2xvYWRpbmcnIHN0YXR1c1xuICAgICAgfHwgaW5mby5mYXZJY29uVXJsICYmIHRhYi51cmwuc3RhcnRzV2l0aCgnYWJvdXQ6JykpIHtcbiAgICB1cGRhdGVTdGF0ZSh0YWIsIHVybCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBzZXRCYWRnZShpZHMsIHsgdGFiLCBmcmFtZUlkIH0pIHtcbiAgY29uc3QgdGFiSWQgPSB0YWIuaWQ7XG4gIGNvbnN0IGRhdGEgPSBiYWRnZXNbdGFiSWRdIHx8IHt9O1xuICBpZiAoIWRhdGEuaWRNYXAgfHwgZnJhbWVJZCA9PT0gMCkge1xuICAgIC8vIDEpIGtlZXBpbmcgZGF0YSBvYmplY3QgdG8gcHJlc2VydmUgZGF0YS5ibG9ja2VkXG4gICAgLy8gMikgJ3RvdGFsJyBhbmQgJ3VuaXF1ZScgbXVzdCBtYXRjaCBzaG93QmFkZ2UgaW4gb3B0aW9ucy1kZWZhdWx0cy5qc1xuICAgIGRhdGEudG90YWwgPSAwO1xuICAgIGRhdGEudW5pcXVlID0gMDtcbiAgICBkYXRhLmlkTWFwID0ge307XG4gICAgYmFkZ2VzW3RhYklkXSA9IGRhdGE7XG4gIH1cbiAgZGF0YS50b3RhbCArPSBpZHMubGVuZ3RoO1xuICBpZiAoaWRzKSB7XG4gICAgaWRzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBkYXRhLmlkTWFwW2lkXSA9IDE7XG4gICAgfSk7XG4gICAgZGF0YS51bmlxdWUgPSBPYmplY3Qua2V5cyhkYXRhLmlkTWFwKS5sZW5ndGg7XG4gIH1cbiAgdXBkYXRlQmFkZ2VDb2xvcih0YWIsIGRhdGEpO1xuICB1cGRhdGVCYWRnZSh0YWIsIGRhdGEpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVCYWRnZSh0YWIsIGRhdGEgPSBiYWRnZXNbdGFiLmlkXSkge1xuICBpZiAoZGF0YSkge1xuICAgIGJyb3dzZXJBY3Rpb24uc2V0QmFkZ2VUZXh0KHtcbiAgICAgIHRleHQ6IGAke2RhdGFbc2hvd0JhZGdlXSB8fCAnJ31gLFxuICAgICAgdGFiSWQ6IHRhYi5pZCxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVCYWRnZUNvbG9yKHRhYiwgZGF0YSA9IGJhZGdlc1t0YWIuaWRdKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgYnJvd3NlckFjdGlvbi5zZXRCYWRnZUJhY2tncm91bmRDb2xvcih7XG4gICAgICBjb2xvcjogZGF0YS5ibG9ja2VkID8gYmFkZ2VDb2xvckJsb2NrZWQgOiBiYWRnZUNvbG9yLFxuICAgICAgdGFiSWQ6IHRhYi5pZCxcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBDaHJvbWUgNzkrIHVzZXMgcGVuZGluZ1VybCB3aGlsZSB0aGUgdGFiIGNvbm5lY3RzIHRvIHRoZSBuZXdseSBuYXZpZ2F0ZWQgVVJMXG4vLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2ZvcnVtLyMhdG9waWMvY2hyb21pdW0tZXh0ZW5zaW9ucy81enVfUFQwYXJsc1xuZnVuY3Rpb24gdXBkYXRlU3RhdGUodGFiLCB1cmwgPSB0YWIucGVuZGluZ1VybCB8fCB0YWIudXJsKSB7XG4gIGNvbnN0IHRhYklkID0gdGFiLmlkO1xuICBjb25zdCBpbmplY3RhYmxlID0gSU5KRUNUQUJMRV9UQUJfVVJMX1JFLnRlc3QodXJsKTtcbiAgY29uc3QgYmxhY2tsaXN0ZWQgPSBpbmplY3RhYmxlID8gdGVzdEJsYWNrbGlzdCh1cmwpIDogdW5kZWZpbmVkO1xuICBjb25zdCB0aXRsZSA9IGJsYWNrbGlzdGVkICYmIHRpdGxlQmxhY2tsaXN0ZWQgfHwgIWluamVjdGFibGUgJiYgdGl0bGVOb25pbmplY3RhYmxlIHx8ICcnO1xuICAvLyBpZiB0aGUgdXNlciB1bmJsYWNrbGlzdGVkIHRoaXMgcHJldmlvdXNseSBibG9ja2VkIHRhYiBpbiBzZXR0aW5ncyxcbiAgLy8gYnV0IGRpZG4ndCByZWxvYWQgdGhlIHRhYiB5ZXQsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgaWNvbiBhbmQgdGhlIHRpdGxlXG4gIGlmICh0aXRsZSB8fCAoYmFkZ2VzW3RhYklkXSB8fCB7fSkuYmxvY2tlZCkge1xuICAgIGJyb3dzZXJBY3Rpb24uc2V0VGl0bGUoeyB0aXRsZSwgdGFiSWQgfSk7XG4gICAgY29uc3QgZGF0YSA9IHRpdGxlID8geyBibG9ja2VkOiB0cnVlIH0gOiB7fTtcbiAgICBiYWRnZXNbdGFiSWRdID0gZGF0YTtcbiAgICBzZXRJY29uKHRhYiwgZGF0YSk7XG4gICAgdXBkYXRlQmFkZ2UodGFiLCBkYXRhKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzZXRJY29uKHRhYiA9IHt9LCBkYXRhID0ge30pIHtcbiAgLy8gbW9kZXJuIENocm9tZSBhbmQgRmlyZWZveCB1c2UgMTYvMzIsIG90aGVyIGJyb3dzZXJzIG1heSBzdGlsbCB1c2UgMTkvMzggKGUuZy4gVml2YWxkaSlcbiAgY29uc3QgbW9kID0gZGF0YS5ibG9ja2VkICYmICdiJyB8fCAhaXNBcHBsaWVkICYmICd3JyB8fCAnJztcbiAgY29uc3QgaWNvbkRhdGEgPSB7fTtcbiAgZm9yIChjb25zdCBuIG9mIFsxNiwgMTksIDMyLCAzOF0pIHtcbiAgICBjb25zdCBwYXRoID0gYC9wdWJsaWMvaW1hZ2VzL2ljb24ke259JHttb2R9LnBuZ2A7XG4gICAgbGV0IGljb24gPSBpY29uQ2FjaGUgPyBpY29uQ2FjaGVbcGF0aF0gOiBwYXRoO1xuICAgIGlmICghaWNvbikge1xuICAgICAgaWNvbiA9IGF3YWl0IGxvYWRJbWFnZURhdGEocGF0aCk7XG4gICAgICBpY29uQ2FjaGVbcGF0aF0gPSBpY29uO1xuICAgIH1cbiAgICBpY29uRGF0YVtuXSA9IGljb247XG4gIH1cbiAgYnJvd3NlckFjdGlvbi5zZXRJY29uKHtcbiAgICB0YWJJZDogdGFiLmlkLFxuICAgIFtpY29uQ2FjaGUgPyAnaW1hZ2VEYXRhJyA6ICdwYXRoJ106IGljb25EYXRhLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gbG9hZEltYWdlRGF0YShwYXRoLCB7IGJhc2U2NCB9ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuc3JjID0gcGF0aDtcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWc7XG4gICAgICBpZiAoIXdpZHRoKSB7IC8vIEZGIHJlcG9ydHMgMCBmb3IgU1ZHXG4gICAgICAgIHJlc29sdmUocGF0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXNvbHZlKGJhc2U2NCA/IGNhbnZhcy50b0RhdGFVUkwoKSA6IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkpO1xuICAgIH07XG4gICAgaW1nLm9uZXJyb3IgPSByZWplY3Q7XG4gIH0pO1xufVxuIiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBjYWNoZSB9IGZyb20gJy4vY2FjaGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRFdmVudEVtaXR0ZXIgfSBmcm9tICcuL2V2ZW50cyc7XG5leHBvcnQgKiBmcm9tICcuL21lc3NhZ2UnO1xuZXhwb3J0ICogZnJvbSAnLi9vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vc2VhcmNoJztcbiIsImV4cG9ydCBjb25zdCBleHRlbnNpb25Sb290ID0gYnJvd3Nlci5ydW50aW1lLmdldFVSTCgnLycpO1xuXG5leHBvcnQgY29uc3QgcHJlSW5pdGlhbGl6ZSA9IFtdO1xuZXhwb3J0IGNvbnN0IHBvc3RJbml0aWFsaXplID0gW107XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKG1haW4pIHtcbiAgY29uc3QgcnVuID0gaW5pdCA9PiAodHlwZW9mIGluaXQgPT09ICdmdW5jdGlvbicgPyBpbml0KCkgOiBpbml0KTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwocHJlSW5pdGlhbGl6ZS5tYXAocnVuKSk7XG4gIGF3YWl0IHJ1bihtYWluKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwocG9zdEluaXRpYWxpemUubWFwKHJ1bikpO1xuICBwcmVJbml0aWFsaXplLmxlbmd0aCA9IDA7XG4gIHBvc3RJbml0aWFsaXplLmxlbmd0aCA9IDA7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBjcmVkaXRzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9tbzcwNzU3NzA0NS9tM3U4LWRvd25sb2FkZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGVsbHZvbi96aC1kb3dubG9hZGVyXG4gKi9cblxuaW1wb3J0IGpCaW5hcnkgZnJvbSAnamJpbmFyeSc7XG5pbXBvcnQgTVBFR1RTIGZyb20gJ21wZWd0c190b19tcDQvbXBlZ3RzX3RvX21wNC9tcGVndHMnO1xuaW1wb3J0IG1wZWd0c190b19tcDQgZnJvbSAnbXBlZ3RzX3RvX21wNC9tcGVndHNfdG9fbXA0L2luZGV4JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbmltcG9ydCB7IEFFU0RlY3J5cHRvciB9IGZyb20gJy4vYWVzLWRlY3J5cHRvcic7XG5cbmxldCB0c0xpc3QgPSBbXTtcbmxldCBzdGF0dXNMaXN0ID0gW107XG5sZXQgbWVkaWFGaWxlTGlzdCA9IFtdO1xuXG4vLyBBRVMg6KeG6aKR6Kej5a+G6YWN572uXG5jb25zdCBBRVMgPSB7XG4gIG1ldGhvZDogJycsIC8vIOWKoOWvhueul+azlVxuICB1cmk6ICcnLCAvLyBrZXkg5omA5Zyo5paH5Lu26Lev5b6EXG4gIGl2OiAnJywgLy8g5YGP56e75YC8XG4gIGtleTogJycsIC8vIOenmOmSpVxuICBkZWNyeXB0b3I6IG51bGwsIC8vIOino+eggeWZqOWvueixoVxuICBzdHJpbmdUb0J1ZmZlcjogZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKVxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgZG93bmxvYWRNM3U4ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8gY2xlYXJcbiAgdHNMaXN0ID0gW107XG4gIHN0YXR1c0xpc3QgPSBbXTtcbiAgbWVkaWFGaWxlTGlzdCA9IFtdO1xuXG4gIGNvbnN0IG0zdTggPSBvcHRzLmRhdGFbMF07XG4gIGNvbnN0IGJhc2VVcmwgPSBvcHRzLnVybDtcbiAgbGV0IGxpbWl0ID0gNTtcbiAgbTN1OC5zcGxpdCgnXFxuJykuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgIGlmIChsaW1pdCA+IDAgJiYgdHNMaXN0Lmxlbmd0aCA+PSBsaW1pdCkgcmV0dXJuO1xuICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignLnRzJykgPiAtMSkge1xuICAgICAgdHNMaXN0LnB1c2godHNVcmwobGluZSwgYmFzZVVybCkpO1xuICAgICAgc3RhdHVzTGlzdC5wdXNoKHtcbiAgICAgICAgdGl0bGU6IGxpbmUsXG4gICAgICAgIHN0YXR1czogJ2luaXQnLFxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgLy8gY29uc29sZS5sb2coJ3RzTGlzdCcsIHRzTGlzdCk7XG5cbiAgaWYgKG0zdTguaW5kZXhPZignI0VYVC1YLUtFWScpID4gLTEpIHtcbiAgICAvLyDop4bpopEgQUVTIOWKoOWvhlxuICAgIEFFUy5tZXRob2QgPSAobTN1OC5tYXRjaCgvKC4qTUVUSE9EPShbXixcXHNdKykpLykgfHwgWycnLCAnJywgJyddKVsyXVxuICAgIEFFUy51cmkgPSAobTN1OC5tYXRjaCgvKC4qVVJJPVwiKFteXCJdKykpXCIvKSB8fCBbJycsICcnLCAnJ10pWzJdXG4gICAgQUVTLnVyaSA9IHRzVXJsKEFFUy51cmksIGJhc2VVcmwpXG4gICAgQUVTLml2ID0gKG0zdTgubWF0Y2goLyguKklWPShbXixcXHNdKykpLykgfHwgWycnLCAnJywgJyddKVsyXVxuICAgIEFFUy5pdiA9IEFFUy5pdiA/IEFFUy5zdHJpbmdUb0J1ZmZlcihBRVMuaXYpIDogJydcblxuICAgIC8vIOWFiOS4i+i9veenmOmSpVxuICAgIGdldEFFUygoKSA9PiB7XG4gICAgICBkb3dubG9hZFRTKG9wdHMpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgLy8g5aaC5p6c6KeG6aKR5rKh5Yqg5a+G77yM5YiZ55u05o6l5LiL6L2954mH5q61XG4gICAgZG93bmxvYWRUUyhvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmluZm8oJ2VtcHR5IG0zdTghJylcbiAgfVxufVxuXG5jb25zdCBnZXRBRVMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgYWpheCh7XG4gICAgdXJsOiBBRVMudXJpLFxuICAgIHN1Y2Nlc3M6IChrZXkpID0+IHtcbiAgICAgIEFFUy5rZXkgPSBrZXlcbiAgICAgIEFFUy5kZWNyeXB0b3IgPSBuZXcgQUVTRGVjcnlwdG9yKClcbiAgICAgIEFFUy5kZWNyeXB0b3IuY29uc3RydWN0b3IoKVxuICAgICAgQUVTLmRlY3J5cHRvci5leHBhbmRLZXkoQUVTLmtleSk7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSxcbiAgICBmYWlsOiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmluZm8oJ+inhumikeW3sui/m+ihjOWumuWItuWMluWKoOWvhicpXG4gICAgfSxcbiAgfSlcbn1cblxuY29uc3QgdHNVcmwgPSBmdW5jdGlvbiAodHNVcmksIGJhc2VVUkwpIHtcbiAgaWYgKHRzVXJpLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIHJldHVybiB0c1VyaVxuICB9IGVsc2UgaWYgKHRzVXJpWzBdID09PSAnLycpIHtcbiAgICBsZXQgZG9tYWluID0gYmFzZVVSTC5zcGxpdCgnLycpXG4gICAgcmV0dXJuIGRvbWFpblswXSArICcvLycgKyBkb21haW5bMl0gKyB0c1VyaVxuICB9IGVsc2Uge1xuICAgIGxldCBkb21haW4gPSBiYXNlVVJMLnNwbGl0KCcvJylcbiAgICBkb21haW4ucG9wKClcbiAgICByZXR1cm4gZG9tYWluLmpvaW4oJy8nKSArICcvJyArIHRzVXJpXG4gIH1cbn1cblxuLy8gdHMg54mH5q6155qEIEFFUyDop6PnoIFcbmNvbnN0IGRlY3J5cHRUcyA9IGZ1bmN0aW9uIChkYXRhLCBpbmRleCkge1xuICBsZXQgaXYgPSBBRVMuaXYgfHwgbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIGluZGV4XSlcbiAgcmV0dXJuIEFFUy5kZWNyeXB0b3IuZGVjcnlwdChkYXRhLCAwLCBpdi5idWZmZXIgfHwgaXYsIHRydWUpXG59XG5cbi8vIOS4i+i9veWIhueJh1xuY29uc3QgZG93bmxvYWRUUyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCByZXRyeSA9IDA7XG4gIGxldCBkb3dubG9hZCA9ICgpID0+IHtcbiAgICBjb25zdCBpID0gaW5kZXg7XG4gICAgaW5kZXgrKztcbiAgICBpZiAoaSA+PSB0c0xpc3QubGVuZ3RoKSB7XG4gICAgICAvLyBhbGwgc3VjY1xuICAgICAgY29uc3QgcHJvY0xpc3QgPSBzdGF0dXNMaXN0LmZpbHRlcihzID0+IFsnc3VjYycsICdsb2FkaW5nJ10uaW5jbHVkZXMocy5zdGF0dXMpKTtcbiAgICAgIGlmIChwcm9jTGlzdC5sZW5ndGggPT09IHRzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0cnkgPCA1KSB7XG4gICAgICAgIC8vIHJldHJ5IGFnYWluXG4gICAgICAgIHJldHJ5ICsrO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZG93bmxvYWQoKSwgMTAwMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZXRyeScsIHJldHJ5LCBwcm9jTGlzdC5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnZG93bmxvYWQnLCBpKTtcbiAgICBpZiAoc3RhdHVzTGlzdFtpXSAmJiBbJ2Vycm9yJywgJ2luaXQnXS5pbmNsdWRlcyhzdGF0dXNMaXN0W2ldLnN0YXR1cykpIHtcbiAgICAgIHN0YXR1c0xpc3RbaV0uc3RhdHVzID0gJ2xvYWRpbmcnXG4gICAgICBhamF4KHtcbiAgICAgICAgdXJsOiB0c0xpc3RbaV0sXG4gICAgICAgIHN1Y2Nlc3M6IChkYXRhKSA9PiB7XG4gICAgICAgICAgc3RhdHVzTGlzdFtpXS5zdGF0dXMgPSAnc3VjYydcbiAgICAgICAgICBkZWFsVFMoZGF0YSwgaSwgb3B0cywgKCkgPT4ge1xuICAgICAgICAgICAgb3B0cy5vbnByb2dyZXNzKG1lZGlhRmlsZUxpc3QubGVuZ3RoLCB0c0xpc3QubGVuZ3RoICsgMSlcbiAgICAgICAgICAgIGRvd25sb2FkKClcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBmYWlsOiAoZSkgPT4ge1xuICAgICAgICAgIC8vIGxldCBlcnIgPSBlLnN0YXR1c1RleHRcbiAgICAgICAgICBjb25zb2xlLmxvZyh7IGUsIGkgfSk7XG4gICAgICAgICAgLy8gdG9kbzogcmV0cnlcbiAgICAgICAgICBzdGF0dXNMaXN0W2ldLnN0YXR1cyA9ICdlcnJvcidcbiAgICAgICAgICBkb3dubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7IC8vIOi3s+i/h+W3sue7j+aIkOWKn+eahOeJh+autVxuICAgICAgZG93bmxvYWQoKVxuICAgIH1cbiAgfVxuXG4gIC8vIOW5tuihjCBO57q/56iL5LiL6L29XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCAzOyBpaSsrKSB7XG4gICAgZG93bmxvYWQoKVxuICB9XG59XG5cbmNvbnN0IG1wNEJ5SmJpbmFyeSA9IChkYXRhQ2h1bmtzLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBibG9iID0gbmV3IEJsb2IoZGF0YUNodW5rcy5tYXAoZGF0YSA9PiBuZXcgVWludDhBcnJheShkYXRhKSksIHsgdHlwZTogJ3ZpZGVvL21wMnQnIH0pO1xuICBqQmluYXJ5LmxvYWQoYmxvYiwgTVBFR1RTLCAoZXJyLCBtcGVndHMpID0+IHtcbiAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyh7IGVyciB9KTtcbiAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IG1wNE9iaiA9IG1wZWd0c190b19tcDQobXBlZ3RzKTtcbiAgICBjb25zb2xlLmxvZyhgQ29udmVydGVkIGZpbmlzaGVkLCB0aW1lIGVsYXBzZWQ6ICR7bmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydH1tc2ApO1xuICAgIGNvbnN0IGRhdGEgPSB7IGRvd25sb2FkTGluazogbXA0T2JqLnRvVVJJKCd2aWRlby9tcDQnKSB9O1xuICAgIGNhbGxiYWNrKGRhdGEpO1xuICB9KTtcbn07XG5cbi8vIOWkhOeQhiB0cyDniYfmrrXvvIxBRVMg6Kej5a+G44CBbXA0IOi9rOeggVxuY29uc3QgZGVhbFRTID0gZnVuY3Rpb24gKHJhd0RhdGEsIGluZGV4LCBvcHRzLCBjYWxsYmFjaykge1xuICBjb25zdCBkYXRhID0gQUVTLnVyaSA/IGRlY3J5cHRUcyhyYXdEYXRhLCBpbmRleCkgOiByYXdEYXRhXG4gIG1lZGlhRmlsZUxpc3RbaW5kZXhdID0gZGF0YTtcbiAgaWYgKG1lZGlhRmlsZUxpc3QuZmlsdGVyKG0gPT4gbSB8fCBmYWxzZSkubGVuZ3RoID09PSB0c0xpc3QubGVuZ3RoKSB7XG4gICAgbXA0QnlKYmluYXJ5KG1lZGlhRmlsZUxpc3QsIHJlcyA9PiB7XG4gICAgICBjaHJvbWUuZG93bmxvYWRzLmRvd25sb2FkKHtcbiAgICAgICAgdXJsOiByZXMuZG93bmxvYWRMaW5rLFxuICAgICAgICBmaWxlbmFtZTogb3B0cy5maWxlTmFtZSxcbiAgICAgIH0sIGRvd25sb2FkSWQgPT4ge1xuICAgICAgICBvcHRzLm9ubG9hZCgpXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwocmVzLmRvd25sb2FkTGluayk7XG4gICAgICB9KTtcbiAgICB9KVxuICB9XG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbn1cblxuY29uc3QgYWpheCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICBsZXQgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICBvcHRpb25zLnN1Y2Nlc3MgJiYgb3B0aW9ucy5zdWNjZXNzKHhoci5yZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLmZhaWwgJiYgb3B0aW9ucy5mYWlsKHN0YXR1cyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHhoci5vcGVuKFwiR0VUXCIsIG9wdGlvbnMudXJsLCB0cnVlKTtcbiAgeGhyLnNlbmQobnVsbCk7XG59IiwiaW1wb3J0IHsgZGVlcENvcHkgfSBmcm9tICcjL2NvbW1vbi9vYmplY3QnO1xuY29uc3QgeyBjcmVhdGVGRm1wZWcsIGZldGNoRmlsZSB9ID0gcmVxdWlyZSgnQGZmbXBlZy9mZm1wZWcnKTtcbmNvbnN0IHsgY2hyb21lIH0gPSBnbG9iYWw7XG5cbmxldCBmZm1wZWc7XG5hc3luYyBmdW5jdGlvbiBsb2FkKCkge1xuICBpZiAoZmZtcGVnKSByZXR1cm4gZmZtcGVnO1xuICBmZm1wZWcgPSBjcmVhdGVGRm1wZWcoe1xuICAgIGNvcmVQYXRoOiAnL3B1YmxpYy9saWIvZmZtcGVnLWNvcmUuanMnLFxuICAgIGxvZzogZmFsc2UsXG4gIH0pO1xuICBhd2FpdCBmZm1wZWcubG9hZCgpO1xuICBjb25zb2xlLmluZm8oJ2ZmIGxvYWRlZCcsIHsgZmZtcGVnIH0pO1xuICByZXR1cm4gZmZtcGVnO1xufVxuXG5jb25zdCBtZXJnZSA9IGFzeW5jICh2aWRlbywgYXVkaW8pID0+IHtcbiAgLy8gY29uc29sZS5pbmZvKHsgdmlkZW8sIGF1ZGlvIH0pO1xuICBmZm1wZWcuRlMoJ3dyaXRlRmlsZScsICd2aWRlby5tcDQnLCBhd2FpdCBmZXRjaEZpbGUodmlkZW8pKTtcbiAgZmZtcGVnLkZTKCd3cml0ZUZpbGUnLCAnYXVkaW8ubXAzJywgYXdhaXQgZmV0Y2hGaWxlKGF1ZGlvKSk7XG4gIGF3YWl0IGZmbXBlZy5ydW4oJy1pJywgJ3ZpZGVvLm1wNCcsICctaScsICdhdWRpby5tcDMnLCAnLWMnLCAnY29weScsICdvdXQubXA0Jyk7XG4gIHJldHVybiBmZm1wZWcuRlMoJ3JlYWRGaWxlJywgJ291dC5tcDQnKTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGdldChvcHRzLCBodHRwUmVxdWVzdCwgcHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBvcHRzLnJlcXVlc3RzW29wdHMuaWRdID0ge1xuICAgICAgaWQ6IG9wdHMuaWQsXG4gICAgICB0YWJJZDogb3B0cy5zcmMudGFiLmlkLFxuICAgICAgZXZlbnRzVG9Ob3RpZnk6IFsnZXJyb3InLCAnbG9hZCcsICdwcm9ncmVzcyddLFxuICAgICAgeGhyOiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICB9O1xuICAgIG9wdHMudHlwZSA9ICdkb3dubG9hZCc7XG4gICAgb3B0cy5maWxlTmFtZSA9IG51bGw7XG4gICAgb3B0cy5kYXRhID0gW107XG4gICAgaHR0cFJlcXVlc3Qob3B0cywgb3B0cy5zcmMsIHJlcyA9PiB7XG4gICAgICAvLyBjb25zb2xlLmluZm8oJ2h0dHBSZXF1ZXN0JywgcmVzKTtcbiAgICAgIGlmIChyZXMudHlwZSA9PT0gJ3Byb2dyZXNzJykge1xuICAgICAgICAvLyBjb25zb2xlLmluZm8oJ2h0dHBSZXF1ZXN0JywgcmVzLmRhdGE/LmxvYWRlZCwgcmVzLmRhdGE/LnRvdGFsKTtcbiAgICAgICAgcHJvZ3Jlc3MocmVzLmRhdGE/LmxvYWRlZCwgcmVzLmRhdGE/LnRvdGFsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzLnR5cGUgPT09ICdsb2FkJykge1xuICAgICAgICByZXNvbHZlKHJlcy5kYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzLnR5cGUgPT09ICdsb2FkZW5kJykge1xuICAgICAgICByZWplY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtZXJnZVZpZGVvKG9wdHMsIGh0dHBSZXF1ZXN0KSB7XG4gIC8vIGNvbnNvbGUuaW5mbygnbWVyZ2VWaWRlbycsIG9wdHMpO1xuICBjb25zdCBwcm9ncmVzcyA9IHtcbiAgICB2aWRlbzogeyBsb2FkZWQ6IDAsIHRvdGFsOiAwIH0sXG4gICAgYXVkaW86IHsgbG9hZGVkOiAwLCB0b3RhbDogMCB9LFxuICB9O1xuXG4gIGNvbnN0IG9ucHJvZ3Jlc3MgPSAocHAsIGxvYWRlZCwgdG90YWwpID0+IHtcbiAgICBpZiAobG9hZGVkICYmIHRvdGFsKSBPYmplY3QuYXNzaWduKHBwLCB7IGxvYWRlZCwgdG90YWwgfSk7XG4gICAgY29uc3QgX2xvYWRlZCA9IHByb2dyZXNzLnZpZGVvLmxvYWRlZCArIHByb2dyZXNzLmF1ZGlvLmxvYWRlZDtcbiAgICBjb25zdCBfdG90YWwgPSBwcm9ncmVzcy52aWRlby50b3RhbCArIHByb2dyZXNzLmF1ZGlvLnRvdGFsO1xuICAgIGlmIChfbG9hZGVkICYmIF90b3RhbCkgb3B0cy5vbnByb2dyZXNzKF9sb2FkZWQsIF90b3RhbCArIDEpO1xuICB9O1xuXG4gIGNvbnN0IHByZWxvYWRzID0gW107XG4gIHByZWxvYWRzLnB1c2gobG9hZCgpKTtcblxuICBjb25zdCB2aWRlb09wdHMgPSBkZWVwQ29weShvcHRzKTtcbiAgdmlkZW9PcHRzLnJlcXVlc3RzID0gb3B0cy5yZXF1ZXN0cztcbiAgdmlkZW9PcHRzLmlkID0gYCR7b3B0cy5pZH0udmlkZW9gO1xuICBwcmVsb2Fkcy5wdXNoKGdldCh2aWRlb09wdHMsIGh0dHBSZXF1ZXN0LCAobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgIG9ucHJvZ3Jlc3MocHJvZ3Jlc3MudmlkZW8sIGxvYWRlZCwgdG90YWwpO1xuICB9KSk7XG5cbiAgY29uc3QgYXVkaW9PcHRzID0gZGVlcENvcHkob3B0cyk7XG4gIGF1ZGlvT3B0cy5yZXF1ZXN0cyA9IG9wdHMucmVxdWVzdHM7XG4gIGF1ZGlvT3B0cy51cmwgPSBvcHRzLmRhdGFbMF07XG4gIGF1ZGlvT3B0cy5pZCA9IGAke29wdHMuaWR9LmF1ZGlvYDtcbiAgcHJlbG9hZHMucHVzaChnZXQoYXVkaW9PcHRzLCBodHRwUmVxdWVzdCwgKGxvYWRlZCwgdG90YWwpID0+IHtcbiAgICBvbnByb2dyZXNzKHByb2dyZXNzLmF1ZGlvLCBsb2FkZWQsIHRvdGFsKTtcbiAgfSkpO1xuXG4gIGNvbnN0IHZhbHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcmVsb2Fkcyk7XG4gIGlmICghdmFsc1sxXSB8fCAhdmFsc1syXSkge1xuICAgIC8vIGZhaWxcbiAgICBvcHRzLm9uZXJyb3IoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjb25zb2xlLmluZm8oeyB2YWxzIH0pO1xuICBjb25zdCBvdXQgPSBhd2FpdCBtZXJnZSh2YWxzWzFdLCB2YWxzWzJdKTtcbiAgLy8gY29uc29sZS5pbmZvKCdvdXQnLCB7IG91dCB9KTtcbiAgY29uc3QgYmxvYkNvbmYgPSB7fTtcbiAgYmxvYkNvbmYudHlwZSA9ICd2aWRlby9tcDQnO1xuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtvdXRdLCBibG9iQ29uZikpO1xuICAvLyBjb25zb2xlLmluZm8oJ3JlcycsIHsgdXJsLCBmaWxlbmFtZTogb3B0cy5maWxlTmFtZSB9KTtcbiAgY2hyb21lLmRvd25sb2Fkcy5kb3dubG9hZCh7XG4gICAgdXJsLFxuICAgIGZpbGVuYW1lOiBvcHRzLmZpbGVOYW1lLFxuICB9LCBkb3dubG9hZElkID0+IHtcbiAgICAvLyBjb25zb2xlLmluZm8oZG93bmxvYWRJZCk7XG4gICAgb3B0cy5vbmxvYWQoZG93bmxvYWRJZCk7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7IGRlZmF1bHRJbWFnZSwgaTE4biwgbm9vcCB9IGZyb20gJyMvY29tbW9uJztcblxuZXhwb3J0IGNvbnN0IGNvbW1hbmRzID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBub3RpZnkob3B0aW9ucykge1xuICBicm93c2VyLm5vdGlmaWNhdGlvbnMuY3JlYXRlKG9wdGlvbnMuaWQgfHwgJ1Zpb2xlbnRNb25rZXknLCB7XG4gICAgdHlwZTogJ2Jhc2ljJyxcbiAgICBpY29uVXJsOiBkZWZhdWx0SW1hZ2UsXG4gICAgdGl0bGU6IGAke29wdGlvbnMudGl0bGV9IC0gJHtpMThuKCdleHROYW1lJyl9YCxcbiAgICBtZXNzYWdlOiBvcHRpb25zLmJvZHksXG4gICAgaXNDbGlja2FibGU6IG9wdGlvbnMuaXNDbGlja2FibGUsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJvYWRjYXN0KGRhdGEpIHtcbiAgZm9yRWFjaFRhYigodGFiKSA9PiB7XG4gICAgYnJvd3Nlci50YWJzLnNlbmRNZXNzYWdlKHRhYi5pZCwgZGF0YSlcbiAgICAuY2F0Y2gobm9vcCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VuZE1lc3NhZ2VPcklnbm9yZSguLi5hcmdzKSB7XG4gIHJldHVybiBicm93c2VyLnJ1bnRpbWUuc2VuZE1lc3NhZ2UoLi4uYXJncykuY2F0Y2gobm9vcCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmb3JFYWNoVGFiKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHRhYnMgPSBhd2FpdCBicm93c2VyLnRhYnMucXVlcnkoe30pO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgdGFiIG9mIHRhYnMpIHtcbiAgICBjYWxsYmFjayh0YWIpO1xuICAgIGkgKz0gMTtcbiAgICAvLyB3ZSdsbCBydW4gYXQgbW9zdCB0aGlzIG1hbnkgdGFicyBpbiBvbmUgZXZlbnQgbG9vcCBjeWNsZVxuICAgIC8vIGJlY2F1c2UgaHVuZHJlZHMgb2YgdGFicyB3b3VsZCBtYWtlIG91ciBleHRlbnNpb24gcHJvY2VzcyB1bnJlc3BvbnNpdmUsXG4gICAgLy8gdGhlIHNhbWUgcHJvY2VzcyB1c2VkIGJ5IG91ciBvd24gcGFnZXMgbGlrZSB0aGUgYmFja2dyb3VuZCBwYWdlLCBkYXNoYm9hcmQsIG9yIHBvcHVwc1xuICAgIGlmIChpICUgMjAgPT09IDApIGF3YWl0IG5ldyBQcm9taXNlKHNldFRpbWVvdXQpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBpMThuLCBkZWZhdWx0SW1hZ2UsIHNlbmRUYWJDbWQgfSBmcm9tICcjL2NvbW1vbic7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5cbmNvbnN0IG9wZW5lcnMgPSB7fTtcblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICAvKiogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fSAqL1xuICBhc3luYyBOb3RpZmljYXRpb24oZGF0YSwgc3JjLCBiZ0V4dHJhcykge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbklkID0gYXdhaXQgYnJvd3Nlci5ub3RpZmljYXRpb25zLmNyZWF0ZSh7XG4gICAgICB0eXBlOiAnYmFzaWMnLFxuICAgICAgdGl0bGU6IGRhdGEudGl0bGUgfHwgKElTX0ZJUkVGT1ggPyBpMThuKCdleHROYW1lJykgOiAnJyksIC8vIENocm9tZSBhbHJlYWR5IHNob3dzIHRoZSBuYW1lXG4gICAgICBtZXNzYWdlOiBkYXRhLnRleHQsXG4gICAgICBpY29uVXJsOiBkYXRhLmltYWdlIHx8IGRlZmF1bHRJbWFnZSxcbiAgICB9KTtcbiAgICBvcGVuZXJzW25vdGlmaWNhdGlvbklkXSA9IGJnRXh0cmFzPy5vbkNsaWNrIHx8IHNyYy50YWIuaWQ7XG4gICAgcmV0dXJuIG5vdGlmaWNhdGlvbklkO1xuICB9LFxuICBSZW1vdmVOb3RpZmljYXRpb24obm90aWZpY2F0aW9uSWQpIHtcbiAgICByZXR1cm4gYnJvd3Nlci5ub3RpZmljYXRpb25zLmNsZWFyKG5vdGlmaWNhdGlvbklkKTtcbiAgfSxcbn0pO1xuXG5icm93c2VyLm5vdGlmaWNhdGlvbnMub25DbGlja2VkLmFkZExpc3RlbmVyKChpZCkgPT4ge1xuICBjb25zdCBvcGVuZXJJZCA9IG9wZW5lcnNbaWRdO1xuICBpZiAob3BlbmVySWQgPj0gMCkge1xuICAgIHNlbmRUYWJDbWQob3BlbmVySWQsICdOb3RpZmljYXRpb25DbGljaycsIGlkKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wZW5lcklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3BlbmVySWQoKTtcbiAgfVxufSk7XG5cbmJyb3dzZXIubm90aWZpY2F0aW9ucy5vbkNsb3NlZC5hZGRMaXN0ZW5lcigoaWQpID0+IHtcbiAgY29uc3Qgb3BlbmVySWQgPSBvcGVuZXJzW2lkXTtcbiAgZGVsZXRlIG9wZW5lcnNbaWRdO1xuICBpZiAob3BlbmVySWQgPj0gMCkge1xuICAgIHNlbmRUYWJDbWQob3BlbmVySWQsICdOb3RpZmljYXRpb25DbG9zZScsIGlkKTtcbiAgfVxufSk7XG4iLCJpbXBvcnQge1xuICBkZWJvdW5jZSwgZW5zdXJlQXJyYXksIGluaXRIb29rcywgbm9ybWFsaXplS2V5cyxcbn0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgbWFwRW50cnksIG9iamVjdEdldCwgb2JqZWN0U2V0IH0gZnJvbSAnIy9jb21tb24vb2JqZWN0JztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcjL2NvbW1vbi9vcHRpb25zLWRlZmF1bHRzJztcbmltcG9ydCB7IHByZUluaXRpYWxpemUgfSBmcm9tICcuL2luaXQnO1xuaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuL21lc3NhZ2UnO1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIC8qKiBAcmV0dXJuIHtPYmplY3R9ICovXG4gIEdldEFsbE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLkdldE9wdGlvbnMoZGVmYXVsdHMpO1xuICB9LFxuICAvKiogQHJldHVybiB7T2JqZWN0fSAqL1xuICBHZXRPcHRpb25zKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTo6bWFwRW50cnkoKFtrZXldKSA9PiBnZXRPcHRpb24oa2V5KSk7XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHt2b2lkfSAqL1xuICBTZXRPcHRpb25zKGRhdGEpIHtcbiAgICBlbnN1cmVBcnJheShkYXRhKS5mb3JFYWNoKGl0ZW0gPT4gc2V0T3B0aW9uKGl0ZW0ua2V5LCBpdGVtLnZhbHVlKSk7XG4gIH0sXG59KTtcblxubGV0IGNoYW5nZXMgPSB7fTtcbmNvbnN0IGhvb2tzID0gaW5pdEhvb2tzKCk7XG5jb25zdCBjYWxsSG9va3NMYXRlciA9IGRlYm91bmNlKGNhbGxIb29rcywgMTAwKTtcblxubGV0IG9wdGlvbnMgPSB7fTtcbmxldCBpbml0UGVuZGluZyA9IGJyb3dzZXIuc3RvcmFnZS5sb2NhbC5nZXQoJ29wdGlvbnMnKVxuLnRoZW4oKHsgb3B0aW9uczogZGF0YSB9KSA9PiB7XG4gIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykgb3B0aW9ucyA9IGRhdGE7XG4gIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGNvbnNvbGUubG9nKCdvcHRpb25zOicsIG9wdGlvbnMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfVxuICBpZiAoIW9iamVjdEdldChvcHRpb25zLCAndmVyc2lvbicpKSB7XG4gICAgc2V0T3B0aW9uKCd2ZXJzaW9uJywgMSk7XG4gIH1cbiAgaW5pdFBlbmRpbmcgPSBudWxsO1xufSk7XG5wcmVJbml0aWFsaXplLnB1c2goaW5pdFBlbmRpbmcpO1xuXG5mdW5jdGlvbiBmaXJlQ2hhbmdlKGtleXMsIHZhbHVlKSB7XG4gIC8vIEZsYXR0ZW5pbmcga2V5IHBhdGggc28gdGhlIHN1YnNjcmliZXJzIGNhbiB1cGRhdGUgbmVzdGVkIHZhbHVlcyB3aXRob3V0IG92ZXJ3cml0aW5nIHRoZSBwYXJlbnRcbiAgY29uc3Qga2V5ID0ga2V5cy5qb2luKCcuJyk7XG4gIC8vIEVuc3VyaW5nIHRoZSBjb3JyZWN0IG9yZGVyIHdoZW4gdXBkYXRlcyB3ZXJlIG1peGVkIGxpa2UgdGhpczogZm9vLmJhcj0xOyBmb289e2JhcjoyfTsgZm9vLmJhcj0zXG4gIGRlbGV0ZSBjaGFuZ2VzW2tleV07XG4gIGNoYW5nZXNba2V5XSA9IHZhbHVlO1xuICBjYWxsSG9va3NMYXRlcigpO1xufVxuXG5mdW5jdGlvbiBjYWxsSG9va3MoKSB7XG4gIGhvb2tzLmZpcmUoY2hhbmdlcyk7XG4gIGNoYW5nZXMgPSB7fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wdGlvbihrZXksIGRlZikge1xuICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5cyhrZXkpO1xuICBjb25zdCBtYWluS2V5ID0ga2V5c1swXTtcbiAgbGV0IHZhbHVlID0gb3B0aW9uc1ttYWluS2V5XTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHZhbHVlID0gZGVmYXVsdHNbbWFpbktleV07XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB2YWx1ZSA9IGRlZjtcbiAgcmV0dXJuIGtleXMubGVuZ3RoID4gMSA/IG9iamVjdEdldCh2YWx1ZSwga2V5cy5zbGljZSgxKSwgZGVmKSA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdE9wdGlvbihrZXkpIHtcbiAgcmV0dXJuIG9iamVjdEdldChkZWZhdWx0cywga2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wdGlvbihrZXksIHZhbHVlKSB7XG4gIGlmIChpbml0UGVuZGluZykge1xuICAgIGluaXRQZW5kaW5nLnRoZW4oKCkgPT4ge1xuICAgICAgc2V0T3B0aW9uKGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5cyhrZXkpO1xuICBjb25zdCBvcHRpb25LZXkgPSBrZXlzLmpvaW4oJy4nKTtcbiAgbGV0IG9wdGlvblZhbHVlID0gdmFsdWU7XG4gIGNvbnN0IG1haW5LZXkgPSBrZXlzWzBdO1xuICBpZiAobWFpbktleSBpbiBkZWZhdWx0cykge1xuICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIG9wdGlvblZhbHVlID0gb2JqZWN0U2V0KGdldE9wdGlvbihtYWluS2V5KSwga2V5cy5zbGljZSgxKSwgdmFsdWUpO1xuICAgIH1cbiAgICBvcHRpb25zW21haW5LZXldID0gb3B0aW9uVmFsdWU7XG4gICAgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldCh7IG9wdGlvbnMgfSk7XG4gICAgZmlyZUNoYW5nZShrZXlzLCB2YWx1ZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICBjb25zb2xlLmxvZygnT3B0aW9ucyB1cGRhdGVkOicsIG9wdGlvbktleSwgdmFsdWUsIG9wdGlvbnMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGhvb2tPcHRpb25zID0gaG9va3MuaG9vaztcbiIsImltcG9ydCB7IHBhcnNlTWV0YSB9IGZyb20gJy4vc2NyaXB0JztcbmltcG9ydCBzdG9yYWdlIGZyb20gJyMvY29tbW9uL3N0b3JhZ2UnO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIGNvbnNvbGUuaW5mbygnVXBncmFkZSBkYXRhYmFzZS4uLicpO1xuICBpbml0KCk7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgY29uc3QgcmVxID0gaW5kZXhlZERCLm9wZW4oJ1Zpb2xlbnRtb25rZXknLCAxKTtcbiAgICByZXEub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhbnNmb3JtKHJlcS5yZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCBkaWQgaGFwcGVuIGluIEZpcmVmb3guXG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgcmVxLm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcbiAgICAgIC8vIE5vIGF2YWlsYWJsZSB1cGdyYWRhdGlvblxuICAgICAgcmVqZWN0KCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2Zvcm0oZGIpIHtcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFsnc2NyaXB0cycsICdyZXF1aXJlJywgJ2NhY2hlJywgJ3ZhbHVlcyddKTtcbiAgICBjb25zdCB1cGRhdGVzID0ge307XG4gICAgbGV0IHByb2Nlc3NpbmcgPSAzO1xuICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICBwcm9jZXNzaW5nIC09IDE7XG4gICAgICBpZiAoIXByb2Nlc3NpbmcpIHJlc29sdmUoYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldCh1cGRhdGVzKSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRBbGwgPSAoc3RvcmVOYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgcmVxID0gdHgub2JqZWN0U3RvcmUoc3RvcmVOYW1lKS5nZXRBbGwoKTtcbiAgICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiBjYWxsYmFjayhyZXEucmVzdWx0KTtcbiAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgIH07XG4gICAgZ2V0QWxsKCdzY3JpcHRzJywgKGFsbFNjcmlwdHMpID0+IHtcbiAgICAgIGNvbnN0IHVyaU1hcCA9IHt9O1xuICAgICAgYWxsU2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2RlLCBpZCwgdXJpIH0gPSBzY3JpcHQ7XG4gICAgICAgIHVwZGF0ZXNbYCR7c3RvcmFnZS5zY3JpcHQucHJlZml4fSR7aWR9YF0gPSB0cmFuc2Zvcm1TY3JpcHQoc2NyaXB0KTtcbiAgICAgICAgdXBkYXRlc1tgJHtzdG9yYWdlLmNvZGUucHJlZml4fSR7aWR9YF0gPSBjb2RlO1xuICAgICAgICB1cmlNYXBbdXJpXSA9IGlkO1xuICAgICAgfSk7XG4gICAgICBnZXRBbGwoJ3ZhbHVlcycsIChhbGxWYWx1ZXMpID0+IHtcbiAgICAgICAgYWxsVmFsdWVzLmZvckVhY2goKHsgdXJpLCB2YWx1ZXMgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gdXJpTWFwW3VyaV07XG4gICAgICAgICAgaWYgKGlkKSB1cGRhdGVzW2Ake3N0b3JhZ2UudmFsdWUucHJlZml4fSR7aWR9YF0gPSB2YWx1ZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBnZXRBbGwoJ2NhY2hlJywgKGFsbENhY2hlKSA9PiB7XG4gICAgICBhbGxDYWNoZS5mb3JFYWNoKCh7IHVyaSwgZGF0YSB9KSA9PiB7XG4gICAgICAgIHVwZGF0ZXNbYCR7c3RvcmFnZS5jYWNoZS5wcmVmaXh9JHt1cml9YF0gPSBkYXRhO1xuICAgICAgfSk7XG4gICAgICBkb25lKCk7XG4gICAgfSk7XG4gICAgZ2V0QWxsKCdyZXF1aXJlJywgKGFsbFJlcXVpcmUpID0+IHtcbiAgICAgIGFsbFJlcXVpcmUuZm9yRWFjaCgoeyB1cmksIGNvZGUgfSkgPT4ge1xuICAgICAgICB1cGRhdGVzW2Ake3N0b3JhZ2UucmVxdWlyZS5wcmVmaXh9JHt1cml9YF0gPSBjb2RlO1xuICAgICAgfSk7XG4gICAgICBkb25lKCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNmb3JtU2NyaXB0KHNjcmlwdCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRhOiBwYXJzZU1ldGEoc2NyaXB0LmNvZGUpLFxuICAgICAgY3VzdG9tOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgb3JpZ0luY2x1ZGU6IHRydWUsXG4gICAgICAgIG9yaWdFeGNsdWRlOiB0cnVlLFxuICAgICAgICBvcmlnTWF0Y2g6IHRydWUsXG4gICAgICAgIG9yaWdFeGNsdWRlTWF0Y2g6IHRydWUsXG4gICAgICB9LCBzY3JpcHQuY3VzdG9tKSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGlkOiBzY3JpcHQuaWQsXG4gICAgICAgIHVyaTogc2NyaXB0LnVyaSxcbiAgICAgICAgcG9zaXRpb246IHNjcmlwdC5wb3NpdGlvbixcbiAgICAgIH0sXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgZW5hYmxlZDogc2NyaXB0LmVuYWJsZWQsXG4gICAgICAgIHNob3VsZFVwZGF0ZTogc2NyaXB0LnVwZGF0ZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufSlcbi8vIElnbm9yZSBlcnJvclxuLmNhdGNoKCgpID0+IHt9KTtcbiIsImltcG9ydCB7IGdldEFjdGl2ZVRhYiwgc2VuZFRhYkNtZCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCBjYWNoZSBmcm9tICcuL2NhY2hlJztcbmltcG9ydCB7IGdldERhdGEgfSBmcm9tICcuL2RiJztcbmltcG9ydCB7IHBvc3RJbml0aWFsaXplIH0gZnJvbSAnLi9pbml0JztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi9tZXNzYWdlJztcblxuZXhwb3J0IGNvbnN0IHBvcHVwVGFicyA9IHt9OyAvLyB7IHRhYklkOiAxIH1cblxucG9zdEluaXRpYWxpemUucHVzaCgoKSA9PiB7XG4gIGJyb3dzZXIucnVudGltZS5vbkNvbm5lY3QuYWRkTGlzdGVuZXIob25Qb3B1cE9wZW5lZCk7XG4gIGJyb3dzZXIud2ViUmVxdWVzdC5vbkJlZm9yZVJlcXVlc3QuYWRkTGlzdGVuZXIocHJlZmV0Y2hTZXRQb3B1cCwge1xuICAgIHVybHM6IFticm93c2VyLnJ1bnRpbWUuZ2V0VVJMKGJyb3dzZXIucnVudGltZS5nZXRNYW5pZmVzdCgpLmJyb3dzZXJfYWN0aW9uLmRlZmF1bHRfcG9wdXApXSxcbiAgICB0eXBlczogWydtYWluX2ZyYW1lJ10sXG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIG9uUG9wdXBPcGVuZWQocG9ydCkge1xuICBjb25zdCB0YWJJZCA9ICtwb3J0Lm5hbWU7XG4gIHBvcHVwVGFic1t0YWJJZF0gPSAxO1xuICBzZW5kVGFiQ21kKHRhYklkLCAnUG9wdXBTaG93bicsIHRydWUpO1xuICBwb3J0Lm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcihvblBvcHVwQ2xvc2VkKTtcbiAgZGVsZXRlIGNvbW1hbmRzLlNldFBvcHVwO1xufVxuXG5mdW5jdGlvbiBvblBvcHVwQ2xvc2VkKHsgbmFtZSB9KSB7XG4gIGRlbGV0ZSBwb3B1cFRhYnNbbmFtZV07XG4gIHNlbmRUYWJDbWQoK25hbWUsICdQb3B1cFNob3duJywgZmFsc2UpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFNldFBvcHVwKCkge1xuICBjb25zdCB0YWJJZCA9IChhd2FpdCBnZXRBY3RpdmVUYWIoKSkuaWQ7XG4gIHNlbmRUYWJDbWQodGFiSWQsICdQb3B1cFNob3duJywgdHJ1ZSk7XG4gIGNvbW1hbmRzLlNldFBvcHVwID0gYXN5bmMgKGRhdGEsIHNyYykgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgYXdhaXQgZ2V0RGF0YShkYXRhLmlkcykpO1xuICAgIGNhY2hlLnB1dCgnU2V0UG9wdXAnLCBPYmplY3QuYXNzaWduKHsgW3NyYy5mcmFtZUlkXTogW2RhdGEsIHNyY10gfSwgY2FjaGUuZ2V0KCdTZXRQb3B1cCcpKSk7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBnZXRTY3JpcHROYW1lLCBnZXRVbmlxSWQgfSBmcm9tICcjL2NvbW1vbic7XG5pbXBvcnQge1xuICBJTkpFQ1RfQVVUTywgSU5KRUNUX0NPTlRFTlQsIElOSkVDVF9NQVBQSU5HLFxuICBJTkpFQ1RBQkxFX1RBQl9VUkxfUkUsIE1FVEFCTE9DS19SRSxcbn0gZnJvbSAnIy9jb21tb24vY29uc3RzJztcbmltcG9ydCBpbml0Q2FjaGUgZnJvbSAnIy9jb21tb24vY2FjaGUnO1xuaW1wb3J0IHsgZm9yRWFjaEVudHJ5LCBvYmplY3RQaWNrLCBvYmplY3RTZXQgfSBmcm9tICcjL2NvbW1vbi9vYmplY3QnO1xuaW1wb3J0IHN0b3JhZ2UgZnJvbSAnIy9jb21tb24vc3RvcmFnZSc7XG5pbXBvcnQgdWEgZnJvbSAnIy9jb21tb24vdWEnO1xuaW1wb3J0IHsgZ2V0U2NyaXB0c0J5VVJMLCBFTlZfQ0FDSEVfS0VZUywgRU5WX1JFUV9LRVlTLCBFTlZfVkFMVUVfSURTIH0gZnJvbSAnLi9kYic7XG5pbXBvcnQgeyBleHRlbnNpb25Sb290LCBwb3N0SW5pdGlhbGl6ZSB9IGZyb20gJy4vaW5pdCc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgeyBnZXRPcHRpb24sIGhvb2tPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJztcblxuY29uc3QgQVBJX0NPTkZJRyA9IHtcbiAgdXJsczogWycqOi8vKi8qJ10sIC8vIGAqYCBzY2hlbWUgbWF0Y2hlcyBvbmx5IGh0dHAgYW5kIGh0dHBzXG4gIHR5cGVzOiBbJ21haW5fZnJhbWUnLCAnc3ViX2ZyYW1lJ10sXG59O1xuY29uc3QgVElNRV9BRlRFUl9TRU5EID0gMTBlMzsgLy8gbG9uZ2VyIGFzIGVzdGFibGlzaGluZyBjb25uZWN0aW9uIHRvIHNpdGVzIG1heSB0YWtlIHRpbWVcbmNvbnN0IFRJTUVfQUZURVJfUkVDRUlWRSA9IDFlMzsgLy8gc2hvcnRlciBhcyByZXNwb25zZSBib2R5IHdpbGwgYmUgY29taW5nIHZlcnkgc29vblxuY29uc3QgVElNRV9LRUVQX0RBVEEgPSA2MGUzOyAvLyAxMDBtcyBzaG91bGQgYmUgZW5vdWdoIGJ1dCB0aGUgdGFiIG1heSBoYW5nIG9yIGdldCBwYXVzZWQgaW4gZGVidWdnZXJcbmNvbnN0IGNhY2hlQ29kZSA9IGluaXRDYWNoZSh7IGxpZmV0aW1lOiBUSU1FX0tFRVBfREFUQSB9KTtcbmNvbnN0IGNhY2hlID0gaW5pdENhY2hlKHtcbiAgbGlmZXRpbWU6IFRJTUVfS0VFUF9EQVRBLFxuICBvbkRpc3Bvc2U6IGFzeW5jIHByb21pc2UgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwcm9taXNlO1xuICAgIGNvbnN0IHJjcyA9IGF3YWl0IGRhdGE/LnJjc1Byb21pc2U7XG4gICAgcmNzPy51bnJlZ2lzdGVyKCk7XG4gIH0sXG59KTtcbmNvbnN0IElOSkVDVF9JTlRPID0gJ2luamVjdEludG8nO1xuLy8gS0VZX1hYWCBmb3IgaG9va2VkIG9wdGlvbnNcbmNvbnN0IEtFWV9FWFBPU0UgPSAnZXhwb3NlJztcbmNvbnN0IEtFWV9ERUZfSU5KRUNUX0lOVE8gPSAnZGVmYXVsdEluamVjdEludG8nO1xuY29uc3QgS0VZX0lTX0FQUExJRUQgPSAnaXNBcHBsaWVkJztcbmNvbnN0IEtFWV9YSFJfSU5KRUNUID0gJ3hockluamVjdCc7XG5jb25zdCBleHBvc2UgPSB7fTtcbmxldCBpc0FwcGxpZWQ7XG5sZXQgaW5qZWN0SW50bztcbmxldCB4aHJJbmplY3Q7XG5ob29rT3B0aW9ucyhvbk9wdGlvbkNoYW5nZWQpO1xucG9zdEluaXRpYWxpemUucHVzaCgoKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIFtLRVlfRVhQT1NFLCBLRVlfREVGX0lOSkVDVF9JTlRPLCBLRVlfSVNfQVBQTElFRCwgS0VZX1hIUl9JTkpFQ1RdKSB7XG4gICAgb25PcHRpb25DaGFuZ2VkKHsgW2tleV06IGdldE9wdGlvbihrZXkpIH0pO1xuICB9XG59KTtcblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICBhc3luYyBJbmplY3Rpb25GZWVkYmFjayh7IGZlZWRJZCwgZmVlZGJhY2ssIGZvcmNlQ29udGVudCB9LCBzcmMpIHtcbiAgICBmZWVkYmFjay5mb3JFYWNoKHByb2Nlc3NGZWVkYmFjaywgc3JjKTtcbiAgICBpZiAoZmVlZElkKSB7XG4gICAgICAvLyBjYWNoZSBjbGVhbnVwIHdoZW4gZ2V0RGF0YUZGIG91dHJ1bnMgR2V0SW5qZWN0ZWRcbiAgICAgIGNhY2hlLmRlbChmZWVkSWQuY2FjaGVLZXkpO1xuICAgICAgLy8gZW52RGVsYXllZFxuICAgICAgY29uc3QgZW52ID0gYXdhaXQgY2FjaGUucG9wKGZlZWRJZC5lbnZLZXkpO1xuICAgICAgaWYgKGVudikge1xuICAgICAgICBlbnYuZm9yY2VDb250ZW50ID0gZm9yY2VDb250ZW50O1xuICAgICAgICBlbnYuc2NyaXB0cy5tYXAocHJlcGFyZVNjcmlwdCwgZW52KS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChwcm9jZXNzRmVlZGJhY2ssIHNyYyk7XG4gICAgICAgIHJldHVybiBvYmplY3RQaWNrKGVudiwgWydjYWNoZScsICdzY3JpcHRzJ10pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pO1xuXG4vKiogQHRoaXMge2Nocm9tZS5ydW50aW1lLk1lc3NhZ2VTZW5kZXJ9ICovXG5mdW5jdGlvbiBwcm9jZXNzRmVlZGJhY2soW2tleSwgbmVlZHNJbmplY3Rpb25dKSB7XG4gIGNvbnN0IGNvZGUgPSBjYWNoZUNvZGUucG9wKGtleSk7XG4gIC8vIHNlZSBUSU1FX0tFRVBfREFUQSBjb21tZW50XG4gIGlmIChuZWVkc0luamVjdGlvbiAmJiBjb2RlKSB7XG4gICAgYnJvd3Nlci50YWJzLmV4ZWN1dGVTY3JpcHQodGhpcy50YWIuaWQsIHtcbiAgICAgIGNvZGUsXG4gICAgICBmcmFtZUlkOiB0aGlzLmZyYW1lSWQsXG4gICAgICBydW5BdDogJ2RvY3VtZW50X3N0YXJ0JyxcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBwcm9wc1RvQ2xlYXIgPSB7XG4gIFtzdG9yYWdlLmNhY2hlLnByZWZpeF06IEVOVl9DQUNIRV9LRVlTLFxuICBbc3RvcmFnZS5jb2RlLnByZWZpeF06IHRydWUsXG4gIFtzdG9yYWdlLnJlcXVpcmUucHJlZml4XTogRU5WX1JFUV9LRVlTLFxuICBbc3RvcmFnZS5zY3JpcHQucHJlZml4XTogdHJ1ZSxcbiAgW3N0b3JhZ2UudmFsdWUucHJlZml4XTogRU5WX1ZBTFVFX0lEUyxcbn07XG5cbmJyb3dzZXIuc3RvcmFnZS5vbkNoYW5nZWQuYWRkTGlzdGVuZXIoYXN5bmMgY2hhbmdlcyA9PiB7XG4gIGNvbnN0IGRiS2V5cyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpO1xuICBjb25zdCBjYWNoZVZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKGNhY2hlLmdldFZhbHVlcygpKTtcbiAgY29uc3QgZGlydHkgPSBjYWNoZVZhbHVlcy5zb21lKGRhdGEgPT4gZGF0YS5pbmplY3RcbiAgICAmJiBkYktleXMuc29tZSgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBrZXkuc2xpY2UoMCwga2V5LmluZGV4T2YoJzonKSArIDEpO1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzVG9DbGVhcltwcmVmaXhdO1xuICAgICAga2V5ID0ga2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHByb3AgPT09IHRydWVcbiAgICAgICAgfHwgZGF0YVtwcm9wXT8uaW5jbHVkZXMocHJlZml4ID09PSBzdG9yYWdlLnZhbHVlLnByZWZpeCA/ICtrZXkgOiBrZXkpO1xuICAgIH0pKTtcbiAgaWYgKGRpcnR5KSB7XG4gICAgY2FjaGUuZGVzdHJveSgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplUmVhbG0odmFsdWUpIHtcbiAgcmV0dXJuIElOSkVDVF9NQVBQSU5HOjpoYXNPd25Qcm9wZXJ0eSh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiBpbmplY3RJbnRvIHx8IElOSkVDVF9BVVRPO1xufVxuXG5mdW5jdGlvbiBvbk9wdGlvbkNoYW5nZWQoY2hhbmdlcykge1xuICBjaGFuZ2VzOjpmb3JFYWNoRW50cnkoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBLRVlfREVGX0lOSkVDVF9JTlRPOlxuICAgICAgaW5qZWN0SW50byA9IG5vcm1hbGl6ZVJlYWxtKHZhbHVlKTtcbiAgICAgIGNhY2hlLmRlc3Ryb3koKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgS0VZX1hIUl9JTkpFQ1Q6XG4gICAgICB0b2dnbGVYaHJJbmplY3QodmFsdWUpO1xuICAgICAgY2FjaGUuZGVzdHJveSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLRVlfSVNfQVBQTElFRDpcbiAgICAgIHRvZ2dsZVByZWluamVjdCh2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEtFWV9FWFBPU0U6XG4gICAgICB2YWx1ZTo6Zm9yRWFjaEVudHJ5KChbc2l0ZSwgaXNFeHBvc2VkXSkgPT4ge1xuICAgICAgICBleHBvc2VbZGVjb2RlVVJJQ29tcG9uZW50KHNpdGUpXSA9IGlzRXhwb3NlZDtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkgeyAvLyB1c2VkIGJ5IGBleHBvc2UudXJsYFxuICAgICAgICBvbk9wdGlvbkNoYW5nZWQob2JqZWN0U2V0KHt9LCBrZXksIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmplY3RlZFNjcmlwdHModXJsLCB0YWJJZCwgZnJhbWVJZCwgZm9yY2VDb250ZW50KSB7XG4gIGNvbnN0IGtleSA9IGdldEtleSh1cmwsICFmcmFtZUlkKTtcbiAgcmV0dXJuIGNhY2hlLnBvcChrZXkpIHx8IHByZXBhcmUoa2V5LCB1cmwsIHRhYklkLCBmcmFtZUlkLCBmb3JjZUNvbnRlbnQpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXkodXJsLCBpc1RvcCkge1xuICByZXR1cm4gaXNUb3AgPyB1cmwgOiBgLSR7dXJsfWA7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZVByZWluamVjdChlbmFibGUpIHtcbiAgaXNBcHBsaWVkID0gZW5hYmxlO1xuICAvLyBVc2luZyBvblNlbmRIZWFkZXJzIGJlY2F1c2Ugb25IZWFkZXJzUmVjZWl2ZWQgaW4gRmlyZWZveCBmaXJlcyAqYWZ0ZXIqIGNvbnRlbnQgc2NyaXB0cy5cbiAgLy8gQW5kIGV2ZW4gaW4gQ2hyb21lIGEgc2l0ZSBtYXkgYmUgc28gZmFzdCB0aGF0IHByZWluamVjdCBvbiBvbkhlYWRlcnNSZWNlaXZlZCB3b24ndCBiZSB1c2VmdWwuXG4gIGNvbnN0IG9uT2ZmID0gYCR7ZW5hYmxlID8gJ2FkZCcgOiAncmVtb3ZlJ31MaXN0ZW5lcmA7XG4gIGNvbnN0IGNvbmZpZyA9IGVuYWJsZSA/IEFQSV9DT05GSUcgOiB1bmRlZmluZWQ7XG4gIGJyb3dzZXIud2ViUmVxdWVzdC5vblNlbmRIZWFkZXJzW29uT2ZmXShvblNlbmRIZWFkZXJzLCBjb25maWcpO1xuICBpZiAoIWlzQXBwbGllZCB8fCAheGhySW5qZWN0KSB7IC8vIHdpbGwgYmUgcmVnaXN0ZXJlZCBpbiB0b2dnbGVYaHJJbmplY3RcbiAgICBicm93c2VyLndlYlJlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWRbb25PZmZdKG9uSGVhZGVyc1JlY2VpdmVkLCBjb25maWcpO1xuICB9XG4gIGNhY2hlLmRlc3Ryb3koKTtcbn1cblxuZnVuY3Rpb24gdG9nZ2xlWGhySW5qZWN0KGVuYWJsZSkge1xuICB4aHJJbmplY3QgPSBlbmFibGU7XG4gIGJyb3dzZXIud2ViUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZC5yZW1vdmVMaXN0ZW5lcihvbkhlYWRlcnNSZWNlaXZlZCk7XG4gIGlmIChlbmFibGUpIHtcbiAgICBicm93c2VyLndlYlJlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQuYWRkTGlzdGVuZXIob25IZWFkZXJzUmVjZWl2ZWQsIEFQSV9DT05GSUcsIFtcbiAgICAgICdibG9ja2luZycsXG4gICAgICAncmVzcG9uc2VIZWFkZXJzJyxcbiAgICAgIGJyb3dzZXIud2ViUmVxdWVzdC5PbkhlYWRlcnNSZWNlaXZlZE9wdGlvbnMuRVhUUkFfSEVBREVSUyxcbiAgICBdLmZpbHRlcihCb29sZWFuKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25TZW5kSGVhZGVycyh7IHVybCwgdGFiSWQsIGZyYW1lSWQgfSkge1xuICBpZiAoIUlOSkVDVEFCTEVfVEFCX1VSTF9SRS50ZXN0KHVybCkpIHJldHVybjtcbiAgY29uc3QgaXNUb3AgPSAhZnJhbWVJZDtcbiAgY29uc3Qga2V5ID0gZ2V0S2V5KHVybCwgaXNUb3ApO1xuICBpZiAoIWNhY2hlLmhhcyhrZXkpKSB7XG4gICAgLy8gR2V0SW5qZWN0ZWQgbWVzc2FnZSB3aWxsIGJlIHNlbnQgc29vbiBieSB0aGUgY29udGVudCBzY3JpcHRcbiAgICAvLyBhbmQgaXQgbWF5IGVhc2lseSBoYXBwZW4gd2hpbGUgZ2V0U2NyaXB0c0J5VVJMIGlzIHN0aWxsIHdhaXRpbmcgZm9yIGJyb3dzZXIuc3RvcmFnZVxuICAgIC8vIHNvIHdlJ2xsIGxldCBHZXRJbmplY3RlZCBhd2FpdCB0aGlzIHBlbmRpbmcgZGF0YSBieSBzdG9yaW5nIFByb21pc2UgaW4gdGhlIGNhY2hlXG4gICAgY2FjaGUucHV0KGtleSwgcHJlcGFyZShrZXksIHVybCwgdGFiSWQsIGZyYW1lSWQpLCBUSU1FX0FGVEVSX1NFTkQpO1xuICB9XG59XG5cbi8qKiBAcGFyYW0ge2Nocm9tZS53ZWJSZXF1ZXN0LldlYlJlc3BvbnNlSGVhZGVyc0RldGFpbHN9IGluZm8gKi9cbmZ1bmN0aW9uIG9uSGVhZGVyc1JlY2VpdmVkKGluZm8pIHtcbiAgY29uc3Qga2V5ID0gZ2V0S2V5KGluZm8udXJsLCAhaW5mby5mcmFtZUlkKTtcbiAgY29uc3QgZGF0YSA9IHhockluamVjdCAmJiBjYWNoZS5nZXQoa2V5KTtcbiAgY2FjaGUuaGl0KGtleSwgVElNRV9BRlRFUl9SRUNFSVZFKTtcbiAgcmV0dXJuIGRhdGE/LmluamVjdCAmJiBwcmVwYXJlWGhyQmxvYihpbmZvLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Nocm9tZS53ZWJSZXF1ZXN0LldlYlJlc3BvbnNlSGVhZGVyc0RldGFpbHN9IGluZm9cbiAqIEBwYXJhbSB7Vk1HZXRJbmplY3RlZERhdGFDb250YWluZXJ9IGRhdGFcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZVhockJsb2IoeyB1cmwsIHJlc3BvbnNlSGVhZGVycyB9LCBkYXRhKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JykgJiYgZGV0ZWN0U3RyaWN0Q3NwKHJlc3BvbnNlSGVhZGVycykpIHtcbiAgICBmb3JjZUNvbnRlbnRJbmplY3Rpb24oZGF0YSk7XG4gIH1cbiAgY29uc3QgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW1xuICAgIEpTT04uc3RyaW5naWZ5KGRhdGEuaW5qZWN0KSxcbiAgXSkpO1xuICByZXNwb25zZUhlYWRlcnMucHVzaCh7XG4gICAgbmFtZTogJ1NldC1Db29raWUnLFxuICAgIHZhbHVlOiBgXCIke3Byb2Nlc3MuZW52LklOSVRfRlVOQ19OQU1FfVwiPSR7YmxvYlVybC5zcGxpdCgnLycpLnBvcCgpfTsgU2FtZVNpdGU9TGF4YCxcbiAgfSk7XG4gIHNldFRpbWVvdXQoVVJMLnJldm9rZU9iamVjdFVSTCwgVElNRV9LRUVQX0RBVEEsIGJsb2JVcmwpO1xuICByZXR1cm4geyByZXNwb25zZUhlYWRlcnMgfTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZShrZXksIHVybCwgdGFiSWQsIGZyYW1lSWQsIGZvcmNlQ29udGVudCkge1xuICAvKiogQG5hbWVzcGFjZSBWTUdldEluamVjdGVkRGF0YUNvbnRhaW5lciAqL1xuICBjb25zdCByZXMgPSB7XG4gICAgLyoqIEBuYW1lc3BhY2UgVk1HZXRJbmplY3RlZERhdGEgKi9cbiAgICBpbmplY3Q6IHtcbiAgICAgIGV4cG9zZTogIWZyYW1lSWRcbiAgICAgICAgJiYgdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJylcbiAgICAgICAgJiYgZXhwb3NlW3VybC5zcGxpdCgnLycsIDMpWzJdXSxcbiAgICB9LFxuICB9O1xuICByZXR1cm4gaXNBcHBsaWVkXG4gICAgPyBwcmVwYXJlU2NyaXB0cyhyZXMsIGtleSwgdXJsLCB0YWJJZCwgZnJhbWVJZCwgZm9yY2VDb250ZW50KVxuICAgIDogcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlU2NyaXB0cyhyZXMsIGNhY2hlS2V5LCB1cmwsIHRhYklkLCBmcmFtZUlkLCBmb3JjZUNvbnRlbnQpIHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFNjcmlwdHNCeVVSTCh1cmwsICFmcmFtZUlkKTtcbiAgY29uc3QgeyBlbnZEZWxheWVkLCBzY3JpcHRzIH0gPSBkYXRhO1xuICBjb25zdCBpc0xhdGUgPSBmb3JjZUNvbnRlbnQgIT0gbnVsbDtcbiAgZGF0YS5mb3JjZUNvbnRlbnQgPSBmb3JjZUNvbnRlbnQ7XG4gIGNvbnN0IGZlZWRiYWNrID0gc2NyaXB0cy5tYXAocHJlcGFyZVNjcmlwdCwgZGF0YSkuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBtb3JlID0gZW52RGVsYXllZC5wcm9taXNlO1xuICBjb25zdCBlbnZLZXkgPSBnZXRVbmlxSWQoYCR7dGFiSWR9OiR7ZnJhbWVJZH06YCk7XG4gIGNvbnN0IHsgaW5qZWN0IH0gPSByZXM7XG4gIC8qKiBAbmFtZXNwYWNlIFZNR2V0SW5qZWN0ZWREYXRhICovXG4gIE9iamVjdC5hc3NpZ24oaW5qZWN0LCB7XG4gICAgc2NyaXB0cyxcbiAgICBbSU5KRUNUX0lOVE9dOiBpbmplY3RJbnRvLFxuICAgIGNhY2hlOiBkYXRhLmNhY2hlLFxuICAgIGZlZWRJZDoge1xuICAgICAgY2FjaGVLZXksIC8vIEluamVjdGlvbkZlZWRiYWNrIGNhY2hlIGtleSBmb3IgY2xlYW51cCB3aGVuIGdldERhdGFGRiBvdXRydW5zIEdldEluamVjdGVkXG4gICAgICBlbnZLZXksIC8vIEluamVjdGlvbkZlZWRiYWNrIGNhY2hlIGtleSBmb3IgZW52RGVsYXllZFxuICAgIH0sXG4gICAgaGFzTW9yZTogISFtb3JlLCAvLyB0ZWxscyBjb250ZW50IGJyaWRnZSB0byBleHBlY3QgZW52RGVsYXllZFxuICAgIGZvcmNlQ29udGVudDogZm9yY2VDb250ZW50IHx8ICggLy8gVHJ5aW5nIHRvIHNraXAgcGFnZSBzYW5kYm94IHdoZW4geGhySW5qZWN0IGlzIG9uOlxuICAgICAgZmVlZGJhY2subGVuZ3RoID09PSBzY3JpcHRzLmxlbmd0aCAvLyAuLi53aGVuIGFsbCBgZW52U3RhcnRgIHNjcmlwdHMgYXJlIGBjb250ZW50YCxcbiAgICAgICYmIGVudkRlbGF5ZWQuc2NyaXB0cy5ldmVyeShzY3IgPT4gaXNDb250ZW50UmVhbG0oc2NyLCBmb3JjZUNvbnRlbnQpKSAvLyBhbmQgYGVudkRlbGF5ZWRgIHRvby5cbiAgICApLFxuICAgIGlkczogZGF0YS5kaXNhYmxlZElkcywgLy8gY29udGVudCBicmlkZ2UgYWRkcyB0aGUgYWN0dWFsbHkgcnVubmluZyBpZHMgYW5kIHNlbmRzIHZpYSBTZXRQb3B1cFxuICAgIGluZm86IHtcbiAgICAgIHVhLFxuICAgIH0sXG4gIH0pO1xuICAvKiogQG5hbWVzcGFjZSBWTUdldEluamVjdGVkRGF0YUNvbnRhaW5lciAqL1xuICBPYmplY3QuYXNzaWduKHJlcywge1xuICAgIGZlZWRiYWNrLFxuICAgIHZhbE9wSWRzOiBbLi4uZGF0YVtFTlZfVkFMVUVfSURTXSwgLi4uZW52RGVsYXllZFtFTlZfVkFMVUVfSURTXV0sXG4gICAgcmNzUHJvbWlzZTogIWlzTGF0ZSAmJiAheGhySW5qZWN0ICYmIElTX0ZJUkVGT1hcbiAgICAgID8gcmVnaXN0ZXJTY3JpcHREYXRhRkYoaW5qZWN0LCB1cmwsICEhZnJhbWVJZClcbiAgICAgIDogbnVsbCxcbiAgfSk7XG4gIGlmIChtb3JlKSBjYWNoZS5wdXQoZW52S2V5LCBtb3JlKTtcbiAgY2FjaGUucHV0KGNhY2hlS2V5LCByZXMpOyAvLyBuZWNlc3NhcnkgZm9yIHRoZSBzeW5jaHJvbm91cyBvbkhlYWRlcnNSZWNlaXZlZFxuICByZXR1cm4gcmVzO1xufVxuXG4vKiogQHRoaXMge1ZNU2NyaXB0QnlVcmxEYXRhfSAqL1xuZnVuY3Rpb24gcHJlcGFyZVNjcmlwdChzY3JpcHQpIHtcbiAgY29uc3QgeyBjdXN0b20sIG1ldGEsIHByb3BzIH0gPSBzY3JpcHQ7XG4gIGNvbnN0IHsgaWQgfSA9IHByb3BzO1xuICBjb25zdCB7IGZvcmNlQ29udGVudCwgcmVxdWlyZSwgdmFsdWUgfSA9IHRoaXM7XG4gIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGVbaWRdO1xuICBjb25zdCBkYXRhS2V5ID0gZ2V0VW5pcUlkKCdWTWluJyk7XG4gIGNvbnN0IGRpc3BsYXlOYW1lID0gZ2V0U2NyaXB0TmFtZShzY3JpcHQpO1xuICBjb25zdCBuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRpc3BsYXlOYW1lLnJlcGxhY2UoL1sjJicsLzo7P0A9K10vZywgcmVwbGFjZVdpdGhGdWxsV2lkdGhGb3JtKSk7XG4gIGNvbnN0IGlzQ29udGVudCA9IGlzQ29udGVudFJlYWxtKHNjcmlwdCwgZm9yY2VDb250ZW50KTtcbiAgY29uc3QgcGF0aE1hcCA9IGN1c3RvbS5wYXRoTWFwIHx8IHt9O1xuICBjb25zdCByZXFzID0gbWV0YS5yZXF1aXJlPy5tYXAoa2V5ID0+IHJlcXVpcmVbcGF0aE1hcFtrZXldIHx8IGtleV0pLmZpbHRlcihCb29sZWFuKTtcbiAgLy8gdHJ5aW5nIHRvIGF2b2lkIHByb2dyZXNzaXZlIHN0cmluZyBjb25jYXRlbmF0aW9uIG9mIHBvdGVudGlhbGx5IGh1Z2UgY29kZSBzbGljZXNcbiAgLy8gYWRkaW5nIGA7YCBvbiBhIG5ldyBsaW5lIGluIGNhc2Ugc29tZSByZXF1aXJlZCBzY3JpcHQgZW5kcyB3aXRoIGEgbGluZSBjb21tZW50XG4gIGNvbnN0IHJlcXNTbGljZXMgPSByZXFzID8gW10uY29uY2F0KC4uLnJlcXMubWFwKHJlcSA9PiBbcmVxLCAnXFxuOyddKSkgOiBbXTtcbiAgY29uc3QgaGFzUmVxcyA9IHJlcXNTbGljZXMubGVuZ3RoO1xuICBjb25zdCBpbmplY3RlZENvZGUgPSBbXG4gICAgLy8gaGlkaW5nIG1vZHVsZSBpbnRlcmZhY2UgZnJvbSBAcmVxdWlyZSdkIHNjcmlwdHMgc28gdGhleSBkb24ndCBtaXN0YWtlbmx5IHVzZSBpdFxuICAgIGB3aW5kb3cuJHtkYXRhS2V5fT1mdW5jdGlvbigke2RhdGFLZXl9KXt0cnl7d2l0aCh0aGlzKSgoZGVmaW5lLG1vZHVsZSxleHBvcnRzKT0+e2AsXG4gICAgLi4ucmVxc1NsaWNlcyxcbiAgICAvLyBhZGRpbmcgYSBuZXN0ZWQgSUlGRSB0byBzdXBwb3J0ICd1c2Ugc3RyaWN0JyBpbiB0aGUgY29kZSB3aGVuIHRoZXJlIGFyZSBAcmVxdWlyZXNcbiAgICBoYXNSZXFzID8gJygoKT0+eycgOiAnJyxcbiAgICBjb2RlLFxuICAgIC8vIGFkZGluZyBhIG5ldyBsaW5lIGluIGNhc2UgdGhlIGNvZGUgZW5kcyB3aXRoIGEgbGluZSBjb21tZW50XG4gICAgY29kZS5lbmRzV2l0aCgnXFxuJykgPyAnJyA6ICdcXG4nLFxuICAgIGhhc1JlcXMgPyAnfSkoKScgOiAnJyxcbiAgICAvLyAwIGF0IHRoZSBlbmQgdG8gc3VwcHJlc3MgZXJyb3JzIGFib3V0IG5vbi1jbG9uZWFibGUgcmVzdWx0IG9mIGV4ZWN1dGVTY3JpcHQgaW4gRkZcbiAgICBgfSkoKX1jYXRjaChlKXske2RhdGFLZXl9KGUpfX07MGAsXG4gICAgLy8gRmlyZWZveCBsaXN0cyAudXNlci5qcyBhbW9uZyBvdXIgb3duIGNvbnRlbnQgc2NyaXB0cyBzbyBhIHNwYWNlIGF0IHN0YXJ0IHdpbGwgZ3JvdXAgdGhlbVxuICAgIGBcXG4vLyMgc291cmNlVVJMPSR7ZXh0ZW5zaW9uUm9vdH0ke0lTX0ZJUkVGT1ggPyAnJTIwJyA6ICcnfSR7bmFtZX0udXNlci5qcyMke2lkfWAsXG4gIF0uam9pbignJyk7XG4gIGNhY2hlQ29kZS5wdXQoZGF0YUtleSwgaW5qZWN0ZWRDb2RlLCBUSU1FX0tFRVBfREFUQSk7XG4gIC8qKiBAbmFtZXNwYWNlIFZNSW5qZWN0ZWRTY3JpcHQgKi9cbiAgT2JqZWN0LmFzc2lnbihzY3JpcHQsIHtcbiAgICBkYXRhS2V5LFxuICAgIGRpc3BsYXlOYW1lLFxuICAgIC8vIGNvZGUgd2lsbCBiZSBgdHJ1ZWAgaWYgdGhlIGRlc2lyZWQgcmVhbG0gaXMgUEFHRSB3aGljaCBpcyBub3QgaW5qZWN0YWJsZVxuICAgIGNvZGU6IGlzQ29udGVudCA/ICcnIDogZm9yY2VDb250ZW50IHx8IGluamVjdGVkQ29kZSxcbiAgICBtZXRhU3RyOiBjb2RlLm1hdGNoKE1FVEFCTE9DS19SRSlbMV0gfHwgJycsXG4gICAgdmFsdWVzOiB2YWx1ZVtpZF0gfHwgbnVsbCxcbiAgfSk7XG4gIHJldHVybiBpc0NvbnRlbnQgJiYgW2RhdGFLZXksIHRydWVdO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlV2l0aEZ1bGxXaWR0aEZvcm0ocykge1xuICAvLyBmdWxsd2lkdGggcmFuZ2Ugc3RhcnRzIGF0IDB4RkYwMCwgbm9ybWFsIHJhbmdlIHN0YXJ0cyBhdCBzcGFjZSBjaGFyIGNvZGUgMHgyMFxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzLmNoYXJDb2RlQXQoMCkgLSAweDIwICsgMHhGRjAwKTtcbn1cblxuY29uc3QgcmVzb2x2ZURhdGFDb2RlU3RyID0gYCgke2Z1bmN0aW9uIF8oZGF0YSkge1xuICAvKiBgZnVuY3Rpb25gIGlzIHJlcXVpcmVkIHRvIGNvbXBpbGUgYHRoaXNgLCBhbmQgYHRoaXNgIGlzIHJlcXVpcmVkIGJlY2F1c2Ugb3VyIHNhZmUtZ2xvYmFsc1xuICAgKiBzaGFkb3dzIGB3aW5kb3dgIHNvIGl0cyBuYW1lIGlzIG1pbmlmaWVkIGFuZCBoZW5jZSBpbmFjY2Vzc2libGUgaGVyZSAqL1xuICBjb25zdCB7IHZtUmVzb2x2ZSB9ID0gdGhpcztcbiAgaWYgKHZtUmVzb2x2ZSkge1xuICAgIHZtUmVzb2x2ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBydW5uaW5nIGVhcmxpZXIgdGhhbiB0aGUgbWFpbiBjb250ZW50IHNjcmlwdCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgdGhpcy52bURhdGEgPSBkYXRhO1xuICB9XG59fSlgO1xuXG4vLyBUT0RPOiByZXdvcmsgdGhlIHdob2xlIHRoaW5nIHRvIHJlZ2lzdGVyIHNjcmlwdHMgaW5kaXZpZHVhbGx5IHdpdGggcmVhbCBgbWF0Y2hlc2BcbmZ1bmN0aW9uIHJlZ2lzdGVyU2NyaXB0RGF0YUZGKGluamVjdCwgdXJsLCBhbGxGcmFtZXMpIHtcbiAgcmV0dXJuIGJyb3dzZXIuY29udGVudFNjcmlwdHM/LnJlZ2lzdGVyKHtcbiAgICBhbGxGcmFtZXMsXG4gICAganM6IFt7XG4gICAgICBjb2RlOiBgJHtyZXNvbHZlRGF0YUNvZGVTdHJ9KCR7SlNPTi5zdHJpbmdpZnkoaW5qZWN0KX0pYCxcbiAgICB9XSxcbiAgICBtYXRjaGVzOiB1cmwuc3BsaXQoJyMnLCAxKSxcbiAgICBydW5BdDogJ2RvY3VtZW50X3N0YXJ0JyxcbiAgfSk7XG59XG5cbi8qKiBAcGFyYW0ge2Nocm9tZS53ZWJSZXF1ZXN0Lkh0dHBIZWFkZXJbXX0gcmVzcG9uc2VIZWFkZXJzICovXG5mdW5jdGlvbiBkZXRlY3RTdHJpY3RDc3AocmVzcG9uc2VIZWFkZXJzKSB7XG4gIHJldHVybiByZXNwb25zZUhlYWRlcnMuc29tZSgoeyBuYW1lLCB2YWx1ZSB9KSA9PiAoXG4gICAgL15jb250ZW50LXNlY3VyaXR5LXBvbGljeSQvaS50ZXN0KG5hbWUpXG4gICAgJiYgL14uKD8hLiondW5zYWZlLWlubGluZScpLy50ZXN0KCAvLyB0cnVlIGlmIG5vdCBlbXB0eSBhbmQgd2l0aG91dCAndW5zYWZlLWlubGluZSdcbiAgICAgIHZhbHVlLm1hdGNoKC8oPzpefDspXFxzKnNjcmlwdC1zcmMtZWxlbVxcc1teO10rLylcbiAgICAgIHx8IHZhbHVlLm1hdGNoKC8oPzpefDspXFxzKnNjcmlwdC1zcmNcXHNbXjtdKy8pXG4gICAgICB8fCB2YWx1ZS5tYXRjaCgvKD86Xnw7KVxccypkZWZhdWx0LXNyY1xcc1teO10rLylcbiAgICAgIHx8ICcnLFxuICAgIClcbiAgKSk7XG59XG5cbi8qKiBAcGFyYW0ge1ZNR2V0SW5qZWN0ZWREYXRhQ29udGFpbmVyfSBkYXRhICovXG5mdW5jdGlvbiBmb3JjZUNvbnRlbnRJbmplY3Rpb24oZGF0YSkge1xuICAvKiogQHR5cGUgVk1HZXRJbmplY3RlZERhdGEgKi9cbiAgY29uc3QgaW5qZWN0ID0gZGF0YS5pbmplY3Q7XG4gIGluamVjdC5mb3JjZUNvbnRlbnQgPSB0cnVlO1xuICBpbmplY3Quc2NyaXB0cy5mb3JFYWNoKHNjciA9PiB7XG4gICAgLy8gV2hlbiBzY3JpcHQgd2FudHMgYHBhZ2VgLCB0aGUgcmVzdWx0IGJlbG93IHdpbGwgYmUgYHRydWVgIHNvIHRoZSBzY3JpcHQgZ29lcyBpbnRvIGBmYWlsZWRJZHNgXG4gICAgc2NyLmNvZGUgPSAhaXNDb250ZW50UmVhbG0oc2NyLCB0cnVlKSB8fCAnJztcbiAgICBkYXRhLmZlZWRiYWNrLnB1c2goW3Njci5kYXRhS2V5LCB0cnVlXSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRlbnRSZWFsbShzY3IsIGZvcmNlQ29udGVudCkge1xuICBjb25zdCByZWFsbSA9IHNjcltJTkpFQ1RfSU5UT10gfHwgKFxuICAgIHNjcltJTkpFQ1RfSU5UT10gPSBub3JtYWxpemVSZWFsbShzY3IuY3VzdG9tW0lOSkVDVF9JTlRPXSB8fCBzY3IubWV0YVtJTkpFQ1RfSU5UT10pXG4gICk7XG4gIHJldHVybiByZWFsbSA9PT0gSU5KRUNUX0NPTlRFTlQgfHwgZm9yY2VDb250ZW50ICYmIHJlYWxtID09PSBJTkpFQ1RfQVVUTztcbn1cbiIsImltcG9ydCB7XG4gIGJsb2IyYmFzZTY0LCBidWZmZXIyc3RyaW5nLCBnZXRVbmlxSWQsIHJlcXVlc3QsIGkxOG4sIGlzRW1wdHksIG5vb3AsIHNlbmRUYWJDbWQsXG4gIHN0cmluZzJ1aW50OGFycmF5LFxufSBmcm9tICcjL2NvbW1vbic7XG5pbXBvcnQgeyBmb3JFYWNoRW50cnksIG9iamVjdFBpY2sgfSBmcm9tICcjL2NvbW1vbi9vYmplY3QnO1xuaW1wb3J0IHVhIGZyb20gJyMvY29tbW9uL3VhJztcbmltcG9ydCBjYWNoZSBmcm9tICcuL2NhY2hlJztcbmltcG9ydCB7IGlzVXNlclNjcmlwdCwgcGFyc2VNZXRhIH0gZnJvbSAnLi9zY3JpcHQnO1xuaW1wb3J0IHsgZXh0ZW5zaW9uUm9vdCB9IGZyb20gJy4vaW5pdCc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgeyBkb3dubG9hZE0zdTggfSBmcm9tICcuL20zdTgnO1xuaW1wb3J0IHsgbWVyZ2VWaWRlbyB9IGZyb20gJy4vbWVyZ2UtdmlkZW8nO1xuXG5jb25zdCByZXFIYW5kbGVyID0ge1xuICBtM3U4OiBkb3dubG9hZE0zdTgsXG4gIG1lcmdlOiBtZXJnZVZpZGVvLFxufTtcblxuY29uc3QgVk1fVkVSSUZZID0gJ1ZNLVZlcmlmeSc7XG5jb25zdCBDT05GSVJNX1VSTF9CQVNFID0gYCR7ZXh0ZW5zaW9uUm9vdH1jb25maXJtL2luZGV4Lmh0bWwjYDtcbi8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxWTUh0dHBSZXF1ZXN0Pn0gKi9cbmNvbnN0IHJlcXVlc3RzID0ge307XG5jb25zdCBkb3dubG9hZHMgPSB7fTtcbmNvbnN0IHZlcmlmeSA9IHt9O1xuY29uc3QgdGFiUmVxdWVzdHMgPSB7fTtcbmNvbnN0IHsgY2hyb21lIH0gPSBnbG9iYWw7XG5sZXQgZW5jb2RlcjtcblxuaWYgKGNocm9tZSkge1xuICBjaHJvbWUuZG93bmxvYWRzLm9uQ2hhbmdlZC5hZGRMaXN0ZW5lcihldnQgPT4ge1xuICAgIC8vIGNvbnNvbGUuaW5mbygnZG93bmxvYWRzIG9uQ2hhbmdlZCcsIGV2dCk7XG4gICAgaWYgKCFkb3dubG9hZHNbZXZ0LmlkXSkgcmV0dXJuO1xuICAgIGNvbnN0IHsgcmVxLCBzcmMgfSA9IGRvd25sb2Fkc1tldnQuaWRdO1xuICAgIGNvbnN0IHsgdGFiOiB7IGlkOiB0YWJJZCB9LCBmcmFtZUlkIH0gPSBzcmM7XG5cbiAgICBpZiAoZXZ0LnN0YXRlPy5jdXJyZW50ID09PSAnY29tcGxldGUnKSB7XG4gICAgICBzZW5kVGFiQ21kKHRhYklkLCAnSHR0cFJlcXVlc3RlZCcsIHtcbiAgICAgICAgdHlwZTogJ2xvYWQnLCBpZDogcmVxLmlkLCBkb3dubG9hZElkOiBldnQuaWQsXG4gICAgICB9LCB7IGZyYW1lSWQgfSk7XG4gICAgfSBlbHNlIGlmIChldnQuc3RhdGU/LmN1cnJlbnQgPT09ICdpbnRlcnJ1cHRlZCcpIHtcbiAgICAgIHNlbmRUYWJDbWQodGFiSWQsICdIdHRwUmVxdWVzdGVkJywge1xuICAgICAgICB0eXBlOiAnZXJyb3InLCBpZDogcmVxLmlkLCBkb3dubG9hZElkOiBldnQuaWQsXG4gICAgICB9LCB7IGZyYW1lSWQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIGRvd25sb2Fkc1tldnQuaWRdO1xuICAgIGRlbGV0ZSByZXF1ZXN0c1tyZXEuaWRdO1xuICB9KTtcbn1cblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICBDb25maXJtSW5zdGFsbDogY29uZmlybUluc3RhbGwsXG4gIGFzeW5jIENoZWNrSW5zdGFsbGVyVGFiKHRhYklkLCBzcmMpIHtcbiAgICBjb25zdCB0YWIgPSBJU19GSVJFRk9YICYmIChzcmMudXJsIHx8ICcnKS5zdGFydHNXaXRoKCdmaWxlOicpXG4gICAgICAmJiBhd2FpdCBicm93c2VyLnRhYnMuZ2V0KHRhYklkKS5jYXRjaChub29wKTtcbiAgICByZXR1cm4gdGFiICYmICh0YWIucGVuZGluZ1VybCB8fCB0YWIudXJsIHx8ICcnKS5zdGFydHNXaXRoKENPTkZJUk1fVVJMX0JBU0UpO1xuICB9LFxuICAvKiogQHJldHVybiB7dm9pZH0gKi9cbiAgSHR0cFJlcXVlc3Qob3B0cywgc3JjKSB7XG4gICAgY29uc3QgeyB0YWI6IHsgaWQ6IHRhYklkIH0sIGZyYW1lSWQgfSA9IHNyYztcbiAgICBjb25zdCB7IGlkLCBldmVudHNUb05vdGlmeSB9ID0gb3B0cztcblxuICAgIGNvbnNvbGUuaW5mbygncmVxIG9wdHMnLCBvcHRzKTtcblxuICAgIGlmIChyZXFIYW5kbGVyW29wdHMudHlwZV0pIHtcbiAgICAgIGNvbnN0IGRvd25sb2FkSWQgPSBpZDsgLy8gZmFrZSBkb3dubG9hZElkIGZvciBpbmplY3QuanNcbiAgICAgIG9wdHMuc3JjID0gc3JjO1xuICAgICAgb3B0cy5yZXF1ZXN0cyA9IHJlcXVlc3RzOyAvLyBuZWVkZWQgdG8gYXBwZW5kIHJlcSBpbiBtZXJnZVZpZGVvXG4gICAgICBvcHRzLm9ucHJvZ3Jlc3MgPSAobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnRzVG9Ob3RpZnk/LmluY2x1ZGVzKCdwcm9ncmVzcycpKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5pbmZvKCdvbnByb2dyZXNzJywge2xvYWRlZCwgdG90YWx9KTtcbiAgICAgICAgICBzZW5kVGFiQ21kKHRhYklkLCAnSHR0cFJlcXVlc3RlZCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdwcm9ncmVzcycsIGlkLCBkb3dubG9hZElkLCBsb2FkZWQsIHRvdGFsLFxuICAgICAgICAgIH0sIHsgZnJhbWVJZCB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG9wdHMub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBzZW5kVGFiQ21kKHRhYklkLCAnSHR0cFJlcXVlc3RlZCcsIHsgdHlwZTogJ2xvYWQnLCBkb3dubG9hZElkLCBpZCB9LCB7IGZyYW1lSWQgfSk7XG4gICAgICB9O1xuICAgICAgb3B0cy5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIHNlbmRUYWJDbWQodGFiSWQsICdIdHRwUmVxdWVzdGVkJywgeyB0eXBlOiAnZXJyb3InLCBkb3dubG9hZElkLCBpZCwgZXJyb3IgfSwgeyBmcmFtZUlkIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXFIYW5kbGVyW29wdHMudHlwZV0ob3B0cywgaHR0cFJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJlcXVlc3RzW2lkXSA9IHtcbiAgICAgIGlkLFxuICAgICAgdGFiSWQsXG4gICAgICBldmVudHNUb05vdGlmeSxcbiAgICAgIHhocjogbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAgfTtcbiAgICAodGFiUmVxdWVzdHNbdGFiSWRdIHx8ICh0YWJSZXF1ZXN0c1t0YWJJZF0gPSB7fSkpW2lkXSA9IDE7XG4gICAgaHR0cFJlcXVlc3Qob3B0cywgc3JjLCByZXMgPT4ge1xuICAgICAgLy8gY29uc29sZS5pbmZvKHsgcmVzLCByZXE6IHJlcXVlc3RzW2lkXSB9KTtcbiAgICAgIGlmIChyZXF1ZXN0c1tpZF0pIHtcbiAgICAgICAgc2VuZFRhYkNtZCh0YWJJZCwgJ0h0dHBSZXF1ZXN0ZWQnLCByZXMsIHsgZnJhbWVJZCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge3ZvaWR9ICovXG4gIEFib3J0UmVxdWVzdChpZCkge1xuICAgIGNvbnN0IHJlcSA9IHJlcXVlc3RzW2lkXTtcbiAgICBpZiAocmVxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIGlmIChjaHJvbWUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgIGNocm9tZS5kb3dubG9hZHMuY2FuY2VsKHJlcS5pZCk7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0c1tyZXEuaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLnhoci5hYm9ydCgpO1xuICAgICAgICBjbGVhclJlcXVlc3QocmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFJldm9rZUJsb2IodXJsKSB7XG4gICAgY29uc3QgdGltZXIgPSBjYWNoZS5wb3AoYHhockJsb2I6JHt1cmx9YCk7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgIH1cbiAgfSxcbn0pO1xuXG5jb25zdCBzcGVjaWFsSGVhZGVycyA9IFtcbiAgJ3VzZXItYWdlbnQnLFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0ZvcmJpZGRlbl9oZWFkZXJfbmFtZVxuICAvLyBodHRwczovL2NzLmNocm9taXVtLm9yZy8/cT1maWxlOmNjK3N5bWJvbDpJc0ZvcmJpZGRlbkhlYWRlciU1Q2JcbiAgJ2FjY2VwdC1jaGFyc2V0JyxcbiAgJ2FjY2VwdC1lbmNvZGluZycsXG4gICdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnLFxuICAnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnLFxuICAnY29ubmVjdGlvbicsXG4gICdjb250ZW50LWxlbmd0aCcsXG4gICdjb29raWUnLFxuICAnY29va2llMicsXG4gICdkYXRlJyxcbiAgJ2RudCcsXG4gICdleHBlY3QnLFxuICAnaG9zdCcsXG4gICdrZWVwLWFsaXZlJyxcbiAgJ29yaWdpbicsXG4gICdyZWZlcmVyJyxcbiAgJ3RlJyxcbiAgJ3RyYWlsZXInLFxuICAndHJhbnNmZXItZW5jb2RpbmcnLFxuICAndXBncmFkZScsXG4gICd2aWEnLFxuXTtcbi8vIGNvbnN0IHRhc2tzID0ge307XG5jb25zdCBIZWFkZXJJbmplY3RvciA9ICgoKSA9PiB7XG4gIC8qKiBAdHlwZSBjaHJvbWUud2ViUmVxdWVzdC5SZXF1ZXN0RmlsdGVyICovXG4gIGNvbnN0IGFwaUZpbHRlciA9IHtcbiAgICB1cmxzOiBbJzxhbGxfdXJscz4nXSxcbiAgICB0eXBlczogWyd4bWxodHRwcmVxdWVzdCddLFxuICB9O1xuICBjb25zdCBFWFRSQV9IRUFERVJTID0gW1xuICAgIGJyb3dzZXIud2ViUmVxdWVzdC5PbkJlZm9yZVNlbmRIZWFkZXJzT3B0aW9ucy5FWFRSQV9IRUFERVJTLFxuICBdLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgaGVhZGVyc1RvSW5qZWN0ID0ge307XG4gIC8qKiBAcGFyYW0ge2Nocm9tZS53ZWJSZXF1ZXN0Lkh0dHBIZWFkZXJ9IGhlYWRlciAqL1xuICBjb25zdCBpc1ZtVmVyaWZ5ID0gaGVhZGVyID0+IGhlYWRlci5uYW1lID09PSBWTV9WRVJJRlk7XG4gIGNvbnN0IGlzTm90Q29va2llID0gaGVhZGVyID0+ICEvXmNvb2tpZTI/JC9pLnRlc3QoaGVhZGVyLm5hbWUpO1xuICBjb25zdCBpc1NlbmRhYmxlID0gaGVhZGVyID0+IGhlYWRlci5uYW1lICE9PSBWTV9WRVJJRlk7XG4gIGNvbnN0IGlzU2VuZGFibGVBbm9uID0gaGVhZGVyID0+IGlzU2VuZGFibGUoaGVhZGVyKSAmJiBpc05vdENvb2tpZShoZWFkZXIpO1xuICBjb25zdCBSRV9TRVRfQ09PS0lFID0gL15zZXQtY29va2llMj8kL2k7XG4gIGNvbnN0IFJFX1NFVF9DT09LSUVfVkFMVUUgPSAvXlxccyooPzpfXyhTZWN1cmV8SG9zdCktKT8oW149XFxzXSspXFxzKj1cXHMqKFwiKT8oWyEjLStcXC0tOjwtW1xcXS1+XSopXFwzKC4qKS87XG4gIGNvbnN0IFJFX1NFVF9DT09LSUVfQVRUUiA9IC9cXHMqOz9cXHMqKFxcdyspKD86PShcIik/KFshIy0rXFwtLTo8LVtcXF0tfl0qKVxcMik/L3k7XG4gIGNvbnN0IFNBTUVfU0lURV9NQVAgPSB7XG4gICAgc3RyaWN0OiAnc3RyaWN0JyxcbiAgICBsYXg6ICdsYXgnLFxuICAgIG5vbmU6ICdub19yZXN0cmljdGlvbicsXG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyVmFsdWVcbiAgICogQHBhcmFtIHtWTUh0dHBSZXF1ZXN0fSByZXFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKi9cbiAgY29uc3Qgc2V0Q29va2llSW5TdG9yZSA9IChoZWFkZXJWYWx1ZSwgcmVxLCB1cmwpID0+IHtcbiAgICBsZXQgbSA9IFJFX1NFVF9DT09LSUVfVkFMVUUuZXhlYyhoZWFkZXJWYWx1ZSk7XG4gICAgaWYgKG0pIHtcbiAgICAgIGNvbnN0IFssIHByZWZpeCwgbmFtZSwgLCB2YWx1ZSwgb3B0U3RyXSA9IG07XG4gICAgICBjb25zdCBvcHQgPSB7fTtcbiAgICAgIGNvbnN0IGlzSG9zdCA9IHByZWZpeCA9PT0gJ0hvc3QnO1xuICAgICAgUkVfU0VUX0NPT0tJRV9BVFRSLmxhc3RJbmRleCA9IDA7XG4gICAgICB3aGlsZSAoKG0gPSBSRV9TRVRfQ09PS0lFX0FUVFIuZXhlYyhvcHRTdHIpKSkge1xuICAgICAgICBvcHRbbVsxXS50b0xvd2VyQ2FzZSgpXSA9IG1bM107XG4gICAgICB9XG4gICAgICBjb25zdCBzYW1lU2l0ZSA9IG9wdC5zYW1lU2l0ZT8udG9Mb3dlckNhc2UoKTtcbiAgICAgIGJyb3dzZXIuY29va2llcy5zZXQoe1xuICAgICAgICB1cmwsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb21haW46IGlzSG9zdCA/IHVuZGVmaW5lZCA6IG9wdC5kb21haW4sXG4gICAgICAgIGV4cGlyYXRpb25EYXRlOiBNYXRoLm1heCgwLCArbmV3IERhdGUob3B0WydtYXgtYWdlJ10gKiAxMDAwIHx8IG9wdC5leHBpcmVzKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBodHRwT25seTogJ2h0dHBvbmx5JyBpbiBvcHQsXG4gICAgICAgIHBhdGg6IGlzSG9zdCA/ICcvJyA6IG9wdC5wYXRoLFxuICAgICAgICBzYW1lU2l0ZTogU0FNRV9TSVRFX01BUFtzYW1lU2l0ZV0sXG4gICAgICAgIHNlY3VyZTogdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpICYmICghIXByZWZpeCB8fCBzYW1lU2l0ZSA9PT0gJ25vbmUnIHx8ICdzZWN1cmUnIGluIG9wdCksXG4gICAgICAgIHN0b3JlSWQ6IHJlcS5zdG9yZUlkLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBhcGlFdmVudHMgPSB7XG4gICAgb25CZWZvcmVTZW5kSGVhZGVyczoge1xuICAgICAgb3B0aW9uczogWydyZXF1ZXN0SGVhZGVycycsICdibG9ja2luZycsIC4uLkVYVFJBX0hFQURFUlNdLFxuICAgICAgLyoqIEBwYXJhbSB7Y2hyb21lLndlYlJlcXVlc3QuV2ViUmVxdWVzdEhlYWRlcnNEZXRhaWxzfSBkZXRhaWxzICovXG4gICAgICBsaXN0ZW5lcih7IHJlcXVlc3RIZWFkZXJzOiBoZWFkZXJzLCByZXF1ZXN0SWQgfSkge1xuICAgICAgICAvLyBvbmx5IHRoZSBmaXJzdCBjYWxsIGR1cmluZyBhIHJlZGlyZWN0L2F1dGggY2hhaW4gd2lsbCBoYXZlIFZNLVZlcmlmeSBoZWFkZXJcbiAgICAgICAgY29uc3QgcmVxSWQgPSBoZWFkZXJzLmZpbmQoaXNWbVZlcmlmeSk/LnZhbHVlIHx8IHZlcmlmeVtyZXF1ZXN0SWRdO1xuICAgICAgICBjb25zdCByZXEgPSByZXFJZCAmJiByZXF1ZXN0c1tyZXFJZF07XG4gICAgICAgIGlmIChyZXFJZCAmJiByZXEpIHtcbiAgICAgICAgICB2ZXJpZnlbcmVxdWVzdElkXSA9IHJlcUlkO1xuICAgICAgICAgIHJlcS5jb3JlSWQgPSByZXF1ZXN0SWQ7XG4gICAgICAgICAgaGVhZGVycyA9IChyZXEubm9OYXRpdmVDb29raWUgPyBoZWFkZXJzLmZpbHRlcihpc05vdENvb2tpZSkgOiBoZWFkZXJzKVxuICAgICAgICAgIC5jb25jYXQoaGVhZGVyc1RvSW5qZWN0W3JlcUlkXSB8fCBbXSlcbiAgICAgICAgICAuZmlsdGVyKHJlcS5hbm9ueW1vdXMgPyBpc1NlbmRhYmxlQW5vbiA6IGlzU2VuZGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlcXVlc3RIZWFkZXJzOiBoZWFkZXJzIH07XG4gICAgICB9LFxuICAgIH0sXG4gICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHtcbiAgICAgIG9wdGlvbnM6IFsncmVzcG9uc2VIZWFkZXJzJywgJ2Jsb2NraW5nJywgLi4uRVhUUkFfSEVBREVSU10sXG4gICAgICAvKiogQHBhcmFtIHtjaHJvbWUud2ViUmVxdWVzdC5XZWJSZXF1ZXN0SGVhZGVyc0RldGFpbHN9IGRldGFpbHMgKi9cbiAgICAgIGxpc3RlbmVyKHsgcmVzcG9uc2VIZWFkZXJzOiBoZWFkZXJzLCByZXF1ZXN0SWQsIHVybCB9KSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IHJlcXVlc3RzW3ZlcmlmeVtyZXF1ZXN0SWRdXTtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgIGlmIChyZXEuYW5vbnltb3VzIHx8IHJlcS5zdG9yZUlkKSB7XG4gICAgICAgICAgICBoZWFkZXJzID0gaGVhZGVycy5maWx0ZXIoaCA9PiAoXG4gICAgICAgICAgICAgICFSRV9TRVRfQ09PS0lFLnRlc3QoaC5uYW1lKVxuICAgICAgICAgICAgICB8fCAhcmVxLnN0b3JlSWRcbiAgICAgICAgICAgICAgfHwgc2V0Q29va2llSW5TdG9yZShoLnZhbHVlLCByZXEsIHVybClcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEucmVzcG9uc2VIZWFkZXJzID0gaGVhZGVycy5tYXAoZW5jb2RlV2ViUmVxdWVzdEhlYWRlcikuam9pbignJyk7XG4gICAgICAgICAgcmV0dXJuIHsgcmVzcG9uc2VIZWFkZXJzOiBoZWFkZXJzIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbiAgLy8gQ2hyb21lIDc0LTkxIG5lZWRzIGFuIGV4dHJhSGVhZGVycyBsaXN0ZW5lciBhdCB0YWIgbG9hZCBzdGFydCwgaHR0cHM6Ly9jcmJ1Zy5jb20vMTA3NDI4MlxuICAvLyBXZSdyZSBhdHRhY2hpbmcgYSBuby1vcCBpbiBub24tYmxvY2tpbmcgbW9kZSBzbyBpdCdzIHZlcnkgbGlnaHR3ZWlnaHQgYW5kIGZhc3QuXG4gIGlmICh1YS5jaHJvbWUgPj0gNzQgJiYgdWEuY2hyb21lIDw9IDkxKSB7XG4gICAgYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uQmVmb3JlU2VuZEhlYWRlcnMuYWRkTGlzdGVuZXIobm9vcCwgYXBpRmlsdGVyLCBbJ2V4dHJhSGVhZGVycyddKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFkZChyZXFJZCwgaGVhZGVycykge1xuICAgICAgLy8gbmVlZCB0byBzZXQgdGhlIGVudHJ5IGV2ZW4gaWYgaXQncyBlbXB0eSBbXSBzbyB0aGF0ICdpZicgY2hlY2sgaW4gZGVsKCkgcnVucyBvbmx5IG9uY2VcbiAgICAgIGhlYWRlcnNUb0luamVjdFtyZXFJZF0gPSBoZWFkZXJzO1xuICAgICAgLy8gbmVlZCB0aGUgbGlzdGVuZXIgdG8gZ2V0IHRoZSByZXF1ZXN0SWRcbiAgICAgIGFwaUV2ZW50czo6Zm9yRWFjaEVudHJ5KChbbmFtZSwgeyBsaXN0ZW5lciwgb3B0aW9ucyB9XSkgPT4ge1xuICAgICAgICBicm93c2VyLndlYlJlcXVlc3RbbmFtZV0uYWRkTGlzdGVuZXIobGlzdGVuZXIsIGFwaUZpbHRlciwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlbChyZXFJZCkge1xuICAgICAgaWYgKHJlcUlkIGluIGhlYWRlcnNUb0luamVjdCkge1xuICAgICAgICBkZWxldGUgaGVhZGVyc1RvSW5qZWN0W3JlcUlkXTtcbiAgICAgICAgaWYgKGlzRW1wdHkoaGVhZGVyc1RvSW5qZWN0KSkge1xuICAgICAgICAgIGFwaUV2ZW50czo6Zm9yRWFjaEVudHJ5KChbbmFtZSwgeyBsaXN0ZW5lciB9XSkgPT4ge1xuICAgICAgICAgICAgYnJvd3Nlci53ZWJSZXF1ZXN0W25hbWVdLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH07XG59KSgpO1xuXG4vKiAxTUIgdGFrZXMgfjIwbXMgdG8gZW5jb2RlL2RlY29kZSBzbyBpdCBkb2Vzbid0IGJsb2NrIHRoZSBwcm9jZXNzIG9mIHRoZSBleHRlbnNpb24gYW5kIHdlYiBwYWdlLFxuICogd2hpY2ggbGV0cyB1cyBhbmQgdGhlbSBiZSByZXNwb25zaXZlIHRvIG90aGVyIGV2ZW50cyBvciB1c2VyIGlucHV0LiAqL1xuY29uc3QgQ0hVTktfU0laRSA9IDFlNjtcblxuYXN5bmMgZnVuY3Rpb24gYmxvYjJjaHVuayhyZXNwb25zZSwgaW5kZXgpIHtcbiAgcmV0dXJuIGJsb2IyYmFzZTY0KHJlc3BvbnNlLCBpbmRleCAqIENIVU5LX1NJWkUsIENIVU5LX1NJWkUpO1xufVxuXG5mdW5jdGlvbiBibG9iMm9iamVjdFVybChyZXNwb25zZSkge1xuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlc3BvbnNlKTtcbiAgY2FjaGUucHV0KGB4aHJCbG9iOiR7dXJsfWAsIHNldFRpbWVvdXQoY29tbWFuZHMuUmV2b2tlQmxvYiwgNjBlMywgdXJsKSwgNjFlMyk7XG4gIHJldHVybiB1cmw7XG59XG5cbi8qKiBAcGFyYW0ge1ZNSHR0cFJlcXVlc3R9IHJlcSAqL1xuZnVuY3Rpb24geGhyQ2FsbGJhY2tXcmFwcGVyKHJlcSkge1xuICBsZXQgbGFzdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgbGV0IGNvbnRlbnRUeXBlO1xuICBsZXQgZGF0YVNpemU7XG4gIGxldCBudW1DaHVua3M7XG4gIGxldCByZXNwb25zZTtcbiAgbGV0IHJlc3BvbnNlVGV4dDtcbiAgbGV0IHJlc3BvbnNlSGVhZGVycztcbiAgLy8gbGV0IHNlbnQgPSBmYWxzZTtcbiAgY29uc3QgeyBpZCwgYmxvYmJlZCwgY2h1bmtlZCwgeGhyIH0gPSByZXE7XG4gIC8vIENocm9tZSBlbmNvZGVzIG1lc3NhZ2VzIHRvIFVURjggc28gdGhleSBjYW4gZ3JvdyB1cCB0byA0eCBidXQgNjRNQiBpcyB0aGUgbWVzc2FnZSBzaXplIGxpbWl0XG4gIGNvbnN0IGdldENodW5rID0gYmxvYmJlZCAmJiBibG9iMm9iamVjdFVybCB8fCBjaHVua2VkICYmIGJsb2IyY2h1bms7XG4gIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVycyA9ICgpID0+IHtcbiAgICBjb25zdCBoZWFkZXJzID0gcmVxLnJlc3BvbnNlSGVhZGVycyB8fCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgaWYgKHJlc3BvbnNlSGVhZGVycyAhPT0gaGVhZGVycykge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzID0gaGVhZGVycztcbiAgICAgIHJldHVybiB7IHJlc3BvbnNlSGVhZGVycyB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChldnQpID0+IHtcbiAgICBjb25zdCB0eXBlID0gZXZ0LnR5cGU7XG4gICAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgICAgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIH1cbiAgICBpZiAoeGhyLnJlc3BvbnNlICE9PSByZXNwb25zZSkge1xuICAgICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2U7XG4gICAgICAvLyBzZW50ID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZVRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBpZiAocmVzcG9uc2VUZXh0ID09PSByZXNwb25zZSkgcmVzcG9uc2VUZXh0ID0gWydzYW1lJ107XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlnbm9yZSBpZiByZXNwb25zZVRleHQgaXMgdW5yZWFjaGFibGVcbiAgICAgIH1cbiAgICAgIGlmICgoYmxvYmJlZCB8fCBjaHVua2VkKSAmJiByZXNwb25zZSkge1xuICAgICAgICBkYXRhU2l6ZSA9IHJlc3BvbnNlLnNpemU7XG4gICAgICAgIG51bUNodW5rcyA9IGNodW5rZWQgJiYgTWF0aC5jZWlsKGRhdGFTaXplIC8gQ0hVTktfU0laRSkgfHwgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkTm90aWZ5ID0gcmVxLmV2ZW50c1RvTm90aWZ5LmluY2x1ZGVzKHR5cGUpO1xuICAgIC8vIG9ubHkgc2VuZCByZXNwb25zZSB3aGVuIFhIUiBpcyBjb21wbGV0ZVxuICAgIGNvbnN0IHNob3VsZFNlbmRSZXNwb25zZSA9IHhoci5yZWFkeVN0YXRlID09PSA0ICYmIHNob3VsZE5vdGlmeTtcbiAgICBsYXN0UHJvbWlzZSA9IGxhc3RQcm9taXNlLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHNob3VsZFNlbmRSZXNwb25zZSAmJiBibG9iYmVkICYmIHJlcS50eXBlID09PSAnZG93bmxvYWQnKSB7XG4gICAgICAgIGlmIChyZXEuZmlsZU5hbWUgJiYgY2hyb21lKSB7XG4gICAgICAgICAgY29uc3QgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVzcG9uc2UpO1xuICAgICAgICAgIHJldHVybiBjaHJvbWUuZG93bmxvYWRzLmRvd25sb2FkKHtcbiAgICAgICAgICAgIHVybDogYmxvYlVybCxcbiAgICAgICAgICAgIGZpbGVuYW1lOiByZXEuZmlsZU5hbWUsXG4gICAgICAgICAgfSwgZG93bmxvYWRJZCA9PiB7XG4gICAgICAgICAgICByZXEuY2Ioe1xuICAgICAgICAgICAgICBibG9iYmVkLFxuICAgICAgICAgICAgICBjaHVua2VkLFxuICAgICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgZGF0YVNpemUsXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBkYXRhOiB7IGZpbmFsVXJsOiB4aHIucmVzcG9uc2VVUkwsIHJlc3BvbnNlOiAnJywgcmVzcG9uc2VUZXh0OiBkb3dubG9hZElkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcS5jYih7XG4gICAgICAgICAgYmxvYmJlZCxcbiAgICAgICAgICBjaHVua2VkLFxuICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgIGRhdGFTaXplLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGF0YTogcmVzcG9uc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmluZm8oeyBldnQgfSk7XG4gICAgICBhd2FpdCByZXEuY2Ioe1xuICAgICAgICBibG9iYmVkLFxuICAgICAgICBjaHVua2VkLFxuICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgZGF0YVNpemUsXG4gICAgICAgIGlkLFxuICAgICAgICBudW1DaHVua3MsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGE6IHNob3VsZE5vdGlmeSAmJiB7XG4gICAgICAgICAgZmluYWxVcmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAuLi5nZXRSZXNwb25zZUhlYWRlcnMoKSxcbiAgICAgICAgICAuLi5vYmplY3RQaWNrKHhociwgWydyZWFkeVN0YXRlJywgJ3N0YXR1cycsICdzdGF0dXNUZXh0J10pLFxuICAgICAgICAgIC4uLignbG9hZGVkJyBpbiBldnQpICYmIG9iamVjdFBpY2soZXZ0LCBbJ2xlbmd0aENvbXB1dGFibGUnLCAnbG9hZGVkJywgJ3RvdGFsJ10pLFxuICAgICAgICAgIHJlc3BvbnNlOiBzaG91bGRTZW5kUmVzcG9uc2VcbiAgICAgICAgICAgID8gbnVtQ2h1bmtzICYmIGF3YWl0IGdldENodW5rKHJlc3BvbnNlLCAwKSB8fCByZXNwb25zZVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgIHJlc3BvbnNlVGV4dDogc2hvdWxkU2VuZFJlc3BvbnNlXG4gICAgICAgICAgICA/IHJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBpZiAoc2hvdWxkU2VuZFJlc3BvbnNlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtQ2h1bmtzOyBpICs9IDEpIHtcbiAgICAgICAgICBhd2FpdCByZXEuY2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICBwb3M6IGkgKiBDSFVOS19TSVpFLFxuICAgICAgICAgICAgICBkYXRhOiBhd2FpdCBnZXRDaHVuayhyZXNwb25zZSwgaSksXG4gICAgICAgICAgICAgIGxhc3Q6IGkgKyAxID09PSBudW1DaHVua3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2xvYWRlbmQnKSB7XG4gICAgICAgIGNsZWFyUmVxdWVzdChyZXEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWxIZWFkZXIobG93ZXJIZWFkZXIpIHtcbiAgcmV0dXJuIHNwZWNpYWxIZWFkZXJzLmluY2x1ZGVzKGxvd2VySGVhZGVyKVxuICAgIHx8IGxvd2VySGVhZGVyLnN0YXJ0c1dpdGgoJ3Byb3h5LScpXG4gICAgfHwgbG93ZXJIZWFkZXIuc3RhcnRzV2l0aCgnc2VjLScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge2Nocm9tZS5ydW50aW1lLk1lc3NhZ2VTZW5kZXIgfCBicm93c2VyLnJ1bnRpbWUuTWVzc2FnZVNlbmRlcn0gc3JjXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYlxuICovXG5hc3luYyBmdW5jdGlvbiBodHRwUmVxdWVzdChvcHRzLCBzcmMsIGNiKSB7XG4gIGNvbnN0IHsgdGFiIH0gPSBzcmM7XG4gIGNvbnN0IHsgaW5jb2duaXRvIH0gPSB0YWI7XG4gIGNvbnN0IHsgYW5vbnltb3VzLCBpZCwgb3ZlcnJpZGVNaW1lVHlwZSwgeGhyVHlwZSwgdXJsIH0gPSBvcHRzO1xuICBjb25zdCByZXEgPSByZXF1ZXN0c1tpZF07XG4gIGlmICghcmVxIHx8IHJlcS5jYikgcmV0dXJuO1xuICByZXEuY2IgPSBjYjtcbiAgcmVxLnR5cGUgPSBvcHRzLnR5cGU7XG4gIHJlcS5maWxlTmFtZSA9IG9wdHMuZmlsZU5hbWU7XG4gIHJlcS5hbm9ueW1vdXMgPSBhbm9ueW1vdXM7XG4gIGNvbnN0IHsgeGhyIH0gPSByZXE7XG4gIGNvbnN0IHZtSGVhZGVycyA9IFtdO1xuICAvLyBGaXJlZm94IGNhbiBzZW5kIEJsb2IvQXJyYXlCdWZmZXIgZGlyZWN0bHlcbiAgY29uc3QgY2h1bmtlZCA9ICFJU19GSVJFRk9YICYmIGluY29nbml0bztcbiAgY29uc3QgYmxvYmJlZCA9IHhoclR5cGUgJiYgIUlTX0ZJUkVGT1ggJiYgIWluY29nbml0bztcbiAgY29uc3QgW2JvZHksIGNvbnRlbnRUeXBlXSA9IGRlY29kZUJvZHkob3B0cy5kYXRhKTtcbiAgLy8gQ2hyb21lIGNhbid0IGZldGNoIEJsb2IgVVJMIGluIGluY29nbml0byBzbyB3ZSB1c2UgY2h1bmtzXG4gIHJlcS5ibG9iYmVkID0gYmxvYmJlZDtcbiAgcmVxLmNodW5rZWQgPSBjaHVua2VkO1xuICAvLyBGaXJlZm94IGRvZXNuJ3Qgc2VuZCBjb29raWVzLCBodHRwczovL2dpdGh1Yi5jb20vdmlvbGVudG1vbmtleS92aW9sZW50bW9ua2V5L2lzc3Vlcy82MDZcbiAgLy8gQm90aCBDaHJvbWUgJiBGRiBuZWVkIGV4cGxpY2l0IHJvdXRpbmcgb2YgY29va2llcyBpbiBjb250YWluZXJzIG9yIGluY29nbml0b1xuICBsZXQgc2hvdWxkU2VuZENvb2tpZXMgPSAhYW5vbnltb3VzICYmIChpbmNvZ25pdG8gfHwgSVNfRklSRUZPWCk7XG4gIHhoci5vcGVuKG9wdHMubWV0aG9kIHx8ICdHRVQnLCB1cmwsIHRydWUsIG9wdHMudXNlciB8fCAnJywgb3B0cy5wYXNzd29yZCB8fCAnJyk7XG4gIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFZNX1ZFUklGWSwgaWQpO1xuICBpZiAoY29udGVudFR5cGUpIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG4gIG9wdHMuaGVhZGVyczo6Zm9yRWFjaEVudHJ5KChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbG93ZXJOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc1NwZWNpYWxIZWFkZXIobG93ZXJOYW1lKSkge1xuICAgICAgdm1IZWFkZXJzLnB1c2goeyBuYW1lLCB2YWx1ZSB9KTtcbiAgICB9IGVsc2UgaWYgKCFsb3dlck5hbWUuc3RhcnRzV2l0aCgndm0tJykpIHtcbiAgICAgIC8vIGBWTS1gIGhlYWRlcnMgYXJlIHJlc2VydmVkXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChsb3dlck5hbWUgPT09ICdjb29raWUnKSB7XG4gICAgICBzaG91bGRTZW5kQ29va2llcyA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHhoci5yZXNwb25zZVR5cGUgPSAoY2h1bmtlZCB8fCBibG9iYmVkKSAmJiAnYmxvYicgfHwgeGhyVHlwZSB8fCAndGV4dCc7XG4gIHhoci50aW1lb3V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMHg3RkZGX0ZGRkYsIG9wdHMudGltZW91dCkpIHx8IDA7XG4gIGlmIChvdmVycmlkZU1pbWVUeXBlKSB4aHIub3ZlcnJpZGVNaW1lVHlwZShvdmVycmlkZU1pbWVUeXBlKTtcbiAgaWYgKHNob3VsZFNlbmRDb29raWVzKSB7XG4gICAgcmVxLm5vTmF0aXZlQ29va2llID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHN0b3JlIG9mIGF3YWl0IGJyb3dzZXIuY29va2llcy5nZXRBbGxDb29raWVTdG9yZXMoKSkge1xuICAgICAgaWYgKHN0b3JlLnRhYklkcy5pbmNsdWRlcyh0YWIuaWQpKSB7XG4gICAgICAgIGlmIChJU19GSVJFRk9YID8gc3RvcmUuaWQgIT09ICdmaXJlZm94LWRlZmF1bHQnIDogc3RvcmUuaWQgIT09ICcwJykge1xuICAgICAgICAgIC8qIENvb2tpZSByb3V0aW5nLiBGb3IgdGhlIG1haW4gc3RvcmUgd2UgcmVseSBvbiB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgKiBUaGUgaWRzIGFyZSBoYXJkLWNvZGVkIGFzIGBzdG9yZXNgIG1heSBvbWl0IHRoZSBtYWluIHN0b3JlIGlmIG5vIHN1Y2ggdGFicyBhcmUgb3Blbi4gKi9cbiAgICAgICAgICByZXEuc3RvcmVJZCA9IHN0b3JlLmlkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBjb25zdCBjb29raWVzID0gKGF3YWl0IGJyb3dzZXIuY29va2llcy5nZXRBbGwoe1xuICAgICAgdXJsLFxuICAgICAgc3RvcmVJZDogcmVxLnN0b3JlSWQsXG4gICAgICAuLi51YS5maXJlZm94ID49IDU5ICYmIHsgZmlyc3RQYXJ0eURvbWFpbjogbnVsbCB9LFxuICAgIH0pKS5maWx0ZXIoYyA9PiBjLnNlc3Npb24gfHwgYy5leHBpcmF0aW9uRGF0ZSA+IG5vdyk7IC8vIEZGIHJlcG9ydHMgZXhwaXJlZCBjb29raWVzIVxuICAgIGlmIChjb29raWVzLmxlbmd0aCkge1xuICAgICAgdm1IZWFkZXJzLnB1c2goe1xuICAgICAgICBuYW1lOiAnY29va2llJyxcbiAgICAgICAgdmFsdWU6IGNvb2tpZXMubWFwKGMgPT4gYCR7Yy5uYW1lfT0ke2MudmFsdWV9O2ApLmpvaW4oJyAnKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBIZWFkZXJJbmplY3Rvci5hZGQoaWQsIHZtSGVhZGVycyk7XG4gIGNvbnN0IGNhbGxiYWNrID0geGhyQ2FsbGJhY2tXcmFwcGVyKHJlcSk7XG4gIHJlcS5ldmVudHNUb05vdGlmeS5mb3JFYWNoKGV2dCA9PiB7IHhocltgb24ke2V2dH1gXSA9IGNhbGxiYWNrOyB9KTtcbiAgeGhyLm9ubG9hZGVuZCA9IGNhbGxiYWNrOyAvLyBhbHdheXMgc2VuZCBpdCBmb3IgdGhlIGludGVybmFsIGNsZWFudXBcbiAgeGhyLnNlbmQoYm9keSk7XG59XG5cbi8qKiBAcGFyYW0ge1ZNSHR0cFJlcXVlc3R9IHJlcSAqL1xuZnVuY3Rpb24gY2xlYXJSZXF1ZXN0KHJlcSkge1xuICBpZiAocmVxLmNvcmVJZCkgZGVsZXRlIHZlcmlmeVtyZXEuY29yZUlkXTtcbiAgZGVsZXRlIHJlcXVlc3RzW3JlcS5pZF07XG4gIGRlbGV0ZSAodGFiUmVxdWVzdHNbcmVxLnRhYklkXSB8fCB7fSlbcmVxLmlkXTtcbiAgSGVhZGVySW5qZWN0b3IuZGVsKHJlcS5pZCk7XG59XG5cbi8qKiBQb2x5ZmlsbCBmb3IgQ2hyb21lJ3MgaW5hYmlsaXR5IHRvIHNlbmQgY29tcGxleCB0eXBlcyBvdmVyIGV4dGVuc2lvbiBtZXNzYWdpbmcgKi9cbmZ1bmN0aW9uIGRlY29kZUJvZHkoW2JvZHksIHR5cGUsIHdhc0Jsb2JdKSB7XG4gIGlmICh0eXBlID09PSAncXVlcnknKSB7XG4gICAgdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICB9IGVsc2UgaWYgKHR5cGUpIHtcbiAgICAvLyA1eCB0aW1lcyBmYXN0ZXIgdGhhbiBmZXRjaCgpIHdoaWNoIHdhc3RlcyB0aW1lIG9uIGludGVyLXByb2Nlc3MgY29tbXVuaWNhdGlvblxuICAgIGNvbnN0IHJlcyA9IHN0cmluZzJ1aW50OGFycmF5KGF0b2IoYm9keS5zbGljZShib2R5LmluZGV4T2YoJywnKSArIDEpKSk7XG4gICAgaWYgKCF3YXNCbG9iKSB7XG4gICAgICB0eXBlID0gYm9keS5tYXRjaCgvXmRhdGE6KC4rPyk7YmFzZTY0LylbMV0ucmVwbGFjZSgvKGJvdW5kYXJ5PSlbXjtdKy8sXG4gICAgICAgIC8vIHVzaW5nIGEgZnVuY3Rpb24gc28gaXQgcnVucyBvbmx5IGlmIFwiYm91bmRhcnlcIiB3YXMgZm91bmRcbiAgICAgICAgKF8sIHAxKSA9PiBwMSArIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ucmVzLnNsaWNlKDIsIHJlcy5pbmRleE9mKDEzKSkpKTtcbiAgICB9XG4gICAgYm9keSA9IHJlcztcbiAgfVxuICByZXR1cm4gW2JvZHksIHR5cGVdO1xufVxuXG4vLyBXYXRjaCBVUkwgcmVkaXJlY3RzXG4vLyBicm93c2VyLndlYlJlcXVlc3Qub25CZWZvcmVSZWRpcmVjdC5hZGRMaXN0ZW5lcihkZXRhaWxzID0+IHtcbi8vICAgY29uc3QgcmVxSWQgPSB2ZXJpZnlbZGV0YWlscy5yZXF1ZXN0SWRdO1xuLy8gICBpZiAocmVxSWQpIHtcbi8vICAgICBjb25zdCByZXEgPSByZXF1ZXN0c1tyZXFJZF07XG4vLyAgICAgaWYgKHJlcSkgcmVxLmZpbmFsVXJsID0gZGV0YWlscy5yZWRpcmVjdFVybDtcbi8vICAgfVxuLy8gfSwge1xuLy8gICB1cmxzOiBbJzxhbGxfdXJscz4nXSxcbi8vICAgdHlwZXM6IFsneG1saHR0cHJlcXVlc3QnXSxcbi8vIH0pO1xuXG4vLyB0YXNrcyBhcmUgbm90IG5lY2Vzc2FyeSBub3csIHR1cm5lZCBvZmZcbi8vIFN0b3AgcmVkaXJlY3RzXG4vLyBicm93c2VyLndlYlJlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQuYWRkTGlzdGVuZXIoZGV0YWlscyA9PiB7XG4vLyAgIGNvbnN0IHRhc2sgPSB0YXNrc1tkZXRhaWxzLnJlcXVlc3RJZF07XG4vLyAgIGlmICh0YXNrKSB7XG4vLyAgICAgZGVsZXRlIHRhc2tzW2RldGFpbHMucmVxdWVzdElkXTtcbi8vICAgICBpZiAodGFzayA9PT0gJ0dldC1Mb2NhdGlvbicgJiYgWzMwMSwgMzAyLCAzMDNdLmluY2x1ZGVzKGRldGFpbHMuc3RhdHVzQ29kZSkpIHtcbi8vICAgICAgIGNvbnN0IGxvY2F0aW9uSGVhZGVyID0gZGV0YWlscy5yZXNwb25zZUhlYWRlcnMuZmluZChcbi8vICAgICAgICAgaGVhZGVyID0+IGhlYWRlci5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhdGlvbicpO1xuLy8gICAgICAgY29uc3QgYmFzZTY0ID0gbG9jYXRpb25IZWFkZXIgJiYgbG9jYXRpb25IZWFkZXIudmFsdWU7XG4vLyAgICAgICByZXR1cm4ge1xuLy8gICAgICAgICByZWRpcmVjdFVybDogYGRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04LCR7YmFzZTY0IHx8ICcnfWAsXG4vLyAgICAgICB9O1xuLy8gICAgIH1cbi8vICAgfVxuLy8gfSwge1xuLy8gICB1cmxzOiBbJzxhbGxfdXJscz4nXSxcbi8vICAgdHlwZXM6IFsneG1saHR0cHJlcXVlc3QnXSxcbi8vIH0sIFsnYmxvY2tpbmcnLCAncmVzcG9uc2VIZWFkZXJzJ10pO1xuLy8gYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uQ29tcGxldGVkLmFkZExpc3RlbmVyKGRldGFpbHMgPT4ge1xuLy8gICBkZWxldGUgdGFza3NbZGV0YWlscy5yZXF1ZXN0SWRdO1xuLy8gfSwge1xuLy8gICB1cmxzOiBbJzxhbGxfdXJscz4nXSxcbi8vICAgdHlwZXM6IFsneG1saHR0cHJlcXVlc3QnXSxcbi8vIH0pO1xuLy8gYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uRXJyb3JPY2N1cnJlZC5hZGRMaXN0ZW5lcihkZXRhaWxzID0+IHtcbi8vICAgZGVsZXRlIHRhc2tzW2RldGFpbHMucmVxdWVzdElkXTtcbi8vIH0sIHtcbi8vICAgdXJsczogWyc8YWxsX3VybHM+J10sXG4vLyAgIHR5cGVzOiBbJ3htbGh0dHByZXF1ZXN0J10sXG4vLyB9KTtcblxuYXN5bmMgZnVuY3Rpb24gY29uZmlybUluc3RhbGwoeyBjb2RlLCBmcm9tLCB1cmwgfSwgeyB0YWIgPSB7fSB9KSB7XG4gIGlmICghY29kZSkgY29kZSA9IChhd2FpdCByZXF1ZXN0KHVybCkpLmRhdGE7XG4gIC8vIFRPRE86IGRpc3BsYXkgdGhlIGVycm9yIGluIFVJXG4gIGlmICghaXNVc2VyU2NyaXB0KGNvZGUpKSB0aHJvdyBpMThuKCdtc2dJbnZhbGlkU2NyaXB0Jyk7XG4gIGNhY2hlLnB1dCh1cmwsIGNvZGUsIDMwMDApO1xuICBjb25zdCBjb25maXJtS2V5ID0gZ2V0VW5pcUlkKCk7XG4gIGNvbnN0IHsgYWN0aXZlLCBpZDogdGFiSWQsIGluY29nbml0byB9ID0gdGFiO1xuICAvLyBOb3QgdGVzdGluZyB0YWIucGVuZGluZ1VybCBiZWNhdXNlIGl0IHdpbGwgYmUgYWx3YXlzIGVxdWFsIHRvIGB1cmxgXG4gIGNvbnN0IGNhblJlcGxhY2VDdXJUYWIgPSAoIWluY29nbml0byB8fCBJU19GSVJFRk9YKSAmJiAoXG4gICAgdXJsID09PSBmcm9tXG4gICAgfHwgY2FjaGUuaGFzKGBhdXRvY2xvc2U6JHt0YWJJZH1gKVxuICAgIHx8IC9eKGNocm9tZTpcXC9cXC8obmV3dGFifHN0YXJ0cGFnZSlcXC98YWJvdXQ6KGhvbWV8bmV3dGFiKSkkLy50ZXN0KGZyb20pKTtcbiAgLyoqIEBuYW1lc3BhY2UgVk1Db25maXJtQ2FjaGUgKi9cbiAgY2FjaGUucHV0KGBjb25maXJtLSR7Y29uZmlybUtleX1gLCB7IGluY29nbml0bywgdXJsLCBmcm9tLCB0YWJJZCwgZmY6IHVhLmZpcmVmb3ggfSk7XG4gIGNvbnN0IGNvbmZpcm1VcmwgPSBDT05GSVJNX1VSTF9CQVNFICsgY29uZmlybUtleTtcbiAgY29uc3QgeyB3aW5kb3dJZCB9ID0gY2FuUmVwbGFjZUN1clRhYlxuICAgID8gYXdhaXQgYnJvd3Nlci50YWJzLnVwZGF0ZSh0YWJJZCwgeyB1cmw6IGNvbmZpcm1VcmwgfSlcbiAgICA6IGF3YWl0IGNvbW1hbmRzLlRhYk9wZW4oeyB1cmw6IGNvbmZpcm1VcmwsIGFjdGl2ZTogISFhY3RpdmUgfSwgeyB0YWIgfSk7XG4gIGlmIChhY3RpdmUgJiYgd2luZG93SWQgIT09IHRhYi53aW5kb3dJZCkge1xuICAgIGF3YWl0IGJyb3dzZXIud2luZG93cy51cGRhdGUod2luZG93SWQsIHsgZm9jdXNlZDogdHJ1ZSB9KTtcbiAgfVxufVxuXG5jb25zdCB3aGl0ZWxpc3RSZSA9IG5ldyBSZWdFeHAoYF5odHRwczovLygke1xuICBbXG4gICAgJ2dyZWFzeWZvcmtcXFxcLm9yZy9zY3JpcHRzLyUvY29kZS8nLFxuICAgICdvcGVudXNlcmpzXFxcXC5vcmcvaW5zdGFsbC8lLycsXG4gICAgJ2dpdGh1YlxcXFwuY29tLyUvJS9yYXcvJS8nLFxuICAgICdnaXRodWJcXFxcLmNvbS8lLyUvcmVsZWFzZXMvJS9kb3dubG9hZC8nLFxuICAgICdyYXdcXFxcLmdpdGh1YnVzZXJjb250ZW50XFxcXC5jb20oLyUpezN9LycsXG4gICAgJ2dpc3RcXFxcLmdpdGh1YlxcXFwuY29tLy4qPy8nLFxuICBdLmpvaW4oJ3wnKVxufSklP1xcXFwudXNlclxcXFwuanMoWz8jXXwkKWAucmVwbGFjZSgvJS9nLCAnW14vXSonKSk7XG5cbmNvbnN0IGJsYWNrbGlzdFJlID0gbmV3IFJlZ0V4cChgXmh0dHBzOi8vKCR7XG4gIFtcbiAgICAnKGdpc3RcXFxcLik/Z2l0aHViXFxcXC5jb20nLFxuICAgICdncmVhc3lmb3JrXFxcXC5vcmcnLFxuICAgICdvcGVudXNlcmpzXFxcXC5vcmcnLFxuICBdLmpvaW4oJ3wnKVxufSkvYCk7XG5cbmNvbnN0IHJlc29sdmVWaXJ0dWFsVXJsID0gdXJsID0+IChcbiAgYCR7ZXh0ZW5zaW9uUm9vdH1vcHRpb25zL2luZGV4Lmh0bWwjc2NyaXB0cy8keyt1cmwuc3BsaXQoJyMnKVsxXX1gXG4pO1xuLy8gRkYgY2FuJ3QgaW50ZXJjZXB0IHZpcnR1YWwgLnVzZXIuanMgVVJMIHZpYSB3ZWJSZXF1ZXN0LCBzbyB3ZSByZWRpcmVjdCBpdCBleHBsaWNpdGx5XG5jb25zdCB2aXJ0dWFsVXJsUmUgPSBJU19GSVJFRk9YICYmIG5ldyBSZWdFeHAoKFxuICBgXih2aWV3LXNvdXJjZTopPygke2V4dGVuc2lvblJvb3QucmVwbGFjZSgnOi8vJywgJyQmKT8nKX1bXi9dKlxcXFwudXNlclxcXFwuanMjXFxcXGQrYFxuKSk7XG5jb25zdCBtYXliZVJlZGlyZWN0VmlydHVhbFVybEZGID0gdmlydHVhbFVybFJlICYmICgodGFiSWQsIHNyYykgPT4ge1xuICBpZiAodmlydHVhbFVybFJlLnRlc3Qoc3JjKSkge1xuICAgIGJyb3dzZXIudGFicy51cGRhdGUodGFiSWQsIHsgdXJsOiByZXNvbHZlVmlydHVhbFVybChzcmMpIH0pO1xuICB9XG59KTtcbmlmICh2aXJ0dWFsVXJsUmUpIHtcbiAgY29uc3QgbGlzdGVuZXIgPSAodGFiSWQsIHsgdXJsIH0pID0+IHVybCAmJiBtYXliZVJlZGlyZWN0VmlydHVhbFVybEZGKHRhYklkLCB1cmwpO1xuICBjb25zdCBhcGlFdmVudCA9IGJyb3dzZXIudGFicy5vblVwZGF0ZWQ7XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gYXBpRXZlbnQuYWRkTGlzdGVuZXIuYmluZChhcGlFdmVudCwgbGlzdGVuZXIpO1xuICB0cnkgeyBhZGRMaXN0ZW5lcih7IHByb3BlcnRpZXM6IFsndXJsJ10gfSk7IH0gY2F0Y2ggKGUpIHsgYWRkTGlzdGVuZXIoKTsgfVxufVxuXG5icm93c2VyLnRhYnMub25DcmVhdGVkLmFkZExpc3RlbmVyKCh0YWIpID0+IHtcbiAgY29uc3QgeyBpZCwgdGl0bGUsIHVybCB9ID0gdGFiO1xuICAvKiBEZXRlcm1pbmluZyBpZiB0aGlzIHRhYiBjYW4gYmUgYXV0by1jbG9zZWQgKHJlcGxhY2VkLCBhY3R1YWxseSkuXG4gICAgIEZGPj02OCBhbGxvd3MgcmVhZGluZyBmaWxlOiBVUkwgb25seSBpbiB0aGUgdGFiJ3MgY29udGVudCBzY3JpcHQgc28gdGhlIHRhYiBtdXN0IHN0YXkgb3Blbi4gKi9cbiAgaWYgKCghdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6JykgfHwgdWEuZmlyZWZveCA8IDY4KVxuICAgICAgJiYgL1xcLnVzZXJcXC5qcyhbPyNdfCQpLy50ZXN0KHRhYi5wZW5kaW5nVXJsIHx8IHVybCkpIHtcbiAgICBjYWNoZS5wdXQoYGF1dG9jbG9zZToke2lkfWAsIHRydWUsIDEwZTMpO1xuICB9XG4gIGlmICh2aXJ0dWFsVXJsUmUgJiYgdXJsID09PSAnYWJvdXQ6YmxhbmsnKSB7XG4gICAgbWF5YmVSZWRpcmVjdFZpcnR1YWxVcmxGRihpZCwgdGl0bGUpO1xuICB9XG59KTtcblxuYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uQmVmb3JlUmVxdWVzdC5hZGRMaXN0ZW5lcigocmVxKSA9PiB7XG4gIGNvbnN0IHsgbWV0aG9kLCB0YWJJZCwgdXJsIH0gPSByZXE7XG4gIGlmIChtZXRob2QgIT09ICdHRVQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIG9wZW4gYSByZWFsIFVSTCBmb3Igc2ltcGxpZmllZCB1c2Vyc2NyaXB0IFVSTCBsaXN0ZWQgaW4gZGV2dG9vbHMgb2YgdGhlIHdlYiBwYWdlXG4gIGlmICh1cmwuc3RhcnRzV2l0aChleHRlbnNpb25Sb290KSkge1xuICAgIHJldHVybiB7IHJlZGlyZWN0VXJsOiByZXNvbHZlVmlydHVhbFVybCh1cmwpIH07XG4gIH1cbiAgaWYgKCFjYWNoZS5oYXMoYGJ5cGFzczoke3VybH1gKVxuICAmJiAoIWJsYWNrbGlzdFJlLnRlc3QodXJsKSB8fCB3aGl0ZWxpc3RSZS50ZXN0KHVybCkpKSB7XG4gICAgbWF5YmVJbnN0YWxsVXNlckpzKHRhYklkLCB1cmwpO1xuICAgIHJldHVybiB7IHJlZGlyZWN0VXJsOiAnamF2YXNjcmlwdDp2b2lkIDAnIH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICB9XG59LCB7XG4gIHVybHM6IFtcbiAgICAvLyAxLiAqOi8vIGNvbXByaXNlcyBvbmx5IGh0dHAvaHR0cHNcbiAgICAvLyAyLiB0aGUgQVBJIGlnbm9yZXMgI2hhc2ggcGFydFxuICAgIC8vIDMuIEZpcmVmb3g6IG9uQmVmb3JlUmVxdWVzdCBkb2VzIG5vdCB3b3JrIHdpdGggZmlsZTovLyBvciBtb3otZXh0ZW5zaW9uOi8vXG4gICAgJyo6Ly8qLyoudXNlci5qcycsXG4gICAgJyo6Ly8qLyoudXNlci5qcz8qJyxcbiAgICAnZmlsZTovLyovKi51c2VyLmpzJyxcbiAgICAnZmlsZTovLyovKi51c2VyLmpzPyonLFxuICAgIGAke2V4dGVuc2lvblJvb3R9Ki51c2VyLmpzYCxcbiAgXSxcbiAgdHlwZXM6IFsnbWFpbl9mcmFtZSddLFxufSwgWydibG9ja2luZyddKTtcblxuYXN5bmMgZnVuY3Rpb24gbWF5YmVJbnN0YWxsVXNlckpzKHRhYklkLCB1cmwpIHtcbiAgY29uc3QgeyBkYXRhOiBjb2RlIH0gPSBhd2FpdCByZXF1ZXN0KHVybCkuY2F0Y2gobm9vcCkgfHwge307XG4gIGlmIChjb2RlICYmIHBhcnNlTWV0YShjb2RlKS5uYW1lKSB7XG4gICAgY29uc3QgdGFiID0gdGFiSWQgPj0gMCAmJiBhd2FpdCBicm93c2VyLnRhYnMuZ2V0KHRhYklkKSB8fCB7fTtcbiAgICBjb25maXJtSW5zdGFsbCh7IGNvZGUsIHVybCwgZnJvbTogdGFiLnVybCB9LCB7IHRhYiB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZS5wdXQoYGJ5cGFzczoke3VybH1gLCB0cnVlLCAxMGUzKTtcbiAgICBpZiAodGFiSWQgPj0gMCkgYnJvd3Nlci50YWJzLnVwZGF0ZSh0YWJJZCwgeyB1cmwgfSk7XG4gIH1cbn1cblxuLy8gSW4gRmlyZWZveCB3aXRoIHByb2R1Y3Rpb24gY29kZSBvZiBWaW9sZW50bW9ua2V5LCBzY3JpcHRzIGNhbiBiZSBpbmplY3RlZCBiZWZvcmUgYHRhYnMub25VcGRhdGVkYCBpcyBmaXJlZC5cbi8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL3Zpb2xlbnRtb25rZXkvdmlvbGVudG1vbmtleS9pc3N1ZXMvMTI1NVxuXG5icm93c2VyLnRhYnMub25SZW1vdmVkLmFkZExpc3RlbmVyKCh0YWJJZCkgPT4ge1xuICBjbGVhclJlcXVlc3RzQnlUYWJJZCh0YWJJZCk7XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUmVxdWVzdHNCeVRhYklkKHRhYklkKSB7XG4gIGNvbnN0IHNldCA9IHRhYlJlcXVlc3RzW3RhYklkXTtcbiAgaWYgKHNldCkge1xuICAgIGRlbGV0ZSB0YWJSZXF1ZXN0c1t0YWJJZF07XG4gICAgc2V0Ojpmb3JFYWNoRW50cnkoKFtpZF0pID0+IGNvbW1hbmRzLkFib3J0UmVxdWVzdChpZCkpO1xuICB9XG59XG5cbi8qKlxuICogSW1pdGF0aW5nIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9nZXRBbGxSZXNwb25zZUhlYWRlcnNcbiAqIFBlciB0aGUgc3BlY2lmaWNhdGlvbiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCB0aGUgaGVhZGVyIG5hbWUgaXMgd2l0aGluIEFTQ0lJLFxuICogYnV0IHdlJ2xsIHRyeSBlbmNvZGluZyBpdCwgaWYgbmVjZXNzYXJ5LCB0byBoYW5kbGUgaW52YWxpZCBzZXJ2ZXIgcmVzcG9uc2VzLlxuICovXG5mdW5jdGlvbiBlbmNvZGVXZWJSZXF1ZXN0SGVhZGVyKHsgbmFtZSwgdmFsdWUsIGJpbmFyeVZhbHVlIH0pIHtcbiAgcmV0dXJuIGAke3N0cmluZzJieXRlU3RyaW5nKG5hbWUpfTogJHtcbiAgICBiaW5hcnlWYWx1ZVxuICAgICAgPyBidWZmZXIyc3RyaW5nKGJpbmFyeVZhbHVlKVxuICAgICAgOiBzdHJpbmcyYnl0ZVN0cmluZyh2YWx1ZSlcbiAgfVxcclxcbmA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIFVURjgtZW5jb2RlZCBiaW5hcnkgc3RyaW5nIGkuZS4gb25lIGJ5dGUgcGVyIGNoYXJhY3Rlci5cbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHN0cmluZyBpbiBjYXNlIGl0IHdhcyBhbHJlYWR5IHdpdGhpbiBBU0NJSS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nMmJ5dGVTdHJpbmcoc3RyKSB7XG4gIGlmICghL1tcXHUwMDgwLVxcdUZGRkZdLy50ZXN0KHN0cikpIHJldHVybiBzdHI7XG4gIGlmICghZW5jb2RlcikgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICByZXR1cm4gYnVmZmVyMnN0cmluZyhlbmNvZGVyLmVuY29kZShzdHIpKTtcbn1cblxuLyoqIEB0eXBlZGVmIHt7XG4gIGFub255bW91czogYm9vbGVhblxuICBibG9iYmVkOiBib29sZWFuXG4gIGNiOiBmdW5jdGlvbihPYmplY3QpXG4gIGNodW5rZWQ6IGJvb2xlYW5cbiAgY29yZUlkOiBudW1iZXJcbiAgZXZlbnRzVG9Ob3RpZnk6IHN0cmluZ1tdXG4gIGlkOiBudW1iZXJcbiAgbm9OYXRpdmVDb29raWU6IGJvb2xlYW5cbiAgcmVzcG9uc2VIZWFkZXJzOiBzdHJpbmdcbiAgc3RvcmVJZDogc3RyaW5nXG4gIHRhYklkOiBudW1iZXJcbiAgeGhyOiBYTUxIdHRwUmVxdWVzdFxufX0gVk1IdHRwUmVxdWVzdCAqL1xuIiwiaW1wb3J0IHsgZ2V0VW5pcUlkLCBlbmNvZGVGaWxlbmFtZSB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IE1FVEFCTE9DS19SRSB9IGZyb20gJyMvY29tbW9uL2NvbnN0cyc7XG5pbXBvcnQgeyBtYXBFbnRyeSB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgeyBnZXRPcHRpb24gfSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IGNhY2hlIGZyb20gJy4vY2FjaGUnO1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXG4gIENhY2hlTmV3U2NyaXB0KGRhdGEpIHtcbiAgICBjb25zdCBpZCA9IGdldFVuaXFJZCgpO1xuICAgIGNhY2hlLnB1dChgbmV3LSR7aWR9YCwgbmV3U2NyaXB0KGRhdGEpKTtcbiAgICByZXR1cm4gaWQ7XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHtWTVNjcmlwdH0gKi9cbiAgTmV3U2NyaXB0KGlkKSB7XG4gICAgcmV0dXJuIGlkICYmIGNhY2hlLmdldChgbmV3LSR7aWR9YCkgfHwgbmV3U2NyaXB0KCk7XG4gIH0sXG4gIFBhcnNlTWV0YTogcGFyc2VNZXRhLFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VzZXJTY3JpcHQodGV4dCkge1xuICBpZiAoL15cXHMqPC8udGVzdCh0ZXh0KSkgcmV0dXJuIGZhbHNlOyAvLyBIVE1MXG4gIGlmICh0ZXh0LmluZGV4T2YoJy8vID09VXNlclNjcmlwdD09JykgPCAwKSByZXR1cm4gZmFsc2U7IC8vIExhY2sgb2YgbWV0YSBibG9ja1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgYXJyYXlUeXBlID0ge1xuICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAgdHJhbnNmb3JtOiAocmVzLCB2YWwpID0+IHtcbiAgICByZXMucHVzaCh2YWwpO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG59O1xuY29uc3QgZGVmYXVsdFR5cGUgPSB7XG4gIGRlZmF1bHQ6ICgpID0+IG51bGwsXG4gIHRyYW5zZm9ybTogKHJlcywgdmFsKSA9PiAocmVzID09IG51bGwgPyB2YWwgOiByZXMpLFxufTtcbmNvbnN0IG1ldGFUeXBlcyA9IHtcbiAgaW5jbHVkZTogYXJyYXlUeXBlLFxuICBleGNsdWRlOiBhcnJheVR5cGUsXG4gIG1hdGNoOiBhcnJheVR5cGUsXG4gIGV4Y2x1ZGVNYXRjaDogYXJyYXlUeXBlLFxuICByZXF1aXJlOiBhcnJheVR5cGUsXG4gIHJlc291cmNlOiB7XG4gICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgICB0cmFuc2Zvcm06IChyZXMsIHZhbCkgPT4ge1xuICAgICAgY29uc3QgcGFpciA9IHZhbC5tYXRjaCgvXihcXHdcXFMqKVxccysoLiopLyk7XG4gICAgICBpZiAocGFpcikgcmVzW3BhaXJbMV1dID0gcGFpclsyXTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgfSxcbiAgZ3JhbnQ6IGFycmF5VHlwZSxcbiAgbm9mcmFtZXM6IHtcbiAgICBkZWZhdWx0OiAoKSA9PiBmYWxzZSxcbiAgICB0cmFuc2Zvcm06ICgpID0+IHRydWUsXG4gIH0sXG59O1xuY29uc3QgbWV0YU9wdGlvbmFsVHlwZXMgPSB7XG4gIGFudGlmZWF0dXJlOiBhcnJheVR5cGUsXG4gIGNvbXBhdGlibGU6IGFycmF5VHlwZSxcbiAgY29ubmVjdDogYXJyYXlUeXBlLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1ldGEoY29kZSkge1xuICAvLyBpbml0aWFsaXplIG1ldGFcbiAgY29uc3QgbWV0YSA9IG1ldGFUeXBlczo6bWFwRW50cnkoKFssIHZhbHVlXSkgPT4gdmFsdWUuZGVmYXVsdCgpKTtcbiAgY29uc3QgbWV0YUJvZHkgPSBjb2RlLm1hdGNoKE1FVEFCTE9DS19SRSlbMV0gfHwgJyc7XG4gIG1ldGFCb2R5LnJlcGxhY2UoLyg/Ol58XFxuKVxccypcXC9cXC9cXHgyMChAXFxTKykoLiopL2csIChfbWF0Y2gsIHJhd0tleSwgcmF3VmFsdWUpID0+IHtcbiAgICBjb25zdCBba2V5TmFtZSwgbG9jYWxlXSA9IHJhd0tleS5zbGljZSgxKS5zcGxpdCgnOicpO1xuICAgIGNvbnN0IGNhbWVsS2V5ID0ga2V5TmFtZS5yZXBsYWNlKC9bLV9dKFxcdykvZywgKG0sIGcpID0+IGcudG9VcHBlckNhc2UoKSk7XG4gICAgY29uc3Qga2V5ID0gbG9jYWxlID8gYCR7Y2FtZWxLZXl9OiR7bG9jYWxlLnRvTG93ZXJDYXNlKCl9YCA6IGNhbWVsS2V5O1xuICAgIGNvbnN0IHZhbCA9IHJhd1ZhbHVlLnRyaW0oKTtcbiAgICBjb25zdCBtZXRhVHlwZSA9IG1ldGFUeXBlc1trZXldIHx8IG1ldGFPcHRpb25hbFR5cGVzW2tleV0gfHwgZGVmYXVsdFR5cGU7XG4gICAgbGV0IG9sZFZhbHVlID0gbWV0YVtrZXldO1xuICAgIGlmICh0eXBlb2Ygb2xkVmFsdWUgPT09ICd1bmRlZmluZWQnKSBvbGRWYWx1ZSA9IG1ldGFUeXBlLmRlZmF1bHQoKTtcbiAgICBtZXRhW2tleV0gPSBtZXRhVHlwZS50cmFuc2Zvcm0ob2xkVmFsdWUsIHZhbCk7XG4gIH0pO1xuICBtZXRhLnJlc291cmNlcyA9IG1ldGEucmVzb3VyY2U7XG4gIGRlbGV0ZSBtZXRhLnJlc291cmNlO1xuICAvLyBAaG9tZXBhZ2VVUkw6IGNvbXBhdGlibGUgd2l0aCBAaG9tZXBhZ2VcbiAgaWYgKCFtZXRhLmhvbWVwYWdlVVJMICYmIG1ldGEuaG9tZXBhZ2UpIG1ldGEuaG9tZXBhZ2VVUkwgPSBtZXRhLmhvbWVwYWdlO1xuICByZXR1cm4gbWV0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRDdXN0b20oKSB7XG4gIHJldHVybiB7XG4gICAgb3JpZ0luY2x1ZGU6IHRydWUsXG4gICAgb3JpZ0V4Y2x1ZGU6IHRydWUsXG4gICAgb3JpZ01hdGNoOiB0cnVlLFxuICAgIG9yaWdFeGNsdWRlTWF0Y2g6IHRydWUsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdTY3JpcHQoZGF0YSkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICB1cmw6ICcqOi8vKi8qJyxcbiAgICBuYW1lOiAnJyxcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgLi4uZGF0YSxcbiAgfTtcbiAgY29uc3QgY29kZSA9IGdldE9wdGlvbignc2NyaXB0VGVtcGxhdGUnKVxuICAucmVwbGFjZSgve3soXFx3Kyl9fS9nLCAoc3RyLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZVtuYW1lXTtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHN0ciA6IHZhbHVlO1xuICB9KTtcbiAgY29uc3Qgc2NyaXB0ID0ge1xuICAgIGN1c3RvbTogZ2V0RGVmYXVsdEN1c3RvbSgpLFxuICAgIGNvbmZpZzoge1xuICAgICAgZW5hYmxlZDogMSxcbiAgICAgIHNob3VsZFVwZGF0ZTogMSxcbiAgICB9LFxuICAgIG1ldGE6IHBhcnNlTWV0YShjb2RlKSxcbiAgICBwcm9wczoge30sXG4gIH07XG4gIHJldHVybiB7IHNjcmlwdCwgY29kZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmFtZVVSSShzY3JpcHQpIHtcbiAgY29uc3QgbnMgPSBzY3JpcHQubWV0YS5uYW1lc3BhY2UgfHwgJyc7XG4gIGNvbnN0IG5hbWUgPSBzY3JpcHQubWV0YS5uYW1lIHx8ICcnO1xuICBsZXQgbmFtZVVSSSA9IGVuY29kZUZpbGVuYW1lKGAke25zfVxcbiR7bmFtZX1cXG5gKTtcbiAgaWYgKCFucyAmJiAhbmFtZSkgbmFtZVVSSSArPSBzY3JpcHQucHJvcHMuaWQgfHwgJyc7XG4gIHJldHVybiBuYW1lVVJJO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGxvYWRRdWVyeShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJicpLnJlZHVjZSgoZGF0YSwgcGllY2UpID0+IHtcbiAgICBjb25zdCBba2V5LCB2YWxdID0gcGllY2Uuc3BsaXQoJz0nKS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KTtcbiAgICBkYXRhW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGR1bXBRdWVyeShkaWN0KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkaWN0KVxuICAubWFwKGtleVZhbCA9PiBrZXlWYWwubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbignPScpKVxuICAuam9pbignJicpO1xufVxuIiwiaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCBzdG9yYWdlIGZyb20gJyMvY29tbW9uL3N0b3JhZ2UnO1xuXG4vKiogQHR5cGUgeyBmdW5jdGlvbih1cmwsIG9wdGlvbnMsIGNoZWNrKTogUHJvbWlzZTx2b2lkPiB9IG9yIHRocm93cyBvbiBlcnJvciAqL1xuc3RvcmFnZS5jYWNoZS5mZXRjaCA9IGNhY2hlT3JGZXRjaCh7XG4gIGluaXQob3B0aW9ucykge1xuICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIHJlc3BvbnNlVHlwZTogJ2Jsb2InIH07XG4gIH0sXG4gIGFzeW5jIHRyYW5zZm9ybShyZXNwb25zZSwgdXJsLCBvcHRpb25zLCBjaGVjaykge1xuICAgIGNvbnN0IFt0eXBlLCBib2R5XSA9IGF3YWl0IHN0b3JhZ2UuY2FjaGUubWFrZVJhdyhyZXNwb25zZSwgdHJ1ZSk7XG4gICAgYXdhaXQgY2hlY2s/Lih1cmwsIHJlc3BvbnNlLmRhdGEsIHR5cGUpO1xuICAgIHJldHVybiBgJHt0eXBlfSwke2JvZHl9YDtcbiAgfSxcbn0pO1xuXG4vKiogQHR5cGUgeyBmdW5jdGlvbih1cmwsIG9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IH0gb3IgdGhyb3dzIG9uIGVycm9yICovXG5zdG9yYWdlLnJlcXVpcmUuZmV0Y2ggPSBjYWNoZU9yRmV0Y2goe1xuICB0cmFuc2Zvcm06ICh7IGRhdGEgfSwgdXJsKSA9PiAoXG4gICAgL15cXHMqPC8udGVzdChkYXRhKVxuICAgICAgPyBQcm9taXNlLnJlamVjdChgTk9UX0pTOiAke3VybH0gXCIke2RhdGEuc2xpY2UoMCwgMTAwKS50cmltKCkucmVwbGFjZSgvXFxzezIsfS9nLCAnICcpfVwiYClcbiAgICAgIDogZGF0YVxuICApLFxufSk7XG5cbmZ1bmN0aW9uIGNhY2hlT3JGZXRjaChoYW5kbGVycyA9IHt9KSB7XG4gIGNvbnN0IHJlcXVlc3RzID0ge307XG4gIGNvbnN0IHsgaW5pdCwgdHJhbnNmb3JtIH0gPSBoYW5kbGVycztcbiAgLyoqIEB0aGlzIFZNU3RvcmFnZUJhc2UgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlT3JGZXRjaEhhbmRsZXIoLi4uYXJncykge1xuICAgIGNvbnN0IFt1cmxdID0gYXJncztcbiAgICBjb25zdCBwcm9taXNlID0gcmVxdWVzdHNbdXJsXSB8fCAocmVxdWVzdHNbdXJsXSA9IHRoaXM6OmRvRmV0Y2goLi4uYXJncykpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICAvKiogQHRoaXMgVk1TdG9yYWdlQmFzZSAqL1xuICBhc3luYyBmdW5jdGlvbiBkb0ZldGNoKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbdXJsLCBvcHRpb25zXSA9IGFyZ3M7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QodXJsLCBpbml0Py4ob3B0aW9ucykgfHwgb3B0aW9ucyk7XG4gICAgICBpZiAoYXdhaXQgaXNNb2RpZmllZChyZXMsIHVybCkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtID8gYXdhaXQgdHJhbnNmb3JtKHJlcywgLi4uYXJncykgOiByZXMuZGF0YTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXQodXJsLCByZXN1bHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZzogJHt1cmx9YCwgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RzW3VybF07XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzTW9kaWZpZWQoeyBoZWFkZXJzIH0sIHVybCkge1xuICBjb25zdCBtb2QgPSBoZWFkZXJzLmdldCgnZXRhZycpXG4gIHx8ICtuZXcgRGF0ZShoZWFkZXJzLmdldCgnbGFzdC1tb2RpZmllZCcpKVxuICB8fCArbmV3IERhdGUoaGVhZGVycy5nZXQoJ2RhdGUnKSk7XG4gIGlmICghbW9kIHx8IG1vZCAhPT0gYXdhaXQgc3RvcmFnZS5tb2QuZ2V0T25lKHVybCkpIHtcbiAgICBpZiAobW9kKSBhd2FpdCBzdG9yYWdlLm1vZC5zZXQodXJsLCBtb2QpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCJpbXBvcnQgeyBnZXRBY3RpdmVUYWIsIG5vb3AsIHNlbmRUYWJDbWQsIGdldEZ1bGxVcmwgfSBmcm9tICcjL2NvbW1vbic7XG5pbXBvcnQgeyBkZWVwQ29weSB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgdWEgZnJvbSAnIy9jb21tb24vdWEnO1xuaW1wb3J0IHsgZXh0ZW5zaW9uUm9vdCB9IGZyb20gJy4vaW5pdCc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgeyBnZXRPcHRpb24gfSBmcm9tICcuL29wdGlvbnMnO1xuXG5jb25zdCBvcGVuZXJzID0ge307XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aElkXSAtIHBhdGggb3IgaWQgdG8gYWRkIHRvICNzY3JpcHRzIHJvdXRlIGluIGRhc2hib2FyZCxcbiAgICAgaWYgYWJzZW50IGEgbmV3IHNjcmlwdCB3aWxsIGJlIGNyZWF0ZWQgZm9yIGFjdGl2ZSB0YWIncyBVUkxcbiAgICogQHJldHVybnMge1Byb21pc2U8e2lkOiBudW1iZXJ9Pn1cbiAgICovXG4gIGFzeW5jIE9wZW5FZGl0b3IocGF0aElkKSB7XG4gICAgaWYgKCFwYXRoSWQpIHtcbiAgICAgIGNvbnN0IHsgdGFiLCBkb21haW4gfSA9IGF3YWl0IGNvbW1hbmRzLkdldFRhYkRvbWFpbigpO1xuICAgICAgY29uc3QgaWQgPSBkb21haW4gJiYgY29tbWFuZHMuQ2FjaGVOZXdTY3JpcHQoe1xuICAgICAgICB1cmw6ICh0YWIucGVuZGluZ1VybCB8fCB0YWIudXJsKS5zcGxpdCgvWyM/XS8pWzBdLFxuICAgICAgICBuYW1lOiBgJHtnZXRPcHRpb24oJ3NjcmlwdFRlbXBsYXRlRWRpdGVkJykgPyAnJyA6ICctICd9JHtkb21haW59YCxcbiAgICAgIH0pO1xuICAgICAgcGF0aElkID0gYF9uZXcke2lkID8gYC8ke2lkfWAgOiAnJ31gO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHtleHRlbnNpb25Sb290fW9wdGlvbnMvaW5kZXguaHRtbCNzY3JpcHRzLyR7cGF0aElkfWA7XG4gICAgLy8gRmlyZWZveCB1bnRpbCB2NTYgZG9lc24ndCBzdXBwb3J0IG1vei1leHRlbnNpb246Ly8gcGF0dGVybiBpbiBicm93c2VyLnRhYnMucXVlcnkoKVxuICAgIGZvciAoY29uc3QgdmlldyBvZiBicm93c2VyLmV4dGVuc2lvbi5nZXRWaWV3cygpKSB7XG4gICAgICBpZiAodmlldy5sb2NhdGlvbi5ocmVmID09PSB1cmwpIHtcbiAgICAgICAgLy8gZGVlcC1jb3B5aW5nIHRvIGF2b2lkIGRlYWQgb2JqZWN0c1xuICAgICAgICBjb25zdCB0YWIgPSBkZWVwQ29weShhd2FpdCB2aWV3LmJyb3dzZXIudGFicy5nZXRDdXJyZW50KCkpO1xuICAgICAgICBicm93c2VyLnRhYnMudXBkYXRlKHRhYi5pZCwgeyBhY3RpdmU6IHRydWUgfSk7XG4gICAgICAgIGJyb3dzZXIud2luZG93cy51cGRhdGUodGFiLndpbmRvd0lkLCB7IGZvY3VzZWQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB0YWI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy5UYWJPcGVuKHsgdXJsLCBtYXliZUluV2luZG93OiB0cnVlIH0pO1xuICB9LFxuICAvKiogQHJldHVybiB7UHJvbWlzZTx7IGlkOiBudW1iZXIgfSB8IGNocm9tZS50YWJzLlRhYj59IG5ldyB0YWIgaXMgcmV0dXJuZWQgZm9yIGludGVybmFsIGNhbGxzICovXG4gIGFzeW5jIFRhYk9wZW4oe1xuICAgIHVybCxcbiAgICBhY3RpdmUgPSB0cnVlLFxuICAgIGNvbnRhaW5lcixcbiAgICBpbnNlcnQgPSB0cnVlLFxuICAgIG1heWJlSW5XaW5kb3cgPSBmYWxzZSxcbiAgICBwaW5uZWQsXG4gIH0sIHNyYyA9IHt9KSB7XG4gICAgLy8gc3JjLnRhYiBtYXkgYmUgYWJzZW50IHdoZW4gaW52b2tlZCBmcm9tIHBvcHVwIChlLmcuIGVkaXQvY3JlYXRlIGJ1dHRvbnMpXG4gICAgY29uc3Qgc3JjVGFiID0gc3JjLnRhYiB8fCBhd2FpdCBnZXRBY3RpdmVUYWIoKSB8fCB7fTtcbiAgICAvLyBzcmMudXJsIG1heSBiZSBhYnNlbnQgd2hlbiBpbnZva2VkIGRpcmVjdGx5IGFzIGNvbW1hbmRzLlRhYk9wZW5cbiAgICBjb25zdCBzcmNVcmwgPSBzcmMudXJsO1xuICAgIGNvbnN0IGlzSW50ZXJuYWwgPSAhc3JjVXJsIHx8IHNyY1VybC5zdGFydHNXaXRoKGV4dGVuc2lvblJvb3QpO1xuICAgIC8vIG9ubHkgaW5jb2duaXRvIHN0b3JlSWQgbWF5IGJlIHNwZWNpZmllZCB3aGVuIG9wZW5pbmcgaW4gYW4gaW5jb2duaXRvIHdpbmRvd1xuICAgIGNvbnN0IHsgaW5jb2duaXRvLCB3aW5kb3dJZCB9ID0gc3JjVGFiO1xuICAgIC8vIENocm9tZSBjYW4ndCBvcGVuIGNocm9tZS14eHg6IFVSTHMgaW4gaW5jb2duaXRvIHdpbmRvd3NcbiAgICBsZXQgc3RvcmVJZCA9IHNyY1RhYi5jb29raWVTdG9yZUlkO1xuICAgIGlmIChzdG9yZUlkICYmICFpbmNvZ25pdG8pIHtcbiAgICAgIHN0b3JlSWQgPSBnZXRDb250YWluZXJJZChpc0ludGVybmFsID8gMCA6IGNvbnRhaW5lcikgfHwgc3RvcmVJZDtcbiAgICB9XG4gICAgaWYgKHN0b3JlSWQpIHN0b3JlSWQgPSB7IGNvb2tpZVN0b3JlSWQ6IHN0b3JlSWQgfTtcbiAgICAvLyBVUkwgbmVlZHMgdG8gYmUgZXhwYW5kZWQgZm9yIGBjYW5PcGVuSW5jb2duaXRvYCBiZWxvd1xuICAgIGlmICghL15bLVxcd10rOi8udGVzdCh1cmwpKSB7XG4gICAgICB1cmwgPSBpc0ludGVybmFsXG4gICAgICAgID8gYnJvd3Nlci5ydW50aW1lLmdldFVSTCh1cmwpXG4gICAgICAgIDogZ2V0RnVsbFVybCh1cmwsIHNyY1VybCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbk9wZW5JbmNvZ25pdG8gPSAhaW5jb2duaXRvIHx8IElTX0ZJUkVGT1ggfHwgIS9eKGNocm9tZVstXFx3XSopOi8udGVzdCh1cmwpO1xuICAgIGxldCBuZXdUYWI7XG4gICAgaWYgKG1heWJlSW5XaW5kb3dcbiAgICAgICAgJiYgYnJvd3Nlci53aW5kb3dzXG4gICAgICAgICYmIGdldE9wdGlvbignZWRpdG9yV2luZG93JylcbiAgICAgICAgLyogY29va2llU3RvcmVJZCBpbiB3aW5kb3dzLmNyZWF0ZSgpIGlzIHN1cHBvcnRlZCBzaW5jZSBGRjY0IGh0dHBzOi8vYnVnemlsLmxhLzEzOTM1NzBcbiAgICAgICAgICogYW5kIGEgd29ya2Fyb3VuZCBpcyB0b28gY29udm9sdXRlZCB0byBhZGQgaXQgZm9yIHN1Y2ggYW4gYW5jaWVudCB2ZXJzaW9uICovXG4gICAgICAgICYmICghc3RvcmVJZCB8fCB1YS5maXJlZm94ID49IDY0KSkge1xuICAgICAgY29uc3Qgd25kT3B0cyA9IHtcbiAgICAgICAgdXJsLFxuICAgICAgICBpbmNvZ25pdG86IGNhbk9wZW5JbmNvZ25pdG8gJiYgaW5jb2duaXRvLFxuICAgICAgICAuLi5nZXRPcHRpb24oJ2VkaXRvcldpbmRvd1NpbXBsZScpICYmIHsgdHlwZTogJ3BvcHVwJyB9LFxuICAgICAgICAuLi4hSVNfRklSRUZPWCAmJiB7IGZvY3VzZWQ6ICEhYWN0aXZlIH0sIC8vIEZGIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzXG4gICAgICAgIC4uLnN0b3JlSWQsXG4gICAgICB9O1xuICAgICAgY29uc3QgcG9zID0gZ2V0T3B0aW9uKCdlZGl0b3JXaW5kb3dQb3MnKTtcbiAgICAgIGNvbnN0IGhhc1BvcyA9IHBvcyAmJiAndG9wJyBpbiBwb3M7XG4gICAgICBjb25zdCB3bmQgPSBhd2FpdCBicm93c2VyLndpbmRvd3MuY3JlYXRlKHsgLi4ud25kT3B0cywgLi4ucG9zIH0pLmNhdGNoKGhhc1BvcyAmJiBub29wKVxuICAgICAgICB8fCBoYXNQb3MgJiYgYXdhaXQgYnJvd3Nlci53aW5kb3dzLmNyZWF0ZSh3bmRPcHRzKTtcbiAgICAgIG5ld1RhYiA9IHduZC50YWJzWzBdO1xuICAgIH1cbiAgICBpZiAoIW5ld1RhYikge1xuICAgICAgbmV3VGFiID0gYXdhaXQgYnJvd3Nlci50YWJzLmNyZWF0ZSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgLy8gbm9ybWFsaXppbmcgYXMgYm9vbGVhbiBiZWNhdXNlIHRoZSBBUEkgcmVxdWlyZXMgc3RyaWN0IHR5cGVzXG4gICAgICAgIGFjdGl2ZTogISFhY3RpdmUsXG4gICAgICAgIHBpbm5lZDogISFwaW5uZWQsXG4gICAgICAgIC4uLnN0b3JlSWQsXG4gICAgICAgIC4uLmNhbk9wZW5JbmNvZ25pdG8gJiYge1xuICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICAgIC4uLmluc2VydCAmJiB7IGluZGV4OiBzcmNUYWIuaW5kZXggKyAxIH0sXG4gICAgICAgICAgLi4udWEub3BlbmVyVGFiSWRTdXBwb3J0ZWQgJiYgeyBvcGVuZXJUYWJJZDogc3JjVGFiLmlkIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCB9ID0gbmV3VGFiO1xuICAgIGlmIChhY3RpdmUgJiYgbmV3VGFiLndpbmRvd0lkICE9PSB3aW5kb3dJZCkge1xuICAgICAgYXdhaXQgYnJvd3Nlci53aW5kb3dzLnVwZGF0ZShuZXdUYWIud2luZG93SWQsIHsgZm9jdXNlZDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgb3BlbmVyc1tpZF0gPSBzcmNUYWIuaWQ7XG4gICAgcmV0dXJuIGlzSW50ZXJuYWwgPyBuZXdUYWIgOiB7IGlkIH07XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHt2b2lkfSAqL1xuICBUYWJDbG9zZSh7IGlkIH0gPSB7fSwgc3JjKSB7XG4gICAgY29uc3QgdGFiSWQgPSBpZCB8fCBzcmM/LnRhYj8uaWQ7XG4gICAgaWYgKHRhYklkID49IDApIGJyb3dzZXIudGFicy5yZW1vdmUodGFiSWQpO1xuICB9LFxuICBUYWJGb2N1cyhfLCBzcmMpIHtcbiAgICBicm93c2VyLnRhYnMudXBkYXRlKHNyYy50YWIuaWQsIHsgYWN0aXZlOiB0cnVlIH0pLmNhdGNoKG5vb3ApO1xuICAgIGJyb3dzZXIud2luZG93cy51cGRhdGUoc3JjLnRhYi53aW5kb3dJZCwgeyBmb2N1c2VkOiB0cnVlIH0pLmNhdGNoKG5vb3ApO1xuICB9LFxufSk7XG5cbi8vIEZpcmVmb3ggQW5kcm9pZCBkb2VzIG5vdCBzdXBwb3J0IGBvcGVuZXJUYWJJZGAgZmllbGQsIGl0IGZhaWxzIGlmIHRoaXMgZmllbGQgaXMgcGFzc2VkXG4vLyBYWFggb3BlbmVyVGFiSWQgc2VlbXMgYnVnZ3kgb24gQ2hyb21lLCBodHRwczovL2NyYnVnLmNvbS85NjcxNTBcbi8vIEl0IHNlZW1zIHRvIGRvIG5vdGhpbmcgZXZlbiBzZXQgc3VjY2Vzc2Z1bGx5IHdpdGggYGJyb3dzZXIudGFicy51cGRhdGVgLlxudWEucmVhZHkudGhlbigoKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHVhLCB7XG4gICAgb3BlbmVyVGFiSWRTdXBwb3J0ZWQ6IHtcbiAgICAgIHZhbHVlOiAhSVNfRklSRUZPWCB8fCB1YS5maXJlZm94ID49IDU3ICYmIHVhLm9zICE9PSAnYW5kcm9pZCcsXG4gICAgfSxcbiAgfSk7XG59KTtcblxuYnJvd3Nlci50YWJzLm9uUmVtb3ZlZC5hZGRMaXN0ZW5lcigoaWQpID0+IHtcbiAgY29uc3Qgb3BlbmVySWQgPSBvcGVuZXJzW2lkXTtcbiAgaWYgKG9wZW5lcklkID49IDApIHtcbiAgICBzZW5kVGFiQ21kKG9wZW5lcklkLCAnVGFiQ2xvc2VkJywgaWQpO1xuICAgIGRlbGV0ZSBvcGVuZXJzW2lkXTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcklkKGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA9PT0gMCAmJiAnZmlyZWZveC1kZWZhdWx0J1xuICAgICAgICAgfHwgaW5kZXggPiAwICYmIGBmaXJlZm94LWNvbnRhaW5lci0ke2luZGV4fWA7XG59XG4iLCJpbXBvcnQgeyBwb3N0SW5pdGlhbGl6ZSB9IGZyb20gJy4vaW5pdCc7XG5pbXBvcnQgeyBnZXREZWZhdWx0T3B0aW9uLCBnZXRPcHRpb24sIHNldE9wdGlvbiB9IGZyb20gJy4vb3B0aW9ucyc7XG5cbmV4cG9ydCBjb25zdCBTQ1JJUFRfVEVNUExBVEUgPSAnc2NyaXB0VGVtcGxhdGUnO1xuY29uc3QgU0NSSVBUX1RFTVBMQVRFX0VESVRFRCA9IGAke1NDUklQVF9URU1QTEFURX1FZGl0ZWRgO1xuY29uc3QgSU5JVElBTF9URU1QTEFURSA9IGBcXFxuLy8gPT1Vc2VyU2NyaXB0PT1cbi8vIEBuYW1lIE5ldyBTY3JpcHRcbi8vIEBuYW1lc3BhY2UgVmlvbGVudG1vbmtleSBTY3JpcHRzXG4vLyBAbWF0Y2gge3t1cmx9fVxuLy8gQGdyYW50IG5vbmVcbi8vID09L1VzZXJTY3JpcHQ9PVxuYDtcblxucG9zdEluaXRpYWxpemUucHVzaCgoKSA9PiB7XG4gIGxldCBlZGl0ZWQgPSBnZXRPcHRpb24oU0NSSVBUX1RFTVBMQVRFX0VESVRFRCk7XG4gIC8vIFByZXNlcnZlIGFuIGVkaXRlZCB0ZW1wbGF0ZVxuICBpZiAoZWRpdGVkKSByZXR1cm47XG4gIGNvbnN0IHRlbXBsYXRlID0gZ2V0T3B0aW9uKFNDUklQVF9URU1QTEFURSk7XG4gIC8vIFdoZW4gdXBkYXRpbmcgZnJvbSBhbiBvbGQgdmVyc2lvbiwgc2V0IHRoZSBlZGl0ZWQgZmxhZyByZXRyb2FjdGl2ZWx5XG4gIGlmIChlZGl0ZWQgPT0gbnVsbCkge1xuICAgIGVkaXRlZCA9IHRlbXBsYXRlICE9PSBJTklUSUFMX1RFTVBMQVRFO1xuICAgIGlmIChlZGl0ZWQpIHNldE9wdGlvbihTQ1JJUFRfVEVNUExBVEVfRURJVEVELCB0cnVlKTtcbiAgICBlbHNlIHJlc2V0U2NyaXB0VGVtcGxhdGUoKTtcbiAgLy8gV2hlbiB1cGRhdGluZyBWTSwgdXBkYXRlIHRvIHRoZSBuZXcgZGVmYXVsdCB0ZW1wbGF0ZVxuICB9IGVsc2UgaWYgKHRlbXBsYXRlICE9PSBnZXREZWZhdWx0T3B0aW9uKFNDUklQVF9URU1QTEFURSkpIHtcbiAgICByZXNldFNjcmlwdFRlbXBsYXRlKCk7XG4gIH1cbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRTY3JpcHRUZW1wbGF0ZShjaGFuZ2VzID0ge30pIHtcbiAgY29uc3QgZGVmYXVsdFRlbXBsYXRlID0gZ2V0RGVmYXVsdE9wdGlvbihTQ1JJUFRfVEVNUExBVEUpO1xuICBsZXQgdGVtcGxhdGUgPSBjaGFuZ2VzW1NDUklQVF9URU1QTEFURV07XG4gIGlmICghdGVtcGxhdGUpIHtcbiAgICB0ZW1wbGF0ZSA9IGRlZmF1bHRUZW1wbGF0ZTtcbiAgICBjaGFuZ2VzW1NDUklQVF9URU1QTEFURV0gPSB0ZW1wbGF0ZTtcbiAgICBzZXRPcHRpb24oU0NSSVBUX1RFTVBMQVRFLCB0ZW1wbGF0ZSk7XG4gIH1cbiAgY29uc3QgZWRpdGVkID0gdGVtcGxhdGUgIT09IGRlZmF1bHRUZW1wbGF0ZTtcbiAgaWYgKGVkaXRlZCAhPT0gY2hhbmdlc1tTQ1JJUFRfVEVNUExBVEVfRURJVEVEXSkge1xuICAgIGNoYW5nZXNbU0NSSVBUX1RFTVBMQVRFX0VESVRFRF0gPSBlZGl0ZWQ7XG4gICAgc2V0T3B0aW9uKFNDUklQVF9URU1QTEFURV9FRElURUQsIGVkaXRlZCk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHRsZCBmcm9tICcjL2NvbW1vbi90bGQnO1xuaW1wb3J0IGNhY2hlIGZyb20gJy4vY2FjaGUnO1xuaW1wb3J0IHsgcG9zdEluaXRpYWxpemUgfSBmcm9tICcuL2luaXQnO1xuaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuL21lc3NhZ2UnO1xuaW1wb3J0IHsgZ2V0T3B0aW9uLCBob29rT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucyc7XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgVGVzdEJsYWNrbGlzdDogdGVzdEJsYWNrbGlzdCxcbn0pO1xuXG5wb3N0SW5pdGlhbGl6ZS5wdXNoKHJlc2V0QmxhY2tsaXN0KTtcblxudGxkLmluaXRUTEQodHJ1ZSk7XG5cbmNvbnN0IFJFX01BVENIX1BBUlRTID0gLyguKj8pOlxcL1xcLyhbXi9dKilcXC8oLiopLztcbmxldCBibGFja2xpc3RSdWxlcyA9IFtdO1xuaG9va09wdGlvbnMoKGNoYW5nZXMpID0+IHtcbiAgaWYgKCdibGFja2xpc3QnIGluIGNoYW5nZXMpIHJlc2V0QmxhY2tsaXN0KGNoYW5nZXMuYmxhY2tsaXN0IHx8ICcnKTtcbn0pO1xuY29uc3QgUkVfSFRUUF9PUl9IVFRQUyA9IC9eaHR0cHM/JC9pO1xuXG4vKlxuIFNpbXBsZSBGSUZPIHF1ZXVlIGZvciB0aGUgcmVzdWx0cyBvZiB0ZXN0QmxhY2tsaXN0LCBjYWNoZWQgc2VwYXJhdGVseSBmcm9tIHRoZSBtYWluIHxjYWNoZXxcbiBiZWNhdXNlIHRoZSBibGFja2xpc3QgaXMgdXBkYXRlZCBvbmx5IG9uY2UgaW4gYSB3aGlsZSBzbyBpdHMgZW50cmllcyB3b3VsZCBiZSBjcm93ZGluZ1xuIHRoZSBtYWluIGNhY2hlIGFuZCByZWR1Y2luZyBpdHMgcGVyZm9ybWFuY2UgKG9iamVjdHMgd2l0aCBsb3RzIG9mIGtleXMgYXJlIHNsb3cgdG8gYWNjZXNzKS5cblxuIFdlIGFsc28gZG9uJ3QgbmVlZCB0byBhdXRvLWV4cGlyZSB0aGUgZW50cmllcyBhZnRlciBhIHRpbWVvdXQuXG4gVGhlIG9ubHkgbGltaXQgd2UncmUgY29uY2VybmVkIHdpdGggaXMgdGhlIG92ZXJhbGwgbWVtb3J5IHVzZWQuXG4gVGhlIGxpbWl0IGlzIHNwZWNpZmllZCBpbiB0aGUgYW1vdW50IG9mIHVuaWNvZGUgY2hhcmFjdGVycyAoc3RyaW5nIGxlbmd0aCkgZm9yIHNpbXBsaWNpdHkuXG4gRGlzcmVnYXJkaW5nIGRlZHVwbGljYXRpb24gZHVlIHRvIGludGVybmluZywgdGhlIGFjdHVhbCBtZW1vcnkgdXNlZCBpcyBhcHByb3hpbWF0ZWx5IHR3aWNlIGFzIGJpZzpcbiAyICoga2V5TGVuZ3RoICsgb2JqZWN0U3RydWN0dXJlT3ZlcmhlYWQgKiBvYmplY3RDb3VudFxuKi9cbmNvbnN0IE1BWF9CTF9DQUNIRV9MRU5HVEggPSAxMDBlMztcbmxldCBibENhY2hlID0ge307XG5sZXQgYmxDYWNoZVNpemUgPSAwO1xuXG5mdW5jdGlvbiB0ZXN0UnVsZXModXJsLCBydWxlcywgcHJlZml4LCBydWxlQnVpbGRlcikge1xuICByZXR1cm4gcnVsZXMuc29tZShydWxlID0+IHtcbiAgICBjb25zdCBrZXkgPSBgJHtwcmVmaXh9OiR7cnVsZX1gO1xuICAgIGNvbnN0IG1hdGNoZXIgPSBjYWNoZS5nZXQoa2V5KSB8fCBjYWNoZS5wdXQoa2V5LCBydWxlQnVpbGRlcihydWxlKSk7XG4gICAgcmV0dXJuIG1hdGNoZXIudGVzdCh1cmwpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUZXN0IGdsb2IgcnVsZXMgbGlrZSBgQGluY2x1ZGVgIGFuZCBgQGV4Y2x1ZGVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVzdEdsb2IodXJsLCBydWxlcykge1xuICByZXR1cm4gdGVzdFJ1bGVzKHVybCwgcnVsZXMsICdyZScsIGF1dG9SZWcpO1xufVxuXG4vKipcbiAqIFRlc3QgbWF0Y2ggcnVsZXMgbGlrZSBgQG1hdGNoYCBhbmQgYEBleGNsdWRlX21hdGNoYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlc3RNYXRjaCh1cmwsIHJ1bGVzKSB7XG4gIHJldHVybiB0ZXN0UnVsZXModXJsLCBydWxlcywgJ21hdGNoJywgbWF0Y2hUZXN0ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVzdFNjcmlwdCh1cmwsIHNjcmlwdCkge1xuICBjYWNoZS5iYXRjaCh0cnVlKTtcbiAgY29uc3QgeyBjdXN0b20sIG1ldGEgfSA9IHNjcmlwdDtcbiAgY29uc3QgbWF0ID0gbWVyZ2VMaXN0cyhjdXN0b20ub3JpZ01hdGNoICYmIG1ldGEubWF0Y2gsIGN1c3RvbS5tYXRjaCk7XG4gIGNvbnN0IGluYyA9IG1lcmdlTGlzdHMoY3VzdG9tLm9yaWdJbmNsdWRlICYmIG1ldGEuaW5jbHVkZSwgY3VzdG9tLmluY2x1ZGUpO1xuICBjb25zdCBleGMgPSBtZXJnZUxpc3RzKGN1c3RvbS5vcmlnRXhjbHVkZSAmJiBtZXRhLmV4Y2x1ZGUsIGN1c3RvbS5leGNsdWRlKTtcbiAgY29uc3QgZXhjTWF0ID0gbWVyZ2VMaXN0cyhjdXN0b20ub3JpZ0V4Y2x1ZGVNYXRjaCAmJiBtZXRhLmV4Y2x1ZGVNYXRjaCwgY3VzdG9tLmV4Y2x1ZGVNYXRjaCk7XG4gIC8vIG1hdGNoIGFsbCBpZiBubyBAbWF0Y2ggb3IgQGluY2x1ZGUgcnVsZVxuICBsZXQgb2sgPSAhbWF0Lmxlbmd0aCAmJiAhaW5jLmxlbmd0aDtcbiAgLy8gQG1hdGNoXG4gIG9rID0gb2sgfHwgdGVzdE1hdGNoKHVybCwgbWF0KTtcbiAgLy8gQGluY2x1ZGVcbiAgb2sgPSBvayB8fCB0ZXN0R2xvYih1cmwsIGluYyk7XG4gIC8vIEBleGNsdWRlLW1hdGNoXG4gIG9rID0gb2sgJiYgIXRlc3RNYXRjaCh1cmwsIGV4Y01hdCk7XG4gIC8vIEBleGNsdWRlXG4gIG9rID0gb2sgJiYgIXRlc3RHbG9iKHVybCwgZXhjKTtcbiAgY2FjaGUuYmF0Y2goZmFsc2UpO1xuICByZXR1cm4gb2s7XG59XG5cbmZ1bmN0aW9uIG1lcmdlTGlzdHMoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5yZWR1Y2UoKHJlcywgaXRlbSkgPT4gKGl0ZW0gPyByZXMuY29uY2F0KGl0ZW0pIDogcmVzKSwgW10pO1xufVxuXG5mdW5jdGlvbiBzdHIyUkUoc3RyKSB7XG4gIGNvbnN0IHJlID0gc3RyLnJlcGxhY2UoLyhbLj8rW1xcXXt9KCl8XiRdKS9nLCAnXFxcXCQxJykucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgcmV0dXJuIHJlO1xufVxuXG5mdW5jdGlvbiBiaW5kUkUocmUpIHtcbiAgcmV0dXJuIHJlLnRlc3QuYmluZChyZSk7XG59XG5cbmZ1bmN0aW9uIGF1dG9SZWcoc3RyKSB7XG4gIC8vIHJlZ2V4cCBtb2RlOiBjYXNlLWluc2Vuc2l0aXZlIHBlciBHTSBkb2N1bWVudGF0aW9uXG4gIGlmIChzdHIubGVuZ3RoID4gMSAmJiBzdHJbMF0gPT09ICcvJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICBsZXQgcmU7XG4gICAgdHJ5IHsgcmUgPSBuZXcgUmVnRXhwKHN0ci5zbGljZSgxLCAtMSksICdpJyk7IH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICByZXR1cm4geyB0ZXN0OiByZSA/IGJpbmRSRShyZSkgOiAoKSA9PiBmYWxzZSB9O1xuICB9XG4gIC8vIGdsb2IgbW9kZTogY2FzZS1pbnNlbnNpdGl2ZSB0byBtYXRjaCBHTTQgJiBUYW1wZXJtb25rZXkgYnVnZ2VkIGJlaGF2aW9yXG4gIGNvbnN0IHJlU3RyID0gc3RyMlJFKHN0ci50b0xvd2VyQ2FzZSgpKTtcbiAgaWYgKHRsZC5pc1JlYWR5KCkgJiYgc3RyLmluY2x1ZGVzKCcudGxkLycpKSB7XG4gICAgY29uc3QgcmVUbGRTdHIgPSByZVN0ci5yZXBsYWNlKCdcXFxcLnRsZC8nLCAnKCg/OlxcXFwuWy1cXFxcd10rKSspLycpO1xuICAgIHJldHVybiB7XG4gICAgICB0ZXN0OiAodHN0cikgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdHN0ci50b0xvd2VyQ2FzZSgpLm1hdGNoKHJlVGxkU3RyKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICBjb25zdCBzdWZmaXggPSBtYXRjaGVzWzFdLnNsaWNlKDEpO1xuICAgICAgICAgIGlmICh0bGQuZ2V0UHVibGljU3VmZml4KHN1ZmZpeCkgPT09IHN1ZmZpeCkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgXiR7cmVTdHJ9JGAsICdpJyk7IC8vIFN0cmluZyB3aXRoIHdpbGRjYXJkc1xuICByZXR1cm4geyB0ZXN0OiBiaW5kUkUocmUpIH07XG59XG5cbmZ1bmN0aW9uIG1hdGNoU2NoZW1lKHJ1bGUsIGRhdGEpIHtcbiAgLy8gZXhhY3QgbWF0Y2hcbiAgaWYgKHJ1bGUgPT09IGRhdGEpIHJldHVybiAxO1xuICAvLyAqID0gaHR0cCB8IGh0dHBzXG4gIC8vIHN1cHBvcnQgaHR0cCpcbiAgaWYgKFtcbiAgICAnKicsXG4gICAgJ2h0dHAqJyxcbiAgXS5pbmNsdWRlcyhydWxlKSAmJiBSRV9IVFRQX09SX0hUVFBTLnRlc3QoZGF0YSkpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuY29uc3QgUkVfU1RSX0FOWSA9ICcoPzp8Lio/XFxcXC4pJztcbmNvbnN0IFJFX1NUUl9UTEQgPSAnKCg/OlxcXFwuWy1cXFxcd10rKSspJztcbmZ1bmN0aW9uIGhvc3RNYXRjaGVyKHJ1bGUpIHtcbiAgLy8gKiBtYXRjaGVzIGFsbFxuICBpZiAocnVsZSA9PT0gJyonKSB7XG4gICAgcmV0dXJuICgpID0+IDE7XG4gIH1cbiAgLy8gKi5leGFtcGxlLmNvbVxuICAvLyB3d3cuZ29vZ2xlLipcbiAgLy8gd3d3Lmdvb2dsZS50bGRcbiAgY29uc3QgcnVsZUxDID0gcnVsZS50b0xvd2VyQ2FzZSgpOyAvLyBob3N0IG1hdGNoaW5nIGlzIGNhc2UtaW5zZW5zaXRpdmVcbiAgbGV0IHByZWZpeCA9ICcnO1xuICBsZXQgYmFzZSA9IHJ1bGVMQztcbiAgbGV0IHN1ZmZpeCA9ICcnO1xuICBpZiAocnVsZS5zdGFydHNXaXRoKCcqLicpKSB7XG4gICAgYmFzZSA9IGJhc2Uuc2xpY2UoMik7XG4gICAgcHJlZml4ID0gUkVfU1RSX0FOWTtcbiAgfVxuICBpZiAodGxkLmlzUmVhZHkoKSAmJiBydWxlLmVuZHNXaXRoKCcudGxkJykpIHtcbiAgICBiYXNlID0gYmFzZS5zbGljZSgwLCAtNCk7XG4gICAgc3VmZml4ID0gUkVfU1RSX1RMRDtcbiAgfVxuICBjb25zdCByZSA9IG5ldyBSZWdFeHAoYF4ke3ByZWZpeH0ke3N0cjJSRShiYXNlKX0ke3N1ZmZpeH0kYCk7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIC8vIGV4YWN0IG1hdGNoLCBjYXNlLWluc2Vuc2l0aXZlXG4gICAgZGF0YSA9IGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocnVsZUxDID09PSBkYXRhKSByZXR1cm4gMTtcbiAgICAvLyBmdWxsIGNoZWNrXG4gICAgY29uc3QgbWF0Y2hlcyA9IGRhdGEubWF0Y2gocmUpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICBjb25zdCBbLCB0bGRTdHJdID0gbWF0Y2hlcztcbiAgICAgIGlmICghdGxkU3RyKSByZXR1cm4gMTtcbiAgICAgIGNvbnN0IHRsZFN1ZmZpeCA9IHRsZFN0ci5zbGljZSgxKTtcbiAgICAgIHJldHVybiB0bGQuZ2V0UHVibGljU3VmZml4KHRsZFN1ZmZpeCkgPT09IHRsZFN1ZmZpeDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhdGhNYXRjaGVyKHJ1bGUpIHtcbiAgY29uc3QgaUhhc2ggPSBydWxlLmluZGV4T2YoJyMnKTtcbiAgbGV0IGlRdWVyeSA9IHJ1bGUuaW5kZXhPZignPycpO1xuICBsZXQgc3RyUmUgPSBzdHIyUkUocnVsZSk7XG4gIGlmIChpUXVlcnkgPiBpSGFzaCkgaVF1ZXJ5ID0gLTE7XG4gIGlmIChpSGFzaCA8IDApIHtcbiAgICBpZiAoaVF1ZXJ5IDwgMCkgc3RyUmUgPSBgXiR7c3RyUmV9KD86Wz8jXXwkKWA7XG4gICAgZWxzZSBzdHJSZSA9IGBeJHtzdHJSZX0oPzojfCQpYDtcbiAgfVxuICByZXR1cm4gYmluZFJFKG5ldyBSZWdFeHAoc3RyUmUpKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hUZXN0ZXIocnVsZSkge1xuICBsZXQgdGVzdDtcbiAgaWYgKHJ1bGUgPT09ICc8YWxsX3VybHM+Jykge1xuICAgIHRlc3QgPSAoKSA9PiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJ1bGVQYXJ0cyA9IHJ1bGUubWF0Y2goUkVfTUFUQ0hfUEFSVFMpO1xuICAgIGlmIChydWxlUGFydHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoSG9zdCA9IGhvc3RNYXRjaGVyKHJ1bGVQYXJ0c1syXSk7XG4gICAgICBjb25zdCBtYXRjaFBhdGggPSBwYXRoTWF0Y2hlcihydWxlUGFydHNbM10pO1xuICAgICAgdGVzdCA9ICh1cmwpID0+IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB1cmwubWF0Y2goUkVfTUFUQ0hfUEFSVFMpO1xuICAgICAgICByZXR1cm4gISFydWxlUGFydHMgJiYgISFwYXJ0c1xuICAgICAgICAgICYmIG1hdGNoU2NoZW1lKHJ1bGVQYXJ0c1sxXSwgcGFydHNbMV0pXG4gICAgICAgICAgJiYgbWF0Y2hIb3N0KHBhcnRzWzJdKVxuICAgICAgICAgICYmIG1hdGNoUGF0aChwYXJ0c1szXSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZ25vcmUgaW52YWxpZCBtYXRjaCBydWxlc1xuICAgICAgdGVzdCA9ICgpID0+IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0ZXN0IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0QmxhY2tsaXN0KHVybCkge1xuICBsZXQgcmVzID0gYmxDYWNoZVt1cmxdO1xuICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBydWxlID0gYmxhY2tsaXN0UnVsZXMuZmluZCgoeyB0ZXN0IH0pID0+IHRlc3QodXJsKSk7XG4gICAgcmVzID0gcnVsZT8ucmVqZWN0ICYmIHJ1bGUudGV4dDtcbiAgICB1cGRhdGVCbGFja2xpc3RDYWNoZSh1cmwsIHJlcyB8fCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0QmxhY2tsaXN0KGxpc3QpIHtcbiAgY2FjaGUuYmF0Y2godHJ1ZSk7XG4gIGNvbnN0IHJ1bGVzID0gbGlzdCA9PSBudWxsID8gZ2V0T3B0aW9uKCdibGFja2xpc3QnKSA6IGxpc3Q7XG4gIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGNvbnNvbGUuaW5mbygnUmVzZXQgYmxhY2tsaXN0OicsIHJ1bGVzKTtcbiAgfVxuICAvLyBYWFggY29tcGF0aWJsZSB3aXRoIHtBcnJheX0gbGlzdCBpbiB2Mi42LjEtXG4gIGJsYWNrbGlzdFJ1bGVzID0gKEFycmF5LmlzQXJyYXkocnVsZXMpID8gcnVsZXMgOiAocnVsZXMgfHwgJycpLnNwbGl0KCdcXG4nKSlcbiAgLm1hcCgodGV4dCkgPT4ge1xuICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICBpZiAoIXRleHQgfHwgdGV4dC5zdGFydHNXaXRoKCcjJykpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG1vZGUgPSB0ZXh0LnN0YXJ0c1dpdGgoJ0AnKSAmJiB0ZXh0LnNwbGl0KC9cXHMvLCAxKVswXTtcbiAgICBjb25zdCBydWxlID0gbW9kZSA/IHRleHQuc2xpY2UobW9kZS5sZW5ndGggKyAxKS50cmltKCkgOiB0ZXh0O1xuICAgIGNvbnN0IHJlamVjdCA9IG1vZGUgIT09ICdAaW5jbHVkZScgJiYgbW9kZSAhPT0gJ0BtYXRjaCc7IC8vIEBpbmNsdWRlIGFuZCBAbWF0Y2ggPSB3aGl0ZWxpc3RcbiAgICBjb25zdCB7IHRlc3QgfSA9IG1vZGUgPT09ICdAaW5jbHVkZScgfHwgbW9kZSA9PT0gJ0BleGNsdWRlJyAmJiBhdXRvUmVnKHJ1bGUpXG4gICAgICB8fCAhbW9kZSAmJiAhcnVsZS5pbmNsdWRlcygnLycpICYmIG1hdGNoVGVzdGVyKGAqOi8vJHtydWxlfS8qYCkgLy8gZG9tYWluXG4gICAgICB8fCBtYXRjaFRlc3RlcihydWxlKTsgLy8gQG1hdGNoIGFuZCBAZXhjbHVkZS1tYXRjaFxuICAgIHJldHVybiB7IHJlamVjdCwgdGVzdCwgdGV4dCB9O1xuICB9KVxuICAuZmlsdGVyKEJvb2xlYW4pO1xuICBibENhY2hlID0ge307XG4gIGJsQ2FjaGVTaXplID0gMDtcbiAgY2FjaGUuYmF0Y2goZmFsc2UpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVCbGFja2xpc3RDYWNoZShrZXksIHZhbHVlKSB7XG4gIGJsQ2FjaGVba2V5XSA9IHZhbHVlO1xuICBibENhY2hlU2l6ZSArPSBrZXkubGVuZ3RoO1xuICBpZiAoYmxDYWNoZVNpemUgPiBNQVhfQkxfQ0FDSEVfTEVOR1RIKSB7XG4gICAgT2JqZWN0LmtleXMoYmxDYWNoZSlcbiAgICAuc29tZSgoaykgPT4ge1xuICAgICAgYmxDYWNoZVNpemUgLT0gay5sZW5ndGg7XG4gICAgICBkZWxldGUgYmxDYWNoZVtrXTtcbiAgICAgIC8vIHJlZHVjZSB0aGUgY2FjaGUgdG8gNzUlIHNvIHRoYXQgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHJ1biB0b28gb2Z0ZW4uXG4gICAgICByZXR1cm4gYmxDYWNoZVNpemUgPCBNQVhfQkxfQ0FDSEVfTEVOR1RIICogMyAvIDQ7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGdldFNjcmlwdE5hbWUsIGkxOG4sIHJlcXVlc3QsIGNvbXBhcmVWZXJzaW9uLCBzZW5kQ21kLCB0cnVlSm9pbiB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IENNRF9TQ1JJUFRfVVBEQVRFLCBJU19ERVYgfSBmcm9tICcjL2NvbW1vbi9jb25zdHMnO1xuaW1wb3J0IHsgZmV0Y2hSZXNvdXJjZXMsIGdldFNjcmlwdEJ5SWQsIGdldFNjcmlwdHMsIHBhcnNlU2NyaXB0IH0gZnJvbSAnLi9kYic7XG5pbXBvcnQgeyBwYXJzZU1ldGEgfSBmcm9tICcuL3NjcmlwdCc7XG5pbXBvcnQgeyBnZXRPcHRpb24sIHNldE9wdGlvbiB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8dHJ1ZT8+fSAqL1xuICBhc3luYyBDaGVja1VwZGF0ZShpZCkge1xuICAgIGNvbnN0IHNjcmlwdCA9IGdldFNjcmlwdEJ5SWQoaWQpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjaGVja0FsbEFuZE5vdGlmeShbc2NyaXB0XSk7XG4gICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSAqL1xuICBhc3luYyBDaGVja1VwZGF0ZUFsbCgpIHtcbiAgICBzZXRPcHRpb24oJ2xhc3RVcGRhdGUnLCBEYXRlLm5vdygpKTtcbiAgICBjb25zdCB0b1VwZGF0ZSA9IGdldFNjcmlwdHMoKS5maWx0ZXIoaXRlbSA9PiBpdGVtLmNvbmZpZy5zaG91bGRVcGRhdGUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjaGVja0FsbEFuZE5vdGlmeSh0b1VwZGF0ZSk7XG4gICAgcmV0dXJuIHJlc3VsdHMuaW5jbHVkZXModHJ1ZSk7XG4gIH0sXG59KTtcblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tBbGxBbmROb3RpZnkoc2NyaXB0cykge1xuICBjb25zdCBub3RlcyA9IFtdO1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoc2NyaXB0cy5tYXAoaXRlbSA9PiBjaGVja1VwZGF0ZShpdGVtLCBub3RlcykpKTtcbiAgaWYgKG5vdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIG5vdGlmeShub3Rlc1swXSk7XG4gIH0gZWxzZSBpZiAobm90ZXMubGVuZ3RoKSB7XG4gICAgbm90aWZ5KHtcbiAgICAgIC8vIEZGIGRvZXNuJ3Qgc2hvdyBub3RpZmljYXRpb25zIG9mIHR5cGU6J2xpc3QnIHNvIHdlJ2xsIHVzZSBgdGV4dGAgZXZlcnl3aGVyZVxuICAgICAgdGV4dDogbm90ZXMubWFwKG4gPT4gbi50ZXh0KS5qb2luKCdcXG4nKSxcbiAgICAgIG9uQ2xpY2s6IGJyb3dzZXIucnVudGltZS5vcGVuT3B0aW9uc1BhZ2UsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmNvbnN0IHByb2Nlc3NlcyA9IHt9O1xuXG4vLyByZXNvbHZlcyB0byB0cnVlIGlmIHN1Y2Nlc3NmdWxseSB1cGRhdGVkXG5mdW5jdGlvbiBjaGVja1VwZGF0ZShzY3JpcHQsIG5vdGVzKSB7XG4gIGNvbnN0IHsgaWQgfSA9IHNjcmlwdC5wcm9wcztcbiAgY29uc3QgcHJvbWlzZSA9IHByb2Nlc3Nlc1tpZF0gfHwgKHByb2Nlc3Nlc1tpZF0gPSBkb0NoZWNrVXBkYXRlKHNjcmlwdCwgbm90ZXMpKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvQ2hlY2tVcGRhdGUoc2NyaXB0LCBub3Rlcykge1xuICBjb25zdCB7IGlkIH0gPSBzY3JpcHQucHJvcHM7XG4gIGxldCBtc2dPaztcbiAgbGV0IG1zZ0VycjtcbiAgbGV0IHJlc291cmNlT3B0cztcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHVwZGF0ZSB9ID0gYXdhaXQgcGFyc2VTY3JpcHQoe1xuICAgICAgaWQsXG4gICAgICBjb2RlOiBhd2FpdCBkb3dubG9hZFVwZGF0ZShzY3JpcHQpLFxuICAgICAgdXBkYXRlOiB7IGNoZWNraW5nOiBmYWxzZSB9LFxuICAgIH0pO1xuICAgIG1zZ09rID0gaTE4bignbXNnU2NyaXB0VXBkYXRlZCcsIFtnZXRTY3JpcHROYW1lKHVwZGF0ZSldKTtcbiAgICByZXNvdXJjZU9wdHMgPSB7IGNhY2hlOiAnbm8tY2FjaGUnIH07XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKHVwZGF0ZSkge1xuICAgIG1zZ0VyciA9IHVwZGF0ZS5lcnJvcjtcbiAgICAvLyBFaXRoZXIgcHJvY2VlZCB3aXRoIG5vcm1hbCBmZXRjaCBvbiBuby11cGRhdGUgb3Igc2tpcCBpdCBhbHRvZ2V0aGVyIG9uIGVycm9yXG4gICAgcmVzb3VyY2VPcHRzID0gIXVwZGF0ZS5lcnJvciAmJiAhdXBkYXRlLmNoZWNraW5nICYmIHt9O1xuICAgIGlmIChwcm9jZXNzLmVudi5ERUJVRykgY29uc29sZS5lcnJvcih1cGRhdGUpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChyZXNvdXJjZU9wdHMgJiYgIUlTX0RFVikgeyAvLyBERVbnirbmgIHkuI3mm7TmlrByZXNvdXJjZVxuICAgICAgbXNnRXJyID0gYXdhaXQgZmV0Y2hSZXNvdXJjZXMoc2NyaXB0LCBudWxsLCByZXNvdXJjZU9wdHMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHICYmIG1zZ0VycikgY29uc29sZS5lcnJvcihtc2dFcnIpO1xuICAgIH1cbiAgICBpZiAoY2FuTm90aWZ5KHNjcmlwdCkgJiYgKG1zZ09rIHx8IG1zZ0VycikpIHtcbiAgICAgIG5vdGVzLnB1c2goe1xuICAgICAgICBzY3JpcHQsXG4gICAgICAgIHRleHQ6IFttc2dPaywgbXNnRXJyXTo6dHJ1ZUpvaW4oJ1xcbicpLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9jZXNzZXNbaWRdO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkVXBkYXRlKHsgcHJvcHM6IHsgaWQgfSwgbWV0YSwgY3VzdG9tIH0pIHtcbiAgY29uc3QgZG93bmxvYWRVUkwgPSBjdXN0b20uZG93bmxvYWRVUkwgfHwgbWV0YS5kb3dubG9hZFVSTCB8fCBjdXN0b20ubGFzdEluc3RhbGxVUkw7XG4gIGxldCB1cGRhdGVVUkwgPSBjdXN0b20udXBkYXRlVVJMIHx8IG1ldGEudXBkYXRlVVJMIHx8IGRvd25sb2FkVVJMO1xuICBpZiAoSVNfREVWICYmIHVwZGF0ZVVSTCkge1xuICAgIGlmIChtZXRhLmRldikge1xuICAgICAgY29uc3QgdXJscyA9IHVwZGF0ZVVSTC5zcGxpdCgnLycpO1xuICAgICAgdXBkYXRlVVJMID0gYGh0dHA6Ly8xMjcuMC4wLjE6JHttZXRhLmRldn0vJHt1cmxzW3VybHMubGVuZ3RoIC0gMV19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlVVJMID0gbnVsbDtcbiAgICB9XG4gICAgLy8gY29uc29sZS5pbmZvKCdkb3dubG9hZFVwZGF0ZScsIGlkLCB1cGRhdGVVUkwpO1xuICB9XG4gIGlmICghdXBkYXRlVVJMKSB0aHJvdyBmYWxzZTtcbiAgbGV0IGVycm9yTWVzc2FnZTtcbiAgY29uc3QgdXBkYXRlID0ge307XG4gIGNvbnN0IHJlc3VsdCA9IHsgdXBkYXRlLCB3aGVyZTogeyBpZCB9IH07XG4gIGFubm91bmNlKGkxOG4oJ21zZ0NoZWNraW5nRm9yVXBkYXRlJykpO1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgcmVxdWVzdCh1cGRhdGVVUkwsIHtcbiAgICAgIC8vIFRPRE86IGRvIGEgSEVBRCByZXF1ZXN0IGZpcnN0IHRvIGdldCBFVGFnIGhlYWRlciBhbmQgY29tcGFyZSB0byBzdG9yYWdlLm1vZFxuICAgICAgY2FjaGU6ICduby1jYWNoZScsXG4gICAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ3RleHQveC11c2Vyc2NyaXB0LW1ldGEsKi8qJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gcGFyc2VNZXRhKGRhdGEpO1xuICAgIGlmIChJU19ERVYpIHtcbiAgICAgIGlmIChtZXRhLnZlcnNpb24gPT09IHZlcnNpb24pIHRocm93IGZhbHNlO1xuICAgICAgY29uc29sZS5pbmZvKCd1cGRhdGUnLCBtZXRhLm5hbWUsIHZlcnNpb24sIGNvbXBhcmVWZXJzaW9uKG1ldGEudmVyc2lvbiwgdmVyc2lvbikpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChjb21wYXJlVmVyc2lvbihtZXRhLnZlcnNpb24sIHZlcnNpb24pID49IDApIHtcbiAgICAgIGFubm91bmNlKGkxOG4oJ21zZ05vVXBkYXRlJyksIHsgY2hlY2tpbmc6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSBpZiAoIWRvd25sb2FkVVJMKSB7XG4gICAgICBhbm5vdW5jZShpMThuKCdtc2dOZXdWZXJzaW9uJyksIHsgY2hlY2tpbmc6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbm5vdW5jZShpMThuKCdtc2dVcGRhdGluZycpKTtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGkxOG4oJ21zZ0Vycm9yRmV0Y2hpbmdTY3JpcHQnKTtcbiAgICAgIHJldHVybiAoYXdhaXQgcmVxdWVzdChkb3dubG9hZFVSTCwgeyBjYWNoZTogJ25vLWNhY2hlJyB9KSkuZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICBhbm5vdW5jZShlcnJvck1lc3NhZ2UgfHwgaTE4bignbXNnRXJyb3JGZXRjaGluZ1VwZGF0ZUluZm8nKSwgeyBlcnJvciB9KTtcbiAgfVxuICB0aHJvdyB1cGRhdGU7XG4gIGZ1bmN0aW9uIGFubm91bmNlKG1lc3NhZ2UsIHsgZXJyb3IsIGNoZWNraW5nID0gIWVycm9yIH0gPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlLCB7XG4gICAgICBtZXNzYWdlLFxuICAgICAgY2hlY2tpbmcsXG4gICAgICBlcnJvcjogZXJyb3IgPyBgJHtpMThuKCdnZW5lcmljRXJyb3InKX0gJHtlcnJvci5zdGF0dXN9LCAke2Vycm9yLnVybH1gIDogbnVsbCxcbiAgICAgIC8vIGBudWxsYCBpcyB0cmFuc2ZlcmFibGUgaW4gQ2hyb21lIHVubGlrZSBgdW5kZWZpbmVkYFxuICAgIH0pO1xuICAgIHNlbmRDbWQoQ01EX1NDUklQVF9VUERBVEUsIHJlc3VsdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuTm90aWZ5KHNjcmlwdCkge1xuICBjb25zdCBhbGxvd2VkID0gZ2V0T3B0aW9uKCdub3RpZnlVcGRhdGVzJyk7XG4gIHJldHVybiBnZXRPcHRpb24oJ25vdGlmeVVwZGF0ZXNHbG9iYWwnKVxuICAgID8gYWxsb3dlZFxuICAgIDogc2NyaXB0LmNvbmZpZy5ub3RpZnlVcGRhdGVzID8/IGFsbG93ZWQ7XG59XG5cbmZ1bmN0aW9uIG5vdGlmeSh7XG4gIHNjcmlwdCxcbiAgdGV4dCxcbiAgb25DbGljayA9ICgpID0+IGNvbW1hbmRzLk9wZW5FZGl0b3Ioc2NyaXB0LnByb3BzLmlkKSxcbn0pIHtcbiAgY29tbWFuZHMuTm90aWZpY2F0aW9uKHtcbiAgICB0ZXh0LFxuICAgIC8vIEZGIGRvZXNuJ3Qgc2hvdyB0aGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIGluIHRoZSB0aXRsZSBvZiB0aGUgbm90aWZpY2F0aW9uXG4gICAgdGl0bGU6IElTX0ZJUkVGT1ggPyBgJHtpMThuKCd0aXRsZVNjcmlwdFVwZGF0ZWQnKX0gLSAke2kxOG4oJ2V4dE5hbWUnKX1gIDogJycsXG4gIH0sIHVuZGVmaW5lZCwge1xuICAgIG9uQ2xpY2ssXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgaXNFbXB0eSwgc2VuZFRhYkNtZCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IGZvckVhY2hFbnRyeSwgZm9yRWFjaEtleSwgb2JqZWN0U2V0IH0gZnJvbSAnIy9jb21tb24vb2JqZWN0JztcbmltcG9ydCB7IGdldFNjcmlwdCwgZ2V0VmFsdWVTdG9yZXNCeUlkcywgZHVtcFZhbHVlU3RvcmVzIH0gZnJvbSAnLi9kYic7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5cbmNvbnN0IG9wZW5lcnMgPSB7fTsgLy8geyBzY3JpcHRJZDogeyB0YWJJZDogeyBmcmFtZUlkOiAxLCAuLi4gfSwgLi4uIH0gfVxubGV0IGNhY2hlID0ge307IC8vIHsgc2NyaXB0SWQ6IHsga2V5OiB7IGxhc3Q6IHZhbHVlLCB0YWJJZDogeyBmcmFtZUlkOiB2YWx1ZSB9IH0gfSB9XG5sZXQgdXBkYXRlU2NoZWR1bGVkO1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59ICovXG4gIGFzeW5jIEdldFZhbHVlU3RvcmUoaWQpIHtcbiAgICBjb25zdCBzdG9yZXMgPSBhd2FpdCBnZXRWYWx1ZVN0b3Jlc0J5SWRzKFtpZF0pO1xuICAgIHJldHVybiBzdG9yZXNbaWRdIHx8IHt9O1xuICB9LFxuICAvKiogQHBhcmFtIHt7IHdoZXJlLCBzdG9yZSB9W119IGRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gKi9cbiAgYXN5bmMgU2V0VmFsdWVTdG9yZXMoZGF0YSkge1xuICAgIC8vIFZhbHVlIHN0b3JlIHdpbGwgYmUgcmVwbGFjZWQgc29vbi5cbiAgICBjb25zdCBzdG9yZXMgPSBkYXRhLnJlZHVjZSgocmVzLCB7IHdoZXJlLCBzdG9yZSB9KSA9PiB7XG4gICAgICBjb25zdCBpZCA9IHdoZXJlLmlkIHx8IGdldFNjcmlwdCh3aGVyZSk/LnByb3BzLmlkO1xuICAgICAgaWYgKGlkKSByZXNbaWRdID0gc3RvcmU7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHt9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBkdW1wVmFsdWVTdG9yZXMoc3RvcmVzKSxcbiAgICAgIGJyb2FkY2FzdFZhbHVlU3RvcmVzKGdyb3VwU3RvcmVzQnlGcmFtZShzdG9yZXMpKSxcbiAgICBdKTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge3ZvaWR9ICovXG4gIFVwZGF0ZVZhbHVlKHsgaWQsIGtleSwgdmFsdWUgPSBudWxsIH0sIHNyYykge1xuICAgIG9iamVjdFNldChjYWNoZSwgW2lkLCBrZXksICdsYXN0J10sIHZhbHVlKTtcbiAgICBvYmplY3RTZXQoY2FjaGUsIFtpZCwga2V5LCBzcmMudGFiLmlkLCBzcmMuZnJhbWVJZF0sIHZhbHVlKTtcbiAgICB1cGRhdGVMYXRlcigpO1xuICB9LFxufSk7XG5cbmJyb3dzZXIudGFicy5vblJlbW92ZWQuYWRkTGlzdGVuZXIocmVzZXRWYWx1ZU9wZW5lcik7XG5icm93c2VyLnRhYnMub25SZXBsYWNlZC5hZGRMaXN0ZW5lcigoYWRkZWRJZCwgcmVtb3ZlZElkKSA9PiByZXNldFZhbHVlT3BlbmVyKHJlbW92ZWRJZCkpO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRWYWx1ZU9wZW5lcih0YWJJZCkge1xuICBvcGVuZXJzOjpmb3JFYWNoRW50cnkoKFtpZCwgb3BlbmVyVGFic10pID0+IHtcbiAgICBpZiAodGFiSWQgaW4gb3BlbmVyVGFicykge1xuICAgICAgZGVsZXRlIG9wZW5lclRhYnNbdGFiSWRdO1xuICAgICAgaWYgKGlzRW1wdHkob3BlbmVyVGFicykpIGRlbGV0ZSBvcGVuZXJzW2lkXTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkVmFsdWVPcGVuZXIodGFiSWQsIGZyYW1lSWQsIHNjcmlwdElkcykge1xuICBzY3JpcHRJZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICBvYmplY3RTZXQob3BlbmVycywgW2lkLCB0YWJJZCwgZnJhbWVJZF0sIDEpO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlTGF0ZXIoKSB7XG4gIHdoaWxlICghdXBkYXRlU2NoZWR1bGVkKSB7XG4gICAgdXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBhd2FpdCAwO1xuICAgIGNvbnN0IGN1cnJlbnRDYWNoZSA9IGNhY2hlO1xuICAgIGNhY2hlID0ge307XG4gICAgYXdhaXQgZG9VcGRhdGUoY3VycmVudENhY2hlKTtcbiAgICB1cGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBpZiAoaXNFbXB0eShjYWNoZSkpIGJyZWFrO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvVXBkYXRlKGN1cnJlbnRDYWNoZSkge1xuICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhjdXJyZW50Q2FjaGUpO1xuICBjb25zdCB2YWx1ZVN0b3JlcyA9IGF3YWl0IGdldFZhbHVlU3RvcmVzQnlJZHMoaWRzKTtcbiAgaWRzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgY3VycmVudENhY2hlW2lkXTo6Zm9yRWFjaEVudHJ5KChba2V5LCB7IGxhc3QgfV0pID0+IHtcbiAgICAgIG9iamVjdFNldCh2YWx1ZVN0b3JlcywgW2lkLCBrZXldLCBsYXN0IHx8IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH0pO1xuICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgZHVtcFZhbHVlU3RvcmVzKHZhbHVlU3RvcmVzKSxcbiAgICBicm9hZGNhc3RWYWx1ZVN0b3Jlcyhncm91cENhY2hlQnlGcmFtZShjdXJyZW50Q2FjaGUpLCB7IHBhcnRpYWw6IHRydWUgfSksXG4gIF0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBicm9hZGNhc3RWYWx1ZVN0b3Jlcyh0YWJGcmFtZURhdGEsIHsgcGFydGlhbCB9ID0ge30pIHtcbiAgY29uc3QgdGFza3MgPSBbXTtcbiAgZm9yIChjb25zdCBbdGFiSWQsIGZyYW1lc10gb2YgT2JqZWN0LmVudHJpZXModGFiRnJhbWVEYXRhKSkge1xuICAgIGZvciAoY29uc3QgW2ZyYW1lSWQsIGZyYW1lRGF0YV0gb2YgT2JqZWN0LmVudHJpZXMoZnJhbWVzKSkge1xuICAgICAgaWYgKCFpc0VtcHR5KGZyYW1lRGF0YSkpIHtcbiAgICAgICAgaWYgKHBhcnRpYWwpIGZyYW1lRGF0YS5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgdGFza3MucHVzaChzZW5kVGFiQ21kKCt0YWJJZCwgJ1VwZGF0ZWRWYWx1ZXMnLCBmcmFtZURhdGEsIHsgZnJhbWVJZDogK2ZyYW1lSWQgfSkpO1xuICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAyMCkgYXdhaXQgUHJvbWlzZS5hbGwodGFza3Muc3BsaWNlKDApKTsgLy8gdGhyb3R0bGluZ1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhd2FpdCBQcm9taXNlLmFsbCh0YXNrcyk7XG59XG5cbi8vIFJldHVybnMgcGVyIHRhYi9mcmFtZSBkYXRhIHdpdGggb25seSB0aGUgY2hhbmdlZCB2YWx1ZXNcbmZ1bmN0aW9uIGdyb3VwQ2FjaGVCeUZyYW1lKGNhY2hlRGF0YSkge1xuICBjb25zdCB0b1NlbmQgPSB7fTtcbiAgY2FjaGVEYXRhOjpmb3JFYWNoRW50cnkoKFtpZCwgc2NyaXB0RGF0YV0pID0+IHtcbiAgICBjb25zdCBkYXRhRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHNjcmlwdERhdGEpO1xuICAgIG9wZW5lcnNbaWRdOjpmb3JFYWNoRW50cnkoKFt0YWJJZCwgZnJhbWVzXSkgPT4ge1xuICAgICAgZnJhbWVzOjpmb3JFYWNoS2V5KChmcmFtZUlkKSA9PiB7XG4gICAgICAgIGRhdGFFbnRyaWVzLmZvckVhY2goKFtrZXksIGhpc3RvcnldKSA9PiB7XG4gICAgICAgICAgLy8gU2tpcHBpbmcgdGhpcyBmcmFtZSBpZiBpdHMgbGFzdCByZWNvcmRlZCB2YWx1ZSBpcyBpZGVudGljYWxcbiAgICAgICAgICBpZiAoaGlzdG9yeS5sYXN0ICE9PSBoaXN0b3J5W3RhYklkXT8uW2ZyYW1lSWRdKSB7XG4gICAgICAgICAgICBvYmplY3RTZXQodG9TZW5kLCBbdGFiSWQsIGZyYW1lSWQsIGlkLCBrZXldLCBoaXN0b3J5Lmxhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0b1NlbmQ7XG59XG5cbi8vIFJldHVybnMgcGVyIHRhYi9mcmFtZSBkYXRhXG5mdW5jdGlvbiBncm91cFN0b3Jlc0J5RnJhbWUoc3RvcmVzKSB7XG4gIGNvbnN0IHRvU2VuZCA9IHt9O1xuICBzdG9yZXM6OmZvckVhY2hFbnRyeSgoW2lkLCBzdG9yZV0pID0+IHtcbiAgICBvcGVuZXJzW2lkXTo6Zm9yRWFjaEVudHJ5KChbdGFiSWQsIGZyYW1lc10pID0+IHtcbiAgICAgIGZyYW1lczo6Zm9yRWFjaEtleShmcmFtZUlkID0+IHtcbiAgICAgICAgb2JqZWN0U2V0KHRvU2VuZCwgW3RhYklkLCBmcmFtZUlkLCBpZF0sIHN0b3JlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRvU2VuZDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGFsbG93ZWQpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIHRoaXMuYWxsb3dlZCA9IGFsbG93ZWQ7XG4gIH1cblxuICBjaGVja1R5cGUodHlwZSkge1xuICAgIGlmICh0aGlzLmFsbG93ZWQgJiYgIXRoaXMuYWxsb3dlZC5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGV2ZW50IHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBvbih0eXBlLCBoYW5kbGUpIHtcbiAgICB0aGlzLmNoZWNrVHlwZSh0eXBlKTtcbiAgICBjb25zdCB7IGV2ZW50cyB9ID0gdGhpcztcbiAgICBsZXQgaGFuZGxlcnMgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMgPSBbXTtcbiAgICAgIGV2ZW50c1t0eXBlXSA9IGhhbmRsZXJzO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gdGhpcy5vZmYodHlwZSwgaGFuZGxlKTtcbiAgfVxuXG4gIG9mZih0eXBlLCBoYW5kbGUpIHtcbiAgICB0aGlzLmNoZWNrVHlwZSh0eXBlKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuZXZlbnRzW3R5cGVdO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgY29uc3QgaSA9IGhhbmRsZXJzLmluZGV4T2YoaGFuZGxlKTtcbiAgICAgIGlmIChpID49IDApIGhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICBlbWl0KHR5cGUsIGRhdGEpIHtcbiAgICB0aGlzLmNoZWNrVHlwZSh0eXBlKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuZXZlbnRzW3R5cGVdO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgY29uc3QgZXZ0ID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBkYXRhLFxuICAgICAgICBkZWZhdWx0UHJldmVudGVkOiBmYWxzZSxcbiAgICAgICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGhhbmRsZXJzLnNvbWUoKGhhbmRsZSkgPT4ge1xuICAgICAgICBoYW5kbGUoZXZ0KTtcbiAgICAgICAgcmV0dXJuIGV2dC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgdGxkanMgZnJvbSAndGxkanMnO1xuLy8gaW1wb3J0IHsgZnJvbVVzZXJTZXR0aW5ncyB9IGZyb20gJ3RsZGpzJztcbi8vIGltcG9ydCBUcmllIGZyb20gJ3RsZGpzL2xpYi9zdWZmaXgtdHJpZSc7XG4vLyBpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnIy9jb21tb24nO1xuXG4vLyBsZXQgdGxkanM7XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBpbml0VExEKHJlbW90ZSkge1xuLy8gICAvLyBUTEQgcnVsZXMgYXJlIHRvbyBsYXJnZSB0byBiZSBwYWNrZWQsIGRvd25sb2FkIHRoZW0gYXQgcnVudGltZS5cbi8vICAgY29uc3QgdXJsID0gJ2h0dHBzOi8vdmlvbGVudG1vbmtleS50b3Avc3RhdGljL3RsZC1ydWxlcy5qc29uJztcbi8vICAgY29uc3Qga2V5ID0gJ2RhdDp0bGRSdWxlcyc7XG4vLyAgIGJyb3dzZXIuc3RvcmFnZS5sb2NhbC5nZXQoa2V5KVxuLy8gICAudGhlbigoeyBba2V5XTogdGxkUnVsZXMgfSkgPT4ge1xuLy8gICAgIGlmICh0bGRSdWxlcykgcmV0dXJuIHRsZFJ1bGVzO1xuLy8gICAgIGlmICghcmVtb3RlKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ2lnbm9yZSBUTEQnKTtcbi8vICAgICByZXR1cm4gcmVxdWVzdCh1cmwsIHsgcmVzcG9uc2VUeXBlOiAnanNvbicgfSlcbi8vICAgICAudGhlbigoeyBkYXRhOiBydWxlcyB9KSA9PiB7XG4vLyAgICAgICBjb25zb2xlLmluZm8oJ0Rvd25sb2FkZWQgcHVibGljIHN1ZmZpeCBkYXRhJyk7XG4vLyAgICAgICByZXR1cm4gYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldCh7IFtrZXldOiBydWxlcyB9KVxuLy8gICAgICAgLnRoZW4oKCkgPT4gcnVsZXMpO1xuLy8gICAgIH0pO1xuLy8gICB9KVxuLy8gICAudGhlbih0bGRSdWxlcyA9PiB7XG4vLyAgICAgY29uc29sZS5pbmZvKCdJbml0aWFsaXplZCBUTEQnKTtcbi8vICAgICB0bGRqcyA9IGZyb21Vc2VyU2V0dGluZ3MoeyBydWxlczogVHJpZS5mcm9tSnNvbih0bGRSdWxlcykgfSk7XG4vLyAgIH0pXG4vLyAgIC5jYXRjaChlcnIgPT4ge1xuLy8gICAgIGlmIChwcm9jZXNzLmVudi5ERUJVRykgY29uc29sZS5lcnJvcihlcnIpO1xuLy8gICAgIGNvbnNvbGUuaW5mbygnRmFpbGVkIGluaXRpYWxpemluZyBUTEQnKTtcbi8vICAgfSk7XG4vLyB9XG5leHBvcnQgZnVuY3Rpb24gaW5pdFRMRCgpIHt9XG5cbmZ1bmN0aW9uIGV4cG9ydE1ldGhvZChrZXkpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB0bGRqcyAmJiB0bGRqc1trZXldKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgcmV0dXJuICEhdGxkanM7XG59XG5cbmV4cG9ydCBjb25zdCBnZXREb21haW4gPSBleHBvcnRNZXRob2QoJ2dldERvbWFpbicpO1xuZXhwb3J0IGNvbnN0IGdldFN1YmRvbWFpbiA9IGV4cG9ydE1ldGhvZCgnZ2V0U3ViZG9tYWluJyk7XG5leHBvcnQgY29uc3QgZ2V0UHVibGljU3VmZml4ID0gZXhwb3J0TWV0aG9kKCdnZXRQdWJsaWNTdWZmaXgnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=