{ /* eslint-disable no-unused-vars */

/**
 * This file is used by entire `src` except `injected`.
 * `global` is used instead of WebPack's polyfill which we disable in webpack.conf.js.
 * `safeCall` is used by our modified babel-plugin-safe-bind.js.
 * Standard globals are extracted for better minification and marginally improved lookup speed.
 * Not exporting NodeJS built-in globals as this file is imported in the test scripts.
 */
const global = function _() {
  return this || globalThis; // eslint-disable-line no-undef
}();

const {
  Boolean,
  Error,
  Object,
  Promise,
  document,
  window
} = global;
const PromiseSafe = Promise; // alias used by browser.js

const ErrorSafe = Error; // alias used by browser.js

const {
  hasOwnProperty,
  toString: objectToString
} = {};
const safeCall = Object.call.bind(Object.call);
const IS_FIREFOX = !global.chrome.app;/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"background/index": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./src/background/index.js","public/lib/tldjs","common"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@ffmpeg/ffmpeg/package.json":
/*!**************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/package.json ***!
  \**************************************************/
/*! exports provided: name, version, description, main, types, directories, scripts, browser, repository, keywords, author, license, bugs, engines, homepage, dependencies, devDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@ffmpeg/ffmpeg\",\"version\":\"0.10.1\",\"description\":\"FFmpeg WebAssembly version\",\"main\":\"src/index.js\",\"types\":\"src/index.d.ts\",\"directories\":{\"example\":\"examples\"},\"scripts\":{\"start\":\"node scripts/server.js\",\"build\":\"rimraf dist && webpack --config scripts/webpack.config.prod.js\",\"prepublishOnly\":\"npm run build\",\"lint\":\"eslint src\",\"wait\":\"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\",\"test\":\"npm-run-all -p -r start test:all\",\"test:all\":\"npm-run-all wait test:browser:ffmpeg test:node:all\",\"test:node\":\"node --experimental-wasm-threads --experimental-wasm-bulk-memory node_modules/.bin/_mocha --exit --bail --require ./scripts/test-helper.js\",\"test:node:all\":\"npm run test:node -- ./tests/*.test.js\",\"test:browser\":\"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\",\"test:browser:ffmpeg\":\"npm run test:browser -- -f ./tests/ffmpeg.test.html\"},\"browser\":{\"./src/node/index.js\":\"./src/browser/index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\"},\"keywords\":[\"ffmpeg\",\"WebAssembly\",\"video\"],\"author\":\"Jerome Wu <jeromewus@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\"},\"engines\":{\"node\":\">=12.16.1\"},\"homepage\":\"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\",\"dependencies\":{\"is-url\":\"^1.2.4\",\"node-fetch\":\"^2.6.1\",\"regenerator-runtime\":\"^0.13.7\",\"resolve-url\":\"^0.2.1\"},\"devDependencies\":{\"@babel/core\":\"^7.12.3\",\"@babel/preset-env\":\"^7.12.1\",\"@ffmpeg/core\":\"^0.10.0\",\"@types/emscripten\":\"^1.39.4\",\"babel-loader\":\"^8.1.0\",\"chai\":\"^4.2.0\",\"cors\":\"^2.8.5\",\"eslint\":\"^7.12.1\",\"eslint-config-airbnb-base\":\"^14.1.0\",\"eslint-plugin-import\":\"^2.22.1\",\"express\":\"^4.17.1\",\"mocha\":\"^8.2.1\",\"mocha-headless-chrome\":\"^2.0.3\",\"npm-run-all\":\"^4.1.5\",\"wait-on\":\"^5.3.0\",\"webpack\":\"^5.3.2\",\"webpack-cli\":\"^4.1.0\",\"webpack-dev-middleware\":\"^4.0.0\"}}");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const resolveURL = __webpack_require__(/*! resolve-url */ "./node_modules/resolve-url/resolve-url.js");
const { devDependencies } = __webpack_require__(/*! ../../package.json */ "./node_modules/@ffmpeg/ffmpeg/package.json");

/*
 * Default options for browser environment
 */
module.exports = {
  corePath:  true
    ? resolveURL('/node_modules/@ffmpeg/core/dist/ffmpeg-core.js')
    : undefined,
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const resolveURL = __webpack_require__(/*! resolve-url */ "./node_modules/resolve-url/resolve-url.js");

const readFromBlobOrFile = (blob) => (
  new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.onload = () => {
      resolve(fileReader.result);
    };
    fileReader.onerror = ({ target: { error: { code } } }) => {
      reject(Error(`File could not be read! Code=${code}`));
    };
    fileReader.readAsArrayBuffer(blob);
  })
);

module.exports = async (_data) => {
  let data = _data;
  if (typeof _data === 'undefined') {
    return new Uint8Array();
  }

  if (typeof _data === 'string') {
    /* From base64 format */
    if (/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(_data)) {
      data = atob(_data.split(',')[1])
        .split('')
        .map((c) => c.charCodeAt(0));
    /* From remote server/URL */
    } else {
      const res = await fetch(resolveURL(_data));
      data = await res.arrayBuffer();
    }
  /* From Blob or File */
  } else if (_data instanceof File || _data instanceof Blob) {
    data = await readFromBlobOrFile(_data);
  }

  return new Uint8Array(data);
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-undef */
const resolveURL = __webpack_require__(/*! resolve-url */ "./node_modules/resolve-url/resolve-url.js");
const { log } = __webpack_require__(/*! ../utils/log */ "./node_modules/@ffmpeg/ffmpeg/src/utils/log.js");

/*
 * Fetch data from remote URL and convert to blob URL
 * to avoid CORS issue
 */
const toBlobURL = async (url, mimeType) => {
  log('info', `fetch ${url}`);
  const buf = await (await fetch(url)).arrayBuffer();
  log('info', `${url} file size = ${buf.byteLength} bytes`);
  const blob = new Blob([buf], { type: mimeType });
  const blobURL = URL.createObjectURL(blob);
  log('info', `${url} blob URL = ${blobURL}`);
  return blobURL;
};

module.exports = async ({ corePath: _corePath }) => {
  if (typeof _corePath !== 'string') {
    throw Error('corePath should be a string!');
  }
  const coreRemotePath = resolveURL(_corePath);
  const corePath = await toBlobURL(
    coreRemotePath,
    'application/javascript',
  );
  const wasmPath = await toBlobURL(
    coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),
    'application/wasm',
  );
  const workerPath = await toBlobURL(
    coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),
    'application/javascript',
  );
  if (typeof createFFmpegCore === 'undefined') {
    return new Promise((resolve) => {
      const script = document.createElement('script');
      const eventHandler = () => {
        script.removeEventListener('load', eventHandler);
        log('info', 'ffmpeg-core.js script loaded');
        resolve({
          createFFmpegCore,
          corePath,
          wasmPath,
          workerPath,
        });
      };
      script.src = corePath;
      script.type = 'text/javascript';
      script.addEventListener('load', eventHandler);
      document.getElementsByTagName('head')[0].appendChild(script);
    });
  }
  log('info', 'ffmpeg-core.js script is loaded already');
  return Promise.resolve({
    createFFmpegCore,
    corePath,
    wasmPath,
    workerPath,
  });
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const defaultOptions = __webpack_require__(/*! ./defaultOptions */ "./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js");
const getCreateFFmpegCore = __webpack_require__(/*! ./getCreateFFmpegCore */ "./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js");
const fetchFile = __webpack_require__(/*! ./fetchFile */ "./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js");

module.exports = {
  defaultOptions,
  getCreateFFmpegCore,
  fetchFile,
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/config.js":
/*!***************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/config.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  defaultArgs: [
    /* args[0] is always the binary path */
    './ffmpeg',
    /* Disable interaction mode */
    '-nostdin',
    /* Force to override output file */
    '-y',
  ],
  baseOptions: {
    /* Flag to turn on/off log messages in console */
    log: false,
    /*
     * Custom logger to get ffmpeg.wasm output messages.
     * a sample logger looks like this:
     *
     * ```
     * logger = ({ type, message }) => {
     *   console.log(type, message);
     * }
     * ```
     *
     * type can be one of following:
     *
     * info: internal workflow debug messages
     * fferr: ffmpeg native stderr output
     * ffout: ffmpeg native stdout output
     */
    logger: () => {},
    /*
     * Progress handler to get current progress of ffmpeg command.
     * a sample progress handler looks like this:
     *
     * ```
     * progress = ({ ratio }) => {
     *   console.log(ratio);
     * }
     * ```
     *
     * ratio is a float number between 0 to 1.
     */
    progress: () => {},
    /*
     * Path to find/download ffmpeg.wasm-core,
     * this value should be overwriten by `defaultOptions` in
     * each environment.
     */
    corePath: '',
  },
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { defaultArgs, baseOptions } = __webpack_require__(/*! ./config */ "./node_modules/@ffmpeg/ffmpeg/src/config.js");
const { setLogging, setCustomLogger, log } = __webpack_require__(/*! ./utils/log */ "./node_modules/@ffmpeg/ffmpeg/src/utils/log.js");
const parseProgress = __webpack_require__(/*! ./utils/parseProgress */ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js");
const parseArgs = __webpack_require__(/*! ./utils/parseArgs */ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js");
const { defaultOptions, getCreateFFmpegCore } = __webpack_require__(/*! ./node */ "./node_modules/@ffmpeg/ffmpeg/src/browser/index.js");
const { version } = __webpack_require__(/*! ../package.json */ "./node_modules/@ffmpeg/ffmpeg/package.json");

const NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');

module.exports = (_options = {}) => {
  const {
    log: logging,
    logger,
    progress: optProgress,
    ...options
  } = {
    ...baseOptions,
    ...defaultOptions,
    ..._options,
  };
  let Core = null;
  let ffmpeg = null;
  let runResolve = null;
  let running = false;
  let progress = optProgress;
  const detectCompletion = (message) => {
    if (message === 'FFMPEG_END' && runResolve !== null) {
      runResolve();
      runResolve = null;
      running = false;
    }
  };
  const parseMessage = ({ type, message }) => {
    log(type, message);
    parseProgress(message, progress);
    detectCompletion(message);
  };

  /*
   * Load ffmpeg.wasm-core script.
   * In browser environment, the ffmpeg.wasm-core script is fetch from
   * CDN and can be assign to a local path by assigning `corePath`.
   * In node environment, we use dynamic require and the default `corePath`
   * is `$ffmpeg/core`.
   *
   * Typically the load() func might take few seconds to minutes to complete,
   * better to do it as early as possible.
   *
   */
  const load = async () => {
    log('info', 'load ffmpeg-core');
    if (Core === null) {
      log('info', 'loading ffmpeg-core');
      /*
       * In node environment, all paths are undefined as there
       * is no need to set them.
       */
      const {
        createFFmpegCore,
        corePath,
        workerPath,
        wasmPath,
      } = await getCreateFFmpegCore(options);
      Core = await createFFmpegCore({
        /*
         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue
         * as there is no document.currentScript in the context of content_scripts
         */
        mainScriptUrlOrBlob: corePath,
        printErr: (message) => parseMessage({ type: 'fferr', message }),
        print: (message) => parseMessage({ type: 'ffout', message }),
        /*
         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).
         * It is critical for browser environment and we override both wasm and worker paths
         * as we are using blob URL instead of original URL to avoid cross origin issues.
         */
        locateFile: (path, prefix) => {
          if (typeof window !== 'undefined') {
            if (typeof wasmPath !== 'undefined'
              && path.endsWith('ffmpeg-core.wasm')) {
              return wasmPath;
            }
            if (typeof workerPath !== 'undefined'
              && path.endsWith('ffmpeg-core.worker.js')) {
              return workerPath;
            }
          }
          return prefix + path;
        },
      });
      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);
      log('info', 'ffmpeg-core loaded');
    } else {
      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');
    }
  };

  /*
   * Determine whether the Core is loaded.
   */
  const isLoaded = () => Core !== null;

  /*
   * Run ffmpeg command.
   * This is the major function in ffmpeg.wasm, you can just imagine it
   * as ffmpeg native cli and what you need to pass is the same.
   *
   * For example, you can convert native command below:
   *
   * ```
   * $ ffmpeg -i video.avi -c:v libx264 video.mp4
   * ```
   *
   * To
   *
   * ```
   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');
   * ```
   *
   */
  const run = (..._args) => {
    log('info', `run ffmpeg command: ${_args.join(' ')}`);
    if (Core === null) {
      throw NO_LOAD;
    } else if (running) {
      throw Error('ffmpeg.wasm can only run one command at a time');
    } else {
      running = true;
      return new Promise((resolve) => {
        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);
        runResolve = resolve;
        ffmpeg(...parseArgs(Core, args));
      });
    }
  };

  /*
   * Run FS operations.
   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS
   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS
   * methods provided by Emscripten.
   *
   * Common methods to use are:
   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes
   * data to MEMFS. You need to use Uint8Array for binary data.
   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.
   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.
   *
   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html
   *
   */
  const FS = (method, ...args) => {
    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);
    if (Core === null) {
      throw NO_LOAD;
    } else {
      let ret = null;
      try {
        ret = Core.FS[method](...args);
      } catch (e) {
        if (method === 'readdir') {
          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);
        } else if (method === 'readFile') {
          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);
        } else {
          throw Error('Oops, something went wrong in FS operation.');
        }
      }
      return ret;
    }
  };

  /**
   * forcibly terminate the ffmpeg program.
   */
  const exit = () => {
    if (Core === null) {
      throw NO_LOAD;
    } else {
      running = false;
      Core.exit(1);
      Core = null;
      ffmpeg = null;
      runResolve = null;
    }
  };

  const setProgress = (_progress) => {
    progress = _progress;
  };

  const setLogger = (_logger) => {
    setCustomLogger(_logger);
  };

  setLogging(logging);
  setCustomLogger(logger);

  log('info', `use ffmpeg.wasm v${version}`);

  return {
    setProgress,
    setLogger,
    setLogging,
    load,
    isLoaded,
    run,
    exit,
    FS,
  };
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
const createFFmpeg = __webpack_require__(/*! ./createFFmpeg */ "./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js");
const { fetchFile } = __webpack_require__(/*! ./node */ "./node_modules/@ffmpeg/ffmpeg/src/browser/index.js");

module.exports = {
  /*
   * Create ffmpeg instance.
   * Each ffmpeg instance owns an isolated MEMFS and works
   * independently.
   *
   * For example:
   *
   * ```
   * const ffmpeg = createFFmpeg({
   *  log: true,
   *  logger: () => {},
   *  progress: () => {},
   *  corePath: '',
   * })
   * ```
   *
   * For the usage of these four arguments, check config.js
   *
   */
  createFFmpeg,
  /*
   * Helper function for fetching files from various resource.
   * Sometimes the video/audio file you want to process may located
   * in a remote URL and somewhere in your local file system.
   *
   * This helper function helps you to fetch to file and return an
   * Uint8Array variable for ffmpeg.wasm to consume.
   *
   */
  fetchFile,
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/log.js":
/*!******************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/log.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

let logging = false;
let customLogger = () => {};

const setLogging = (_logging) => {
  logging = _logging;
};

const setCustomLogger = (logger) => {
  customLogger = logger;
};

const log = (type, message) => {
  customLogger({ type, message });
  if (logging) {
    console.log(`[${type}] ${message}`);
  }
};

module.exports = {
  logging,
  setLogging,
  setCustomLogger,
  log,
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js":
/*!************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = (Core, args) => {
  const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);
  args.forEach((s, idx) => {
    const buf = Core._malloc(s.length + 1);
    Core.writeAsciiToMemory(s, buf);
    Core.setValue(argsPtr + (Uint32Array.BYTES_PER_ELEMENT * idx), buf, 'i32');
  });
  return [args.length, argsPtr];
};


/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

let duration = 0;
let ratio = 0;

const ts2sec = (ts) => {
  const [h, m, s] = ts.split(':');
  return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);
};

module.exports = (message, progress) => {
  if (typeof message === 'string') {
    if (message.startsWith('  Duration')) {
      const ts = message.split(', ')[0].split(': ')[1];
      const d = ts2sec(ts);
      progress({ duration: d, ratio });
      if (duration === 0 || duration > d) {
        duration = d;
      }
    } else if (message.startsWith('frame') || message.startsWith('size')) {
      const ts = message.split('time=')[1].split(' ')[0];
      const t = ts2sec(ts);
      ratio = t / duration;
      progress({ ratio, time: t });
    } else if (message.startsWith('video:')) {
      progress({ ratio: 1 });
      duration = 0;
    }
  }
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jbinary/dist/browser/jbinary.js":
/*!******************************************************!*\
  !*** ./node_modules/jbinary/dist/browser/jbinary.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e){var i=this; true?module.exports=e(i,__webpack_require__(/*! jdataview */ "./node_modules/jdataview/dist/node/jdataview.js")):undefined}(function(h,i){"use strict";var o,u,n=h.document;"atob"in h&&"btoa"in h||(o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",u=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1],h.btoa||(h.btoa=function(t){for(var e,i,n,r=t.length,a=0,s="";a<r;){if(e=255&t.charCodeAt(a++),a==r){s+=o.charAt(e>>2),s+=o.charAt((3&e)<<4),s+="==";break}if(i=t.charCodeAt(a++),a==r){s+=o.charAt(e>>2),s+=o.charAt((3&e)<<4|(240&i)>>4),s+=o.charAt((15&i)<<2),s+="=";break}n=t.charCodeAt(a++),s+=o.charAt(e>>2),s+=o.charAt((3&e)<<4|(240&i)>>4),s+=o.charAt((15&i)<<2|(192&n)>>6),s+=o.charAt(63&n)}return s}),h.atob||(h.atob=function(t){for(var e,i,n,r,a=t.length,s=0,o="";s<a;){for(;e=u[255&t.charCodeAt(s++)],s<a&&-1==e;);if(-1==e)break;for(;i=u[255&t.charCodeAt(s++)],s<a&&-1==i;);if(-1==i)break;o+=String.fromCharCode(e<<2|(48&i)>>4);do{if(61==(n=255&t.charCodeAt(s++)))return o}while(n=u[n],s<a&&-1==n);if(-1==n)break;o+=String.fromCharCode((15&i)<<4|(60&n)>>2);do{if(61==(r=255&t.charCodeAt(s++)))return o}while(r=u[r],s<a&&-1==r);if(-1==r)break;o+=String.fromCharCode((3&n)<<6|r)}return o}));var c=h.Promise||function(t){this.then=t};function f(t,e){return e&&t instanceof e}function r(t){for(var e=1,i=arguments.length;e<i;++e){var n,r=arguments[e];for(n in r)void 0!==r[n]&&(t[n]=r[n])}return t}function l(t){return arguments[0]=e(t),r.apply(null,arguments)}function a(t,e,i){return f(i,Function)?i.call(t,e.contexts[0]):i}function t(s){return function(){var t=arguments,e=t.length-1,r=s.length-1,i=t[e];if(t.length=1+r,!f(i,Function)){var a=this;return new c(function(i,n){t[r]=function(t,e){return t?n(t):i(e)},s.apply(a,t)})}t[e]=void 0,t[r]=i,s.apply(this,t)}}function s(t,e){return f(t,s)?t.as(e):(f(t,i)||(t=new i(t,void 0,void 0,e?e["jBinary.littleEndian"]:void 0)),f(this,s)?(this.view=t,this.view.seek(0),this.contexts=[],this.as(e,!0)):new s(t,e))}var e=(e=Object.create)||function(t){function e(){}return e.prototype=t,new e},p=s.prototype,y=p.typeSet={};p.toValue=function(t){return a(this,this,t)},p._named=function(t,e,i){return t.displayName=e+" @ "+(void 0!==i?i:this.view.tell()),t};var d=Object.defineProperty;if(1,d)try{d({},"x",{})}catch(t){d=void 0}else d=function(t,e,i,n){n&&(t[e]=i.value)};var v="jBinary.Cache",b=0;function g(t){return l(g.prototype,t)}function w(i){return l(w.prototype,i,{createProperty:function(t){var e=(i.createProperty||w.prototype.createProperty).apply(this,arguments);return e.getBaseType&&(e.baseType=e.binary.getType(e.getBaseType(e.binary.contexts[0]))),e}})}p._getCached=function(t,e,i){if(t.hasOwnProperty(this.cacheKey))return t[this.cacheKey];e=e.call(this,t);return d(t,this.cacheKey,{value:e},i),e},p.getContext=function(e){switch(typeof e){case"undefined":e=0;case"number":return this.contexts[e];case"string":return this.getContext(function(t){return e in t});case"function":for(var t=0,i=this.contexts.length;t<i;t++){var n=this.contexts[t];if(e.call(this,n))return n}}},p.inContext=function(t,e){this.contexts.unshift(t);e=e.call(this);return this.contexts.shift(),e},g.prototype={inherit:function(n,a){var r,s=this;function t(t,e){var i=s[t];i&&(r=r||l(s),e.call(r,i),r[t]=null)}return t("params",function(t){for(var e=0,i=t.length;e<i;e++)this[t[e]]=n[e]}),t("setParams",function(t){t.apply(this,n)}),t("typeParams",function(t){for(var e=0,i=t.length;e<i;e++){var n=t[e],r=this[n];r&&(this[n]=a(r))}}),t("resolve",function(t){t.call(this,a)}),r||s},createProperty:function(t){return l(this,{binary:t,view:t.view})},toValue:function(t,e){return!1!==e&&"string"==typeof t?this.binary.getContext(t)[t]:a(this,this.binary,t)}},w.prototype=l((s.Type=g).prototype,{setParams:function(){this.baseType&&(this.typeParams=["baseType"].concat(this.typeParams||[]))},baseRead:function(){return this.binary.read(this.baseType)},baseWrite:function(t){return this.binary.write(this.baseType,t)}}),r(w.prototype,{read:w.prototype.baseRead,write:w.prototype.baseWrite}),s.Template=w,p.as=function(t,e){e=e?this:l(this);return e.typeSet=(t=t||y)===y||y.isPrototypeOf(t)?t:l(y,t),e.cacheKey=v,e.cacheKey=e._getCached(t,function(){return v+"."+ ++b},!0),e},p.seek=function(t,e){if(t=this.toValue(t),void 0===e)return this.view.seek(t);var i=this.view.tell();this.view.seek(t);e=e.call(this);return this.view.seek(i),e},p.tell=function(){return this.view.tell()},p.skip=function(t,e){return this.seek(this.tell()+this.toValue(t),e)},p.slice=function(t,e,i){return new s(this.view.slice(t,e,i),this.typeSet)},p._getType=function(t,e){switch(typeof t){case"string":if(!(t in this.typeSet))throw new ReferenceError("Unknown type: "+t);return this._getType(this.typeSet[t],e);case"number":return this._getType(y.bitfield,[t]);case"object":if(f(t,g)){var i=this;return t.inherit(e||[],function(t){return i.getType(t)})}return f(t,Array)?this._getCached(t,function(t){return this.getType(t[0],t.slice(1))},!0):this._getCached(t,function(t){return this.getType(y.object,[t])},!1)}},p.getType=function(t,e){e=this._getType(t,e);return e&&!f(t,g)&&(e.name="object"==typeof t?f(t,Array)?t[0]+"("+t.slice(1).join(", ")+")":"object":String(t)),e},p._action=function(t,e,i){if(void 0!==t){t=this.getType(t);var n=this._named(function(){return i.call(this,t.createProperty(this),this.contexts[0])},"["+t.name+"]",e);return void 0!==e?this.seek(e,n):n.call(this)}},p.read=function(t,e){return this._action(t,e,function(t,e){return t.read(e)})},p.readAll=function(){return this.read("jBinary.all",0)},p.write=function(t,n,e){return this._action(t,e,function(t,e){var i=this.tell();return t.write(n,e),this.tell()-i})},p.writeAll=function(t){return this.write("jBinary.all",t,0)},function(t,e){for(var i=0,n=e.length;i<n;i++){var r=e[i];y[r.toLowerCase()]=l(t,{dataType:r})}}(g({params:["littleEndian"],read:function(){return this.view["get"+this.dataType](void 0,this.littleEndian)},write:function(t){this.view["write"+this.dataType](t,this.littleEndian)}}),["Uint8","Uint16","Uint32","Uint64","Int8","Int16","Int32","Int64","Float32","Float64","Char"]),r(y,{byte:y.uint8,float:y.float32,double:y.float64}),y.array=w({params:["baseType","length"],read:function(){var t=this.toValue(this.length);if(this.baseType===y.uint8)return this.view.getBytes(t,void 0,!0,!0);if(void 0!==t)for(var e=new Array(t),i=0;i<t;i++)e[i]=this.baseRead();else{var n=this.view.byteLength;for(e=[];this.binary.tell()<n;)e.push(this.baseRead())}return e},write:function(t){if(this.baseType===y.uint8)return this.view.writeBytes(t);for(var e=0,i=t.length;e<i;e++)this.baseWrite(t[e])}}),y.binary=w({params:["length","typeSet"],read:function(){var t=this.binary.tell(),e=this.binary.skip(this.toValue(this.length));return new s(this.view.slice(t,e),this.typeSet)},write:function(t){this.binary.write("blob",t.read("blob",0))}}),y.bitfield=g({params:["bitSize"],read:function(){return this.view.getUnsigned(this.bitSize)},write:function(t){this.view.writeUnsigned(t,this.bitSize)}}),y.blob=g({params:["length"],read:function(){return this.view.getBytes(this.toValue(this.length))},write:function(t){this.view.writeBytes(t,!0)}}),y.const=w({params:["baseType","value","strict"],read:function(){var t=this.baseRead();if(this.strict&&t!==this.value){if(f(this.strict,Function))return this.strict(t);throw new TypeError("Unexpected value ("+t+" !== "+this.value+").")}return t},write:function(t){this.baseWrite(this.strict||void 0===t?this.value:t)}}),y.enum=w({params:["baseType","matches"],setParams:function(t,e){for(var i in this.backMatches={},e)this.backMatches[e[i]]=i},read:function(){var t=this.baseRead();return t in this.matches?this.matches[t]:t},write:function(t){this.baseWrite(t in this.backMatches?this.backMatches[t]:t)}}),y.extend=g({setParams:function(){this.parts=arguments},resolve:function(t){for(var e=this.parts,i=e.length,n=new Array(i),r=0;r<i;r++)n[r]=t(e[r]);this.parts=n},read:function(){var i=this.parts,n=this.binary.read(i[0]);return this.binary.inContext(n,function(){for(var t=1,e=i.length;t<e;t++)r(n,this.read(i[t]))}),n},write:function(i){var n=this.parts;this.binary.inContext(i,function(){for(var t=0,e=n.length;t<e;t++)this.write(n[t],i)})}}),y.if=w({params:["condition","trueType","falseType"],typeParams:["trueType","falseType"],getBaseType:function(t){return this.toValue(this.condition)?this.trueType:this.falseType}}),y.if_not=y.ifNot=w({setParams:function(t,e,i){this.baseType=["if",t,i,e]}}),y.lazy=w({marker:"jBinary.Lazy",params:["innerType","length"],getBaseType:function(){return["binary",this.length,this.binary.typeSet]},read:function(){var e=function(t){return 0===arguments.length?"value"in e?e.value:e.value=e.binary.read(e.innerType):r(e,{wasChanged:!0,value:t}).value};return e[this.marker]=!0,r(e,{binary:r(this.baseRead(),{contexts:this.binary.contexts.slice()}),innerType:this.innerType})},write:function(t){t.wasChanged||!t[this.marker]?this.binary.write(this.innerType,t()):this.baseWrite(t.binary)}}),y.object=g({params:["structure","proto"],resolve:function(t){var e,i={};for(e in this.structure)i[e]=f(this.structure[e],Function)?this.structure[e]:t(this.structure[e]);this.structure=i},read:function(){var i=this,n=this.structure,r=this.proto?l(this.proto):{};return this.binary.inContext(r,function(){for(var e in n)this._named(function(){var t=f(n[e],Function)?n[e].call(i,r):this.read(n[e]);void 0!==t&&(r[e]=t)},e).call(this)}),r},write:function(e){var i=this,n=this.structure;this.binary.inContext(e,function(){for(var t in n)this._named(function(){f(n[t],Function)?e[t]=n[t].call(i,e):this.write(n[t],e[t])},t).call(this)})}}),y.skip=g({params:["length"],read:function(){this.view.skip(this.toValue(this.length))},write:function(){this.read()}}),y.string=w({params:["length","encoding"],read:function(){return this.view.getString(this.toValue(this.length),void 0,this.encoding)},write:function(t){this.view.writeString(t,this.encoding)}}),y.string0=g({params:["length","encoding"],read:function(){var t=this.view;if(void 0!==(n=this.length))return t.getString(n,void 0,this.encoding).replace(/\0.*$/,"");for(var e=t.tell(),i=0,n=t.byteLength-e;i<n&&t.getUint8();)i++;e=t.getString(i,e,this.encoding);return i<n&&t.skip(1),e},write:function(t){var e=this.view,i=void 0===this.length?1:this.length-t.length;e.writeString(t,void 0,this.encoding),0<i&&(e.writeUint8(0),e.skip(i-1))}});s.loadData=t(function(t,e){var i;if(f(t,h.Blob))if("FileReader"in h)(a=new FileReader).onload=a.onerror=function(){e(this.error,this.result)},a.readAsArrayBuffer(t);else{var n,r,a=new FileReaderSync;try{r=a.readAsArrayBuffer(t)}catch(t){n=t}finally{e(n,r)}}else if(0,"string"!=typeof t)e(new TypeError("Unsupported source type."));else if(r=t.match(/^data:(.+?)(;base64)?,(.*)$/))try{var s=r[2],o=r[3];e(null,(s?atob:decodeURIComponent)(o))}catch(t){e(t)}else"XMLHttpRequest"in h?((o=new XMLHttpRequest).open("GET",t,!0),"responseType"in o?o.responseType="arraybuffer":"overrideMimeType"in o?o.overrideMimeType("text/plain; charset=x-user-defined"):o.setRequestHeader("Accept-Charset","x-user-defined"),"onload"in o||(o.onreadystatechange=function(){4===this.readyState&&this.onload()}),i=function(t){e(new Error(t))},o.onload=function(){if(0!==this.status&&200!==this.status)return i("HTTP Error #"+this.status+": "+this.statusText);"response"in this||(this.response=new VBArray(this.responseBody).toArray()),e(null,this.response)},o.onerror=function(){i("Network error.")},o.send(null)):e(new TypeError("Unsupported source type."))}),(s.load=t(function(t,e,i){var n=s.loadData(t);s.load.getTypeSet(t,e,function(e){n.then(function(t){i(null,new s(t,e))},i)})})).getTypeSet=function(t,e,i){i(e)},p._toURI="URL"in h&&"createObjectURL"in URL?function(t){var e=this.seek(0,function(){return this.view.getBytes()});return URL.createObjectURL(new Blob([e],{type:t}))}:function(t){var e=this.seek(0,function(){return this.view.getString(void 0,void 0,"binary")});return"data:"+t+";base64,"+btoa(e)},p._mimeType=function(t){return t||this.typeSet["jBinary.mimeType"]||"application/octet-stream"};var m;p.toURI=function(t){return this._toURI(this._mimeType(t))};return n&&((m=s.downloader=n.createElement("a")).style.display="none"),p.saveAs=t(function(t,e,i){"string"==typeof t?("msSaveBlob"in navigator?navigator.msSaveBlob(new Blob([this.read("blob",0)],{type:this._mimeType(e)}),t):n?(m.parentNode||n.body.appendChild(m),m.href=this.toURI(e),m.download=t,m.click(),m.href=m.download=""):i(new TypeError("Saving from Web Worker is not supported.")),i()):i(new TypeError("Unsupported storage type."))}),s});
//# sourceMappingURL=jbinary.js.map

/***/ }),

/***/ "./node_modules/jdataview/dist/node/jdataview.js":
/*!*******************************************************!*\
  !*** ./node_modules/jdataview/dist/node/jdataview.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {!function(factory) {
    var global = this;
    module.exports = factory(global);
}(function(global) {
    "use strict";
    function is(obj, Ctor) {
        return "object" != typeof obj || null === obj ? !1 : obj.constructor === Ctor || Object.prototype.toString.call(obj) === "[object " + Ctor.name + "]";
    }
    function arrayFrom(arrayLike, forceCopy) {
        return !forceCopy && is(arrayLike, Array) ? arrayLike : Array.prototype.slice.call(arrayLike);
    }
    function defined(value, defaultValue) {
        return void 0 !== value ? value : defaultValue;
    }
    function jDataView(buffer, byteOffset, byteLength, littleEndian) {
        if (jDataView.is(buffer)) {
            var result = buffer.slice(byteOffset, byteOffset + byteLength);
            return result._littleEndian = defined(littleEndian, result._littleEndian), result;
        }
        if (!jDataView.is(this)) return new jDataView(buffer, byteOffset, byteLength, littleEndian);
        if (this.buffer = buffer = jDataView.wrapBuffer(buffer), this._isArrayBuffer = compatibility.ArrayBuffer && is(buffer, ArrayBuffer), 
        this._isPixelData = !1, this._isDataView = compatibility.DataView && this._isArrayBuffer, 
        this._isNodeBuffer =  true && compatibility.NodeBuffer && is(buffer, Buffer), !this._isNodeBuffer && !this._isArrayBuffer && !is(buffer, Array)) throw new TypeError("jDataView buffer has an incompatible type");
        this._littleEndian = !!littleEndian;
        var bufferLength = "byteLength" in buffer ? buffer.byteLength : buffer.length;
        this.byteOffset = byteOffset = defined(byteOffset, 0), this.byteLength = byteLength = defined(byteLength, bufferLength - byteOffset), 
        this._offset = this._bitOffset = 0, this._isDataView ? this._view = new DataView(buffer, byteOffset, byteLength) : this._checkBounds(byteOffset, byteLength, bufferLength), 
        this._engineAction = this._isDataView ? this._dataViewAction : this._isNodeBuffer ? this._nodeBufferAction : this._isArrayBuffer ? this._arrayBufferAction : this._arrayAction;
    }
    function getCharCodes(string) {
        if (compatibility.NodeBuffer) return new Buffer(string, "binary");
        for (var Type = compatibility.ArrayBuffer ? Uint8Array : Array, codes = new Type(string.length), i = 0, length = string.length; length > i; i++) codes[i] = 255 & string.charCodeAt(i);
        return codes;
    }
    function pow2(n) {
        return n >= 0 && 31 > n ? 1 << n : pow2[n] || (pow2[n] = Math.pow(2, n));
    }
    function Uint64(lo, hi) {
        this.lo = lo, this.hi = hi;
    }
    function Int64() {
        Uint64.apply(this, arguments);
    }
    var compatibility = {
        NodeBuffer:  true && "Buffer" in global,
        DataView: "DataView" in global,
        ArrayBuffer: "ArrayBuffer" in global,
        PixelData: !1
    }, TextEncoder = global.TextEncoder, TextDecoder = global.TextDecoder;
    compatibility.NodeBuffer && !function(buffer) {
        try {
            buffer.writeFloatLE(1/0, 0);
        } catch (e) {
            compatibility.NodeBuffer = !1;
        }
    }(new Buffer(4));
    var dataTypes = {
        Int8: 1,
        Int16: 2,
        Int32: 4,
        Uint8: 1,
        Uint16: 2,
        Uint32: 4,
        Float32: 4,
        Float64: 8
    };
    jDataView.wrapBuffer = function(buffer) {
        switch (typeof buffer) {
          case "number":
            if (compatibility.NodeBuffer) buffer = new Buffer(buffer), buffer.fill(0); else if (compatibility.ArrayBuffer) buffer = new Uint8Array(buffer).buffer; else {
                buffer = new Array(buffer);
                for (var i = 0; i < buffer.length; i++) buffer[i] = 0;
            }
            return buffer;

          case "string":
            buffer = getCharCodes(buffer);

          default:
            return "length" in buffer && !(compatibility.NodeBuffer && is(buffer, Buffer) || compatibility.ArrayBuffer && is(buffer, ArrayBuffer)) && (compatibility.NodeBuffer ? buffer = new Buffer(buffer) : compatibility.ArrayBuffer ? is(buffer, ArrayBuffer) || (buffer = new Uint8Array(buffer).buffer, 
            is(buffer, ArrayBuffer) || (buffer = new Uint8Array(arrayFrom(buffer, !0)).buffer)) : buffer = arrayFrom(buffer)), 
            buffer;
        }
    }, jDataView.is = function(view) {
        return view && view.jDataView;
    }, jDataView.from = function() {
        return new jDataView(arguments);
    }, jDataView.Uint64 = Uint64, Uint64.prototype = {
        valueOf: function() {
            return this.lo + pow2(32) * this.hi;
        },
        toString: function() {
            return Number.prototype.toString.apply(this.valueOf(), arguments);
        }
    }, Uint64.fromNumber = function(number) {
        var hi = Math.floor(number / pow2(32)), lo = number - hi * pow2(32);
        return new Uint64(lo, hi);
    }, jDataView.Int64 = Int64, Int64.prototype = "create" in Object ? Object.create(Uint64.prototype) : new Uint64(), 
    Int64.prototype.valueOf = function() {
        return this.hi < pow2(31) ? Uint64.prototype.valueOf.apply(this, arguments) : -(pow2(32) - this.lo + pow2(32) * (pow2(32) - 1 - this.hi));
    }, Int64.fromNumber = function(number) {
        var lo, hi;
        if (number >= 0) {
            var unsigned = Uint64.fromNumber(number);
            lo = unsigned.lo, hi = unsigned.hi;
        } else hi = Math.floor(number / pow2(32)), lo = number - hi * pow2(32), hi += pow2(32);
        return new Int64(lo, hi);
    };
    var proto = jDataView.prototype = {
        compatibility: compatibility,
        jDataView: !0,
        _checkBounds: function(byteOffset, byteLength, maxLength) {
            if ("number" != typeof byteOffset) throw new TypeError("Offset is not a number.");
            if ("number" != typeof byteLength) throw new TypeError("Size is not a number.");
            if (0 > byteLength) throw new RangeError("Length is negative.");
            if (0 > byteOffset || byteOffset + byteLength > defined(maxLength, this.byteLength)) throw new RangeError("Offsets are out of bounds.");
        },
        _action: function(type, isReadAction, byteOffset, littleEndian, value) {
            return this._engineAction(type, isReadAction, defined(byteOffset, this._offset), defined(littleEndian, this._littleEndian), value);
        },
        _dataViewAction: function(type, isReadAction, byteOffset, littleEndian, value) {
            return this._offset = byteOffset + dataTypes[type], isReadAction ? this._view["get" + type](byteOffset, littleEndian) : this._view["set" + type](byteOffset, value, littleEndian);
        },
        _arrayBufferAction: function(type, isReadAction, byteOffset, littleEndian, value) {
            var typedArray, size = dataTypes[type], TypedArray = global[type + "Array"];
            if (littleEndian = defined(littleEndian, this._littleEndian), 1 === size || (this.byteOffset + byteOffset) % size === 0 && littleEndian) return typedArray = new TypedArray(this.buffer, this.byteOffset + byteOffset, 1), 
            this._offset = byteOffset + size, isReadAction ? typedArray[0] : typedArray[0] = value;
            var bytes = new Uint8Array(isReadAction ? this.getBytes(size, byteOffset, littleEndian, !0) : size);
            return typedArray = new TypedArray(bytes.buffer, 0, 1), isReadAction ? typedArray[0] : (typedArray[0] = value, 
            void this._setBytes(byteOffset, bytes, littleEndian));
        },
        _arrayAction: function(type, isReadAction, byteOffset, littleEndian, value) {
            return isReadAction ? this["_get" + type](byteOffset, littleEndian) : this["_set" + type](byteOffset, value, littleEndian);
        },
        _getBytes: function(length, byteOffset, littleEndian) {
            littleEndian = defined(littleEndian, this._littleEndian), byteOffset = defined(byteOffset, this._offset), 
            length = defined(length, this.byteLength - byteOffset), this._checkBounds(byteOffset, length), 
            byteOffset += this.byteOffset, this._offset = byteOffset - this.byteOffset + length;
            var result = this._isArrayBuffer ? new Uint8Array(this.buffer, byteOffset, length) : (this.buffer.slice || Array.prototype.slice).call(this.buffer, byteOffset, byteOffset + length);
            return littleEndian || 1 >= length ? result : arrayFrom(result).reverse();
        },
        getBytes: function(length, byteOffset, littleEndian, toArray) {
            var result = this._getBytes(length, byteOffset, defined(littleEndian, !0));
            return toArray ? arrayFrom(result) : result;
        },
        _setBytes: function(byteOffset, bytes, littleEndian) {
            var length = bytes.length;
            if (0 !== length) {
                if (littleEndian = defined(littleEndian, this._littleEndian), byteOffset = defined(byteOffset, this._offset), 
                this._checkBounds(byteOffset, length), !littleEndian && length > 1 && (bytes = arrayFrom(bytes, !0).reverse()), 
                byteOffset += this.byteOffset, this._isArrayBuffer) new Uint8Array(this.buffer, byteOffset, length).set(bytes); else if (this._isNodeBuffer) new Buffer(bytes).copy(this.buffer, byteOffset); else for (var i = 0; length > i; i++) this.buffer[byteOffset + i] = bytes[i];
                this._offset = byteOffset - this.byteOffset + length;
            }
        },
        setBytes: function(byteOffset, bytes, littleEndian) {
            this._setBytes(byteOffset, bytes, defined(littleEndian, !0));
        },
        getString: function(byteLength, byteOffset, encoding) {
            if (this._isNodeBuffer) return byteOffset = defined(byteOffset, this._offset), byteLength = defined(byteLength, this.byteLength - byteOffset), 
            this._checkBounds(byteOffset, byteLength), this._offset = byteOffset + byteLength, 
            this.buffer.toString(encoding || "binary", this.byteOffset + byteOffset, this.byteOffset + this._offset);
            var bytes = this._getBytes(byteLength, byteOffset, !0);
            if (encoding = "utf8" === encoding ? "utf-8" : encoding || "binary", TextDecoder && "binary" !== encoding) return new TextDecoder(encoding).decode(this._isArrayBuffer ? bytes : new Uint8Array(bytes));
            var string = "";
            byteLength = bytes.length;
            for (var i = 0; byteLength > i; i++) string += String.fromCharCode(bytes[i]);
            return "utf-8" === encoding && (string = decodeURIComponent(escape(string))), string;
        },
        setString: function(byteOffset, subString, encoding) {
            if (this._isNodeBuffer) return byteOffset = defined(byteOffset, this._offset), this._checkBounds(byteOffset, subString.length), 
            void (this._offset = byteOffset + this.buffer.write(subString, this.byteOffset + byteOffset, encoding || "binary"));
            encoding = "utf8" === encoding ? "utf-8" : encoding || "binary";
            var bytes;
            TextEncoder && "binary" !== encoding ? bytes = new TextEncoder(encoding).encode(subString) : ("utf-8" === encoding && (subString = unescape(encodeURIComponent(subString))), 
            bytes = getCharCodes(subString)), this._setBytes(byteOffset, bytes, !0);
        },
        getChar: function(byteOffset) {
            return this.getString(1, byteOffset);
        },
        setChar: function(byteOffset, character) {
            this.setString(byteOffset, character);
        },
        tell: function() {
            return this._offset;
        },
        seek: function(byteOffset) {
            return this._checkBounds(byteOffset, 0), this._offset = byteOffset;
        },
        skip: function(byteLength) {
            return this.seek(this._offset + byteLength);
        },
        slice: function(start, end, forceCopy) {
            function normalizeOffset(offset, byteLength) {
                return 0 > offset ? offset + byteLength : offset;
            }
            return start = normalizeOffset(start, this.byteLength), end = normalizeOffset(defined(end, this.byteLength), this.byteLength), 
            forceCopy ? new jDataView(this.getBytes(end - start, start, !0, !0), void 0, void 0, this._littleEndian) : new jDataView(this.buffer, this.byteOffset + start, end - start, this._littleEndian);
        },
        alignBy: function(byteCount) {
            return this._bitOffset = 0, 1 !== defined(byteCount, 1) ? this.skip(byteCount - (this._offset % byteCount || byteCount)) : this._offset;
        },
        _getFloat64: function(byteOffset, littleEndian) {
            var b = this._getBytes(8, byteOffset, littleEndian), sign = 1 - 2 * (b[7] >> 7), exponent = ((b[7] << 1 & 255) << 3 | b[6] >> 4) - 1023, mantissa = (15 & b[6]) * pow2(48) + b[5] * pow2(40) + b[4] * pow2(32) + b[3] * pow2(24) + b[2] * pow2(16) + b[1] * pow2(8) + b[0];
            return 1024 === exponent ? 0 !== mantissa ? 0/0 : 1/0 * sign : -1023 === exponent ? sign * mantissa * pow2(-1074) : sign * (1 + mantissa * pow2(-52)) * pow2(exponent);
        },
        _getFloat32: function(byteOffset, littleEndian) {
            var b = this._getBytes(4, byteOffset, littleEndian), sign = 1 - 2 * (b[3] >> 7), exponent = (b[3] << 1 & 255 | b[2] >> 7) - 127, mantissa = (127 & b[2]) << 16 | b[1] << 8 | b[0];
            return 128 === exponent ? 0 !== mantissa ? 0/0 : 1/0 * sign : -127 === exponent ? sign * mantissa * pow2(-149) : sign * (1 + mantissa * pow2(-23)) * pow2(exponent);
        },
        _get64: function(Type, byteOffset, littleEndian) {
            littleEndian = defined(littleEndian, this._littleEndian), byteOffset = defined(byteOffset, this._offset);
            for (var parts = littleEndian ? [ 0, 4 ] : [ 4, 0 ], i = 0; 2 > i; i++) parts[i] = this.getUint32(byteOffset + parts[i], littleEndian);
            return this._offset = byteOffset + 8, new Type(parts[0], parts[1]);
        },
        getInt64: function(byteOffset, littleEndian) {
            return this._get64(Int64, byteOffset, littleEndian);
        },
        getUint64: function(byteOffset, littleEndian) {
            return this._get64(Uint64, byteOffset, littleEndian);
        },
        _getInt32: function(byteOffset, littleEndian) {
            var b = this._getBytes(4, byteOffset, littleEndian);
            return b[3] << 24 | b[2] << 16 | b[1] << 8 | b[0];
        },
        _getUint32: function(byteOffset, littleEndian) {
            return this._getInt32(byteOffset, littleEndian) >>> 0;
        },
        _getInt16: function(byteOffset, littleEndian) {
            return this._getUint16(byteOffset, littleEndian) << 16 >> 16;
        },
        _getUint16: function(byteOffset, littleEndian) {
            var b = this._getBytes(2, byteOffset, littleEndian);
            return b[1] << 8 | b[0];
        },
        _getInt8: function(byteOffset) {
            return this._getUint8(byteOffset) << 24 >> 24;
        },
        _getUint8: function(byteOffset) {
            return this._getBytes(1, byteOffset)[0];
        },
        _getBitRangeData: function(bitLength, byteOffset) {
            var startBit = (defined(byteOffset, this._offset) << 3) + this._bitOffset, endBit = startBit + bitLength, start = startBit >>> 3, end = endBit + 7 >>> 3, b = this._getBytes(end - start, start, !0), wideValue = 0;
            (this._bitOffset = 7 & endBit) && (this._bitOffset -= 8);
            for (var i = 0, length = b.length; length > i; i++) wideValue = wideValue << 8 | b[i];
            return {
                start: start,
                bytes: b,
                wideValue: wideValue
            };
        },
        getSigned: function(bitLength, byteOffset) {
            var shift = 32 - bitLength;
            return this.getUnsigned(bitLength, byteOffset) << shift >> shift;
        },
        getUnsigned: function(bitLength, byteOffset) {
            var value = this._getBitRangeData(bitLength, byteOffset).wideValue >>> -this._bitOffset;
            return 32 > bitLength ? value & ~(-1 << bitLength) : value;
        },
        _setBinaryFloat: function(byteOffset, value, mantSize, expSize, littleEndian) {
            var exponent, mantissa, signBit = 0 > value ? 1 : 0, eMax = ~(-1 << expSize - 1), eMin = 1 - eMax;
            0 > value && (value = -value), 0 === value ? (exponent = 0, mantissa = 0) : isNaN(value) ? (exponent = 2 * eMax + 1, 
            mantissa = 1) : 1/0 === value ? (exponent = 2 * eMax + 1, mantissa = 0) : (exponent = Math.floor(Math.log(value) / Math.LN2), 
            exponent >= eMin && eMax >= exponent ? (mantissa = Math.floor((value * pow2(-exponent) - 1) * pow2(mantSize)), 
            exponent += eMax) : (mantissa = Math.floor(value / pow2(eMin - mantSize)), exponent = 0));
            for (var b = []; mantSize >= 8; ) b.push(mantissa % 256), mantissa = Math.floor(mantissa / 256), 
            mantSize -= 8;
            for (exponent = exponent << mantSize | mantissa, expSize += mantSize; expSize >= 8; ) b.push(255 & exponent), 
            exponent >>>= 8, expSize -= 8;
            b.push(signBit << expSize | exponent), this._setBytes(byteOffset, b, littleEndian);
        },
        _setFloat32: function(byteOffset, value, littleEndian) {
            this._setBinaryFloat(byteOffset, value, 23, 8, littleEndian);
        },
        _setFloat64: function(byteOffset, value, littleEndian) {
            this._setBinaryFloat(byteOffset, value, 52, 11, littleEndian);
        },
        _set64: function(Type, byteOffset, value, littleEndian) {
            "object" != typeof value && (value = Type.fromNumber(value)), littleEndian = defined(littleEndian, this._littleEndian), 
            byteOffset = defined(byteOffset, this._offset);
            var parts = littleEndian ? {
                lo: 0,
                hi: 4
            } : {
                lo: 4,
                hi: 0
            };
            for (var partName in parts) this.setUint32(byteOffset + parts[partName], value[partName], littleEndian);
            this._offset = byteOffset + 8;
        },
        setInt64: function(byteOffset, value, littleEndian) {
            this._set64(Int64, byteOffset, value, littleEndian);
        },
        setUint64: function(byteOffset, value, littleEndian) {
            this._set64(Uint64, byteOffset, value, littleEndian);
        },
        _setUint32: function(byteOffset, value, littleEndian) {
            this._setBytes(byteOffset, [ 255 & value, value >>> 8 & 255, value >>> 16 & 255, value >>> 24 ], littleEndian);
        },
        _setUint16: function(byteOffset, value, littleEndian) {
            this._setBytes(byteOffset, [ 255 & value, value >>> 8 & 255 ], littleEndian);
        },
        _setUint8: function(byteOffset, value) {
            this._setBytes(byteOffset, [ 255 & value ]);
        },
        setUnsigned: function(byteOffset, value, bitLength) {
            var data = this._getBitRangeData(bitLength, byteOffset), wideValue = data.wideValue, b = data.bytes;
            wideValue &= ~(~(-1 << bitLength) << -this._bitOffset), wideValue |= (32 > bitLength ? value & ~(-1 << bitLength) : value) << -this._bitOffset;
            for (var i = b.length - 1; i >= 0; i--) b[i] = 255 & wideValue, wideValue >>>= 8;
            this._setBytes(data.start, b, !0);
        }
    }, nodeNaming = {
        Int8: "Int8",
        Int16: "Int16",
        Int32: "Int32",
        Uint8: "UInt8",
        Uint16: "UInt16",
        Uint32: "UInt32",
        Float32: "Float",
        Float64: "Double"
    };
    proto._nodeBufferAction = function(type, isReadAction, byteOffset, littleEndian, value) {
        this._offset = byteOffset + dataTypes[type];
        var nodeName = nodeNaming[type] + ("Int8" === type || "Uint8" === type ? "" : littleEndian ? "LE" : "BE");
        return byteOffset += this.byteOffset, isReadAction ? this.buffer["read" + nodeName](byteOffset) : this.buffer["write" + nodeName](value, byteOffset);
    };
    for (var type in dataTypes) !function(type) {
        proto["get" + type] = function(byteOffset, littleEndian) {
            return this._action(type, !0, byteOffset, littleEndian);
        }, proto["set" + type] = function(byteOffset, value, littleEndian) {
            this._action(type, !1, byteOffset, littleEndian, value);
        };
    }(type);
    proto._setInt32 = proto._setUint32, proto._setInt16 = proto._setUint16, proto._setInt8 = proto._setUint8, 
    proto.setSigned = proto.setUnsigned;
    for (var method in proto) "set" === method.slice(0, 3) && !function(type) {
        proto["write" + type] = function() {
            Array.prototype.unshift.call(arguments, void 0), this["set" + type].apply(this, arguments);
        };
    }(method.slice(3));
    return jDataView;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/adts.js":
/*!**********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/adts.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
	'use strict';

	return {
		ADTSPacket: {
			_start: function () { return this.binary.tell() },
			_syncWord: ['const', 12, 0xfff, true],
			version: ['enum', 1, ['mpeg-4', 'mpeg-2']],
			layer: ['const', 2, 0],
			isProtectionAbsent: 1,
			profileMinusOne: 2, // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Object_Types minus one
			samplingFreq: ['enum', 4, [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350]], // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Sampling_Frequencies
			_privateStream: 1,
			channelConfig: 3, // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Channel_Configurations
			_reserved: 4, // originality, home, copyrighted, copyright start bits
			frameLength: 13,
			bufferFullness: 11,
			aacFramesCountMinusOne: 2,
			data: ['blob', function (context) { return context.frameLength - (this.binary.tell() - context._start) }]
		}
	};
}));

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/h264.js":
/*!**********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/h264.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jBinary) {
	'use strict';

	return {
		ExpGolomb: jBinary.Type({
			params: ['isSigned'],
			read: function () {
				var count = 0;
				while (!this.binary.read(1)) count++;
				var value = (1 << count) | this.binary.read(count);
				return this.isSigned ? (value & 1 ? -(value >> 1) : value >> 1) : value - 1;
			},
			write: function (value) {
				if (this.isSigned) {
					value <<= 1;
					if (value <= 0) {
						value = -value | 1;
					}
				} else {
					value++;
				}
				var length = value.toString(2).length;
				this.binary.write(length - 1, 0);
				this.binary.write(length, value);
			}
		}),

		Optional: jBinary.Template({
		    params: ['baseType'],
			read: function () {
				if (this.binary.read(1)) return this.baseRead();
			},
			write: function (value) {
				this.binary.write(value != null ? 1 : 0);
				if (value != null) {
					this.baseWrite(value);
				}
			}
		}),

		ScalingList: jBinary.Template({
			setParams: function (size) {
				this.baseType = ['array', { /* TODO: implement scaling list */ }, size];
			}
		}),

		SPS: [
			'extend',
			{
				profile_idc: 'uint8',
				constraint_set_flags: ['array', 1, 8],
				level_idc: 'uint8',
				seq_parameter_set_id: 'ExpGolomb'
			},
			['if', function (context) { return [100, 110, 122, 244, 44, 83, 86, 118].indexOf(context.profile_idc) >= 0 }, {
				chroma_format: ['enum', 'ExpGolomb', ['MONO', 'YUV420', 'YUV422', 'YUV444']],
				separate_color_plane_flag: ['if', function (context) { return context.chroma_format === 'YUV444' }, 1],
				bit_depth_luma_minus8: 'ExpGolomb',
				bit_depth_chroma_minus8: 'ExpGolomb',
				qpprime_y_zero_transform_bypass_flag: 1,
				scaling_matrix: ['Optional', {
					scalingList4x4: ['array', ['ScalingList', 16], 6],
					scalingList8x8: ['array', ['ScalingList', 64], function () { return this.binary.getContext(1).chroma_format !== 'YUV444' ? 2 : 6 }]
				}]
			}],
			{
				log2_max_frame_num_minus4: 'ExpGolomb',
				pic_order_cnt_type: 'ExpGolomb',
				pic_order: ['if_not', 'pic_order_cnt_type', {log2_max_pic_order_cnt_lsb_minus4: 'ExpGolomb'}, [
					'if',
					function (context) { return context.pic_order_cnt_type === 1 },
					{
						delta_pic_order_always_zero_flag: 1,
						offset_for_non_ref_pic: ['ExpGolomb', true],
						offset_for_top_to_bottom_field: ['ExpGolomb', true],
						_num_ref_frames_in_pic_order_cnt_cycle: jBinary.Template({
							baseType: 'ExpGolomb',
							write: function (value, context) { this.baseWrite(context.offset_for_ref_frame.length) }
						}),
						offset_for_ref_frame: ['array', ['ExpGolomb', true], function (context) { return context._num_ref_frames_in_pic_order_cnt_cycle }]
					}
				]],
				max_num_ref_frames: 'ExpGolomb',
				gaps_in_frame_num_value_allowed_flag: 1,
				pic_width_in_mbs_minus_1: 'ExpGolomb',
				pic_height_in_map_units_minus_1: 'ExpGolomb',
				frame_mbs_only_flag: 1,
				mb_adaptive_frame_field_flag: ['if_not', 'frame_mbs_only_flag', 1],
				direct_8x8_inference_flag: 1,
				frame_cropping: ['Optional', {
					left: 'ExpGolomb',
					right: 'ExpGolomb',
					top: 'ExpGolomb',
					bottom: 'ExpGolomb'
				}]
				// TODO: add VUI parameters
			}
		],

		NALUnit: jBinary.Type({
			read: function () {
				var sync = this.binary.read(['blob', 3]); // [0, 0, 1] or [0, 0, 0, 1]
				if (sync[2] === 0) this.binary.skip(1);
				var end = this.binary.view.byteLength, pos = this.binary.tell();
				var bytes = this.binary.skip(0, function () { return this.view.getBytes() });
				for (var i = 1, length = bytes.length - 3; i < length; i++) {
					if (bytes[i] === 0 && bytes[i + 1] === 0 && (bytes[i + 2] === 1 || (bytes[i + 2] === 0 && bytes[i + 3] === 1))) {
						end = pos + i;
						break;
					}
				}
				var data = this.binary.read(['blob', end - pos]);
				// TODO: ideally there should be Annex.B conversion from [0, 0, 3, X=0..3] to [0, 0, X]
				return data;
			}
		})
	};
}));

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jdataview */ "./node_modules/jdataview/dist/node/jdataview.js"), __webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js"), __webpack_require__(/*! ./mp4 */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/mp4.js"), __webpack_require__(/*! ./h264 */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/h264.js"), __webpack_require__(/*! ./pes */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/pes.js"), __webpack_require__(/*! ./adts */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/adts.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jDataView, jBinary, MP4, H264, PES, ADTS) {
	'use strict';


	/**
	 * Copied from mux.js => https://github.com/videojs/mux.js/blob/957441d44307a47d801af3db5c51072ed241f8c2/lib/codecs/h264.js#L266
	 * Expunge any "Emulation Prevention" bytes from a "Raw Byte
	 * Sequence Payload"
	 * @param data {Uint8Array} the bytes of a RBSP from a NAL
	 * unit
	 * @return {Uint8Array} the RBSP without any Emulation
	 * Prevention Bytes
	 */
	var discardEmulationPreventionBytes = function(data) {
		var
		length = data.byteLength,
		emulationPreventionBytesPositions = [],
		i = 0,
		newLength, newData;

		// Find all `Emulation Prevention Bytes`
		while (i < length - 2) {
		if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
			emulationPreventionBytesPositions.push(i + 2);
			i += 2;
		} else {
			i++;
		}
		}

		// If no Emulation Prevention Bytes were found just return the original
		// array
		if (emulationPreventionBytesPositions.length === 0) {
		return data;
		}

		// Create a new array to hold the NAL unit data
		newLength = length - emulationPreventionBytesPositions.length;
		newData = new Uint8Array(newLength);
		var sourceIndex = 0;

		for (i = 0; i < newLength; sourceIndex++, i++) {
		if (sourceIndex === emulationPreventionBytesPositions[0]) {
			// Skip this byte
			sourceIndex++;
			// Remove this position index
			emulationPreventionBytesPositions.shift();
		}
		newData[i] = data[sourceIndex];
		}

		return newData;
	};


	return function (mpegts) {
		var packets = mpegts.read('File');
		
		// extracting and concatenating raw stream parts
		var stream = new jDataView(mpegts.view.byteLength);
		for (var i = 0, length = packets.length; i < length; i++) {
			var packet = packets[i], adaptation = packet.adaptationField, payload = packet.payload;
			if (payload && payload._rawStream) {
				stream.writeBytes(payload._rawStream);
			}
		}
		
		var pesStream = new jBinary(stream.slice(0, stream.tell()), PES),
			audioStream = new jBinary(stream.byteLength, ADTS),
			samples = [],
			audioSamples = [];

		stream = new jDataView(stream.byteLength);
		
		while (pesStream.tell() < pesStream.view.byteLength) {
			var packet = pesStream.read('PESPacket');

			if (packet.streamId === 0xC0) {
				// 0xC0 means we have got first audio stream
				audioStream.write('blob', packet.data);
			} else
			if (packet.streamId === 0xE0) {
				var nalStream = new jBinary(packet.data, H264),
					pts = packet.pts,
					dts = packet.dts,
					curSample = {offset: stream.tell(), pts: pts, dts: dts !== undefined ? dts : pts};
				
				samples.push(curSample);
				
				// collecting info from H.264 NAL units
				while (nalStream.tell() < nalStream.view.byteLength) {
					var nalUnit = nalStream.read('NALUnit');
					switch (nalUnit[0] & 0x1F) {
						case 7:
							if (!sps) {
								var sps = nalUnit;
								// remove Emulation Prevention Bytes to get correct width & height
								// See http://blog.51cto.com/danielllf/1758115
								var spsInfo = new jBinary(discardEmulationPreventionBytes(sps.subarray(1)), H264).read('SPS');
								var width = (spsInfo.pic_width_in_mbs_minus_1 + 1) * 16;
								var height = (2 - spsInfo.frame_mbs_only_flag) * (spsInfo.pic_height_in_map_units_minus_1 + 1) * 16;
								var cropping = spsInfo.frame_cropping;
								if (cropping) {
									width -= 2 * (cropping.left + cropping.right);
									height -= 2 * (cropping.top + cropping.bottom);
								}
							}
							break;

						case 8:
							if (!pps) {
								var pps = nalUnit;
							}
							break;

						case 5:
							curSample.isIDR = true;
						/* falls through */
						default:
							stream.writeUint32(nalUnit.length);
							stream.writeBytes(nalUnit);
					}
				}
			}
		}
		
		samples.push({offset: stream.tell()});

		var sizes = [],
			dtsDiffs = [],
			accessIndexes = [],
			pts_dts_Diffs = [],
			current = samples[0],
			frameRate = {sum: 0, count: 0},
			duration = 0;
		
		// calculating PTS/DTS differences and collecting keyframes
		
		for (var i = 0, length = samples.length - 1; i < length; i++) {
			var next = samples[i + 1];
			sizes.push(next.offset - current.offset);
			var dtsDiff = next.dts - current.dts;
			if (dtsDiff) {
				dtsDiffs.push({sample_count: 1, sample_delta: dtsDiff});
				duration += dtsDiff;
				frameRate.sum += dtsDiff;
				frameRate.count++;
			} else {
				dtsDiffs.length++;
			}
			if (current.isIDR) {
				accessIndexes.push(i + 1);
			}
			pts_dts_Diffs.push({
				first_chunk: pts_dts_Diffs.length + 1,
				sample_count: 1,
				sample_offset: current.dtsFix = current.pts - current.dts
			});
			current = next;
		}
		
		frameRate = Math.round(frameRate.sum / frameRate.count);
		
		for (var i = 0, length = dtsDiffs.length; i < length; i++) {
			if (dtsDiffs[i] === undefined) {
				dtsDiffs[i] = {first_chunk: i + 1, sample_count: 1, sample_delta: frameRate};
				duration += frameRate;
				//samples[i + 1].dts = samples[i].dts + frameRate;
			}
		}

		// checking if DTS differences are same everywhere to pack them into one item
		
		var dtsDiffsSame = true;
		
		for (var i = 1, length = dtsDiffs.length; i < length; i++) {
			if (dtsDiffs[i].sample_delta !== dtsDiffs[0].sample_delta) {
				dtsDiffsSame = false;
				break;
			}
		}
		
		if (dtsDiffsSame) {
			dtsDiffs = [{first_chunk: 1, sample_count: sizes.length, sample_delta: dtsDiffs[0].sample_delta}];
		}

		// building audio metadata

		var audioStart = stream.tell(),
			audioSize = audioStream.tell(),
			audioSizes = [],
			audioHeader,
			maxAudioSize = 0;
			
		audioStream.seek(0);
		
		while (audioStream.tell() < audioSize) {
			audioHeader = audioStream.read('ADTSPacket');
			audioSizes.push(audioHeader.data.length);
			if (audioHeader.data.length > maxAudioSize) {
				maxAudioSize = audioHeader.data.length;
			}
			stream.writeBytes(audioHeader.data);
		}

		// generating resulting MP4

		var mp4 = new jBinary(stream.byteLength, MP4);
		
		var trak = [{
			atoms: {
				tkhd: [{
					version: 0,
					flags: 15,
					track_ID: 1,
					duration: duration,
					layer: 0,
					alternate_group: 0,
					volume: 1,
					matrix: {
						a: 1, b: 0, x: 0,
						c: 0, d: 1, y: 0,
						u: 0, v: 0, w: 1
					},
					dimensions: {
						horz: width,
						vert: height
					}
				}],
				mdia: [{
					atoms: {
						mdhd: [{
							version: 0,
							flags: 0,
							timescale: 90000,
							duration: duration,
							lang: 'und'
						}],
						hdlr: [{
							version: 0,
							flags: 0,
							handler_type: 'vide',
							name: 'VideoHandler'
						}],
						minf: [{
							atoms: {
								vmhd: [{
									version: 0,
									flags: 1,
									graphicsmode: 0,
									opcolor: {r: 0, g: 0, b: 0}
								}],
								dinf: [{
									atoms: {
										dref: [{
											version: 0,
											flags: 0,
											entries: [{
												type: 'url ',
												version: 0,
												flags: 1,
												location: ''
											}]
										}]
									}
								}],
								stbl: [{
									atoms: {
										stsd: [{
											version: 0,
											flags: 0,
											entries: [{
												type: 'avc1',
												data_reference_index: 1,
												dimensions: {
													horz: width,
													vert: height
												},
												resolution: {
													horz: 72,
													vert: 72
												},
												frame_count: 1,
												compressorname: '',
												depth: 24,
												atoms: {
													avcC: [{
														version: 1,
														profileIndication: spsInfo.profile_idc,
														profileCompatibility: parseInt(spsInfo.constraint_set_flags.join(''), 2),
														levelIndication: spsInfo.level_idc,
														lengthSizeMinusOne: 3,
														seqParamSets: [sps],
														pictParamSets: [pps]
													}]
												}
											}]
										}],
										stts: [{
											version: 0,
											flags: 0,
											entries: dtsDiffs
										}],
										stss: [{
											version: 0,
											flags: 0,
											entries: accessIndexes
										}],
										ctts: [{
											version: 0,
											flags: 0,
											entries: pts_dts_Diffs
										}],
										stsc: [{
											version: 0,
											flags: 0,
											entries: [{
												first_chunk: 1,
												samples_per_chunk: sizes.length,
												sample_description_index: 1
											}]
										}],
										stsz: [{
											version: 0,
											flags: 0,
											sample_size: 0,
											sample_count: sizes.length,
											sample_sizes: sizes
										}],
										stco: [{
											version: 0,
											flags: 0,
											entries: [0x28]
										}]
									}
								}]
							}
						}]
					}
				}]
			}
		}];

		if (audioSize > 0) {
			trak.push({
				atoms: {
					tkhd: [{
						version: 0,
						flags: 15,
						track_ID: 2,
						duration: duration,
						layer: 0,
						alternate_group: 1,
						volume: 1,
						matrix: {
							a: 1, b: 0, x: 0,
							c: 0, d: 1, y: 0,
							u: 0, v: 0, w: 1
						},
						dimensions: {
							horz: 0,
							vert: 0
						}
					}],
					mdia: [{
						atoms: {
							mdhd: [{
								version: 0,
								flags: 0,
								timescale: 90000,
								duration: duration,
								lang: 'eng'
							}],
							hdlr: [{
								version: 0,
								flags: 0,
								handler_type: 'soun',
								name: 'SoundHandler'
							}],
							minf: [{
								atoms: {
									smhd: [{
										version: 0,
										flags: 0,
										balance: 0
									}],
									dinf: [{
										atoms: {
											dref: [{
												version: 0,
												flags: 0,
												entries: [{
													type: 'url ',
													version: 0,
													flags: 1,
													location: ''
												}]
											}]
										}
									}],
									stbl: [{
										atoms: {
											stsd: [{
												version: 0,
												flags: 0,
												entries: [{
													type: 'mp4a',
													data_reference_index: 1,
													channelcount: 2,
													samplesize: 16,
													samplerate: 22050,
													atoms: {
														esds: [{
															version: 0,
															flags: 0,
															sections: [
																{
																	descriptor_type: 3,
																	ext_type: 128,
																	length: 34,
																	es_id: 2,
																	stream_priority: 0
																},
																{
																	descriptor_type: 4,
																	ext_type: 128,
																	length: 20,
																	type: 'mpeg4_audio',
																	stream_type: 'audio',
																	upstream_flag: 0,
																	buffer_size: 0,
																	maxBitrate: Math.round(maxAudioSize / (duration / 90000 / audioSizes.length)),
																	avgBitrate: Math.round((stream.tell() - audioStart) / (duration / 90000))
																},
																{
																	descriptor_type: 5,
																	ext_type: 128,
																	length: 2,
																	audio_profile: audioHeader.profileMinusOne + 1,
																	sampling_freq: audioHeader.samplingFreq,
																	channelConfig: audioHeader.channelConfig
																},
																{
																	descriptor_type: 6,
																	ext_type: 128,
																	length: 1,
																	sl: 2
																}
															]
														}]
													}
												}]
											}],
											stts: [{
												version: 0,
												flags: 0,
												entries: [{
													sample_count: audioSizes.length,
													sample_delta: Math.round(duration / audioSizes.length)
												}]
											}],
											stsc: [{
												version: 0,
												flags: 0,
												entries: [{
													first_chunk: 1,
													samples_per_chunk: audioSizes.length,
													sample_description_index: 1
												}]
											}],
											stsz: [{
												version: 0,
												flags: 0,
												sample_size: 0,
												sample_count: audioSizes.length,
												sample_sizes: audioSizes
											}],
											stco: [{
												version: 0,
												flags: 0,
												entries: [0x28 + audioStart]
											}]
										}
									}]
								}
							}]
						}
					}]
				}
			});
		};
		
		var creationTime = new Date();

		mp4.write('File', {
			ftyp: [{
				major_brand: 'isom',
				minor_version: 512,
				compatible_brands: ['isom', 'iso2', 'avc1', 'mp41']
			}],
			mdat: [{
				_rawData: stream.getBytes(stream.tell(), 0)
			}],
			moov: [{
				atoms: {
					mvhd: [{
						version: 0,
						flags: 0,
						creation_time: creationTime,
						modification_time: creationTime,
						timescale: 90000,
						duration: duration,
						rate: 1,
						volume: 1,
						matrix: {
							a: 1, b: 0, x: 0,
							c: 0, d: 1, y: 0,
							u: 0, v: 0, w: 1
						},
						next_track_ID: 2
					}],
					trak: trak
				}
			}]
		});
		
		return mp4.slice(0, mp4.tell());
	};
}));

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/mp4.js":
/*!*********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/mp4.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jBinary) {
	'use strict';

	var timeBasis = new Date(1970, 0, 1) - new Date(1904, 0, 1);

	function atomFilter(type) {
		return function (atom) {
			return atom.type === type;
		};
	}

	return {
		ShortName: ['string0', 4],
		
		Rate: ['FixedPoint', 'int32', 16],

		Dimensions: jBinary.Template({
			setParams: function (itemType) {
				this.baseType = {
					horz: itemType,
					vert: itemType
				};
			}
		}),

		BoxHeader: {
			_begin: function () {
				return this.binary.tell();
			},
			_size: jBinary.Template({
				baseType: 'uint32',
				write: function (value, context) {
					var size = context.size;
					this.baseWrite(size ? (size < Math.pow(2, 32) ? size : 1) : 0);
				}
			}),
			type: 'ShortName',
			size: jBinary.Type({
				read: function (context) {
					var _size = context._size;
					switch (_size) {
						case 0: return this.binary.view.byteLength - this.binary.tell() + 8;
						case 1: return this.binary.read('uint64');
						default: return _size;
					}
				},
				write: function (value) {
					if (value >= Math.pow(2, 32)) {
						this.binary.write('uint64', value);
					}
				}
			}),
			_end: function (context) {
				return context._begin + context.size;
			}
		},

		FullBox: ['extend', 'BoxHeader', {
			version: 'uint8',
			flags: 24
		}],

		Box: jBinary.Type({
			read: function () {
				var header = this.binary.skip(0, function () {
					return this.read('BoxHeader');
				});
				var box = this.binary.read(header.type) || header;
				if (box === header) console.log(header.type);
				this.binary.seek(header._end);
				return box;
			},
			write: function (box) {
				this.binary.write(box.type, box);
				var size = this.binary.tell() - box._begin;
				this.binary.seek(box._begin, function () {
					this.write('uint32', size);
				});
			}
		}),

		Time: jBinary.Template({
			params: ['baseType'],
			read: function () {
				var intTime = this.baseRead();
				if (intTime) {
					return new Date(intTime + timeBasis);
				}
			},
			write: function (time) {
				this.baseWrite((time - timeBasis) >>> 0);
			}
		}),

		FixedPoint: jBinary.Template({
			params: ['baseType'],
			setParams: function (baseType, shift) {
				this.coef = 1 << shift;
			},
			read: function () {
				return this.baseRead() / this.coef;
			},
			write: function (value) {
				this.baseWrite(value * this.coef);
			}
		}),

		Atoms: jBinary.Type({
			params: ['end'],
			read: function () {
				var atoms = {}, end = this.toValue(this.end) || this.binary.getContext('_end')._end;
				while (this.binary.tell() < end) {
					var item = this.binary.read('Box');
					(atoms[item.type] || (atoms[item.type] = [])).push(item);
				}
				return atoms;
			},
			write: function (parent) {
				for (var type in parent) {
					var atoms = parent[type];
					for (var i = 0, length = atoms.length; i < length; i++) {
						atoms[i].type = type;
						this.binary.write('Box', atoms[i]);
					}
				}
			}
		}),

		ChildAtoms: {
			atoms: 'Atoms'
		},

		MultiBox: ['extend', 'BoxHeader', 'ChildAtoms'],

		TransformationMatrix: {
			a: ['FixedPoint', 'uint32', 16],
			b: ['FixedPoint', 'uint32', 16],
			u: ['FixedPoint', 'uint32', 30],
			c: ['FixedPoint', 'uint32', 16],
			d: ['FixedPoint', 'uint32', 16],
			v: ['FixedPoint', 'uint32', 30],
			x: ['FixedPoint', 'uint32', 16],
			y: ['FixedPoint', 'uint32', 16],
			w: ['FixedPoint', 'uint32', 30]
		},

		Volume: ['FixedPoint', 'uint16', 8],

		FBVersionable: jBinary.Template({
			setParams: function (type0, type1) {
				this.baseType = ['if', 'version', type1, type0];
			}
		}),

		FBUint: ['FBVersionable', 'uint32', 'uint64'],

		FBTime: ['Time', 'FBUint'],

		TimestampBox: ['extend', 'FullBox', {
			creation_time: 'FBTime',
			modification_time: 'FBTime'
		}],

		DurationBox: ['extend', 'TimestampBox', {
			timescale: 'uint32',
			duration: 'FBUint'
		}],

		ftyp: ['extend', 'BoxHeader', {
			major_brand: 'ShortName',
			minor_version: 'uint32',
			compatible_brands: ['array', 'ShortName', function () { return (this.binary.getContext(1)._end - this.binary.tell()) / 4 }]
		}],

		free: 'BoxHeader',

		RawData: {
			_rawData: ['blob', function () { return this.binary.getContext('_end')._end - this.binary.tell() }]
		},

		mdat: ['extend', 'BoxHeader', 'RawData'],

		ParamSets: jBinary.Template({
			setParams: function (numType) {
				this.baseType = ['DynamicArray', numType, jBinary.Template({
					baseType: {
						length: 'uint16',
						paramSet: ['blob', 'length']
					},
					read: function () {
						return this.baseRead().paramSet;
					},
					write: function (paramSet) {
						this.baseWrite({
							length: paramSet.length,
							paramSet: paramSet
						});
					}
				})];
			}
		}),

		avcC: ['extend', 'BoxHeader', {
			version: ['const', 'uint8', 1],
			profileIndication: 'uint8',
			profileCompatibility: 'uint8',
			levelIndication: 'uint8',
			_reserved: ['const', 6, -1],
			lengthSizeMinusOne: 2,
			_reserved2: ['const', 3, -1],
			seqParamSets: ['ParamSets', 5],
			pictParamSets: ['ParamSets', 'uint8']
		}],

		moov: 'MultiBox',

		mvhd: ['extend', 'DurationBox', {
			rate: 'Rate',
			volume: 'Volume',
			_reserved: ['skip', 10],
			matrix: 'TransformationMatrix',
			_reserved2: ['skip', 24],
			next_track_ID: 'uint32'
		}],

		trak: 'MultiBox',

		tkhd: ['extend', 'TimestampBox', {
			track_ID: 'uint32',
			_reserved: ['skip', 4],
			duration: 'FBUint',
			_reserved2: ['skip', 8],
			layer: 'int16',
			alternate_group: 'uint16',
			volume: 'Volume',
			_reserved3: ['skip', 2],
			matrix: 'TransformationMatrix',
			dimensions: ['Dimensions', 'Rate']
		}],

		tref: 'MultiBox',

		TrackReferenceTypeBox: ['extend', 'BoxHeader', {
			track_IDs: ['array', 'uint32', function () { return (this.binary.getContext(1)._end - this.binary.tell()) / 4 }]
		}],

		hint: 'TrackReferenceTypeBox',

		cdsc: 'TrackReferenceTypeBox',

		hind: 'TrackReferenceTypeBox',

		mdia: 'MultiBox',

		mdhd: ['extend', 'DurationBox', {
			_padding: 1,
			lang: jBinary.Type({
				read: function () {
					return String.fromCharCode.apply(
						String,
						this.binary.read(['array', 5, 3]).map(function (code) { return code + 0x60 })
					);
				},
				write: function (value) {
					for (var i = 0; i < 3; i++) {
						this.binary.write(5, value.charCodeAt(i) - 0x60);
					}
				}
			}),
			_reserved: ['skip', 2]
		}],

		hdlr: ['extend', 'FullBox', {
			_reserved: ['skip', 4],
			handler_type: 'ShortName',
			_set_handler_type: function (context) {
				this.binary.getContext(atomFilter('trak'))._handler_type = context.handler_type;
			},
			_reserved2: ['skip', 12],
			name: 'string0'
		}],

		minf: 'MultiBox',

		vmhd: ['extend', 'FullBox', {
			graphicsmode: 'uint16',
			opcolor: {
				r: 'uint16',
				g: 'uint16',
				b: 'uint16'
			}
		}],

		smhd: ['extend', 'FullBox', {
			balance: ['FixedPoint', 'int16', 8],
			_reserved: ['skip', 2]
		}],

		hmhd: ['extend', 'FullBox', {
			maxPDUsize: 'uint16',
			avgPDUsize: 'uint16',
			maxbitrate: 'uint32',
			avgbitrate: 'uint32',
			_reserved: ['skip', 4]
		}],

		stbl: 'MultiBox',

		SampleEntry: ['extend', 'BoxHeader', {
			_reserved: ['skip', 6],
			data_reference_index: 'uint16'
		}],

		btrt: ['extend', 'BoxHeader', {
			bufferSizeDB: 'uint32',
			maxBitrate: 'uint32',
			avgBitrate: 'uint32'
		}],

		metx: ['extend', 'SampleEntry', {
			content_encoding: 'string0',
			namespace: 'string0',
			schema_location: 'string0',
			bitratebox: 'btrt'
		}],

		mett: ['extend', 'SampleEntry', {
			content_encoding: 'string0',
			mime_format: 'string0',
			bitratebox: 'btrt'
		}],

		pasp: ['extend', 'BoxHeader', {
			spacing: ['Dimensions', 'uint32']
		}],

		ClapInnerFormat: ['Dimensions', {
			N: 'uint32',
			D: 'uint32'
		}],

		clap: ['extend', 'BoxHeader', {
			cleanAperture: 'ClapInnerFormat',
			off: 'ClapInnerFormat'
		}],

		VisualSampleEntry: ['extend', 'SampleEntry', {
			_reserved: ['skip', 16],
			dimensions: ['Dimensions', 'uint16'],
			resolution: ['Dimensions', 'Rate'],
			_reserved2: ['skip', 4],
			frame_count: ['const', 'uint16', 1],
			compressorname: jBinary.Template({
				baseType: {
					length: 'uint8',
					string: ['string', 'length'],
					_skip: ['skip', function (context) { return 32 - 1 - context.length }]
				},
				read: function () {
					return this.baseRead().string;
				},
				write: function (value) {
					this.baseWrite({
						length: value.length,
						string: value
					});
				}
			}),
			depth: 'uint16',
			_reserved3: ['const', 'int16', -1]
		}, jBinary.Type({
			setParams: function () {
				this.optional = {
					cleanaperture: 'clap',
					pixelaspectratio: 'pasp'
				};
			},
			read: function () {
				var extension = {};

				for (var propName in this.optional) {
					var type = this.optional[propName];
					var atom = this.binary.skip(0, function () { return this.read('BoxHeader') });
					if (atom.type === type) {
						extension[propName] = this.binary.read(type);
					}
				}

				return extension;
			},
			write: function (box) {
				for (var propName in this.optional) {
					var value = box[propName];
					if (value) {
						this.binary.write(this.optional[propName], value);
					}
				}
			}
		}), 'ChildAtoms'],

		AudioSampleEntry: ['extend', 'SampleEntry', {
			_reserved: ['skip', 8],
			channelcount: 'uint16',
			samplesize: 'uint16',
			_reserved2: ['skip', 4],
			samplerate: 'Rate'
		}, 'ChildAtoms'],

		DynamicArray: jBinary.Template({
			setParams: function (lengthType, itemType) {
				this.baseType = {
					length: lengthType,
					array: ['array', itemType, 'length']
				};
			},
			read: function () {
				return this.baseRead().array;
			},
			write: function (array) {
				this.baseWrite({
					length: array.length,
					array: array
				});
			}
		}),

		ArrayBox: jBinary.Template({
			setParams: function (entryType) {
				this.baseType = ['extend', 'FullBox', {
					entries: ['DynamicArray', 'uint32', entryType]
				}];
			}
		}),

		stsd: ['ArrayBox', jBinary.Template({
			getBaseType: function () {
				return {soun: 'AudioSampleEntry', vide: 'VisualSampleEntry', meta: 'Box'}[this.binary.getContext(atomFilter('trak'))._handler_type] || 'SampleEntry';
			},
			write: function (value) {
				var pos = this.binary.tell();
				this.baseWrite(value);
				var size = this.binary.tell() - pos;
				this.binary.seek(pos, function () { this.write('uint32', size) });
			}
		})],

		stdp: ['extend', 'FullBox', {
			priorities: ['array', 'uint16', function () { return this.binary.getContext(atomFilter('stbl'))._sample_count }]
		}],

		stsl: ['extend', 'FullBox', {
			_reserved: 7,
			constraint_flag: 'bool',
			scale_method: ['enum', 'uint8', [false, 'fill', 'hidden', 'meet', 'slice-x', 'slice-y']],
			display_center: ['Dimensions', 'int16']
		}],

		stts: ['ArrayBox', {
			sample_count: 'uint32',
			sample_delta: 'uint32'
		}],

		ctts: ['ArrayBox', {
			sample_count: 'uint32',
			sample_offset: 'uint32'
		}],

		stss: ['ArrayBox', 'uint32'],

		stsh: ['ArrayBox', {
			shadowed_sample_number: 'uint32',
			sync_sample_number: 'uint32'
		}],

		ExtendedBoolean: ['enum', 2, [undefined, true, false]],

		sdtp: ['extend', 'FullBox', {
			dependencies: ['array', {
				_reserved: 2,
				sample_depends_on: 'ExtendedBoolean',
				sample_is_depended_on: 'ExtendedBoolean',
				sample_has_redundancy: 'ExtendedBoolean'
			}, function () { return this.binary.getContext(atomFilter('stbl'))._sample_count }]
		}],

		edts: 'MultiBox',

		elst: ['ArrayBox', {
			segment_duration: 'FBUint',
			media_time: ['FBVersionable', 'int32', 'int64'],
			media_rate: 'Rate'
		}],

		dinf: 'MultiBox',

		'url ': ['extend', 'FullBox', {
			location: 'string0'
		}],

		'urn ': ['extend', 'FullBox', {
			name: 'string0',
			location: 'string0'
		}],

		dref: ['ArrayBox', 'Box'],

		stsz: ['extend', 'FullBox', {
			sample_size: 'uint32',
			sample_count: 'uint32',
			_sample_count_to_stbl: function (context) {
				this.binary.getContext(atomFilter('stbl'))._sample_count = context.sample_count;
			},
			sample_sizes: ['if_not', 'sample_size',
				['array', 'uint32', 'sample_count']
			]
		}],

		stz2: ['extend', 'FullBox', {
			_reserved: ['skip', 3],
			field_size: 'uint8',
			sample_count: 'uint32',
			_sample_count_to_stbl: function (context) {
				this.binary.getContext(atomFilter('stbl'))._sample_count = context.sample_count;
			},
			sample_sizes: [
				'array',
				jBinary.Template({
					getBaseType: function (context) { return context.field_size }
				}),
				'sample_count'
			]
		}],

		stsc: ['ArrayBox', {
			first_chunk: 'uint32',
			samples_per_chunk: 'uint32',
			sample_description_index: 'uint32'
		}],

		stco: ['ArrayBox', 'uint32'],

		co64: ['ArrayBox', 'uint64'],

		padb: ['extend', 'FullBox', {
			pads: ['DynamicArray', 'uint32', jBinary.Template({
				baseType: {
					_skip: ['const', 1, 0],
					pad: 3
				},
				read: function () {
					return this.baseRead().pad;
				},
				write: function (pad) {
					this.baseWrite({pad: pad});
				}
			})]
		}],

		subs: ['ArrayBox', {
			sample_delta: 'uint32',
			subsamples: ['DynamicArray', 'uint16', {
				subsample_size: ['FBVersionable', 'uint16', 'uint32'],
				subsample_priority: 'uint8',
				discardable: 'uint8',
				_reserved: ['skip', 4]
			}]
		}],

		mvex: 'MultiBox',

		mehd: ['extend', 'FullBox', {
			fragment_duration: 'FBUint'
		}],

		esds_section: ['extend', {
			descriptor_type: 'uint8',
			ext_type: jBinary.Type({
				read: function () {
					var next_byte = this.binary.read('uint8');
					if (next_byte === 0x80 || next_byte === 0x81 || next_byte === 0xFE) {
						this.binary.skip(2);
						return next_byte;
					} else {
						this.binary.skip(-1);
					}
				},
				write: function (filler) {
					if (filler !== undefined) this.binary.write('blob', [filler, filler, filler]);
				}
			}),
			length: 'uint8'
		}, jBinary.Template({
			getBaseType: function (context) {
				switch (context.descriptor_type) {
					case 3: return {
						es_id: 'uint16',
						stream_priority: 'uint8'
					};

					case 4: return {
						type: ['enum', 'uint8', {
							1: 'v1',
							2: 'v2',
							32: 'mpeg4_video',
							33: 'mpeg4_avc_sps',
							34: 'mpeg4_avc_pps',
							64: 'mpeg4_audio',
							96: 'mpeg2_simple_video',
							97: 'mpeg2_main_video',
							98: 'mpeg2_snr_video',
							99: 'mpeg2_spatial_video',
							100: 'mpeg2_high_video',
							101: 'mpeg2_422_video',
							102: 'mpeg4_adts_main',
							103: 'mpeg4_adts_low_complexity',
							104: 'mpeg4_adts_scaleable_sampling',
							105: 'mpeg2_adts_main',
							106: 'mpeg1_video',
							107: 'mpeg1_adts',
							108: 'jpeg_video',
							192: 'private_audio',
							208: 'private_video',
							224: 'pcm_little_endian_audio',
							225: 'vorbis_audio',
							226: 'dolby_v3_audio',
							227: 'alaw_audio',
							228: 'mulaw_audio',
							229: 'adpcm_audio',
							230: 'pcm_big_endian_audio',
							240: 'yv12_video',
							241: 'h264_video',
							242: 'h263_video',
							243: 'h261_video'
						}],
						stream_type: ['enum', 6, [
							null,
							'object',
							'clock',
							'scene',
							'visual',
							'audio',
							'mpeg-7',
							'ipmp',
							'oci',
							'mpeg-java'
						]],
						upstream_flag: 1,
						_reserved: ['const', 1, 1],
						buffer_size: 24,
						maxBitrate: 'uint32',
						avgBitrate: 'uint32'
					};

					case 5: return {
						audio_profile: ['enum', 5, [
							null,
							'aac-main',
							'aac-lc',
							'aac-ssr',
							'aac-ltp',
							'sbr',
							'aac-scalable',
							'twinvq',
							'celp',
							'hxvc',
							null,
							null,
							'ttsi',
							'main-synthesis',
							'wavetable-synthesis',
							'general-midi',
							'algorithmic-synthesis-and-audio-effects',
							'er-aac-lc',
							'reserved',
							'er-aac-ltp',
							'er-aac-scalable',
							'er-twinvq',
							'er-bsac',
							'er-aac-ld',
							'er-celp',
							'er-hvxc',
							'er-hiln',
							'er-parametric',
							'ssc',
							'ps',
							'mpeg-surround'
						]],
						sampling_freq: jBinary.Type({
							setParams: function () {
								this.freqList = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
							},
							read: function () {
								var freqIndex = this.binary.read(4);
								return freqIndex !== 15 ? this.freqList[freqIndex] : this.binary.read(24);
							},
							write: function (value) {
								var freqIndex = this.freqList.indexOf(value);
								if (freqIndex !== -1) {
									this.binary.write(4, freqIndex);
								} else {
									this.binary.write(4, 15);
									this.binary.write(24, value);
								}
							}
						}),
						channelConfig: 4,
						frameLength: ['enum', 1, [1024, 960]],
						dependsOnCoreCoder: 1,
						extensionFlag: 1
					};

					case 6: return {
						sl: ['const', 'uint8', 2]
					};
				}
			}
		})],

		esds: ['extend', 'FullBox', {
			sections: jBinary.Template({
				baseType: 'esds_section',
				read: function () {
					var end = this.binary.getContext('_end')._end, sections = [];
					while (this.binary.tell() < end) {
						sections.push(this.baseRead());
					}
					return sections;
				},
				write: function (sections) {
					for (var i = 0, length = sections.length; i < length; i++) {
						this.baseWrite(sections[i]);
					}
				}
			})
		}],

		File: ['Atoms', function () { return this.binary.view.byteLength }]
	};
}));


/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/mpegts.js":
/*!************************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/mpegts.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jBinary) {
	'use strict';

	return {
		PCR: {
			pts: 33,
			_reserved: 6,
			extension: 9
		},

		DynamicArray: jBinary.Template({
			setParams: function (lengthType, itemType) {
				this.baseType = {
					length: lengthType,
					array: ['array', itemType, 'length']
				};
			},
			read: function () {
				return this.baseRead().array;
			},
			write: function (array) {
				this.baseWrite({
					length: array.length,
					array: array
				});
			}
		}),

		Field: ['DynamicArray', 'uint8', 'uint8'],

		Flag: jBinary.Template({
			baseType: 1,
			params: ['dependentField'],
			write: function (value, context) {
				this.baseWrite(this.dependentField in context ? 1 : 0);
			}
		}),

		FlagDependent: jBinary.Template({
			params: ['flagField', 'baseType'],
			read: function () {
				return this.binary.read(['if', this.flagField, this.baseType]);
			}
		}),

		AdaptationField: {
			length: 'uint8',
			_endOf: function (context) { return this.binary.tell() + context.length },
			discontinuity: 1,
			randomAccess: 1,
			priority: 1,
			_hasPCR: ['Flag', 'pcr'],
			_hasOPCR: ['Flag', 'opcr'],
			_hasSplicingPoint: ['Flag', 'spliceCountdown'],
			_hasTransportPrivateData: ['Flag', 'privateData'],
			_hasExtension: ['Flag', 'extension'],
			pcr: ['FlagDependent', '_hasPCR', 'PCR'],
			opcr: ['FlagDependent', '_hasOPCR', 'PCR'],
			spliceCountdown: ['FlagDependent', '_hasSplicingPoint', 'uint8'],
			privateData: ['FlagDependent', '_hasTransportPrivateData', 'Field'],
			extension: ['FlagDependent', '_hasExtension', 'Field'],
			_toEnd: function (context) { this.binary.seek(context._endOf) }
		},

		ES: {
			_rawStream: ['blob', function () { return this.binary.getContext(1)._endof - this.binary.tell() }]
		},

		PATItem: ['array', {
			programNumber: 'uint16',
			_reserved: 3,
			pid: 13
		}, function (context) { return context._dataLength / 4 }],

		PMTHeader: {
			_reserved: 3,
			pcrPID: 13,
			_reserved2: 4,
			programDescriptors: ['DynamicArray', 12, 'uint8']
		},

		PMTItem: {
			streamType: 'uint8',
			_reserved: 3,
			elementaryPID: 13,
			_reserved2: 4,
			esInfo: ['DynamicArray', 12, 'uint8']
		},

		PrivateSection: ['extend', {
			pointerField: ['if', 'payloadStart', 'uint8'],
			tableId: ['enum', 'uint8', ['PAT', 'CAT', 'PMT']],
			isLongSection: 1,
			isPrivate: 1,
			_reserved: 2,
			_sectionLength: 12
		}, ['if', 'isLongSection', {
				tableIdExt: 'uint16',
				_reserved: 2,
				versionNumber: 5,
				currentNextIndicator: 1,
				sectionNumber: 'uint8',
				lastSectionNumber: 'uint8',

				_dataLength: function () { return this.binary.getContext(1)._sectionLength - 9 },

				data: jBinary.Type({
					read: function (header) {
						var data, file = this.binary.getContext(3), dataLength = header._dataLength;

						switch (this.binary.getContext(1).tableId) {
							case 'PAT':
								data = this.binary.read('PATItem');

								if (header.sectionNumber == 0) {
									file.pat = {};
								}

								for (var i = 0; i < data.length; i++) {
									file.pat[data[i].pid] = data[i];
								}

								break;

							case 'PMT':
								data = this.binary.read('PMTHeader');

								data.mappings = [];

								dataLength -= 4 + data.programDescriptors.length;

								while (dataLength > 0) {
									var mapping = this.binary.read('PMTItem');
									data.mappings.push(mapping);
									dataLength -= 5 + mapping.esInfo.length;
								}

								if (header.sectionNumber == 0) {
									file.pmt = {};
								}

								for (var i = 0; i < data.mappings.length; i++) {
									var mapping = data.mappings[i];
									file.pmt[mapping.elementaryPID] = mapping;
								}

								break;
						}

						return data;
					}
				}),

				crc32: 'uint32'
			},
			['blob', '_sectionLength']
		]],

		Packet: {
			_startof: function () { return this.binary.tell() },
			_endof: function (context) { return context._startof + 188 },

			_syncByte: ['const', 'uint8', 0x47, true],

			transportError: 1,
			payloadStart: 1,
			transportPriority: 1,
			pid: 13,

			scramblingControl: 2,
			_hasAdaptationField: ['Flag', 'adaptationField'],
			_hasPayload: ['Flag', 'payload'],
			contCounter: 4,

			adaptationField: ['FlagDependent', '_hasAdaptationField', 'AdaptationField'],

			payload: ['FlagDependent', '_hasPayload', jBinary.Template({
				getBaseType: function (context) {
					var pid = context.pid, file = this.binary.getContext(1);
					if (pid < 2 || pid in file.pat) {
						return 'PrivateSection';
					}
					if (pid in file.pmt) {
						return 'ES';
					}
				}
			})],

			_toEnd: function (context) { this.binary.seek(context._endof) }
		},

		File: jBinary.Template({
			baseType: ['array', 'Packet'],
			read: function () {
				this.pat = {};
				this.pmt = {};
				var self = this;
				return this.binary.inContext(this, function () {
					return self.baseRead();
				});
			},
			write: function (packets) {
				var self = this;
				this.binary.inContext(this, function () {
					self.baseWrite(packets);
				});
			}
		})
	};
}));

/***/ }),

/***/ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/pes.js":
/*!*********************************************************!*\
  !*** ./node_modules/mpegts_to_mp4/mpegts_to_mp4/pes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (jBinary) {
	'use strict';

	return {
		Flag: jBinary.Template({
			baseType: 1,
			params: ['dependentField'],
			write: function (value, context) {
				this.baseWrite(this.dependentField in context ? 1 : 0);
			}
		}),

		FlagDependent: jBinary.Template({
			params: ['flagField', 'baseType'],
			read: function () {
				return this.binary.read(['if', this.flagField, this.baseType]);
			}
		}),

		PESTimeStamp: jBinary.Template({
			setParams: function (prefix) {
				var skipBit = ['const', 1, 1, true];
				this.baseType = {
					_prefix: ['const', 4, prefix, true],
					hiPart: 3,
					_skip1: skipBit,
					midPart: 15,
					_skip2: skipBit,
					loPart: 15,
					_skip3: skipBit
				};
			},
			read: function () {
				var parts = this.baseRead();
				return parts.loPart | (parts.midPart << 15) | (parts.hiPart << 30);
			},
			write: function (value) {
				this.baseWrite({
					hiPart: value >>> 30,
					midPart: (value >>> 15) & ~(-1 << 15),
					loPart: value & ~(-1 << 15)
				});
			}
		}),

		PESPacket: ['extend', {
			_startCode0: ['const', 'uint8', 0, true],
			_startCode1: ['const', 'uint8', 0, true],
			_startCode2: ['const', 'uint8', 1, true],
			streamId: 'uint8',
			length: 'uint16',
			_end: function (context) {
				var pos = this.binary.tell(), length = context.length;

				if (length) {
					pos += length;
					if (pos > this.view.byteLength - 4) {
						return pos;
					}
					var bytes = this.binary.read(['blob', 4], pos);
					if (bytes[0] === 0 && bytes[1] === 0 && bytes[2] === 1 && (bytes[3] & 0x80)) {
						return pos;
					}
					pos -= length;
				}

				/*
				not sure if it correctly covers cases where `length`==0
				(according to specification, it may be written as zero for video streams of undefined length)
				but should work for H.264 streams since NAL unit types always have clear highest bit (`forbidden_zero_bit`)
				*/
				var fileEnd = this.view.byteLength, bytes = this.binary.read('blob', pos);
				for (var i = 0; i < bytes.length - 4; i++) {
					if (bytes[i] === 0 && bytes[i + 1] === 0 && bytes[i + 2] === 1 && (bytes[i + 3] & 0x80)) {
						return pos + i;
					}
				}
				return fileEnd;
			}
		}, jBinary.Template({
			baseType: {
				_marker: ['const', 2, 2, true],
				scramblingControl: ['enum', 2, ['not_scrambled']],
				priority: 1,
				dataAlignmentIndicator: 1,
				hasCopyright: 1,
				isOriginal: 1,
				_hasPTS: ['Flag', 'pts'],
				_hasDTS: ['Flag', 'dts'],
				_hasESCR: ['Flag', 'escr'],
				_hasESRate: ['Flag', 'esRate'],
				dsmTrickMode: 1,
				_hasAdditionalCopyInfo: ['Flag', 'additionalCopyInfo'],
				_hasPESCRC: ['Flag', 'pesCRC'],
				_hasExtension: ['Flag', 'extension'],
				dataLength: 'uint8',
				_headerEnd: function (context) { return this.binary.tell() + context.dataLength },
				pts: ['FlagDependent', '_hasPTS', ['if', '_hasDTS', ['PESTimeStamp', 3], ['PESTimeStamp', 2]]],
				dts: ['FlagDependent', '_hasDTS', ['PESTimeStamp', 1]],
				_toHeaderEnd: function (context) { this.binary.seek(context._headerEnd) }
			},
			read: function () {
				var pos = this.binary.tell();
				try {
					return this.baseRead();
				} catch (e) {
					this.binary.seek(pos);
					this.binary.view.alignBy();
				}
			}
		}), {
			data: ['blob', function () { return this.binary.getContext('_end')._end - this.binary.tell() }]
		}]
	};
}));

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/punycode/punycode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/resolve-url/resolve-url.js":
/*!*************************************************!*\
  !*** ./node_modules/resolve-url/resolve-url.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell
// X11 (MIT) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/background/index.js":
/*!*********************************!*\
  !*** ./src/background/index.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/browser */ "./src/common/browser.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_browser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_ZhaoJun_Desktop_violentmonkey_src_common_browser__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/common/tld */ "./src/common/tld.js");
/* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sync */ "./src/background/sync/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ "./src/background/utils/index.js");
/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/db */ "./src/background/utils/db.js");
/* harmony import */ var _utils_init__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/init */ "./src/background/utils/init.js");
/* harmony import */ var _utils_options__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/options */ "./src/background/utils/options.js");
/* harmony import */ var _utils_popup_tracker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/popup-tracker */ "./src/background/utils/popup-tracker.js");
/* harmony import */ var _utils_preinject__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/preinject */ "./src/background/utils/preinject.js");
/* harmony import */ var _utils_template_hook__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/template-hook */ "./src/background/utils/template-hook.js");
/* harmony import */ var _utils_values__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/values */ "./src/background/utils/values.js");
/* harmony import */ var _utils_requests__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/requests */ "./src/background/utils/requests.js");
/* harmony import */ var _utils_clipboard__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/clipboard */ "./src/background/utils/clipboard.js");
/* harmony import */ var _utils_hotkeys__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/hotkeys */ "./src/background/utils/hotkeys.js");
/* harmony import */ var _utils_icon__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/icon */ "./src/background/utils/icon.js");
/* harmony import */ var _utils_notifications__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./utils/notifications */ "./src/background/utils/notifications.js");
/* harmony import */ var _utils_script__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils/script */ "./src/background/utils/script.js");
/* harmony import */ var _utils_tabs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/tabs */ "./src/background/utils/tabs.js");
/* harmony import */ var _utils_tester__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/tester */ "./src/background/utils/tester.js");
/* harmony import */ var _utils_update__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./utils/update */ "./src/background/utils/update.js");























Object(_utils_options__WEBPACK_IMPORTED_MODULE_9__["hookOptions"])(changes => {
  if ('autoUpdate' in changes) {
    autoUpdate();
  }

  if (_utils_template_hook__WEBPACK_IMPORTED_MODULE_12__["SCRIPT_TEMPLATE"] in changes) {
    Object(_utils_template_hook__WEBPACK_IMPORTED_MODULE_12__["resetScriptTemplate"])(changes);
  }

  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])('UpdateOptions', changes);
});
Object.assign(_utils__WEBPACK_IMPORTED_MODULE_6__["commands"], {
  /** @return {Promise<{ scripts: VMScript[], cache: Object, sync: Object }>} */
  async GetData(ids) {
    const data = await Object(_utils_db__WEBPACK_IMPORTED_MODULE_7__["getData"])(ids);
    data.sync = _sync__WEBPACK_IMPORTED_MODULE_5__["getStates"]();
    return data;
  },

  /** @return {Promise<Object>} */
  async GetInjected({
    url,
    forceContent
  }, src) {
    const {
      frameId,
      tab
    } = src;
    const tabId = tab.id;
    if (!url) url = src.url || tab.url;

    if (!frameId) {
      Object(_utils_values__WEBPACK_IMPORTED_MODULE_13__["resetValueOpener"])(tabId);
      Object(_utils_requests__WEBPACK_IMPORTED_MODULE_14__["clearRequestsByTabId"])(tabId);
    }

    const res = await Object(_utils_preinject__WEBPACK_IMPORTED_MODULE_11__["getInjectedScripts"])(url, tabId, frameId, forceContent);
    const {
      feedback,
      inject,
      valOpIds
    } = res;
    inject.isPopupShown = _utils_popup_tracker__WEBPACK_IMPORTED_MODULE_10__["popupTabs"][tabId]; // Injecting known content scripts without waiting for InjectionFeedback message.
    // Running in a separate task because it may take a long time to serialize data.

    if (feedback.length) {
      setTimeout(_utils__WEBPACK_IMPORTED_MODULE_6__["commands"].InjectionFeedback, 0, {
        feedback
      }, src);
    }

    Object(_utils_values__WEBPACK_IMPORTED_MODULE_13__["addValueOpener"])(tabId, frameId, valOpIds);
    return inject;
  },

  /** @return {Promise<Object>} */
  async GetTabDomain() {
    const tab = (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getActiveTab"])()) || {};
    const url = tab.pendingUrl || tab.url || '';
    const host = url.match(/^https?:\/\/([^/]+)|$/)[1];
    return {
      tab,
      domain: host && _Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_4__["getDomain"](host) || host
    };
  },

  /**
   * Timers in content scripts are shared with the web page so it can clear them.
   * await sendCmd('SetTimeout', 100) in injected/content
   * await bridge.send('SetTimeout', 100) in injected/web
   */
  SetTimeout(ms) {
    return ms > 0 && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["makePause"])(ms);
  }

}); // commands to sync unconditionally regardless of the returned value from the handler

const commandsToSync = ['MarkRemoved', 'Move', 'ParseScript', 'RemoveScript', 'UpdateScriptInfo']; // commands to sync only if the handler returns a truthy value

const commandsToSyncIfTruthy = ['CheckRemove', 'CheckUpdate', 'CheckUpdateAll'];

async function handleCommandMessage(req, src) {
  var _commands$cmd;

  const {
    cmd
  } = req;
  const res = await ((_commands$cmd = _utils__WEBPACK_IMPORTED_MODULE_6__["commands"][cmd]) == null ? void 0 : _commands$cmd.call(_utils__WEBPACK_IMPORTED_MODULE_6__["commands"], req.data, src));

  if (commandsToSync.includes(cmd) || res && commandsToSyncIfTruthy.includes(cmd)) {
    _sync__WEBPACK_IMPORTED_MODULE_5__["sync"]();
  } // `undefined` is not transferable, but `null` is


  return res != null ? res : null;
}

function autoUpdate() {
  const interval = _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["IS_DEV"] ? 1000 : (+Object(_utils_options__WEBPACK_IMPORTED_MODULE_9__["getOption"])('autoUpdate') || 0) * _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["TIMEOUT_24HOURS"];
  if (!interval) return;
  let elapsed = Date.now() - Object(_utils_options__WEBPACK_IMPORTED_MODULE_9__["getOption"])('lastUpdate');

  if (elapsed >= interval) {
    handleCommandMessage({
      cmd: 'CheckUpdateAll'
    });
    elapsed = 0;
  }

  clearTimeout(autoUpdate.timer);
  autoUpdate.timer = setTimeout(autoUpdate, Math.min(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["TIMEOUT_MAX"], interval - elapsed));
}

async function initBuildin() {
  const {
    data
  } = await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["request"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["BUILD_IN_SCRIPT_SRC"], {
    cache: 'no-cache',
    headers: {
      Accept: 'text/x-userscript-meta,*/*'
    }
  });
  const res = await _utils__WEBPACK_IMPORTED_MODULE_6__["commands"].ParseScript({
    url: _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["BUILD_IN_SCRIPT_SRC"],
    code: data,
    custom: {
      buildIn: true
    }
  });
  _sync__WEBPACK_IMPORTED_MODULE_5__["sync"]();

  if (res.where.id !== 1) {
    throw `wrong id: ${res.where.id}`;
  }
}

Object(_utils_init__WEBPACK_IMPORTED_MODULE_8__["initialize"])(() => {
  global.handleCommandMessage = handleCommandMessage;
  global.deepCopy = _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["deepCopy"];
  browser.runtime.onMessage.addListener(IS_FIREFOX // in FF a rejected Promise value is transferred only if it's an Error object
  ? (...args) => handleCommandMessage(...args).catch(e => Promise.reject(e instanceof Error ? e : new Error(e))) // Didn't use `throw` to avoid interruption in devtools with pause-on-exception enabled.
  : handleCommandMessage); // check and install the build-in script

  initBuildin();
  console.info('initBuildin...');
  setTimeout(autoUpdate, _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["IS_DEV"] ? 1 : 2e4);
  _sync__WEBPACK_IMPORTED_MODULE_5__["initialize"]();
  Object(_utils_db__WEBPACK_IMPORTED_MODULE_7__["checkRemove"])();
  setInterval(_utils_db__WEBPACK_IMPORTED_MODULE_7__["checkRemove"], _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["TIMEOUT_24HOURS"]);
  const api = global.chrome.declarativeContent;

  if (api) {
    // Using declarativeContent to run content scripts earlier than document_start
    api.onPageChanged.getRules(async ([rule]) => {
      const id = rule == null ? void 0 : rule.id;
      const newId = "Violentmonkey:LRWVgCrw+RY=";

      if (id === newId) {
        return;
      }

      if (id) {
        await browser.declarativeContent.onPageChanged.removeRules([id]);
      }

      api.onPageChanged.addRules([{
        id: newId,
        conditions: [new api.PageStateMatcher({
          pageUrl: {
            urlContains: '://'
          } // essentially like <all_urls>

        })],
        actions: [new api.RequestContentScript({
          js: browser.runtime.getManifest().content_scripts[0].js // Not using `allFrames:true` as there's no improvement in frames

        })]
      }]);
    });
  }
});

/***/ }),

/***/ "./src/background/plugin/events.js":
/*!*****************************************!*\
  !*** ./src/background/plugin/events.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/events */ "./src/common/events.js");

/* harmony default export */ __webpack_exports__["default"] = (new _Users_ZhaoJun_Desktop_violentmonkey_src_common_events__WEBPACK_IMPORTED_MODULE_0__["default"](['scriptEdit', 'scriptChanged']));

/***/ }),

/***/ "./src/background/plugin/index.js":
/*!****************************************!*\
  !*** ./src/background/plugin/index.js ***!
  \****************************************/
/*! exports provided: script */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "script", function() { return script; });
/* harmony import */ var _utils_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/message */ "./src/background/utils/message.js");
/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/db */ "./src/background/utils/db.js");


const script = {
  /**
   * Update an existing script identified by the provided id
   * @param {{ id, code, message, isNew, config, custom, props, update }} data
   * @return {Promise<{ isNew?, update, where }>}
   */
  update: _utils_message__WEBPACK_IMPORTED_MODULE_0__["commands"].ParseScript,

  /**
   * List all available scripts, without script code
   * @return {Promise<VMScript[]>}
   */
  list: async () => Object(_utils_db__WEBPACK_IMPORTED_MODULE_1__["getScripts"])(),

  /**
   * Get script code of an existing script
   * @param {number} id
   * @return {Promise<string>}
   */
  get: _utils_message__WEBPACK_IMPORTED_MODULE_0__["commands"].GetScriptCode,

  /**
   * Remove script
   * @param {number} id
   * @return {Promise<void>}
   */
  remove: id => _utils_message__WEBPACK_IMPORTED_MODULE_0__["commands"].MarkRemoved({
    id,
    removed: true
  })
};

/***/ }),

/***/ "./src/background/sync/base.js":
/*!*************************************!*\
  !*** ./src/background/sync/base.js ***!
  \*************************************/
/*! exports provided: getItemFilename, isScriptFile, getURI, getStates, BaseService, register, initialize, sync, authorize, revoke, setConfig, openAuthPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getItemFilename", function() { return getItemFilename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isScriptFile", function() { return isScriptFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getURI", function() { return getURI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStates", function() { return getStates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseService", function() { return BaseService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "register", function() { return register; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialize", function() { return initialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sync", function() { return sync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "authorize", function() { return authorize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "revoke", function() { return revoke; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConfig", function() { return setConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openAuthPage", function() { return openAuthPage; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./src/background/utils/index.js");
/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/db */ "./src/background/utils/db.js");
/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugin */ "./src/background/plugin/index.js");






const serviceNames = [];
const serviceClasses = [];
const services = {};
const autoSync = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["debounce"])(sync, _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["TIMEOUT_HOUR"]);
let working = Promise.resolve();
let syncConfig;
function getItemFilename({
  name,
  uri
}) {
  // When get or remove, current name should be prefered
  if (name) return name; // otherwise uri derived name should be prefered
  // uri is already encoded by `encodeFilename`

  return `vm@2-${uri}`;
}
function isScriptFile(name) {
  return /^vm(?:@\d+)?-/.test(name);
}
function getURI(name) {
  const i = name.indexOf('-');
  const [, version] = name.slice(0, i).split('@');

  if (version === '2') {
    // uri is encoded by `encodedFilename`, so we should not decode it here
    return name.slice(i + 1);
  }

  try {
    return decodeURIComponent(name.slice(3));
  } catch (err) {
    return name.slice(3);
  }
}

function initConfig() {
  function get(key, def) {
    const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
    keys.unshift('sync');
    return Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getOption"])(keys, def);
  }

  function set(key, value) {
    const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
    keys.unshift('sync');
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["setOption"])(keys, value);
  }

  function init() {
    let config = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getOption"])('sync');

    if (!config || !config.services) {
      config = {
        services: {}
      };
      set([], config);
    }
  }

  init();
  return {
    get,
    set
  };
}

function serviceConfig(name) {
  function getKeys(key) {
    const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
    keys.unshift('services', name);
    return keys;
  }

  function get(key, def) {
    return syncConfig.get(getKeys(key), def);
  }

  function set(key, val) {
    if (typeof key === 'object') {
      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], key, ([k, v]) => {
        syncConfig.set(getKeys(k), v);
      });
    } else {
      syncConfig.set(getKeys(key), val);
    }
  }

  function clear() {
    syncConfig.set(getKeys(), {});
  }

  return {
    get,
    set,
    clear
  };
}

function serviceState(validStates, initialState, onChange) {
  let state = initialState || validStates[0];

  function get() {
    return state;
  }

  function set(newState) {
    if (validStates.includes(newState)) {
      state = newState;
      if (onChange) onChange();
    } else {
      console.warn('Invalid state:', newState);
    }

    return get();
  }

  function is(states) {
    return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["ensureArray"])(states).includes(state);
  }

  return {
    get,
    set,
    is
  };
}

function getStates() {
  return serviceNames.map(name => {
    const service = services[name];
    return {
      name: service.name,
      displayName: service.displayName,
      authState: service.authState.get(),
      syncState: service.syncState.get(),
      lastSync: service.config.get('meta', {}).lastSync,
      progress: service.progress,
      properties: service.properties,
      userConfig: service.getUserConfig()
    };
  });
}

function getScriptData(script, syncVersion, extra) {
  let data;

  if (syncVersion === 2) {
    data = {
      version: syncVersion,
      custom: script.custom,
      config: script.config,
      props: Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectPick"])(script.props, ['lastUpdated'])
    };
  } else if (syncVersion === 1) {
    data = {
      version: syncVersion,
      more: {
        custom: script.custom,
        enabled: script.config.enabled,
        update: script.config.shouldUpdate,
        lastUpdated: script.props.lastUpdated
      }
    };
  }

  return Object.assign(data, extra);
}

function parseScriptData(raw) {
  const data = {};

  try {
    const obj = JSON.parse(raw);
    data.code = obj.code;

    if (obj.version === 2) {
      data.config = obj.config;
      data.custom = obj.custom;
      data.props = obj.props;
    } else if (obj.version === 1) {
      if (obj.more) {
        data.custom = obj.more.custom;
        data.config = objectPurify({
          enabled: obj.more.enabled,
          shouldUpdate: obj.more.update
        });
        data.props = objectPurify({
          lastUpdated: obj.more.lastUpdated
        });
      }
    }
  } catch (e) {
    data.code = raw;
  }

  return data;
}

function objectPurify(obj) {
  // Remove keys with undefined values
  if (Array.isArray(obj)) {
    obj.forEach(objectPurify);
  } else if (obj && typeof obj === 'object') {
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], obj, ([key, value]) => {
      if (typeof value === 'undefined') delete obj[key];else objectPurify(value);
    });
  }

  return obj;
}

function serviceFactory(base) {
  const Service = function constructor() {
    this.initialize();
  };

  Service.prototype = base;
  Service.extend = extendService;
  return Service;
}

function extendService(options) {
  return serviceFactory(Object.assign(Object.create(this.prototype), options));
}

const onStateChange = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["debounce"])(() => {
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendCmd"])('UpdateSync', getStates());
});
const BaseService = serviceFactory({
  name: 'base',
  displayName: 'BaseService',
  delayTime: 1000,
  urlPrefix: '',
  metaFile: 'Violentmonkey',
  properties: {
    authType: 'oauth'
  },
  getUserConfig: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],
  setUserConfig: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],

  initialize() {
    this.progress = {
      finished: 0,
      total: 0
    };
    this.config = serviceConfig(this.name);
    this.authState = serviceState(['idle', 'no-auth', 'initializing', 'authorizing', // in case some services require asynchronous requests to get access_tokens
    'authorized', 'unauthorized', 'error'], null, onStateChange);
    this.syncState = serviceState(['idle', 'ready', 'syncing', 'error'], null, onStateChange);
    this.lastFetch = Promise.resolve();
    this.startSync = this.syncFactory();
    const events = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getEventEmitter"])();
    ['on', 'off', 'fire'].forEach(key => {
      this[key] = (...args) => {
        events[key](...args);
      };
    });
  },

  log(...args) {
    console.log(...args); // eslint-disable-line no-console
  },

  syncFactory() {
    let promise;
    let debouncedResolve;

    const shouldSync = () => this.authState.is('authorized') && getCurrent() === this.name;

    const getReady = () => {
      if (!shouldSync()) return Promise.resolve();
      this.log('Ready to sync:', this.displayName);
      this.syncState.set('ready');
      working = working.then(() => new Promise(resolve => {
        debouncedResolve = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["debounce"])(resolve, 10 * 1000);
        debouncedResolve();
      })).then(() => {
        if (shouldSync()) return this.sync();
        this.syncState.set('idle');
      }).catch(err => {
        console.error(err);
      }).then(() => {
        promise = null;
        debouncedResolve = null;
      });
      promise = working;
    };

    function startSync() {
      if (!promise) getReady();
      if (debouncedResolve) debouncedResolve();
      return promise;
    }

    return startSync;
  },

  prepareHeaders() {
    this.headers = {};
  },

  prepare() {
    this.authState.set('initializing');
    return (this.initToken() ? Promise.resolve(this.user()) : Promise.reject({
      type: 'no-auth'
    })).then(() => {
      this.authState.set('authorized');
    }, err => {
      if (['no-auth', 'unauthorized'].includes(err == null ? void 0 : err.type)) {
        this.authState.set(err.type);
      } else {
        console.error(err);
        this.authState.set('error');
      }

      this.syncState.set('idle');
      throw err;
    });
  },

  checkSync() {
    return this.prepare().then(() => this.startSync());
  },

  user: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],
  acquireLock: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],
  releaseLock: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],

  handleMetaError(err) {
    throw err;
  },

  getMeta() {
    return this.get({
      name: this.metaFile
    }).then(data => JSON.parse(data)).catch(err => this.handleMetaError(err)).then(data => ({
      name: this.metaFile,
      data
    }));
  },

  initToken() {
    this.prepareHeaders();
    const token = this.config.get('token');
    this.headers.Authorization = token ? `Bearer ${token}` : null;
    return !!token;
  },

  loadData(options) {
    const {
      progress
    } = this;
    const {
      delay = this.delayTime
    } = options;
    let lastFetch = Promise.resolve();

    if (delay) {
      lastFetch = this.lastFetch.then(ts => Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["makePause"])(delay - (Date.now() - ts))).then(() => Date.now());
      this.lastFetch = lastFetch;
    }

    progress.total += 1;
    onStateChange();
    return lastFetch.then(() => {
      var _options$prefix;

      options = Object.assign({}, options);
      options.headers = Object.assign({}, this.headers, options.headers);
      let {
        url
      } = options;
      if (url.startsWith('/')) url = ((_options$prefix = options.prefix) != null ? _options$prefix : this.urlPrefix) + url;
      return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["request"])(url, options);
    }).then(({
      data
    }) => ({
      data
    }), error => ({
      error
    })).then(({
      data,
      error
    }) => {
      progress.finished += 1;
      onStateChange();
      if (error) return Promise.reject(error);
      return data;
    });
  },

  getLocalData() {
    return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].list();
  },

  getSyncData() {
    return this.getMeta().then(remoteMeta => Promise.all([remoteMeta, this.list(), this.getLocalData()]));
  },

  sync() {
    this.progress = {
      finished: 0,
      total: 0
    };
    this.syncState.set('syncing'); // Avoid simultaneous requests

    return this.prepare().then(() => this.getSyncData()).then(data => Promise.resolve(this.acquireLock()).then(() => data)).then(([remoteMeta, remoteData, localData]) => {
      const remoteMetaData = remoteMeta.data || {};
      const remoteMetaInfo = remoteMetaData.info || {};
      const remoteTimestamp = remoteMetaData.timestamp || 0;
      let remoteChanged = !remoteTimestamp || Object.keys(remoteMetaInfo).length !== remoteData.length;
      const now = Date.now();
      const globalLastModified = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getOption"])('lastModified');
      const remoteItemMap = {};
      const localMeta = this.config.get('meta', {});
      const firstSync = !localMeta.timestamp;
      const outdated = firstSync || remoteTimestamp > localMeta.timestamp;
      this.log('First sync:', firstSync);
      this.log('Outdated:', outdated, '(', 'local:', localMeta.timestamp, 'remote:', remoteTimestamp, ')');
      const putLocal = [];
      const putRemote = [];
      const delRemote = [];
      const delLocal = [];
      const updateLocal = [];
      remoteMetaData.info = remoteData.reduce((info, item) => {
        remoteItemMap[item.uri] = item;
        let itemInfo = remoteMetaInfo[item.uri];

        if (!itemInfo) {
          itemInfo = {};
          remoteChanged = true;
        }

        info[item.uri] = itemInfo;

        if (!itemInfo.modified) {
          itemInfo.modified = now;
          remoteChanged = true;
        }

        return info;
      }, {});
      localData.forEach(item => {
        const {
          props: {
            uri,
            position,
            lastModified
          }
        } = item;
        const remoteInfo = remoteMetaData.info[uri];
        const remoteItem = remoteItemMap[uri];

        if (remoteInfo && remoteItem) {
          if (firstSync || !lastModified || remoteInfo.modified > lastModified) {
            putLocal.push({
              local: item,
              remote: remoteItem,
              info: remoteInfo
            });
          } else {
            if (remoteInfo.modified < lastModified) {
              putRemote.push({
                local: item,
                remote: remoteItem
              });
              remoteInfo.modified = lastModified;
              remoteChanged = true;
            }

            if (remoteInfo.position !== position) {
              if (remoteInfo.position && globalLastModified <= remoteTimestamp) {
                updateLocal.push({
                  local: item,
                  remote: remoteItem,
                  info: remoteInfo
                });
              } else {
                remoteInfo.position = position;
                remoteChanged = true;
              }
            }
          }

          delete remoteItemMap[uri];
        } else if (firstSync || !outdated || lastModified > remoteTimestamp) {
          putRemote.push({
            local: item
          });
        } else {
          delLocal.push({
            local: item
          });
        }
      });
      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], remoteItemMap, ([uri, item]) => {
        const info = remoteMetaData.info[uri];

        if (outdated) {
          putLocal.push({
            remote: item,
            info
          });
        } else {
          delRemote.push({
            remote: item
          });
        }
      });
      const promiseQueue = [...putLocal.map(({
        remote,
        info
      }) => {
        this.log('Download script:', remote.uri);
        return this.get(remote).then(raw => {
          const data = parseScriptData(raw); // Invalid data

          if (!data.code) return;
          if (info.modified) Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectSet"])(data, 'props.lastModified', info.modified);
          const position = +info.position;
          if (position) data.position = position;

          if (!Object(_utils__WEBPACK_IMPORTED_MODULE_3__["getOption"])('syncScriptStatus') && data.config) {
            delete data.config.enabled;
          }

          return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].update(data);
        });
      }), ...putRemote.map(({
        local,
        remote
      }) => {
        this.log('Upload script:', local.props.uri);
        return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].get(local.props.id).then(code => {
          // XXX use version 1 to be compatible with Violentmonkey on other platforms
          const data = getScriptData(local, 1, {
            code
          });
          remoteMetaData.info[local.props.uri] = {
            modified: local.props.lastModified,
            position: local.props.position
          };
          remoteChanged = true;
          return this.put(Object.assign({}, remote, {
            uri: local.props.uri,
            name: null // prefer using uri on PUT

          }), JSON.stringify(data));
        });
      }), ...delRemote.map(({
        remote
      }) => {
        this.log('Remove remote script:', remote.uri);
        delete remoteMetaData.info[remote.uri];
        remoteChanged = true;
        return this.remove(remote);
      }), ...delLocal.map(({
        local
      }) => {
        this.log('Remove local script:', local.props.uri);
        return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].remove(local.props.id);
      }), ...updateLocal.map(({
        local,
        info
      }) => {
        const updates = {};

        if (info.position) {
          updates.props = {
            position: info.position
          };
        }

        return Object(_utils_db__WEBPACK_IMPORTED_MODULE_4__["updateScriptInfo"])(local.props.id, updates);
      })];
      promiseQueue.push(Promise.all(promiseQueue).then(() => Object(_utils_db__WEBPACK_IMPORTED_MODULE_4__["sortScripts"])()).then(changed => {
        if (!changed) return;
        remoteChanged = true;
        return _plugin__WEBPACK_IMPORTED_MODULE_5__["script"].list().then(scripts => {
          scripts.forEach(script => {
            const remoteInfo = remoteMetaData.info[script.props.uri];
            if (remoteInfo) remoteInfo.position = script.props.position;
          });
        });
      }));
      promiseQueue.push(Promise.all(promiseQueue).then(() => {
        const promises = [];

        if (remoteChanged) {
          remoteMetaData.timestamp = Date.now();
          promises.push(this.put(remoteMeta, JSON.stringify(remoteMetaData)));
        }

        localMeta.timestamp = remoteMetaData.timestamp;
        localMeta.lastSync = Date.now();
        this.config.set('meta', localMeta);
        return Promise.all(promises);
      })); // ignore errors to ensure all promises are fulfilled

      return Promise.all(promiseQueue.map(promise => promise.then(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"], err => err || true))).then(errors => errors.filter(Boolean)).then(errors => {
        if (errors.length) throw errors;
      });
    }).then(() => {
      this.syncState.set('idle');
      this.log('Sync finished:', this.displayName);
    }, err => {
      this.syncState.set('error');
      this.log('Failed syncing:', this.displayName);
      this.log(err);
    }).then(() => Promise.resolve(this.releaseLock()).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]));
  }

});
function register(Factory) {
  serviceClasses.push(Factory);
}

function getCurrent() {
  return syncConfig.get('current');
}

function getService(name) {
  return services[name || getCurrent()];
}

function initialize() {
  if (!syncConfig) {
    syncConfig = initConfig();
    serviceClasses.forEach(Factory => {
      const service = new Factory();
      const {
        name
      } = service;
      serviceNames.push(name);
      services[name] = service;
    });
  }

  sync();
}

function syncOne(service) {
  if (service.syncState.is(['ready', 'syncing'])) return;
  if (service.authState.is(['idle', 'error'])) return service.checkSync();
  if (service.authState.is('authorized')) return service.startSync();
}

function sync() {
  const service = getService();
  return service && Promise.resolve(syncOne(service)).then(autoSync);
}
function authorize() {
  const service = getService();
  if (service) service.authorize();
}
function revoke() {
  const service = getService();
  if (service) service.revoke();
}
function setConfig(config) {
  const service = getService();

  if (service) {
    service.setUserConfig(config);
    return service.checkSync();
  }
}
async function openAuthPage(url, redirectUri) {
  unregisterWebRequest(); // otherwise our new tabId will be ignored

  browser.webRequest.onBeforeRequest.addListener(onBeforeRequest, {
    urls: [`${redirectUri}*`],
    types: ['main_frame'],
    tabId: (await browser.tabs.create({
      url
    })).id
  }, ['blocking']);
}
/**
 * @param {chrome.webRequest.WebResponseDetails} info
 * @returns {chrome.webRequest.BlockingResponse}
 */

function onBeforeRequest(info) {
  var _getService$checkAuth, _getService;

  if ((_getService$checkAuth = (_getService = getService()).checkAuth) == null ? void 0 : _getService$checkAuth.call(_getService, info.url)) {
    browser.tabs.remove(info.tabId); // If we unregister without setTimeout, API will ignore { cancel: true }

    setTimeout(unregisterWebRequest, 0);
    return {
      cancel: true
    };
  }
}

function unregisterWebRequest() {
  browser.webRequest.onBeforeRequest.removeListener(onBeforeRequest);
}

Object(_utils__WEBPACK_IMPORTED_MODULE_3__["hookOptions"])(data => {
  const value = data == null ? void 0 : data['sync.current'];
  if (value) initialize();
});

/***/ }),

/***/ "./src/background/sync/dropbox.js":
/*!****************************************!*\
  !*** ./src/background/sync/dropbox.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/background/utils/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");


const config = {
  client_id: 'f0q12zup2uys5w8',
  redirect_uri: 'https://violentmonkey.github.io/auth_dropbox.html'
};
const escRE = /[\u007f-\uffff]/g; // eslint-disable-line no-control-regex

const escFunc = m => `\\u${(m.charCodeAt(0) + 0x10000).toString(16).slice(1)}`;

function jsonStringifySafe(obj) {
  const string = JSON.stringify(obj);
  return string.replace(escRE, escFunc);
}

const Dropbox = _base__WEBPACK_IMPORTED_MODULE_1__["BaseService"].extend({
  name: 'dropbox',
  displayName: 'Dropbox',

  user() {
    return this.loadData({
      method: 'POST',
      url: 'https://api.dropboxapi.com/2/users/get_current_account'
    }).catch(err => {
      if (err.status === 401) {
        return Promise.reject({
          type: 'unauthorized'
        });
      }

      return Promise.reject({
        type: 'error',
        data: err
      });
    });
  },

  handleMetaError(res) {
    if (res.status !== 409) throw res;
  },

  list() {
    return this.loadData({
      method: 'POST',
      url: 'https://api.dropboxapi.com/2/files/list_folder',
      body: {
        path: ''
      },
      responseType: 'json'
    }).then(data => data.entries.filter(item => item['.tag'] === 'file' && Object(_base__WEBPACK_IMPORTED_MODULE_1__["isScriptFile"])(item.name)).map(normalize));
  },

  get(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    return this.loadData({
      method: 'POST',
      url: 'https://content.dropboxapi.com/2/files/download',
      headers: {
        'Dropbox-API-Arg': jsonStringifySafe({
          path: `/${name}`
        })
      }
    });
  },

  put(item, data) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    return this.loadData({
      method: 'POST',
      url: 'https://content.dropboxapi.com/2/files/upload',
      headers: {
        'Dropbox-API-Arg': jsonStringifySafe({
          path: `/${name}`,
          mode: 'overwrite'
        }),
        'Content-Type': 'application/octet-stream'
      },
      body: data,
      responseType: 'json'
    }).then(normalize);
  },

  remove(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    return this.loadData({
      method: 'POST',
      url: 'https://api.dropboxapi.com/2/files/delete',
      body: {
        path: `/${name}`
      },
      responseType: 'json'
    }).then(normalize);
  },

  authorize() {
    const params = {
      response_type: 'token',
      client_id: config.client_id,
      redirect_uri: config.redirect_uri
    };
    const url = `https://www.dropbox.com/oauth2/authorize?${Object(_utils__WEBPACK_IMPORTED_MODULE_0__["dumpQuery"])(params)}`;
    Object(_base__WEBPACK_IMPORTED_MODULE_1__["openAuthPage"])(url, config.redirect_uri);
  },

  authorized(raw) {
    const data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["loadQuery"])(raw);

    if (data.access_token) {
      this.config.set({
        uid: data.uid,
        token: data.access_token
      });
    }
  },

  checkAuth(url) {
    const redirectUri = `${config.redirect_uri}#`;

    if (url.startsWith(redirectUri)) {
      this.authorized(url.slice(redirectUri.length));
      this.checkSync();
      return true;
    }
  },

  revoke() {
    this.config.set({
      uid: null,
      token: null
    });
    return this.prepare();
  }

});
Object(_base__WEBPACK_IMPORTED_MODULE_1__["register"])(Dropbox);

function normalize(item) {
  return {
    name: item.name,
    size: item.size,
    uri: Object(_base__WEBPACK_IMPORTED_MODULE_1__["getURI"])(item.name) // modified: new Date(item.server_modified).getTime(),
    // isDeleted: item.is_deleted,

  };
}

/***/ }),

/***/ "./src/background/sync/googledrive.js":
/*!********************************************!*\
  !*** ./src/background/sync/googledrive.js ***!
  \********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/background/utils/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");
// Reference:
// - https://developers.google.com/drive/v3/reference/files
// - https://github.com/google/google-api-nodejs-client




const config = {
  client_id: undefined,
  client_secret: undefined,
  redirect_uri: 'https://violentmonkey.github.io/auth_googledrive.html',
  scope: 'https://www.googleapis.com/auth/drive.appdata'
};
const UNAUTHORIZED = {
  status: 'UNAUTHORIZED'
};
const GoogleDrive = _base__WEBPACK_IMPORTED_MODULE_3__["BaseService"].extend({
  name: 'googledrive',
  displayName: 'Google Drive',
  urlPrefix: 'https://www.googleapis.com/drive/v3',

  refreshToken() {
    const refreshToken = this.config.get('refresh_token');
    if (!refreshToken) return Promise.reject({
      type: 'unauthorized'
    });
    return this.authorized({
      refresh_token: refreshToken,
      grant_type: 'refresh_token'
    }).then(() => this.prepare());
  },

  user() {
    const requestUser = () => this.loadData({
      url: `https://www.googleapis.com/oauth2/v3/tokeninfo?${Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])({
        access_token: this.config.get('token')
      })}`,
      responseType: 'json'
    });

    return requestUser().then(info => {
      // If access was granted with access_type=online, revoke it.
      if (info.access_type === 'online') {
        return this.loadData({
          method: 'POST',
          url: `https://accounts.google.com/o/oauth2/revoke?token=${this.config.get('token')}`,
          prefix: '',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        }).then(() => {
          Object(_utils__WEBPACK_IMPORTED_MODULE_2__["notify"])({
            title: 'Sync Upgraded',
            body: 'Please reauthorize access to your Google Drive to complete the upgradation.'
          });
          return Promise.reject('Online access revoked.');
        });
      }

      if (info.scope !== config.scope) return Promise.reject(UNAUTHORIZED);
    }).catch(res => {
      if (res === UNAUTHORIZED || res.status === 400 && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(res, 'data.error_description') === 'Invalid Value') {
        return this.refreshToken().then(requestUser);
      }

      return Promise.reject({
        type: 'error',
        data: res
      });
    });
  },

  getSyncData() {
    const params = {
      spaces: 'appDataFolder',
      fields: 'files(id,name,size)'
    };
    return this.loadData({
      url: `/files?${Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(params)}`,
      responseType: 'json'
    }).then(({
      files
    }) => {
      let metaFile;
      const remoteData = files.filter(item => {
        if (Object(_base__WEBPACK_IMPORTED_MODULE_3__["isScriptFile"])(item.name)) return true;

        if (!metaFile && item.name === this.metaFile) {
          metaFile = item;
        } else {
          this.remove(item);
        }

        return false;
      }).map(normalize).filter(item => {
        if (!item.size) {
          this.remove(item);
          return false;
        }

        return true;
      });
      const metaItem = metaFile ? normalize(metaFile) : {};
      const gotMeta = this.get(metaItem).then(data => JSON.parse(data)).catch(err => this.handleMetaError(err)).then(data => Object.assign({}, metaItem, {
        name: this.metaFile,
        uri: null,
        data
      }));
      return Promise.all([gotMeta, remoteData, this.getLocalData()]);
    });
  },

  authorize() {
    const params = {
      response_type: 'code',
      access_type: 'offline',
      client_id: config.client_id,
      redirect_uri: config.redirect_uri,
      scope: config.scope
    };
    if (!this.config.get('refresh_token')) params.prompt = 'consent';
    const url = `https://accounts.google.com/o/oauth2/v2/auth?${Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(params)}`;
    Object(_base__WEBPACK_IMPORTED_MODULE_3__["openAuthPage"])(url, config.redirect_uri);
  },

  checkAuth(url) {
    const redirectUri = `${config.redirect_uri}?code=`;

    if (url.startsWith(redirectUri)) {
      this.authState.set('authorizing');
      this.authorized({
        code: decodeURIComponent(url.split('#')[0].slice(redirectUri.length))
      }).then(() => this.checkSync());
      return true;
    }
  },

  revoke() {
    this.config.set({
      token: null,
      refresh_token: null
    });
    return this.prepare();
  },

  authorized(params) {
    return this.loadData({
      method: 'POST',
      url: 'https://www.googleapis.com/oauth2/v4/token',
      prefix: '',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(Object.assign({}, {
        client_id: config.client_id,
        client_secret: config.client_secret,
        redirect_uri: config.redirect_uri,
        grant_type: 'authorization_code'
      }, params)),
      responseType: 'json'
    }).then(data => {
      if (data.access_token) {
        const update = {
          token: data.access_token
        };

        if (data.refresh_token) {
          update.refresh_token = data.refresh_token;
        }

        this.config.set(update);
      } else {
        throw data;
      }
    });
  },

  handleMetaError: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"],

  list() {
    throw new Error('Not supported');
  },

  get({
    id
  }) {
    if (!id) return Promise.reject();
    return this.loadData({
      url: `/files/${id}?alt=media`
    });
  },

  put(item, data) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_3__["getItemFilename"])(item);
    const {
      id
    } = item;
    const boundary = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getUniqId"])('violentmonkey-is-great-');
    const headers = {
      'Content-Type': `multipart/related; boundary=${boundary}`
    };
    const metadata = id ? {
      name
    } : {
      name,
      parents: ['appDataFolder']
    };
    const body = [`--${boundary}`, 'Content-Type: application/json; charset=UTF-8', '', JSON.stringify(metadata), `--${boundary}`, 'Content-Type: text/plain', '', data, `--${boundary}--`, ''].join('\r\n');
    const url = id ? `https://www.googleapis.com/upload/drive/v3/files/${id}?uploadType=multipart` : 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart';
    return this.loadData({
      url,
      body,
      headers,
      method: id ? 'PATCH' : 'POST'
    });
  },

  remove({
    id
  }) {
    return this.loadData({
      method: 'DELETE',
      url: `/files/${id}`
    });
  }

});
Object(_base__WEBPACK_IMPORTED_MODULE_3__["register"])(GoogleDrive);

function normalize(item) {
  return {
    id: item.id,
    name: item.name,
    size: +item.size,
    uri: Object(_base__WEBPACK_IMPORTED_MODULE_3__["getURI"])(item.name)
  };
}

/***/ }),

/***/ "./src/background/sync/index.js":
/*!**************************************!*\
  !*** ./src/background/sync/index.js ***!
  \**************************************/
/*! exports provided: initialize, sync, getStates, authorize, revoke */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initialize", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["initialize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sync", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["sync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStates", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["getStates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "authorize", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["authorize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "revoke", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["revoke"]; });

/* harmony import */ var _dropbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dropbox */ "./src/background/sync/dropbox.js");
/* harmony import */ var _onedrive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./onedrive */ "./src/background/sync/onedrive.js");
/* harmony import */ var _googledrive__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./googledrive */ "./src/background/sync/googledrive.js");
/* harmony import */ var _webdav__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webdav */ "./src/background/sync/webdav.js");
/* harmony import */ var _utils_message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/message */ "./src/background/utils/message.js");






Object.assign(_utils_message__WEBPACK_IMPORTED_MODULE_5__["commands"], {
  SyncAuthorize: _base__WEBPACK_IMPORTED_MODULE_0__["authorize"],
  SyncRevoke: _base__WEBPACK_IMPORTED_MODULE_0__["revoke"],
  SyncStart: _base__WEBPACK_IMPORTED_MODULE_0__["sync"],
  SyncSetConfig: _base__WEBPACK_IMPORTED_MODULE_0__["setConfig"]
});


/***/ }),

/***/ "./src/background/sync/onedrive.js":
/*!*****************************************!*\
  !*** ./src/background/sync/onedrive.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/background/utils/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");
// Reference: https://dev.onedrive.com/README.htm




const config = {
  client_id: undefined,
  client_secret: undefined,
  redirect_uri: 'https://violentmonkey.github.io/auth_onedrive.html'
};
const OneDrive = _base__WEBPACK_IMPORTED_MODULE_3__["BaseService"].extend({
  name: 'onedrive',
  displayName: 'OneDrive',
  urlPrefix: 'https://api.onedrive.com/v1.0',

  refreshToken() {
    const refreshToken = this.config.get('refresh_token');
    return this.authorized({
      refresh_token: refreshToken,
      grant_type: 'refresh_token'
    }).then(() => this.prepare());
  },

  user() {
    const requestUser = () => this.loadData({
      url: '/drive',
      responseType: 'json'
    });

    return requestUser().catch(res => {
      if (res.status === 401) {
        return this.refreshToken().then(requestUser);
      }

      throw res;
    }).catch(res => {
      if (res.status === 400 && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(res, 'data.error') === 'invalid_grant') {
        return Promise.reject({
          type: 'unauthorized'
        });
      }

      return Promise.reject({
        type: 'error',
        data: res
      });
    });
  },

  handleMetaError(res) {
    if (res.status === 404) {
      var _res$headers$get;

      const header = ((_res$headers$get = res.headers.get('WWW-Authenticate')) == null ? void 0 : _res$headers$get[0]) || '';

      if (/^Bearer realm="OneDriveAPI"/.test(header)) {
        return this.refreshToken().then(() => this.getMeta());
      }

      return;
    }

    throw res;
  },

  list() {
    return this.loadData({
      url: '/drive/special/approot/children',
      responseType: 'json'
    }).then(data => data.value.filter(item => item.file && Object(_base__WEBPACK_IMPORTED_MODULE_3__["isScriptFile"])(item.name)).map(normalize));
  },

  get(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_3__["getItemFilename"])(item);
    return this.loadData({
      url: `/drive/special/approot:/${encodeURIComponent(name)}`,
      responseType: 'json'
    }).then(data => this.loadData({
      url: data['@content.downloadUrl'],
      delay: false
    }));
  },

  put(item, data) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_3__["getItemFilename"])(item);
    return this.loadData({
      method: 'PUT',
      url: `/drive/special/approot:/${encodeURIComponent(name)}:/content`,
      headers: {
        'Content-Type': 'application/octet-stream'
      },
      body: data,
      responseType: 'json'
    }).then(normalize);
  },

  remove(item) {
    // return 204
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_3__["getItemFilename"])(item);
    return this.loadData({
      method: 'DELETE',
      url: `/drive/special/approot:/${encodeURIComponent(name)}`
    }).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]);
  },

  authorize() {
    const params = {
      client_id: config.client_id,
      scope: 'onedrive.appfolder wl.offline_access',
      response_type: 'code',
      redirect_uri: config.redirect_uri
    };
    const url = `https://login.live.com/oauth20_authorize.srf?${Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(params)}`;
    Object(_base__WEBPACK_IMPORTED_MODULE_3__["openAuthPage"])(url, config.redirect_uri);
  },

  checkAuth(url) {
    const redirectUri = `${config.redirect_uri}?code=`;

    if (url.startsWith(redirectUri)) {
      this.authState.set('authorizing');
      this.authorized({
        code: url.slice(redirectUri.length)
      }).then(() => this.checkSync());
      return true;
    }
  },

  revoke() {
    this.config.set({
      uid: null,
      token: null,
      refresh_token: null
    });
    return this.prepare();
  },

  authorized(params) {
    return this.loadData({
      method: 'POST',
      url: 'https://login.live.com/oauth20_token.srf',
      prefix: '',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: Object(_utils__WEBPACK_IMPORTED_MODULE_2__["dumpQuery"])(Object.assign({}, {
        client_id: config.client_id,
        client_secret: config.client_secret,
        redirect_uri: config.redirect_uri,
        grant_type: 'authorization_code'
      }, params)),
      responseType: 'json'
    }).then(data => {
      if (data.access_token) {
        this.config.set({
          uid: data.user_id,
          token: data.access_token,
          refresh_token: data.refresh_token
        });
      } else {
        throw data;
      }
    });
  }

});
Object(_base__WEBPACK_IMPORTED_MODULE_3__["register"])(OneDrive);

function normalize(item) {
  return {
    name: item.name,
    size: item.size,
    uri: Object(_base__WEBPACK_IMPORTED_MODULE_3__["getURI"])(item.name) // modified: new Date(item.lastModifiedDateTime).getTime(),

  };
}

/***/ }),

/***/ "./src/background/sync/webdav.js":
/*!***************************************!*\
  !*** ./src/background/sync/webdav.js ***!
  \***************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/background/sync/base.js");


const KEY_CHILDREN = Symbol('children');

class XNode {
  constructor(node, nsMap) {
    this.node = node;
    this.nsMap = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, nsMap);
    this.parseAttrs();
    this.parseName();
  }

  static fromXML(xml) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'application/xml');
    return new XNode(doc);
  }

  parseAttrs() {
    const {
      node,
      nsMap
    } = this;
    const attrs = {};
    const {
      attributes
    } = node;

    if (attributes) {
      for (const attr of node.attributes) {
        const {
          name,
          value
        } = attr;
        if (name === 'xmlns') nsMap.$ = value;else if (name.startsWith('xmlns:')) nsMap[name.slice(6)] = value;
        attrs[name] = value;
      }
    }

    this.attrs = attrs;
  }

  parseName() {
    const {
      node,
      nsMap
    } = this;

    if (node.nodeType === 1) {
      let name = node.tagName;
      let ns = nsMap.$;

      if (name.includes(':')) {
        let prefix;
        [prefix, name] = name.split(':');
        ns = nsMap[prefix];
        if (!ns) throw new Error(`Unknown namespace: ${prefix}`);
      }

      this.name = ns + name;
    }
  }

  text() {
    const {
      node
    } = this;
    if (node) return (node.textContent || '').trim();
  }

  children() {
    if (!this[KEY_CHILDREN]) {
      const {
        node,
        nsMap
      } = this;
      this[KEY_CHILDREN] = [...node.children].map(child => new XNode(child, nsMap));
    }

    return this[KEY_CHILDREN];
  }

  map(callback) {
    return this.children().map(callback);
  }

  getCallback(callback) {
    if (typeof callback === 'string') {
      return (tagName => node => node.name === tagName)(callback);
    }

    return callback;
  }

  filter(callback) {
    return this.children().filter(this.getCallback(callback));
  }

  find(callback) {
    return this.children().find(this.getCallback(callback));
  }

  attr(key) {
    return this.attrs[key];
  }

}

const DEFAULT_CONFIG = {
  serverUrl: '',
  anonymous: false,
  username: '',
  password: ''
};
const WebDAV = _base__WEBPACK_IMPORTED_MODULE_1__["BaseService"].extend({
  name: 'webdav',
  displayName: 'WebDAV',
  properties: {
    authType: 'password',
    serverUrl: null
  },

  getUserConfig() {
    if (!this.userConfig) {
      this.userConfig = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, DEFAULT_CONFIG, {}, this.config.get('userConfig'));
    }

    return this.userConfig;
  },

  setUserConfig(config) {
    Object.assign(this.userConfig, config);
    this.config.set('userConfig', this.userConfig);
  },

  initToken() {
    var _config$serverUrl;

    this.prepareHeaders();
    const config = this.getUserConfig();
    let url = ((_config$serverUrl = config.serverUrl) == null ? void 0 : _config$serverUrl.trim()) || '';
    if (!url.includes('://')) url = `http://${url}`;
    if (!url.endsWith('/')) url += '/';

    try {
      new URL(url); // eslint-disable-line no-new
    } catch (e) {
      this.properties.serverUrl = null;
      return false;
    }

    this.properties.serverUrl = `${url}Violentmonkey/`;
    const {
      anonymous,
      username,
      password
    } = config;
    if (anonymous) return true;
    if (!username || !password) return false;
    const auth = window.btoa(`${username}:${password}`);
    this.headers.Authorization = `Basic ${auth}`;
    return true;
  },

  loadData(options) {
    // Bypassing login CSRF protection in Nextcloud / Owncloud by not sending cookies.
    // We are not using web UI and cookie authentication, so we don't have to worry about that.
    // See https://github.com/violentmonkey/violentmonkey/issues/976
    return _base__WEBPACK_IMPORTED_MODULE_1__["BaseService"].prototype.loadData.call(this, Object.assign({
      credentials: 'omit'
    }, options));
  },

  handleMetaError(res) {
    if (![404, // File not exists
    409 // Directory not exists
    ].includes(res.status)) throw res;
  },

  // Some WebDAV servers do not allow LOCK / UNLOCK

  /*
  acquireLock() {
    const { serverUrl } = this.properties;
    const createLock = () => {
      this.log('Acquire lock...');
      return this.loadData({
        method: 'LOCK',
        url: serverUrl,
        headers: {
          Timeout: `Second-${30 * 60}`,
        },
        body: `\
  <?xml version="1.0" encoding="utf-8" ?>
  <D:lockinfo xmlns:D='DAV:'>
  <D:lockscope><D:exclusive/></D:lockscope>
  <D:locktype><D:write/></D:locktype>
  </D:lockinfo>`,
      })
      .then(xml => {
        const doc = XNode.fromXML(xml);
        const lock = doc.find('DAV:prop')
        .find('DAV:lockdiscovery')
        .find('DAV:activelock')
        .find('DAV:locktoken')
        .find('DAV:href')
        .text();
        this.log('Acquired lock:', lock);
        this.config.set({
          lock,
        });
      });
    };
    const lock = this.config.get('lock');
    if (lock) {
      this.log('Refresh lock:', lock);
      return this.loadData({
        method: 'LOCK',
        url: serverUrl,
        headers: {
          If: `(<${lock}>)`,
        },
      })
      .then(() => {
        this.log('Refreshed lock:', lock);
      }, err => {
        if (err.status === 412) {
          this.log('Refresh lock error');
          this.config.set({ lock: null });
          // Precondition Failed
          return createLock();
        }
        throw err;
      });
    }
    return createLock();
  },
  releaseLock() {
    const lock = this.config.get('lock');
    if (lock) {
      const { serverUrl } = this.properties;
      this.log('Release lock:', lock);
      return this.loadData({
        method: 'UNLOCK',
        url: serverUrl,
        headers: {
          'Lock-Token': `<${lock}>`,
        },
      })
      .then(() => {
        this.log('Released lock');
      }, () => {
        this.log('Release lock error');
      })
      .then(() => {
        this.config.set({ lock: null });
      });
    }
  },
  */
  list() {
    const {
      serverUrl
    } = this.properties;

    const mkdir = () => this.loadData({
      method: 'MKCOL',
      url: serverUrl
    });

    const readdir = () => this.loadData({
      method: 'PROPFIND',
      url: serverUrl,
      headers: {
        depth: '1'
      }
    }).then(xml => {
      const doc = XNode.fromXML(xml);
      const items = doc.children()[0].map(node => {
        const prop = node.find('DAV:propstat').find('DAV:prop');
        const type = prop.find('DAV:resourcetype').find('DAV:collection') ? 'directory' : 'file';

        if (type === 'file') {
          let displayName;
          const displayNameNode = prop.find('DAV:displayname');

          if (displayNameNode !== undefined) {
            displayName = displayNameNode.text();
          } else {
            const href = node.find('DAV:href').text();
            displayName = decodeURIComponent(href.substring(href.lastIndexOf('/') + 1));
          }

          if (Object(_base__WEBPACK_IMPORTED_MODULE_1__["isScriptFile"])(displayName)) {
            const size = prop.find('DAV:getcontentlength');
            return normalize({
              name: displayName,
              size: size ? +size.text() : 0
            });
          }
        }

        return null;
      }).filter(Boolean);
      return items;
    });

    return readdir().catch(err => {
      if (err.status === 404) {
        return mkdir().then(readdir);
      }

      throw err;
    });
  },

  get(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    const {
      serverUrl
    } = this.properties;
    return this.loadData({
      url: serverUrl + name
    });
  },

  put(item, data) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    const headers = {
      'Content-Type': 'text/plain'
    };
    const lock = this.config.get('lock');
    if (lock) headers.If = `(<${lock}>)`;
    const {
      serverUrl
    } = this.properties;
    return this.loadData({
      method: 'PUT',
      url: serverUrl + name,
      body: data,
      headers
    });
  },

  remove(item) {
    const name = Object(_base__WEBPACK_IMPORTED_MODULE_1__["getItemFilename"])(item);
    const headers = {};
    const lock = this.config.get('lock');
    if (lock) headers.If = `(<${lock}>)`;
    const {
      serverUrl
    } = this.properties;
    return this.loadData({
      method: 'DELETE',
      url: serverUrl + name,
      headers
    });
  }

});
Object(_base__WEBPACK_IMPORTED_MODULE_1__["register"])(WebDAV);

function normalize(item) {
  return {
    name: item.name,
    size: item.size,
    uri: Object(_base__WEBPACK_IMPORTED_MODULE_1__["getURI"])(item.name)
  };
}

/***/ }),

/***/ "./src/background/utils/aes-decryptor.js":
/*!***********************************************!*\
  !*** ./src/background/utils/aes-decryptor.js ***!
  \***********************************************/
/*! exports provided: AESDecryptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AESDecryptor", function() { return AESDecryptor; });
/* eslint-disable */
// refer https://github.com/video-dev/hls.js
function removePadding(buffer) {
  const outputBytes = buffer.byteLength;
  const paddingBytes = outputBytes && new DataView(buffer).getUint8(outputBytes - 1);

  if (paddingBytes) {
    return buffer.slice(0, outputBytes - paddingBytes);
  }

  return buffer;
}

const AESDecryptor = function () {
  return {
    constructor() {
      this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.sBox = new Uint32Array(256);
      this.invSBox = new Uint32Array(256); // Changes during runtime

      this.key = new Uint32Array(0);
      this.initTable();
    },

    // Using view.getUint32() also swaps the byte order.
    uint8ArrayToUint32Array_(arrayBuffer) {
      let view = new DataView(arrayBuffer);
      let newArray = new Uint32Array(4);

      for (let i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }

      return newArray;
    },

    initTable() {
      let sBox = this.sBox;
      let invSBox = this.invSBox;
      let subMix = this.subMix;
      let subMix0 = subMix[0];
      let subMix1 = subMix[1];
      let subMix2 = subMix[2];
      let subMix3 = subMix[3];
      let invSubMix = this.invSubMix;
      let invSubMix0 = invSubMix[0];
      let invSubMix1 = invSubMix[1];
      let invSubMix2 = invSubMix[2];
      let invSubMix3 = invSubMix[3];
      let d = new Uint32Array(256);
      let x = 0;
      let xi = 0;
      let i = 0;

      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x; // Compute multiplication

        let x2 = d[x];
        let x4 = d[x2];
        let x8 = d[x4]; // Compute sub/invSub bytes, mix columns tables

        let t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t; // Compute inv sub bytes, inv mix columns tables

        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t; // Compute next counter

        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    },

    expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      let key = this.uint8ArrayToUint32Array_(keyBuffer);
      let sameKey = true;
      let offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      let keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      let ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      let ksRow;
      let invKsRow;
      let keySchedule = this.keySchedule = new Uint32Array(ksRows);
      let invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      let sbox = this.sBox;
      let rcon = this.rcon;
      let invSubMix = this.invSubMix;
      let invSubMix0 = invSubMix[0];
      let invSubMix1 = invSubMix[1];
      let invSubMix2 = invSubMix[2];
      let invSubMix3 = invSubMix[3];
      let prev;
      let t;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }

        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24; // Sub word

          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff]; // Mix Rcon

          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;

        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    },

    // Adding this as a method greatly improves performance.
    networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    },

    decrypt(inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
      let nRounds = this.keySize + 6;
      let invKeySchedule = this.invKeySchedule;
      let invSBOX = this.invSBox;
      let invSubMix = this.invSubMix;
      let invSubMix0 = invSubMix[0];
      let invSubMix1 = invSubMix[1];
      let invSubMix2 = invSubMix[2];
      let invSubMix3 = invSubMix[3];
      let initVector = this.uint8ArrayToUint32Array_(aesIV);
      let initVector0 = initVector[0];
      let initVector1 = initVector[1];
      let initVector2 = initVector[2];
      let initVector3 = initVector[3];
      let inputInt32 = new Int32Array(inputArrayBuffer);
      let outputInt32 = new Int32Array(inputInt32.length);
      let t0, t1, t2, t3;
      let s0, s1, s2, s3;
      let inputWords0, inputWords1, inputWords2, inputWords3;
      let ksRow, i;
      let swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);
        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];
        ksRow = 4; // Iterate through the rounds of decryption

        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3]; // Update state

          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
          ksRow = ksRow + 4;
        } // Shift rows, sub bytes, add round key


        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3; // Write

        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3); // reset initVector to last 4 unsigned int

        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;
        offset = offset + 4;
      }

      return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
    },

    destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;
      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;
      this.rcon = undefined;
    }

  };
};

/***/ }),

/***/ "./src/background/utils/cache.js":
/*!***************************************!*\
  !*** ./src/background/utils/cache.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/cache */ "./src/common/cache.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");


const cache = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_0__["default"])({
  /* Keeping the data for one hour since chrome.storage.local is insanely slow in Chrome,
     it can takes seconds to read it when injecting tabs with a big script/value, which delays
     all other scripts in this tab and they will never be able to run at document-start. */
  lifetime: 60 * 60 * 1000
});
Object.assign(_message__WEBPACK_IMPORTED_MODULE_1__["commands"], {
  CacheLoad(data) {
    return cache.get(data) || null;
  },

  CacheHit(data) {
    cache.hit(data.key, data.lifetime);
  },

  CachePop(key) {
    return cache.pop(key) || null;
  }

});
/* harmony default export */ __webpack_exports__["default"] = (cache);

/***/ }),

/***/ "./src/background/utils/clipboard.js":
/*!*******************************************!*\
  !*** ./src/background/utils/clipboard.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");

const textarea = document.createElement('textarea');
let clipboardData;
Object.assign(_message__WEBPACK_IMPORTED_MODULE_0__["commands"], {
  SetClipboard(data) {
    clipboardData = data;
    textarea.focus();
    const ret = document.execCommand('copy', false, null);

    if (!ret && false) {
      console.warn('Copy failed!');
    }
  }

});
document.body.appendChild(textarea);
document.addEventListener('copy', e => {
  e.preventDefault();
  const {
    type,
    data
  } = clipboardData;
  e.clipboardData.setData(type || 'text/plain', data);
});

/***/ }),

/***/ "./src/background/utils/db.js":
/*!************************************!*\
  !*** ./src/background/utils/db.js ***!
  \************************************/
/*! exports provided: normalizePosition, sortScripts, getScriptById, getScript, getScripts, getValueStoresByIds, dumpValueStores, ENV_CACHE_KEYS, ENV_REQ_KEYS, ENV_VALUE_IDS, getScriptsByURL, getData, checkRemove, updateScriptInfo, parseScript, fetchResources, vacuum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizePosition", function() { return normalizePosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortScripts", function() { return sortScripts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScriptById", function() { return getScriptById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScript", function() { return getScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScripts", function() { return getScripts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValueStoresByIds", function() { return getValueStoresByIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dumpValueStores", function() { return dumpValueStores; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV_CACHE_KEYS", function() { return ENV_CACHE_KEYS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV_REQ_KEYS", function() { return ENV_REQ_KEYS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV_VALUE_IDS", function() { return ENV_VALUE_IDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScriptsByURL", function() { return getScriptsByURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getData", function() { return getData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkRemove", function() { return checkRemove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateScriptInfo", function() { return updateScriptInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseScript", function() { return parseScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchResources", function() { return fetchResources; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vacuum", function() { return vacuum; });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/common/storage */ "./src/common/storage.js");
/* harmony import */ var _plugin_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugin/events */ "./src/background/plugin/events.js");
/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./script */ "./src/background/utils/script.js");
/* harmony import */ var _tester__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tester */ "./src/background/utils/tester.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _patch_db__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./patch-db */ "./src/background/utils/patch-db.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony import */ var _storage_fetch__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./storage-fetch */ "./src/background/utils/storage-fetch.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");














const store = {};
_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].base.setDataCache(_cache__WEBPACK_IMPORTED_MODULE_13__["default"]);

_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.onDump = item => {
  store.scriptMap[item.props.id] = item;
};

Object.assign(_message__WEBPACK_IMPORTED_MODULE_9__["commands"], {
  CheckPosition: sortScripts,
  CheckRemove: checkRemove,

  /** @return {VMScript} */
  GetScript: getScript,

  /** @return {Promise<{ items: VMScript[], values? }>} */
  async ExportZip({
    values
  }) {
    const scripts = getScripts();
    const ids = scripts.map(getPropsId);
    const codeMap = await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.getMulti(ids);
    return {
      items: scripts.map(script => ({
        script,
        code: codeMap[script.props.id]
      })),
      values: values ? await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.getMulti(ids) : undefined
    };
  },

  /** @return {Promise<string>} */
  GetScriptCode(id) {
    return _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.getOne(id);
  },

  GetScriptVer(opts) {
    const script = getScript(opts);
    return script && !script.config.removed ? script.meta.version : null;
  },

  /** @return {Promise<void>} */
  MarkRemoved({
    id,
    removed
  }) {
    return updateScriptInfo(id, {
      config: {
        removed: removed ? 1 : 0
      },
      props: {
        lastModified: Date.now()
      }
    });
  },

  /** @return {Promise<number>} */
  Move({
    id,
    offset
  }) {
    const script = getScriptById(id);
    const index = store.scripts.indexOf(script);
    store.scripts.splice(index, 1);
    store.scripts.splice(index + offset, 0, script);
    return normalizePosition();
  },

  /** @return {Promise<void>} */
  async RemoveScript(id) {
    const i = store.scripts.indexOf(getScriptById(id));

    if (i >= 0) {
      store.scripts.splice(i, 1);
      await Promise.all([_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.remove(id), _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.remove(id), _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.remove(id)]);
    }

    return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])('RemoveScript', id);
  },

  ParseMeta: _script__WEBPACK_IMPORTED_MODULE_6__["parseMeta"],
  ParseScript: parseScript,

  /** @return {Promise<void>} */
  UpdateScriptInfo({
    id,
    config,
    custom
  }) {
    return updateScriptInfo(id, {
      config,
      custom,
      props: {
        lastModified: Date.now()
      }
    });
  },

  /** @return {Promise<number>} */
  Vacuum: vacuum
});
_init__WEBPACK_IMPORTED_MODULE_8__["preInitialize"].push(async () => {
  var _data$options;

  const {
    version: lastVersion
  } = await browser.storage.local.get('version');
  const version = "2.13.0.12";
  if (!lastVersion) await Object(_patch_db__WEBPACK_IMPORTED_MODULE_10__["default"])();
  if (version !== lastVersion) browser.storage.local.set({
    version
  });
  const data = await browser.storage.local.get();
  const scripts = [];
  const storeInfo = {
    id: 0,
    position: 0
  };
  const idMap = {};
  const uriMap = {};
  const mods = [];
  const resUrls = [];
  /** @this VMScriptCustom.pathMap */

  const rememberUrl = function _(url) {
    resUrls.push(this[url] || url);
  };

  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachEntry"], data, ([key, script]) => {
    _cache__WEBPACK_IMPORTED_MODULE_13__["default"].put(key, script);

    if (key.startsWith(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.prefix)) {
      var _meta$require;

      // {
      //   meta,
      //   custom,
      //   props: { id, position, uri },
      //   config: { enabled, shouldUpdate },
      // }
      const id = getInt(key.slice(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.prefix.length));

      if (!id || idMap[id]) {
        // ID conflicts!
        // Should not happen, discard duplicates.
        return;
      }

      idMap[id] = script;
      const uri = Object(_script__WEBPACK_IMPORTED_MODULE_6__["getNameURI"])(script);

      if (uriMap[uri]) {
        // Namespace conflicts!
        // Should not happen, discard duplicates.
        return;
      }

      uriMap[uri] = script;
      script.props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.props, {
        id,
        uri
      });
      script.custom = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, Object(_script__WEBPACK_IMPORTED_MODULE_6__["getDefaultCustom"])(), {}, script.custom);
      storeInfo.id = Math.max(storeInfo.id, id);
      storeInfo.position = Math.max(storeInfo.position, getInt(script.props.position));
      scripts.push(script); // listing all known resource urls in order to remove unused mod keys

      const {
        custom: {
          pathMap = {}
        } = {},
        meta = script.meta = {}
      } = script;
      meta.grant = [...new Set(meta.grant || [])]; // deduplicate

      (_meta$require = meta.require) == null ? void 0 : _meta$require.forEach(rememberUrl, pathMap);
      Object.values(meta.resources || {}).forEach(rememberUrl, pathMap);
      safeCall(rememberUrl, pathMap, meta.icon);
    } else if (key.startsWith(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].mod.prefix)) {
      mods.push(key.slice(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].mod.prefix.length));
    }
  });
  _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].mod.removeMulti(mods.filter(url => !resUrls.includes(url)));
  Object.assign(store, {
    scripts,
    storeInfo,
    scriptMap: scripts.reduce((map, item) => {
      map[item.props.id] = item;
      return map;
    }, {})
  }); // Switch defaultInjectInto from `page` to `auto` when upgrading VM2.12.7 or older

  if (version !== lastVersion && IS_FIREFOX && ((_data$options = data.options) == null ? void 0 : _data$options.defaultInjectInto) === _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["INJECT_PAGE"] && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["compareVersion"])(lastVersion, '2.12.7') <= 0) {
    Object(_options__WEBPACK_IMPORTED_MODULE_11__["setOption"])('defaultInjectInto', _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["INJECT_AUTO"]);
  }

  if (false) {}

  vacuum(data);
  return sortScripts();
});
/** @return {number} */

function getInt(val) {
  return +val || 0;
}
/** @return {?number} */


function getPropsId(script) {
  return script == null ? void 0 : script.props.id;
}
/** @return {void} */


function updateLastModified() {
  Object(_options__WEBPACK_IMPORTED_MODULE_11__["setOption"])('lastModified', Date.now());
}
/** @return {Promise<number>} */


async function normalizePosition() {
  const updates = store.scripts.filter(({
    props
  }, index) => {
    const position = index + 1;
    const res = props.position !== position;
    if (res) props.position = position;
    return res;
  });
  store.storeInfo.position = store.scripts.length;

  if (updates.length) {
    await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.dump(updates);
    updateLastModified();
  }

  return updates.length;
}
/** @return {Promise<number>} */

async function sortScripts() {
  store.scripts.sort((a, b) => getInt(a.props.position) - getInt(b.props.position));
  const changed = await normalizePosition();
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])('ScriptsUpdated', null);
  return changed;
}
/** @return {?VMScript} */

function getScriptById(id) {
  return store.scriptMap[id];
}
/** @return {?VMScript} */

function getScript({
  id,
  uri,
  meta
}) {
  let script;

  if (id) {
    script = getScriptById(id);
  } else {
    if (!uri) uri = Object(_script__WEBPACK_IMPORTED_MODULE_6__["getNameURI"])({
      meta,
      id: '@@should-have-name'
    });
    script = store.scripts.find(({
      props
    }) => uri === props.uri);
  }

  return script;
}
/** @return {VMScript[]} */

function getScripts() {
  return store.scripts.filter(script => !script.config.removed);
}
/**
 * @desc Load values for batch updates.
 * @param {number[]} ids
 * @return {Promise<Object>}
 */

function getValueStoresByIds(ids) {
  return _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.getMulti(ids);
}
/**
 * @desc Dump values for batch updates.
 * @param {Object} valueDict { id1: value1, id2: value2, ... }
 * @return {Promise<Object>}
 */

async function dumpValueStores(valueDict) {
  if (false) {}
  await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.dump(valueDict);
  return valueDict;
}
const ENV_CACHE_KEYS = 'cacheKeys';
const ENV_REQ_KEYS = 'reqKeys';
const ENV_VALUE_IDS = 'valueIds';
const GMVALUES_RE = /^GM[_.](listValues|([gs]et|delete)Value)$/;
const RUN_AT_RE = /^document-(start|body|end|idle)$/;
/**
 * @desc Get scripts to be injected to page with specific URL.
 */

async function getScriptsByURL(url, isTop) {
  const allScripts = Object(_tester__WEBPACK_IMPORTED_MODULE_7__["testBlacklist"])(url) ? [] : store.scripts.filter(script => {
    var _script$custom$nofram;

    return !script.config.removed && (isTop || !((_script$custom$nofram = script.custom.noframes) != null ? _script$custom$nofram : script.meta.noframes)) && Object(_tester__WEBPACK_IMPORTED_MODULE_7__["testScript"])(url, script);
  });
  const disabledIds = [];
  /** @namespace VMScriptByUrlData */

  const [envStart, envDelayed] = [0, 1].map(() => ({
    ids: [],

    /** @type {(VMScript & VMInjectedScript)[]} */
    scripts: [],
    [ENV_CACHE_KEYS]: [],
    [ENV_REQ_KEYS]: [],
    [ENV_VALUE_IDS]: []
  }));
  allScripts.forEach(script => {
    var _$match;

    const {
      id
    } = script.props;

    if (!script.config.enabled) {
      disabledIds.push(id);
      return;
    }

    const {
      meta,
      custom
    } = script;
    const {
      pathMap = buildPathMap(script)
    } = custom;
    const runAt = ((_$match = `${custom.runAt || meta.runAt || ''}`.match(RUN_AT_RE)) == null ? void 0 : _$match[1]) || 'end';
    const env = runAt === 'start' || runAt === 'body' ? envStart : envDelayed;
    env.ids.push(id);

    if (meta.grant.some(GMVALUES_RE.test, GMVALUES_RE)) {
      env[ENV_VALUE_IDS].push(id);
    }

    for (const [list, name] of [[meta.require, ENV_REQ_KEYS], [Object.values(meta.resources), ENV_CACHE_KEYS]]) {
      list.forEach(key => {
        key = pathMap[key] || key;

        if (!envStart[name].includes(key)) {
          env[name].push(key);
        }
      });
    }
    /** @namespace VMInjectedScript */


    env.scripts.push(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script, {
      runAt
    }));
  });

  if (envDelayed.ids.length) {
    envDelayed.promise = readEnvironmentData(envDelayed);
  }
  /** @namespace VMScriptByUrlData */


  return _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, envStart, {}, (await readEnvironmentData(envStart)), {
    disabledIds,
    envDelayed
  });
}
/**
 * Object keys == areas in `storage` module.
 * @namespace VMScriptByUrlData
 */

const STORAGE_ROUTES = Object.entries({
  cache: ENV_CACHE_KEYS,
  code: 'ids',
  require: ENV_REQ_KEYS,
  value: ENV_VALUE_IDS
});
const retriedStorageKeys = {};

async function readEnvironmentData(env, isRetry) {
  const keys = [];
  STORAGE_ROUTES.forEach(([area, srcIds]) => {
    env[srcIds].forEach(id => {
      keys.push(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"][area].getKey(id));
    });
  });
  const data = await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].base.getMulti(keys);

  for (const [area, srcIds] of STORAGE_ROUTES) {
    env[area] = {};

    for (const id of env[srcIds]) {
      const val = data[_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"][area].getKey(id)];
      env[area][id] = val;

      if (val == null && area !== 'value' && retriedStorageKeys[area + id] !== 2) {
        const err = `The "${area}" storage is missing "${id}"!`;
        const err2 = 'Vacuuming did not help. Please reinstall the affected scripts.';
        retriedStorageKeys[area + id] = isRetry ? 2 : 1;

        if (!isRetry) {
          console.warn(err, 'Vacuuming...');

          if (await vacuum()) {
            return readEnvironmentData(env, true);
          }
        }

        console.error(err, err2);
        Object(_message__WEBPACK_IMPORTED_MODULE_9__["notify"])({
          title: err,
          body: err2
        });
      }
    }
  }

  return env;
}
/**
 * @desc Get data for dashboard.
 * @return {Promise<{ scripts: VMScript[], cache: Object }>}
 */


async function getData(ids) {
  const scripts = ids ? ids.map(getScriptById) : store.scripts;
  return {
    scripts,
    cache: await getIconCache(scripts)
  };
}

function getIconCache(scripts) {
  const iconUrls = [];
  scripts.forEach(script => {
    const {
      icon
    } = script.meta;

    if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(icon)) {
      var _script$custom$pathMa;

      iconUrls.push(((_script$custom$pathMa = script.custom.pathMap) == null ? void 0 : _script$custom$pathMa[icon]) || icon);
    }
  });
  return iconUrls.length ? _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].cache.getMulti(iconUrls, undefined, _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].cache.makeDataUri) : {};
}
/** @return {number} */


function checkRemove({
  force
} = {}) {
  const now = Date.now();
  const toRemove = store.scripts.filter(script => script.config.removed && (force || now - getInt(script.props.lastModified) > _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["TIMEOUT_WEEK"]));

  if (toRemove.length) {
    store.scripts = store.scripts.filter(script => !script.config.removed);
    const ids = toRemove.map(getPropsId);
    _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.removeMulti(ids);
    _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.removeMulti(ids);
    _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.removeMulti(ids);
  }

  return toRemove.length;
}
/** @return {string} */

function getUUID() {
  const rnd = new Uint16Array(8);
  window.crypto.getRandomValues(rnd); // xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
  // We're using UUIDv4 variant 1 so N=4 and M=8
  // See format_uuid_v3or5 in https://tools.ietf.org/rfc/rfc4122.txt

  rnd[3] = rnd[3] & 0x0FFF | 0x4000; // eslint-disable-line no-bitwise

  rnd[4] = rnd[4] & 0x3FFF | 0x8000; // eslint-disable-line no-bitwise

  return '01-2-3-4-567'.replace(/\d/g, i => (rnd[i] + 0x10000).toString(16).slice(-4));
}
/**
 * @param {VMScript} script
 * @param {string} code
 * @return {Promise<VMScript[]>}
 */


async function saveScript(script, code) {
  const config = script.config || {};
  config.enabled = getInt(config.enabled);
  config.shouldUpdate = getInt(config.shouldUpdate);
  const props = script.props || {};
  let oldScript;

  if (!props.id) {
    store.storeInfo.id += 1;
    props.id = store.storeInfo.id;
  } else {
    oldScript = store.scriptMap[props.id];
  }

  props.uri = Object(_script__WEBPACK_IMPORTED_MODULE_6__["getNameURI"])(script);
  props.uuid = props.uuid || (crypto.randomUUID == null ? void 0 : crypto.randomUUID()) || getUUID(); // Do not allow script with same name and namespace

  if (store.scripts.some(({
    props: {
      id,
      uri
    } = {}
  }) => props.id !== id && props.uri === uri)) {
    throw Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgNamespaceConflict');
  }

  if (oldScript) {
    script.config = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, oldScript.config, {}, config);
    script.props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, oldScript.props, {}, props);
    const index = store.scripts.indexOf(oldScript);
    store.scripts[index] = script;
  } else {
    if (!props.position) {
      store.storeInfo.position += 1;
      props.position = store.storeInfo.position;
    } else if (store.storeInfo.position < props.position) {
      store.storeInfo.position = props.position;
    }

    script.config = config;
    script.props = props;
    store.scripts.push(script);
  }

  return Promise.all([_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.dump(script), _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.set(props.id, code)]);
}
/** @return {Promise<void>} */


async function updateScriptInfo(id, data) {
  const script = store.scriptMap[id];
  if (!script) throw null;
  script.props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.props, {}, data.props);
  script.config = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.config, {}, data.config);
  script.custom = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.custom, {}, data.custom);
  await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.dump(script);
  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["CMD_SCRIPT_UPDATE"], {
    where: {
      id
    },
    update: script
  });
}
/** @return {Promise<{ isNew?, update, where }>} */

async function parseScript(src) {
  const meta = Object(_script__WEBPACK_IMPORTED_MODULE_6__["parseMeta"])(src.code);
  if (!meta.name) throw `${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgInvalidScript')}\n${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('labelNoName')}`;
  const result = {
    update: {
      message: src.message == null ? Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgUpdated') : src.message || ''
    }
  };
  let cmd = _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["CMD_SCRIPT_UPDATE"];
  let script;
  const oldScript = await getScript({
    id: src.id,
    meta
  });

  if (oldScript) {
    if (src.isNew) throw Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgNamespaceConflict');
    script = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, oldScript);
  } else {
    ({
      script
    } = Object(_script__WEBPACK_IMPORTED_MODULE_6__["newScript"])());
    cmd = _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["CMD_SCRIPT_ADD"];
    result.isNew = true;
    result.update.message = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgInstalled');
  }

  script.config = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.config, {}, src.config, {
    removed: 0 // force reset `removed` since this is an installation

  });
  script.custom = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.custom, {}, src.custom);
  script.props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, script.props, {
    lastModified: Date.now(),
    lastUpdated: Date.now()
  }, src.props);
  script.meta = meta;

  if (!meta.homepageURL && !script.custom.homepageURL && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(src.from)) {
    script.custom.homepageURL = src.from;
  }

  if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(src.url)) script.custom.lastInstallURL = src.url;
  if (src.position) script.props.position = +src.position;
  buildPathMap(script, src.url);
  await saveScript(script, src.code);
  fetchResources(script, src);
  Object.assign(result.update, script, src.update);
  result.where = {
    id: script.props.id
  };
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])(cmd, result);
  _plugin_events__WEBPACK_IMPORTED_MODULE_5__["default"].emit('scriptChanged', result);
  return result;
}
/** @return {Object} */

function buildPathMap(script, base) {
  const {
    meta
  } = script;
  const baseUrl = base || script.custom.lastInstallURL;
  const pathMap = baseUrl ? [...meta.require, ...Object.values(meta.resources), meta.icon].reduce((map, key) => {
    if (key) {
      const fullUrl = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getFullUrl"])(key, baseUrl);
      if (fullUrl !== key) map[key] = fullUrl;
    }

    return map;
  }, {}) : {};
  script.custom.pathMap = pathMap;
  return pathMap;
}
/** @return {Promise<?string>} resolves to error text if `resourceCache` is absent */


async function fetchResources(script, resourceCache, reqOptions) {
  const {
    custom: {
      pathMap
    },
    meta
  } = script;

  const snatch = (url, type, validator) => {
    var _resourceCache$type;

    url = pathMap[url] || url;
    const contents = resourceCache == null ? void 0 : (_resourceCache$type = resourceCache[type]) == null ? void 0 : _resourceCache$type[url];
    return contents != null && !validator ? _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"][type].set(url, contents) && null : _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"][type].fetch(url, reqOptions, validator).catch(err => err);
  };

  const errors = await Promise.all([...meta.require.map(url => snatch(url, 'require')), ...Object.values(meta.resources).map(url => snatch(url, 'cache')), Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(meta.icon) && snatch(meta.icon, 'cache', validateImage)]);

  if (!(resourceCache == null ? void 0 : resourceCache.ignoreDepsErrors)) {
    const error = safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["trueJoin"], errors.map(formatHttpError), '\n');

    if (error) {
      const message = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgErrorFetchingResource');
      Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendCmd"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["CMD_SCRIPT_UPDATE"], {
        update: {
          error,
          message
        },
        where: {
          id: script.props.id
        }
      });
      return `${message}\n${error}`;
    }
  }
}
/** @return {Promise<void>} resolves on success, rejects on error */

function validateImage(url, buf, type) {
  return new Promise((resolve, reject) => {
    const blobUrl = URL.createObjectURL(new Blob([buf], {
      type
    }));

    const onDone = e => {
      URL.revokeObjectURL(blobUrl);
      if (e.type === 'load') resolve();else reject(`IMAGE_ERROR: ${url}`);
    };

    const image = new Image();
    image.onload = onDone;
    image.onerror = onDone;
    image.src = blobUrl;
  });
}

function formatHttpError(e) {
  return e && safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["trueJoin"], [e.status && `HTTP${e.status}`, e.url], ' ') || e;
}

let _vacuuming;
/**
 * @param {Object} [data]
 * @return {Promise<number>}
 */


async function vacuum(data) {
  if (_vacuuming) return _vacuuming;
  let numFixes = 0;
  let resolveSelf;
  _vacuuming = new Promise(r => {
    resolveSelf = r;
  });
  const result = {};
  const toFetch = [];
  const keysToRemove = [];
  const valueKeys = {};
  const cacheKeys = {};
  const requireKeys = {};
  const codeKeys = {};
  const mappings = [[_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value, valueKeys], [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].cache, cacheKeys], [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].require, requireKeys], [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code, codeKeys]];
  if (!data) data = await browser.storage.local.get();
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachKey"], data, key => {
    mappings.some(([substore, map]) => {
      const {
        prefix
      } = substore;

      if (key.startsWith(prefix)) {
        // -1 for untouched, 1 for touched, 2 for missing
        map[key.slice(prefix.length)] = -1;
        return true;
      }

      return false;
    });
  });

  const touch = (obj, key, scriptId) => {
    if (obj[key] < 0) {
      obj[key] = 1;
    } else if (!obj[key]) {
      obj[key] = 2 + scriptId;
    }
  };

  store.scripts.forEach(script => {
    const {
      id
    } = script.props;
    touch(codeKeys, id, id);
    touch(valueKeys, id, id);
    if (!script.custom.pathMap) buildPathMap(script);
    const {
      pathMap
    } = script.custom;

    script.meta.require.forEach(url => {
      touch(requireKeys, pathMap[url] || url, id);
    });

    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachValue"], script.meta.resources, url => {
      touch(cacheKeys, pathMap[url] || url, id);
    });
    const {
      icon
    } = script.meta;

    if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isRemote"])(icon)) {
      const fullUrl = pathMap[icon] || icon;
      touch(cacheKeys, fullUrl, id);
    }
  });
  mappings.forEach(([substore, map]) => {
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachEntry"], map, ([key, value]) => {
      if (value < 0) {
        // redundant value
        keysToRemove.push(substore.getKey(key));
        numFixes += 1;
      } else if (value >= 2 && substore.fetch) {
        // missing resource
        keysToRemove.push(_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].mod.getKey(key));
        toFetch.push(substore.fetch(key).catch(err => `${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getScriptName"])(getScriptById(value - 2))}: ${formatHttpError(err)}`));
        numFixes += 1;
      }
    });
  });

  if (numFixes) {
    await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].base.removeMulti(keysToRemove); // Removing `mod` before fetching

    result.errors = (await Promise.all(toFetch)).filter(Boolean);
  }

  _vacuuming = null;
  result.fixes = numFixes;
  resolveSelf(result);
  return result;
}
/** @typedef VMScript
 * @property {VMScriptConfig} config
 * @property {VMScriptCustom} custom
 * @property {VMScriptMeta} meta
 * @property {VMScriptProps} props
 */

/** @typedef VMScriptConfig *
 * @property {Boolean} enabled - stored as 0 or 1
 * @property {Boolean} removed - stored as 0 or 1
 * @property {Boolean} shouldUpdate - stored as 0 or 1
 * @property {Boolean | null} notifyUpdates - stored as 0 or 1 or null (default) which means "use global setting"
 */

/** @typedef VMScriptCustom *
 * @property {string} name
 * @property {string} downloadURL
 * @property {string} homepageURL
 * @property {string} lastInstallURL
 * @property {string} updateURL
 * @property {'auto' | 'page' | 'content'} injectInto
 * @property {null | 1 | 0} noframes - null or absence == default (script's value)
 * @property {string[]} exclude
 * @property {string[]} excludeMatch
 * @property {string[]} include
 * @property {string[]} match
 * @property {boolean} origExclude
 * @property {boolean} origExcludeMatch
 * @property {boolean} origInclude
 * @property {boolean} origMatch
 * @property {Object} pathMap
 * @property {VMScriptRunAt} runAt
 */

/** @typedef VMScriptMeta *
 * @property {string} description
 * @property {string} downloadURL
 * @property {string[]} exclude
 * @property {string[]} excludeMatch
 * @property {string[]} grant
 * @property {string} homepageURL
 * @property {string} icon
 * @property {string[]} include
 * @property {'auto' | 'page' | 'content'} injectInto
 * @property {string[]} match
 * @property {string} namespace
 * @property {string} name
 * @property {boolean} noframes
 * @property {string[]} require
 * @property {Object} resources
 * @property {VMScriptRunAt} runAt
 * @property {string} supportURL
 * @property {string} version
 */

/** @typedef VMScriptProps *
 * @property {number} id
 * @property {number} lastModified
 * @property {number} lastUpdated
 * @property {number} position
 * @property {string} uri
 * @property {string} uuid
 */

/**
 * @typedef {
   'document-start' | 'document-body' | 'document-end' | 'document-idle'
 } VMScriptRunAt
 */

/***/ }),

/***/ "./src/background/utils/events.js":
/*!****************************************!*\
  !*** ./src/background/utils/events.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getEventEmitter; });
function getEventEmitter() {
  const events = {};
  return {
    on,
    off,
    fire
  };

  function on(type, func) {
    let list = events[type];

    if (!list) {
      list = [];
      events[type] = list;
    }

    list.push(func);
  }

  function off(type, func) {
    const list = events[type];

    if (list) {
      const i = list.indexOf(func);
      if (i >= 0) list.splice(i, 1);
    }
  }

  function fire(type, data) {
    const list = events[type];

    if (list) {
      list.forEach(func => {
        func(data, type);
      });
    }
  }
}

/***/ }),

/***/ "./src/background/utils/hotkeys.js":
/*!*****************************************!*\
  !*** ./src/background/utils/hotkeys.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");


_init__WEBPACK_IMPORTED_MODULE_0__["postInitialize"].push(() => {
  browser.commands.onCommand.addListener(cmd => {
    if (cmd === 'newScript') {
      _message__WEBPACK_IMPORTED_MODULE_1__["commands"].OpenEditor();
    } else {
      const route = cmd === 'settings' ? `#${cmd}` : '';
      _message__WEBPACK_IMPORTED_MODULE_1__["commands"].TabOpen({
        url: `/options/index.html${route}`
      });
    }
  });
});

/***/ }),

/***/ "./src/background/utils/icon.js":
/*!**************************************!*\
  !*** ./src/background/utils/icon.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony import */ var _tester__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tester */ "./src/background/utils/tester.js");







 // storing in `cache` only for the duration of page load in case there are 2+ identical urls

const CACHE_DURATION = 1000;
Object.assign(_message__WEBPACK_IMPORTED_MODULE_5__["commands"], {
  async GetImageData(url) {
    const key = `GetImageData:${url}`;
    return _cache__WEBPACK_IMPORTED_MODULE_3__["default"].get(key) || _cache__WEBPACK_IMPORTED_MODULE_3__["default"].put(key, loadImageData(url, {
      base64: true
    }).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]), CACHE_DURATION);
  },

  SetBadge: setBadge
}); // Firefox Android does not support such APIs, use noop

const browserAction = (() => {
  const {
    chrome
  } = global; // Using `chrome` namespace in order to skip our browser.js polyfill in Chrome

  const api = chrome.browserAction; // Suppress the "no tab id" error when setting an icon/badge as it cannot be reliably prevented

  const ignoreErrors = () => chrome.runtime.lastError; // Some methods like setBadgeText added callbacks only in Chrome 67+.


  const makeMethod = fn => (...args) => {
    try {
      safeCall(fn, api, ...args, ignoreErrors);
    } catch (e) {
      safeCall(fn, api, ...args);
    }
  };

  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectPick"])(api, ['setIcon', 'setBadgeText', 'setBadgeBackgroundColor', 'setTitle'], fn => fn ? makeMethod(fn) : _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]);
})();

const badges = {};
const KEY_IS_APPLIED = 'isApplied';
const KEY_SHOW_BADGE = 'showBadge';
const KEY_BADGE_COLOR = 'badgeColor';
const KEY_BADGE_COLOR_BLOCKED = 'badgeColorBlocked';
/** @type boolean */

let isApplied;
/** @type VMBadgeMode */

let showBadge;
/** @type string */

let badgeColor;
/** @type string */

let badgeColorBlocked;
/** @type string */

let titleBlacklisted;
/** @type string */

let titleNoninjectable; // We'll cache the icon data in Chrome as it doesn't cache the data and takes up to 40ms
// in our background page context to set the 4 icon sizes for each new tab opened

const iconCache = !IS_FIREFOX && {};
Object(_options__WEBPACK_IMPORTED_MODULE_6__["hookOptions"])(changes => {
  let v;
  const jobs = [];

  if ((v = changes[KEY_IS_APPLIED]) != null) {
    isApplied = v;
    setIcon(); // change the default icon

    jobs.push(setIcon); // change the current tabs' icons
  }

  if ((v = changes[KEY_SHOW_BADGE]) != null) {
    showBadge = v;
    jobs.push(updateBadge);
  }

  if ((v = changes[KEY_BADGE_COLOR]) && (badgeColor = v) || (v = changes[KEY_BADGE_COLOR_BLOCKED]) && (badgeColorBlocked = v)) {
    jobs.push(updateBadgeColor);
  }

  if ('blacklist' in changes) {
    jobs.push(updateState);
  }

  if (jobs.length) {
    Object(_message__WEBPACK_IMPORTED_MODULE_5__["forEachTab"])(tab => jobs.forEach(fn => fn(tab)));
  }
});
_init__WEBPACK_IMPORTED_MODULE_4__["postInitialize"].push(() => {
  isApplied = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])(KEY_IS_APPLIED);
  showBadge = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])(KEY_SHOW_BADGE);
  badgeColor = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])(KEY_BADGE_COLOR);
  badgeColorBlocked = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])(KEY_BADGE_COLOR_BLOCKED);
  titleBlacklisted = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('failureReasonBlacklisted');
  titleNoninjectable = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('failureReasonNoninjectable');
  Object(_message__WEBPACK_IMPORTED_MODULE_5__["forEachTab"])(updateState);
  if (!isApplied) setIcon(); // sets the dimmed icon as default
});
browser.tabs.onRemoved.addListener(id => {
  delete badges[id];
});
browser.tabs.onUpdated.addListener((tabId, info, tab) => {
  const {
    url
  } = info;

  if (info.status === 'loading' // at least about:newtab in Firefox may open without 'loading' status
  || info.favIconUrl && tab.url.startsWith('about:')) {
    updateState(tab, url);
  }
});

function setBadge(ids, {
  tab,
  frameId
}) {
  const tabId = tab.id;
  const data = badges[tabId] || {};

  if (!data.idMap || frameId === 0) {
    // 1) keeping data object to preserve data.blocked
    // 2) 'total' and 'unique' must match showBadge in options-defaults.js
    data.total = 0;
    data.unique = 0;
    data.idMap = {};
    badges[tabId] = data;
  }

  data.total += ids.length;

  if (ids) {
    ids.forEach(id => {
      data.idMap[id] = 1;
    });
    data.unique = Object.keys(data.idMap).length;
  }

  updateBadgeColor(tab, data);
  updateBadge(tab, data);
}

function updateBadge(tab, data = badges[tab.id]) {
  if (data) {
    browserAction.setBadgeText({
      text: `${data[showBadge] || ''}`,
      tabId: tab.id
    });
  }
}

function updateBadgeColor(tab, data = badges[tab.id]) {
  if (data) {
    browserAction.setBadgeBackgroundColor({
      color: data.blocked ? badgeColorBlocked : badgeColor,
      tabId: tab.id
    });
  }
} // Chrome 79+ uses pendingUrl while the tab connects to the newly navigated URL
// https://groups.google.com/a/chromium.org/forum/#!topic/chromium-extensions/5zu_PT0arls


function updateState(tab, url = tab.pendingUrl || tab.url) {
  const tabId = tab.id;
  const injectable = _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECTABLE_TAB_URL_RE"].test(url);
  const blacklisted = injectable ? Object(_tester__WEBPACK_IMPORTED_MODULE_7__["testBlacklist"])(url) : undefined;
  const title = blacklisted && titleBlacklisted || !injectable && titleNoninjectable || ''; // if the user unblacklisted this previously blocked tab in settings,
  // but didn't reload the tab yet, we need to restore the icon and the title

  if (title || (badges[tabId] || {}).blocked) {
    browserAction.setTitle({
      title,
      tabId
    });
    const data = title ? {
      blocked: true
    } : {};
    badges[tabId] = data;
    setIcon(tab, data);
    updateBadge(tab, data);
  }
}

async function setIcon(tab = {}, data = {}) {
  // modern Chrome and Firefox use 16/32, other browsers may still use 19/38 (e.g. Vivaldi)
  const mod = data.blocked && 'b' || !isApplied && 'w' || '';
  const iconData = {};

  for (const n of [16, 19, 32, 38]) {
    const path = `/public/images/icon${n}${mod}.png`;
    let icon = iconCache ? iconCache[path] : path;

    if (!icon) {
      icon = await loadImageData(path);
      iconCache[path] = icon;
    }

    iconData[n] = icon;
  }

  browserAction.setIcon({
    tabId: tab.id,
    [iconCache ? 'imageData' : 'path']: iconData
  });
}

function loadImageData(path, {
  base64
} = {}) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.src = path;

    img.onload = () => {
      const {
        width,
        height
      } = img;

      if (!width) {
        // FF reports 0 for SVG
        resolve(path);
        return;
      }

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      resolve(base64 ? canvas.toDataURL() : ctx.getImageData(0, 0, width, height));
    };

    img.onerror = reject;
  });
}

/***/ }),

/***/ "./src/background/utils/index.js":
/*!***************************************!*\
  !*** ./src/background/utils/index.js ***!
  \***************************************/
/*! exports provided: cache, getEventEmitter, commands, notify, broadcast, sendMessageOrIgnore, forEachTab, getOption, getDefaultOption, setOption, hookOptions, loadQuery, dumpQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cache", function() { return _cache__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ "./src/background/utils/events.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEventEmitter", function() { return _events__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "commands", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["commands"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notify", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["notify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "broadcast", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["broadcast"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sendMessageOrIgnore", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["sendMessageOrIgnore"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEachTab", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["forEachTab"]; });

/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOption", function() { return _options__WEBPACK_IMPORTED_MODULE_3__["getOption"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultOption", function() { return _options__WEBPACK_IMPORTED_MODULE_3__["getDefaultOption"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setOption", function() { return _options__WEBPACK_IMPORTED_MODULE_3__["setOption"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hookOptions", function() { return _options__WEBPACK_IMPORTED_MODULE_3__["hookOptions"]; });

/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./search */ "./src/background/utils/search.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadQuery", function() { return _search__WEBPACK_IMPORTED_MODULE_4__["loadQuery"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dumpQuery", function() { return _search__WEBPACK_IMPORTED_MODULE_4__["dumpQuery"]; });







/***/ }),

/***/ "./src/background/utils/init.js":
/*!**************************************!*\
  !*** ./src/background/utils/init.js ***!
  \**************************************/
/*! exports provided: extensionRoot, preInitialize, postInitialize, initialize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extensionRoot", function() { return extensionRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preInitialize", function() { return preInitialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "postInitialize", function() { return postInitialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialize", function() { return initialize; });
const extensionRoot = browser.runtime.getURL('/');
const preInitialize = [];
const postInitialize = [];
async function initialize(main) {
  const run = init => typeof init === 'function' ? init() : init;

  await Promise.all(preInitialize.map(run));
  await run(main);
  await Promise.all(postInitialize.map(run));
  preInitialize.length = 0;
  postInitialize.length = 0;
}

/***/ }),

/***/ "./src/background/utils/m3u8.js":
/*!**************************************!*\
  !*** ./src/background/utils/m3u8.js ***!
  \**************************************/
/*! exports provided: downloadM3u8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadM3u8", function() { return downloadM3u8; });
/* harmony import */ var jbinary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jbinary */ "./node_modules/jbinary/dist/browser/jbinary.js");
/* harmony import */ var jbinary__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jbinary__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mpegts_to_mp4_mpegts_to_mp4_mpegts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mpegts_to_mp4/mpegts_to_mp4/mpegts */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/mpegts.js");
/* harmony import */ var mpegts_to_mp4_mpegts_to_mp4_mpegts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mpegts_to_mp4_mpegts_to_mp4_mpegts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mpegts_to_mp4_mpegts_to_mp4_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mpegts_to_mp4/mpegts_to_mp4/index */ "./node_modules/mpegts_to_mp4/mpegts_to_mp4/index.js");
/* harmony import */ var mpegts_to_mp4_mpegts_to_mp4_index__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mpegts_to_mp4_mpegts_to_mp4_index__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _aes_decryptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aes-decryptor */ "./src/background/utils/aes-decryptor.js");
/* eslint-disable */

/**
 * credits
 * https://github.com/Momo707577045/m3u8-downloader
 * https://github.com/shellvon/zh-downloader
 */


 // eslint-disable-line camelcase


let tsList = [];
let statusList = [];
let mediaFileList = []; // AES 

const AES = {
  method: '',
  // 
  uri: '',
  // key 
  iv: '',
  // 
  key: '',
  // 
  decryptor: null,
  // 
  stringToBuffer: function (str) {
    return new TextEncoder().encode(str);
  }
};
const downloadM3u8 = function (opts) {
  // clear
  tsList = [];
  statusList = [];
  mediaFileList = [];
  const m3u8 = opts.data[0];
  const baseUrl = opts.url;
  let limit = 5;
  m3u8.split('\n').forEach(line => {
    if (limit > 0 && tsList.length >= limit) return;

    if (line.toLowerCase().indexOf('.ts') > -1) {
      tsList.push(tsUrl(line, baseUrl));
      statusList.push({
        title: line,
        status: 'init'
      });
    }
  }); // console.log('tsList', tsList);

  if (m3u8.indexOf('#EXT-X-KEY') > -1) {
    //  AES 
    AES.method = (m3u8.match(/(.*METHOD=([^,\s]+))/) || ['', '', ''])[2];
    AES.uri = (m3u8.match(/(.*URI="([^"]+))"/) || ['', '', ''])[2];
    AES.uri = tsUrl(AES.uri, baseUrl);
    AES.iv = (m3u8.match(/(.*IV=([^,\s]+))/) || ['', '', ''])[2];
    AES.iv = AES.iv ? AES.stringToBuffer(AES.iv) : ''; // 

    getAES(() => {
      downloadTS(opts);
    });
  } else if (tsList.length > 0) {
    // 
    downloadTS(opts);
  } else {
    console.info('empty m3u8!');
  }
};

const getAES = function (callback) {
  ajax({
    url: AES.uri,
    success: key => {
      AES.key = key;
      AES.decryptor = new _aes_decryptor__WEBPACK_IMPORTED_MODULE_3__["AESDecryptor"]();
      AES.decryptor.constructor();
      AES.decryptor.expandKey(AES.key);
      callback();
    },
    fail: () => {
      console.info('');
    }
  });
};

const tsUrl = function (tsUri, baseURL) {
  if (tsUri.startsWith('http')) {
    return tsUri;
  } else if (tsUri[0] === '/') {
    let domain = baseURL.split('/');
    return domain[0] + '//' + domain[2] + tsUri;
  } else {
    let domain = baseURL.split('/');
    domain.pop();
    return domain.join('/') + '/' + tsUri;
  }
}; // ts  AES 


const decryptTs = function (data, index) {
  let iv = AES.iv || new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, index]);
  return AES.decryptor.decrypt(data, 0, iv.buffer || iv, true);
}; // 


const downloadTS = function (opts) {
  let index = 0;
  let retry = 0;

  let download = () => {
    const i = index;
    index++;

    if (i >= tsList.length) {
      // all succ
      const procList = statusList.filter(s => ['succ', 'loading'].includes(s.status));

      if (procList.length === tsList.length) {
        return;
      }

      if (retry < 5) {
        // retry again
        retry++;
        index = 0;
        setTimeout(() => download(), 1000);
        console.log('retry', retry, procList.length);
        return;
      }
    }

    console.log('download', i);

    if (statusList[i] && ['error', 'init'].includes(statusList[i].status)) {
      statusList[i].status = 'loading';
      ajax({
        url: tsList[i],
        success: data => {
          statusList[i].status = 'succ';
          dealTS(data, i, opts, () => {
            opts.onprogress(mediaFileList.length, tsList.length + 1);
            download();
          });
        },
        fail: e => {
          // let err = e.statusText
          console.log({
            e,
            i
          }); // todo: retry

          statusList[i].status = 'error';
          download();
        }
      });
    } else {
      // 
      download();
    }
  }; //  N


  for (let ii = 0; ii < 3; ii++) {
    download();
  }
};

const mp4ByJbinary = (dataChunks, callback) => {
  const blob = new Blob(dataChunks.map(data => new Uint8Array(data)), {
    type: 'video/mp2t'
  });
  jbinary__WEBPACK_IMPORTED_MODULE_0___default.a.load(blob, mpegts_to_mp4_mpegts_to_mp4_mpegts__WEBPACK_IMPORTED_MODULE_1___default.a, (err, mpegts) => {
    if (err) console.log({
      err
    });
    const start = new Date().getTime();
    const mp4Obj = mpegts_to_mp4_mpegts_to_mp4_index__WEBPACK_IMPORTED_MODULE_2___default()(mpegts);
    console.log(`Converted finished, time elapsed: ${new Date().getTime() - start}ms`);
    const data = {
      downloadLink: mp4Obj.toURI('video/mp4')
    };
    callback(data);
  });
}; //  ts AES mp4 


const dealTS = function (rawData, index, opts, callback) {
  const data = AES.uri ? decryptTs(rawData, index) : rawData;
  mediaFileList[index] = data;

  if (mediaFileList.filter(m => m || false).length === tsList.length) {
    mp4ByJbinary(mediaFileList, res => {
      chrome.downloads.download({
        url: res.downloadLink,
        filename: opts.fileName
      }, downloadId => {
        opts.onload();
        URL.revokeObjectURL(res.downloadLink);
      });
    });
  }

  callback && callback();
};

const ajax = function (options) {
  options = options || {};
  let xhr = new XMLHttpRequest();
  xhr.responseType = 'arraybuffer';

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      let status = xhr.status;

      if (status >= 200 && status < 300) {
        options.success && options.success(xhr.response);
      } else {
        options.fail && options.fail(status);
      }
    }
  };

  xhr.open("GET", options.url, true);
  xhr.send(null);
};

/***/ }),

/***/ "./src/background/utils/merge-video.js":
/*!*********************************************!*\
  !*** ./src/background/utils/merge-video.js ***!
  \*********************************************/
/*! exports provided: mergeVideo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeVideo", function() { return mergeVideo; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");


const {
  createFFmpeg,
  fetchFile
} = __webpack_require__(/*! @ffmpeg/ffmpeg */ "./node_modules/@ffmpeg/ffmpeg/src/index.js");

const {
  chrome
} = global;
let ffmpeg;

async function load() {
  if (ffmpeg) return ffmpeg;
  ffmpeg = createFFmpeg({
    corePath: '/public/lib/ffmpeg-core.js',
    log: false
  });
  await ffmpeg.load();
  console.info('ff loaded', {
    ffmpeg
  });
  return ffmpeg;
}

const merge = async (video, audio) => {
  // console.info({ video, audio });
  ffmpeg.FS('writeFile', 'video.mp4', (await fetchFile(video)));
  ffmpeg.FS('writeFile', 'audio.mp3', (await fetchFile(audio)));
  await ffmpeg.run('-i', 'video.mp4', '-i', 'audio.mp3', '-c', 'copy', 'out.mp4');
  return ffmpeg.FS('readFile', 'out.mp4');
};

async function get(opts, httpRequest, progress) {
  return new Promise((resolve, reject) => {
    opts.requests[opts.id] = {
      id: opts.id,
      tabId: opts.src.tab.id,
      eventsToNotify: ['error', 'load', 'progress'],
      xhr: new XMLHttpRequest()
    };
    opts.type = 'download';
    opts.fileName = null;
    opts.data = [];
    httpRequest(opts, opts.src, res => {
      // console.info('httpRequest', res);
      if (res.type === 'progress') {
        var _res$data, _res$data2;

        // console.info('httpRequest', res.data?.loaded, res.data?.total);
        progress((_res$data = res.data) == null ? void 0 : _res$data.loaded, (_res$data2 = res.data) == null ? void 0 : _res$data2.total);
      } else if (res.type === 'load') {
        resolve(res.data);
      } else if (res.type === 'loadend') {
        reject();
      }
    });
  });
}

async function mergeVideo(opts, httpRequest) {
  // console.info('mergeVideo', opts);
  const progress = {
    video: {
      loaded: 0,
      total: 0
    },
    audio: {
      loaded: 0,
      total: 0
    }
  };

  const onprogress = (pp, loaded, total) => {
    if (loaded && total) Object.assign(pp, {
      loaded,
      total
    });

    const _loaded = progress.video.loaded + progress.audio.loaded;

    const _total = progress.video.total + progress.audio.total;

    if (_loaded && _total) opts.onprogress(_loaded, _total + 1);
  };

  const preloads = [];
  preloads.push(load());
  const videoOpts = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(opts);
  videoOpts.requests = opts.requests;
  videoOpts.id = `${opts.id}.video`;
  preloads.push(get(videoOpts, httpRequest, (loaded, total) => {
    onprogress(progress.video, loaded, total);
  }));
  const audioOpts = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(opts);
  audioOpts.requests = opts.requests;
  audioOpts.url = opts.data[0];
  audioOpts.id = `${opts.id}.audio`;
  preloads.push(get(audioOpts, httpRequest, (loaded, total) => {
    onprogress(progress.audio, loaded, total);
  }));
  const vals = await Promise.all(preloads);

  if (!vals[1] || !vals[2]) {
    // fail
    opts.onerror();
    return;
  } // console.info({ vals });


  const out = await merge(vals[1], vals[2]); // console.info('out', { out });

  const url = URL.createObjectURL(new Blob([out], {
    type: 'video/mp4'
  })); // console.info('res', { url, filename: opts.fileName });

  chrome.downloads.download({
    url,
    filename: opts.fileName
  }, downloadId => {
    // console.info(downloadId);
    opts.onload(downloadId);
    URL.revokeObjectURL(url);
  });
}

/***/ }),

/***/ "./src/background/utils/message.js":
/*!*****************************************!*\
  !*** ./src/background/utils/message.js ***!
  \*****************************************/
/*! exports provided: commands, notify, broadcast, sendMessageOrIgnore, forEachTab */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commands", function() { return commands; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notify", function() { return notify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "broadcast", function() { return broadcast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendMessageOrIgnore", function() { return sendMessageOrIgnore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachTab", function() { return forEachTab; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");

const commands = {};
function notify(options) {
  browser.notifications.create(options.id || 'ViolentMonkey', {
    type: 'basic',
    iconUrl: _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["defaultImage"],
    title: `${options.title} - ${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('extName')}`,
    message: options.body,
    isClickable: options.isClickable
  });
}
function broadcast(data) {
  forEachTab(tab => {
    browser.tabs.sendMessage(tab.id, data).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]);
  });
}
function sendMessageOrIgnore(...args) {
  return browser.runtime.sendMessage(...args).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["noop"]);
}
async function forEachTab(callback) {
  const tabs = await browser.tabs.query({});
  let i = 0;

  for (const tab of tabs) {
    callback(tab);
    i += 1; // we'll run at most this many tabs in one event loop cycle
    // because hundreds of tabs would make our extension process unresponsive,
    // the same process used by our own pages like the background page, dashboard, or popups

    if (i % 20 === 0) await new Promise(setTimeout);
  }
}

/***/ }),

/***/ "./src/background/utils/notifications.js":
/*!***********************************************!*\
  !*** ./src/background/utils/notifications.js ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");


const openers = {};
Object.assign(_message__WEBPACK_IMPORTED_MODULE_1__["commands"], {
  /** @return {Promise<string>} */
  async Notification(data, src, bgExtras) {
    const notificationId = await browser.notifications.create({
      type: 'basic',
      title: data.title || (IS_FIREFOX ? Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('extName') : ''),
      // Chrome already shows the name
      message: data.text,
      iconUrl: data.image || _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["defaultImage"]
    });
    openers[notificationId] = (bgExtras == null ? void 0 : bgExtras.onClick) || src.tab.id;
    return notificationId;
  },

  RemoveNotification(notificationId) {
    return browser.notifications.clear(notificationId);
  }

});
browser.notifications.onClicked.addListener(id => {
  const openerId = openers[id];

  if (openerId >= 0) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(openerId, 'NotificationClick', id);
  }

  if (typeof openerId === 'function') {
    openerId();
  }
});
browser.notifications.onClosed.addListener(id => {
  const openerId = openers[id];
  delete openers[id];

  if (openerId >= 0) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(openerId, 'NotificationClose', id);
  }
});

/***/ }),

/***/ "./src/background/utils/options.js":
/*!*****************************************!*\
  !*** ./src/background/utils/options.js ***!
  \*****************************************/
/*! exports provided: getOption, getDefaultOption, setOption, hookOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOption", function() { return getOption; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultOption", function() { return getDefaultOption; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOption", function() { return setOption; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hookOptions", function() { return hookOptions; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/options-defaults */ "./src/common/options-defaults.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");





Object.assign(_message__WEBPACK_IMPORTED_MODULE_4__["commands"], {
  /** @return {Object} */
  GetAllOptions() {
    return _message__WEBPACK_IMPORTED_MODULE_4__["commands"].GetOptions(_Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__["default"]);
  },

  /** @return {Object} */
  GetOptions(data) {
    return safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["mapEntry"], data, ([key]) => getOption(key));
  },

  /** @return {void} */
  SetOptions(data) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["ensureArray"])(data).forEach(item => setOption(item.key, item.value));
  }

});
let changes = {};
const hooks = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["initHooks"])();
const callHooksLater = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["debounce"])(callHooks, 100);
let options = {};
let initPending = browser.storage.local.get('options').then(({
  options: data
}) => {
  if (data && typeof data === 'object') options = data;

  if (false) {}

  if (!Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(options, 'version')) {
    setOption('version', 1);
  }

  initPending = null;
});
_init__WEBPACK_IMPORTED_MODULE_3__["preInitialize"].push(initPending);

function fireChange(keys, value) {
  // Flattening key path so the subscribers can update nested values without overwriting the parent
  const key = keys.join('.'); // Ensuring the correct order when updates were mixed like this: foo.bar=1; foo={bar:2}; foo.bar=3

  delete changes[key];
  changes[key] = value;
  callHooksLater();
}

function callHooks() {
  hooks.fire(changes);
  changes = {};
}

function getOption(key, def) {
  const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
  const mainKey = keys[0];
  let value = options[mainKey];
  if (value == null) value = _Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__["default"][mainKey];
  if (value == null) value = def;
  return keys.length > 1 ? Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(value, keys.slice(1), def) : value;
}
function getDefaultOption(key) {
  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectGet"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__["default"], key);
}
function setOption(key, value) {
  if (initPending) {
    initPending.then(() => {
      setOption(key, value);
    });
    return;
  }

  const keys = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["normalizeKeys"])(key);
  const optionKey = keys.join('.');
  let optionValue = value;
  const mainKey = keys[0];

  if (mainKey in _Users_ZhaoJun_Desktop_violentmonkey_src_common_options_defaults__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    if (keys.length > 1) {
      optionValue = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(getOption(mainKey), keys.slice(1), value);
    }

    options[mainKey] = optionValue;
    browser.storage.local.set({
      options
    });
    fireChange(keys, value);

    if (false) {}
  }
}
const hookOptions = hooks.hook;

/***/ }),

/***/ "./src/background/utils/patch-db.js":
/*!******************************************!*\
  !*** ./src/background/utils/patch-db.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./script */ "./src/background/utils/script.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/storage */ "./src/common/storage.js");


/* harmony default export */ __webpack_exports__["default"] = (() => new Promise((resolve, reject) => {
  console.info('Upgrade database...');
  init();

  function init() {
    const req = indexedDB.open('Violentmonkey', 1);

    req.onsuccess = () => {
      try {
        transform(req.result);
      } catch (err) {
        // This should not happen, but did happen in Firefox.
        reject(err);
      }
    };

    req.onerror = reject;

    req.onupgradeneeded = () => {
      // No available upgradation
      reject();
    };
  }

  function transform(db) {
    const tx = db.transaction(['scripts', 'require', 'cache', 'values']);
    const updates = {};
    let processing = 3;

    const done = () => {
      processing -= 1;
      if (!processing) resolve(browser.storage.local.set(updates));
    };

    const getAll = (storeName, callback) => {
      const req = tx.objectStore(storeName).getAll();

      req.onsuccess = () => callback(req.result);

      req.onerror = reject;
    };

    getAll('scripts', allScripts => {
      const uriMap = {};
      allScripts.forEach(script => {
        const {
          code,
          id,
          uri
        } = script;
        updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].script.prefix}${id}`] = transformScript(script);
        updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].code.prefix}${id}`] = code;
        uriMap[uri] = id;
      });
      getAll('values', allValues => {
        allValues.forEach(({
          uri,
          values
        }) => {
          const id = uriMap[uri];
          if (id) updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].value.prefix}${id}`] = values;
        });
        done();
      });
    });
    getAll('cache', allCache => {
      allCache.forEach(({
        uri,
        data
      }) => {
        updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].cache.prefix}${uri}`] = data;
      });
      done();
    });
    getAll('require', allRequire => {
      allRequire.forEach(({
        uri,
        code
      }) => {
        updates[`${_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].require.prefix}${uri}`] = code;
      });
      done();
    });
  }

  function transformScript(script) {
    return {
      meta: Object(_script__WEBPACK_IMPORTED_MODULE_0__["parseMeta"])(script.code),
      custom: Object.assign({
        origInclude: true,
        origExclude: true,
        origMatch: true,
        origExcludeMatch: true
      }, script.custom),
      props: {
        id: script.id,
        uri: script.uri,
        position: script.position
      },
      config: {
        enabled: script.enabled,
        shouldUpdate: script.update
      }
    };
  }
}) // Ignore error
.catch(() => {}));

/***/ }),

/***/ "./src/background/utils/popup-tracker.js":
/*!***********************************************!*\
  !*** ./src/background/utils/popup-tracker.js ***!
  \***********************************************/
/*! exports provided: popupTabs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popupTabs", function() { return popupTabs; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "./src/background/utils/db.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");





const popupTabs = {}; // { tabId: 1 }

_init__WEBPACK_IMPORTED_MODULE_3__["postInitialize"].push(() => {
  browser.runtime.onConnect.addListener(onPopupOpened);
  browser.webRequest.onBeforeRequest.addListener(prefetchSetPopup, {
    urls: [browser.runtime.getURL(browser.runtime.getManifest().browser_action.default_popup)],
    types: ['main_frame']
  });
});

function onPopupOpened(port) {
  const tabId = +port.name;
  popupTabs[tabId] = 1;
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(tabId, 'PopupShown', true);
  port.onDisconnect.addListener(onPopupClosed);
  delete _message__WEBPACK_IMPORTED_MODULE_4__["commands"].SetPopup;
}

function onPopupClosed({
  name
}) {
  delete popupTabs[name];
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(+name, 'PopupShown', false);
}

async function prefetchSetPopup() {
  const tabId = (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getActiveTab"])()).id;
  Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(tabId, 'PopupShown', true);

  _message__WEBPACK_IMPORTED_MODULE_4__["commands"].SetPopup = async (data, src) => {
    Object.assign(data, (await Object(_db__WEBPACK_IMPORTED_MODULE_2__["getData"])(data.ids)));
    _cache__WEBPACK_IMPORTED_MODULE_1__["default"].put('SetPopup', Object.assign({
      [src.frameId]: [data, src]
    }, _cache__WEBPACK_IMPORTED_MODULE_1__["default"].get('SetPopup')));
  };
}

/***/ }),

/***/ "./src/background/utils/preinject.js":
/*!*******************************************!*\
  !*** ./src/background/utils/preinject.js ***!
  \*******************************************/
/*! exports provided: getInjectedScripts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInjectedScripts", function() { return getInjectedScripts; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/cache */ "./src/common/cache.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/common/storage */ "./src/common/storage.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/common/ua */ "./src/common/ua.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./db */ "./src/background/utils/db.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");










const API_CONFIG = {
  urls: ['*://*/*'],
  // `*` scheme matches only http and https
  types: ['main_frame', 'sub_frame']
};
const TIME_AFTER_SEND = 10e3; // longer as establishing connection to sites may take time

const TIME_AFTER_RECEIVE = 1e3; // shorter as response body will be coming very soon

const TIME_KEEP_DATA = 60e3; // 100ms should be enough but the tab may hang or get paused in debugger

const cacheCode = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_2__["default"])({
  lifetime: TIME_KEEP_DATA
});
const cache = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_cache__WEBPACK_IMPORTED_MODULE_2__["default"])({
  lifetime: TIME_KEEP_DATA,
  onDispose: async promise => {
    const data = await promise;
    const rcs = await (data == null ? void 0 : data.rcsPromise);
    rcs == null ? void 0 : rcs.unregister();
  }
});
const INJECT_INTO = 'injectInto'; // KEY_XXX for hooked options

const KEY_EXPOSE = 'expose';
const KEY_DEF_INJECT_INTO = 'defaultInjectInto';
const KEY_IS_APPLIED = 'isApplied';
const KEY_XHR_INJECT = 'xhrInject';
const expose = {};
let isApplied;
let injectInto;
let xhrInject;
Object(_options__WEBPACK_IMPORTED_MODULE_9__["hookOptions"])(onOptionChanged);
_init__WEBPACK_IMPORTED_MODULE_7__["postInitialize"].push(() => {
  for (const key of [KEY_EXPOSE, KEY_DEF_INJECT_INTO, KEY_IS_APPLIED, KEY_XHR_INJECT]) {
    onOptionChanged({
      [key]: Object(_options__WEBPACK_IMPORTED_MODULE_9__["getOption"])(key)
    });
  }
});
Object.assign(_message__WEBPACK_IMPORTED_MODULE_8__["commands"], {
  async InjectionFeedback({
    feedId,
    feedback,
    forceContent
  }, src) {
    feedback.forEach(processFeedback, src);

    if (feedId) {
      // cache cleanup when getDataFF outruns GetInjected
      cache.del(feedId.cacheKey); // envDelayed

      const env = await cache.pop(feedId.envKey);

      if (env) {
        env.forceContent = forceContent;
        env.scripts.map(prepareScript, env).filter(Boolean).forEach(processFeedback, src);
        return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["objectPick"])(env, ['cache', 'scripts']);
      }
    }
  }

});
/** @this {chrome.runtime.MessageSender} */

function processFeedback([key, needsInjection]) {
  const code = cacheCode.pop(key); // see TIME_KEEP_DATA comment

  if (needsInjection && code) {
    browser.tabs.executeScript(this.tab.id, {
      code,
      frameId: this.frameId,
      runAt: 'document_start'
    });
  }
}

const propsToClear = {
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].cache.prefix]: _db__WEBPACK_IMPORTED_MODULE_6__["ENV_CACHE_KEYS"],
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].code.prefix]: true,
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].require.prefix]: _db__WEBPACK_IMPORTED_MODULE_6__["ENV_REQ_KEYS"],
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].script.prefix]: true,
  [_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.prefix]: _db__WEBPACK_IMPORTED_MODULE_6__["ENV_VALUE_IDS"]
};
browser.storage.onChanged.addListener(async changes => {
  const dbKeys = Object.keys(changes);
  const cacheValues = await Promise.all(cache.getValues());
  const dirty = cacheValues.some(data => data.inject && dbKeys.some(key => {
    var _data$prop;

    const prefix = key.slice(0, key.indexOf(':') + 1);
    const prop = propsToClear[prefix];
    key = key.slice(prefix.length);
    return prop === true || ((_data$prop = data[prop]) == null ? void 0 : _data$prop.includes(prefix === _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_4__["default"].value.prefix ? +key : key));
  }));

  if (dirty) {
    cache.destroy();
  }
});

function normalizeRealm(value) {
  return safeCall(hasOwnProperty, _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECT_MAPPING"], value) ? value : injectInto || _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECT_AUTO"];
}

function onOptionChanged(changes) {
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachEntry"], changes, ([key, value]) => {
    switch (key) {
      case KEY_DEF_INJECT_INTO:
        injectInto = normalizeRealm(value);
        cache.destroy();
        break;

      case KEY_XHR_INJECT:
        toggleXhrInject(value);
        cache.destroy();
        break;

      case KEY_IS_APPLIED:
        togglePreinject(value);
        break;

      case KEY_EXPOSE:
        safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["forEachEntry"], value, ([site, isExposed]) => {
          expose[decodeURIComponent(site)] = isExposed;
        });
        break;

      default:
        if (key.includes('.')) {
          // used by `expose.url`
          onOptionChanged(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["objectSet"])({}, key, value));
        }

    }
  });
}
/** @return {Promise<Object>} */


function getInjectedScripts(url, tabId, frameId, forceContent) {
  const key = getKey(url, !frameId);
  return cache.pop(key) || prepare(key, url, tabId, frameId, forceContent);
}

function getKey(url, isTop) {
  return isTop ? url : `-${url}`;
}

function togglePreinject(enable) {
  isApplied = enable; // Using onSendHeaders because onHeadersReceived in Firefox fires *after* content scripts.
  // And even in Chrome a site may be so fast that preinject on onHeadersReceived won't be useful.

  const onOff = `${enable ? 'add' : 'remove'}Listener`;
  const config = enable ? API_CONFIG : undefined;
  browser.webRequest.onSendHeaders[onOff](onSendHeaders, config);

  if (!isApplied || !xhrInject) {
    // will be registered in toggleXhrInject
    browser.webRequest.onHeadersReceived[onOff](onHeadersReceived, config);
  }

  cache.destroy();
}

function toggleXhrInject(enable) {
  xhrInject = enable;
  browser.webRequest.onHeadersReceived.removeListener(onHeadersReceived);

  if (enable) {
    browser.webRequest.onHeadersReceived.addListener(onHeadersReceived, API_CONFIG, ['blocking', 'responseHeaders', browser.webRequest.OnHeadersReceivedOptions.EXTRA_HEADERS].filter(Boolean));
  }
}

function onSendHeaders({
  url,
  tabId,
  frameId
}) {
  if (!_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECTABLE_TAB_URL_RE"].test(url)) return;
  const isTop = !frameId;
  const key = getKey(url, isTop);

  if (!cache.has(key)) {
    // GetInjected message will be sent soon by the content script
    // and it may easily happen while getScriptsByURL is still waiting for browser.storage
    // so we'll let GetInjected await this pending data by storing Promise in the cache
    cache.put(key, prepare(key, url, tabId, frameId), TIME_AFTER_SEND);
  }
}
/** @param {chrome.webRequest.WebResponseHeadersDetails} info */


function onHeadersReceived(info) {
  const key = getKey(info.url, !info.frameId);
  const data = xhrInject && cache.get(key);
  cache.hit(key, TIME_AFTER_RECEIVE);
  return (data == null ? void 0 : data.inject) && prepareXhrBlob(info, data);
}
/**
 * @param {chrome.webRequest.WebResponseHeadersDetails} info
 * @param {VMGetInjectedDataContainer} data
 */


function prepareXhrBlob({
  url,
  responseHeaders
}, data) {
  if (url.startsWith('https:') && detectStrictCsp(responseHeaders)) {
    forceContentInjection(data);
  }

  const blobUrl = URL.createObjectURL(new Blob([JSON.stringify(data.inject)]));
  responseHeaders.push({
    name: 'Set-Cookie',
    value: `"${"Violentmonkey:LRWVgCrw+RY="}"=${blobUrl.split('/').pop()}; SameSite=Lax`
  });
  setTimeout(URL.revokeObjectURL, TIME_KEEP_DATA, blobUrl);
  return {
    responseHeaders
  };
}

function prepare(key, url, tabId, frameId, forceContent) {
  /** @namespace VMGetInjectedDataContainer */
  const res = {
    /** @namespace VMGetInjectedData */
    inject: {
      expose: !frameId && url.startsWith('https://') && expose[url.split('/', 3)[2]]
    }
  };
  return isApplied ? prepareScripts(res, key, url, tabId, frameId, forceContent) : res;
}

async function prepareScripts(res, cacheKey, url, tabId, frameId, forceContent) {
  const data = await Object(_db__WEBPACK_IMPORTED_MODULE_6__["getScriptsByURL"])(url, !frameId);
  const {
    envDelayed,
    scripts
  } = data;
  const isLate = forceContent != null;
  data.forceContent = forceContent;
  const feedback = scripts.map(prepareScript, data).filter(Boolean);
  const more = envDelayed.promise;
  const envKey = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getUniqId"])(`${tabId}:${frameId}:`);
  const {
    inject
  } = res;
  /** @namespace VMGetInjectedData */

  Object.assign(inject, {
    scripts,
    [INJECT_INTO]: injectInto,
    cache: data.cache,
    feedId: {
      cacheKey,
      // InjectionFeedback cache key for cleanup when getDataFF outruns GetInjected
      envKey // InjectionFeedback cache key for envDelayed

    },
    hasMore: !!more,
    // tells content bridge to expect envDelayed
    forceContent: forceContent || // Trying to skip page sandbox when xhrInject is on:
    feedback.length === scripts.length // ...when all `envStart` scripts are `content`,
    && envDelayed.scripts.every(scr => isContentRealm(scr, forceContent)) // and `envDelayed` too.
    ,
    ids: data.disabledIds,
    // content bridge adds the actually running ids and sends via SetPopup
    info: {
      ua: _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_5__["default"]
    }
  });
  /** @namespace VMGetInjectedDataContainer */

  Object.assign(res, {
    feedback,
    valOpIds: [...data[_db__WEBPACK_IMPORTED_MODULE_6__["ENV_VALUE_IDS"]], ...envDelayed[_db__WEBPACK_IMPORTED_MODULE_6__["ENV_VALUE_IDS"]]],
    rcsPromise: !isLate && !xhrInject && IS_FIREFOX ? registerScriptDataFF(inject, url, !!frameId) : null
  });
  if (more) cache.put(envKey, more);
  cache.put(cacheKey, res); // necessary for the synchronous onHeadersReceived

  return res;
}
/** @this {VMScriptByUrlData} */


function prepareScript(script) {
  var _meta$require;

  const {
    custom,
    meta,
    props
  } = script;
  const {
    id
  } = props;
  const {
    forceContent,
    require,
    value
  } = this;
  const code = this.code[id];
  const dataKey = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getUniqId"])('VMin');
  const displayName = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getScriptName"])(script);
  const name = encodeURIComponent(displayName.replace(/[#&',/:;?@=+]/g, replaceWithFullWidthForm));
  const isContent = isContentRealm(script, forceContent);
  const pathMap = custom.pathMap || {};
  const reqs = (_meta$require = meta.require) == null ? void 0 : _meta$require.map(key => require[pathMap[key] || key]).filter(Boolean); // trying to avoid progressive string concatenation of potentially huge code slices
  // adding `;` on a new line in case some required script ends with a line comment

  const reqsSlices = reqs ? [].concat(...reqs.map(req => [req, '\n;'])) : [];
  const hasReqs = reqsSlices.length;
  const injectedCode = [// hiding module interface from @require'd scripts so they don't mistakenly use it
  `window.${dataKey}=function(${dataKey}){try{with(this)((define,module,exports)=>{`, ...reqsSlices, // adding a nested IIFE to support 'use strict' in the code when there are @requires
  hasReqs ? '(()=>{' : '', code, // adding a new line in case the code ends with a line comment
  code.endsWith('\n') ? '' : '\n', hasReqs ? '})()' : '', // 0 at the end to suppress errors about non-cloneable result of executeScript in FF
  `})()}catch(e){${dataKey}(e)}};0`, // Firefox lists .user.js among our own content scripts so a space at start will group them
  `\n//# sourceURL=${_init__WEBPACK_IMPORTED_MODULE_7__["extensionRoot"]}${IS_FIREFOX ? '%20' : ''}${name}.user.js#${id}`].join('');
  cacheCode.put(dataKey, injectedCode, TIME_KEEP_DATA);
  /** @namespace VMInjectedScript */

  Object.assign(script, {
    dataKey,
    displayName,
    // code will be `true` if the desired realm is PAGE which is not injectable
    code: isContent ? '' : forceContent || injectedCode,
    metaStr: code.match(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["METABLOCK_RE"])[1] || '',
    values: value[id] || null
  });
  return isContent && [dataKey, true];
}

function replaceWithFullWidthForm(s) {
  // fullwidth range starts at 0xFF00, normal range starts at space char code 0x20
  return String.fromCharCode(s.charCodeAt(0) - 0x20 + 0xFF00);
}

const resolveDataCodeStr = `(${function _(data) {
  /* `function` is required to compile `this`, and `this` is required because our safe-globals
   * shadows `window` so its name is minified and hence inaccessible here */
  const {
    vmResolve
  } = this;

  if (vmResolve) {
    vmResolve(data);
  } else {
    // running earlier than the main content script for whatever reason
    this.vmData = data;
  }
}})`; // TODO: rework the whole thing to register scripts individually with real `matches`

function registerScriptDataFF(inject, url, allFrames) {
  var _browser$contentScrip;

  return (_browser$contentScrip = browser.contentScripts) == null ? void 0 : _browser$contentScrip.register({
    allFrames,
    js: [{
      code: `${resolveDataCodeStr}(${JSON.stringify(inject)})`
    }],
    matches: url.split('#', 1),
    runAt: 'document_start'
  });
}
/** @param {chrome.webRequest.HttpHeader[]} responseHeaders */


function detectStrictCsp(responseHeaders) {
  return responseHeaders.some(({
    name,
    value
  }) => /^content-security-policy$/i.test(name) && /^.(?!.*'unsafe-inline')/.test( // true if not empty and without 'unsafe-inline'
  value.match(/(?:^|;)\s*script-src-elem\s[^;]+/) || value.match(/(?:^|;)\s*script-src\s[^;]+/) || value.match(/(?:^|;)\s*default-src\s[^;]+/) || ''));
}
/** @param {VMGetInjectedDataContainer} data */


function forceContentInjection(data) {
  /** @type VMGetInjectedData */
  const inject = data.inject;
  inject.forceContent = true;
  inject.scripts.forEach(scr => {
    // When script wants `page`, the result below will be `true` so the script goes into `failedIds`
    scr.code = !isContentRealm(scr, true) || '';
    data.feedback.push([scr.dataKey, true]);
  });
}

function isContentRealm(scr, forceContent) {
  const realm = scr[INJECT_INTO] || (scr[INJECT_INTO] = normalizeRealm(scr.custom[INJECT_INTO] || scr.meta[INJECT_INTO]));
  return realm === _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECT_CONTENT"] || forceContent && realm === _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["INJECT_AUTO"];
}

/***/ }),

/***/ "./src/background/utils/requests.js":
/*!******************************************!*\
  !*** ./src/background/utils/requests.js ***!
  \******************************************/
/*! exports provided: clearRequestsByTabId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearRequestsByTabId", function() { return clearRequestsByTabId; });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/ua */ "./src/common/ua.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./script */ "./src/background/utils/script.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _m3u8__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./m3u8 */ "./src/background/utils/m3u8.js");
/* harmony import */ var _merge_video__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge-video */ "./src/background/utils/merge-video.js");










const reqHandler = {
  m3u8: _m3u8__WEBPACK_IMPORTED_MODULE_8__["downloadM3u8"],
  merge: _merge_video__WEBPACK_IMPORTED_MODULE_9__["mergeVideo"]
};
const VM_VERIFY = 'VM-Verify';
const CONFIRM_URL_BASE = `${_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"]}confirm/index.html#`;
/** @type {Object<string,VMHttpRequest>} */

const requests = {};
const downloads = {};
const verify = {};
const tabRequests = {};
const {
  chrome
} = global;
let encoder;

if (chrome) {
  chrome.downloads.onChanged.addListener(evt => {
    var _evt$state, _evt$state2;

    // console.info('downloads onChanged', evt);
    if (!downloads[evt.id]) return;
    const {
      req,
      src
    } = downloads[evt.id];
    const {
      tab: {
        id: tabId
      },
      frameId
    } = src;

    if (((_evt$state = evt.state) == null ? void 0 : _evt$state.current) === 'complete') {
      Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
        type: 'load',
        id: req.id,
        downloadId: evt.id
      }, {
        frameId
      });
    } else if (((_evt$state2 = evt.state) == null ? void 0 : _evt$state2.current) === 'interrupted') {
      Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
        type: 'error',
        id: req.id,
        downloadId: evt.id
      }, {
        frameId
      });
    } else {
      return;
    }

    delete downloads[evt.id];
    delete requests[req.id];
  });
}

Object.assign(_message__WEBPACK_IMPORTED_MODULE_7__["commands"], {
  ConfirmInstall: confirmInstall,

  async CheckInstallerTab(tabId, src) {
    const tab = IS_FIREFOX && (src.url || '').startsWith('file:') && (await browser.tabs.get(tabId).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"]));
    return tab && (tab.pendingUrl || tab.url || '').startsWith(CONFIRM_URL_BASE);
  },

  /** @return {void} */
  HttpRequest(opts, src) {
    const {
      tab: {
        id: tabId
      },
      frameId
    } = src;
    const {
      id,
      eventsToNotify
    } = opts;
    console.info('req opts', opts);

    if (reqHandler[opts.type]) {
      const downloadId = id; // fake downloadId for inject.js

      opts.src = src;
      opts.requests = requests; // needed to append req in mergeVideo

      opts.onprogress = (loaded, total) => {
        if (eventsToNotify == null ? void 0 : eventsToNotify.includes('progress')) {
          // console.info('onprogress', {loaded, total});
          Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
            type: 'progress',
            id,
            downloadId,
            loaded,
            total
          }, {
            frameId
          });
        }
      };

      opts.onload = () => {
        Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
          type: 'load',
          downloadId,
          id
        }, {
          frameId
        });
      };

      opts.onerror = error => {
        Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', {
          type: 'error',
          downloadId,
          id,
          error
        }, {
          frameId
        });
      };

      return reqHandler[opts.type](opts, httpRequest);
    }

    requests[id] = {
      id,
      tabId,
      eventsToNotify,
      xhr: new XMLHttpRequest()
    };
    (tabRequests[tabId] || (tabRequests[tabId] = {}))[id] = 1;
    httpRequest(opts, src, res => {
      // console.info({ res, req: requests[id] });
      if (requests[id]) {
        Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(tabId, 'HttpRequested', res, {
          frameId
        });
      }
    });
  },

  /** @return {void} */
  AbortRequest(id) {
    const req = requests[id];

    if (req) {
      // eslint-disable-next-line no-undef
      if (chrome) {
        // eslint-disable-next-line no-undef
        chrome.downloads.cancel(req.id);
        delete requests[req.id];
      } else {
        req.xhr.abort();
        clearRequest(req);
      }
    }
  },

  RevokeBlob(url) {
    const timer = _cache__WEBPACK_IMPORTED_MODULE_4__["default"].pop(`xhrBlob:${url}`);

    if (timer) {
      clearTimeout(timer);
      URL.revokeObjectURL(url);
    }
  }

});
const specialHeaders = ['user-agent', // https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name
// https://cs.chromium.org/?q=file:cc+symbol:IsForbiddenHeader%5Cb
'accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via']; // const tasks = {};

const HeaderInjector = (() => {
  /** @type chrome.webRequest.RequestFilter */
  const apiFilter = {
    urls: ['<all_urls>'],
    types: ['xmlhttprequest']
  };
  const EXTRA_HEADERS = [browser.webRequest.OnBeforeSendHeadersOptions.EXTRA_HEADERS].filter(Boolean);
  const headersToInject = {};
  /** @param {chrome.webRequest.HttpHeader} header */

  const isVmVerify = header => header.name === VM_VERIFY;

  const isNotCookie = header => !/^cookie2?$/i.test(header.name);

  const isSendable = header => header.name !== VM_VERIFY;

  const isSendableAnon = header => isSendable(header) && isNotCookie(header);

  const RE_SET_COOKIE = /^set-cookie2?$/i;
  const RE_SET_COOKIE_VALUE = /^\s*(?:__(Secure|Host)-)?([^=\s]+)\s*=\s*(")?([!#-+\--:<-[\]-~]*)\3(.*)/;
  const RE_SET_COOKIE_ATTR = /\s*;?\s*(\w+)(?:=(")?([!#-+\--:<-[\]-~]*)\2)?/y;
  const SAME_SITE_MAP = {
    strict: 'strict',
    lax: 'lax',
    none: 'no_restriction'
  };
  /**
   * @param {string} headerValue
   * @param {VMHttpRequest} req
   * @param {string} url
   */

  const setCookieInStore = (headerValue, req, url) => {
    let m = RE_SET_COOKIE_VALUE.exec(headerValue);

    if (m) {
      var _opt$sameSite;

      const [, prefix, name,, value, optStr] = m;
      const opt = {};
      const isHost = prefix === 'Host';
      RE_SET_COOKIE_ATTR.lastIndex = 0;

      while (m = RE_SET_COOKIE_ATTR.exec(optStr)) {
        opt[m[1].toLowerCase()] = m[3];
      }

      const sameSite = (_opt$sameSite = opt.sameSite) == null ? void 0 : _opt$sameSite.toLowerCase();
      browser.cookies.set({
        url,
        name,
        value,
        domain: isHost ? undefined : opt.domain,
        expirationDate: Math.max(0, +new Date(opt['max-age'] * 1000 || opt.expires)) || undefined,
        httpOnly: 'httponly' in opt,
        path: isHost ? '/' : opt.path,
        sameSite: SAME_SITE_MAP[sameSite],
        secure: url.startsWith('https:') && (!!prefix || sameSite === 'none' || 'secure' in opt),
        storeId: req.storeId
      });
    }
  };

  const apiEvents = {
    onBeforeSendHeaders: {
      options: ['requestHeaders', 'blocking', ...EXTRA_HEADERS],

      /** @param {chrome.webRequest.WebRequestHeadersDetails} details */
      listener({
        requestHeaders: headers,
        requestId
      }) {
        var _headers$find;

        // only the first call during a redirect/auth chain will have VM-Verify header
        const reqId = ((_headers$find = headers.find(isVmVerify)) == null ? void 0 : _headers$find.value) || verify[requestId];
        const req = reqId && requests[reqId];

        if (reqId && req) {
          verify[requestId] = reqId;
          req.coreId = requestId;
          headers = (req.noNativeCookie ? headers.filter(isNotCookie) : headers).concat(headersToInject[reqId] || []).filter(req.anonymous ? isSendableAnon : isSendable);
        }

        return {
          requestHeaders: headers
        };
      }

    },
    onHeadersReceived: {
      options: ['responseHeaders', 'blocking', ...EXTRA_HEADERS],

      /** @param {chrome.webRequest.WebRequestHeadersDetails} details */
      listener({
        responseHeaders: headers,
        requestId,
        url
      }) {
        const req = requests[verify[requestId]];

        if (req) {
          if (req.anonymous || req.storeId) {
            headers = headers.filter(h => !RE_SET_COOKIE.test(h.name) || !req.storeId || setCookieInStore(h.value, req, url));
          }

          req.responseHeaders = headers.map(encodeWebRequestHeader).join('');
          return {
            responseHeaders: headers
          };
        }
      }

    }
  }; // Chrome 74-91 needs an extraHeaders listener at tab load start, https://crbug.com/1074282
  // We're attaching a no-op in non-blocking mode so it's very lightweight and fast.

  if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].chrome >= 74 && _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].chrome <= 91) {
    browser.webRequest.onBeforeSendHeaders.addListener(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"], apiFilter, ['extraHeaders']);
  }

  return {
    add(reqId, headers) {
      // need to set the entry even if it's empty [] so that 'if' check in del() runs only once
      headersToInject[reqId] = headers; // need the listener to get the requestId

      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], apiEvents, ([name, {
        listener,
        options
      }]) => {
        browser.webRequest[name].addListener(listener, apiFilter, options);
      });
    },

    del(reqId) {
      if (reqId in headersToInject) {
        delete headersToInject[reqId];

        if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(headersToInject)) {
          safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], apiEvents, ([name, {
            listener
          }]) => {
            browser.webRequest[name].removeListener(listener);
          });
        }
      }
    }

  };
})();
/* 1MB takes ~20ms to encode/decode so it doesn't block the process of the extension and web page,
 * which lets us and them be responsive to other events or user input. */


const CHUNK_SIZE = 1e6;

async function blob2chunk(response, index) {
  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["blob2base64"])(response, index * CHUNK_SIZE, CHUNK_SIZE);
}

function blob2objectUrl(response) {
  const url = URL.createObjectURL(response);
  _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(`xhrBlob:${url}`, setTimeout(_message__WEBPACK_IMPORTED_MODULE_7__["commands"].RevokeBlob, 60e3, url), 61e3);
  return url;
}
/** @param {VMHttpRequest} req */


function xhrCallbackWrapper(req) {
  let lastPromise = Promise.resolve();
  let contentType;
  let dataSize;
  let numChunks;
  let response;
  let responseText;
  let responseHeaders; // let sent = false;

  const {
    id,
    blobbed,
    chunked,
    xhr
  } = req; // Chrome encodes messages to UTF8 so they can grow up to 4x but 64MB is the message size limit

  const getChunk = blobbed && blob2objectUrl || chunked && blob2chunk;

  const getResponseHeaders = () => {
    const headers = req.responseHeaders || xhr.getAllResponseHeaders();

    if (responseHeaders !== headers) {
      responseHeaders = headers;
      return {
        responseHeaders
      };
    }
  };

  return evt => {
    const type = evt.type;

    if (!contentType) {
      contentType = xhr.getResponseHeader('Content-Type') || 'application/octet-stream';
    }

    if (xhr.response !== response) {
      response = xhr.response; // sent = false;

      try {
        responseText = xhr.responseText;
        if (responseText === response) responseText = ['same'];
      } catch (e) {// ignore if responseText is unreachable
      }

      if ((blobbed || chunked) && response) {
        dataSize = response.size;
        numChunks = chunked && Math.ceil(dataSize / CHUNK_SIZE) || 1;
      }
    }

    const shouldNotify = req.eventsToNotify.includes(type); // only send response when XHR is complete

    const shouldSendResponse = xhr.readyState === 4 && shouldNotify;
    lastPromise = lastPromise.then(async () => {
      if (shouldSendResponse && blobbed && req.type === 'download') {
        if (req.fileName && chrome) {
          const blobUrl = URL.createObjectURL(response);
          return chrome.downloads.download({
            url: blobUrl,
            filename: req.fileName
          }, downloadId => {
            req.cb({
              blobbed,
              chunked,
              contentType,
              dataSize,
              id,
              type,
              data: {
                finalUrl: xhr.responseURL,
                response: '',
                responseText: downloadId
              }
            });
            URL.revokeObjectURL(blobUrl);
          });
        }

        return req.cb({
          blobbed,
          chunked,
          contentType,
          dataSize,
          id,
          type,
          data: response
        });
      } // console.info({ evt });


      await req.cb({
        blobbed,
        chunked,
        contentType,
        dataSize,
        id,
        numChunks,
        type,
        data: shouldNotify && _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
          finalUrl: xhr.responseURL
        }, getResponseHeaders(), {}, Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectPick"])(xhr, ['readyState', 'status', 'statusText']), {}, 'loaded' in evt && Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["objectPick"])(evt, ['lengthComputable', 'loaded', 'total']), {
          response: shouldSendResponse ? numChunks && (await getChunk(response, 0)) || response : null,
          responseText: shouldSendResponse ? responseText : null
        })
      });

      if (shouldSendResponse) {
        for (let i = 1; i < numChunks; i += 1) {
          await req.cb({
            id,
            chunk: {
              pos: i * CHUNK_SIZE,
              data: await getChunk(response, i),
              last: i + 1 === numChunks
            }
          });
        }
      }

      if (type === 'loadend') {
        clearRequest(req);
      }
    });
  };
}

function isSpecialHeader(lowerHeader) {
  return specialHeaders.includes(lowerHeader) || lowerHeader.startsWith('proxy-') || lowerHeader.startsWith('sec-');
}
/**
 * @param {Object} opts
 * @param {chrome.runtime.MessageSender | browser.runtime.MessageSender} src
 * @param {function} cb
 */


async function httpRequest(opts, src, cb) {
  const {
    tab
  } = src;
  const {
    incognito
  } = tab;
  const {
    anonymous,
    id,
    overrideMimeType,
    xhrType,
    url
  } = opts;
  const req = requests[id];
  if (!req || req.cb) return;
  req.cb = cb;
  req.type = opts.type;
  req.fileName = opts.fileName;
  req.anonymous = anonymous;
  const {
    xhr
  } = req;
  const vmHeaders = []; // Firefox can send Blob/ArrayBuffer directly

  const chunked = !IS_FIREFOX && incognito;
  const blobbed = xhrType && !IS_FIREFOX && !incognito;
  const [body, contentType] = decodeBody(opts.data); // Chrome can't fetch Blob URL in incognito so we use chunks

  req.blobbed = blobbed;
  req.chunked = chunked; // Firefox doesn't send cookies, https://github.com/violentmonkey/violentmonkey/issues/606
  // Both Chrome & FF need explicit routing of cookies in containers or incognito

  let shouldSendCookies = !anonymous && (incognito || IS_FIREFOX);
  xhr.open(opts.method || 'GET', url, true, opts.user || '', opts.password || '');
  xhr.setRequestHeader(VM_VERIFY, id);
  if (contentType) xhr.setRequestHeader('Content-Type', contentType);
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], opts.headers, ([name, value]) => {
    const lowerName = name.toLowerCase();

    if (isSpecialHeader(lowerName)) {
      vmHeaders.push({
        name,
        value
      });
    } else if (!lowerName.startsWith('vm-')) {
      // `VM-` headers are reserved
      xhr.setRequestHeader(name, value);
    }

    if (lowerName === 'cookie') {
      shouldSendCookies = false;
    }
  });
  xhr.responseType = (chunked || blobbed) && 'blob' || xhrType || 'text';
  xhr.timeout = Math.max(0, Math.min(0x7FFFFFFF, opts.timeout)) || 0;
  if (overrideMimeType) xhr.overrideMimeType(overrideMimeType);

  if (shouldSendCookies) {
    req.noNativeCookie = true;

    for (const store of await browser.cookies.getAllCookieStores()) {
      if (store.tabIds.includes(tab.id)) {
        if (IS_FIREFOX ? store.id !== 'firefox-default' : store.id !== '0') {
          /* Cookie routing. For the main store we rely on the browser.
           * The ids are hard-coded as `stores` may omit the main store if no such tabs are open. */
          req.storeId = store.id;
        }

        break;
      }
    }

    const now = Date.now() / 1000;
    const cookies = (await browser.cookies.getAll(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
      url,
      storeId: req.storeId
    }, _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox >= 59 && {
      firstPartyDomain: null
    }))).filter(c => c.session || c.expirationDate > now); // FF reports expired cookies!

    if (cookies.length) {
      vmHeaders.push({
        name: 'cookie',
        value: cookies.map(c => `${c.name}=${c.value};`).join(' ')
      });
    }
  }

  HeaderInjector.add(id, vmHeaders);
  const callback = xhrCallbackWrapper(req);
  req.eventsToNotify.forEach(evt => {
    xhr[`on${evt}`] = callback;
  });
  xhr.onloadend = callback; // always send it for the internal cleanup

  xhr.send(body);
}
/** @param {VMHttpRequest} req */


function clearRequest(req) {
  if (req.coreId) delete verify[req.coreId];
  delete requests[req.id];
  delete (tabRequests[req.tabId] || {})[req.id];
  HeaderInjector.del(req.id);
}
/** Polyfill for Chrome's inability to send complex types over extension messaging */


function decodeBody([body, type, wasBlob]) {
  if (type === 'query') {
    type = 'application/x-www-form-urlencoded';
  } else if (type) {
    // 5x times faster than fetch() which wastes time on inter-process communication
    const res = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["string2uint8array"])(atob(body.slice(body.indexOf(',') + 1)));

    if (!wasBlob) {
      type = body.match(/^data:(.+?);base64/)[1].replace(/(boundary=)[^;]+/, // using a function so it runs only if "boundary" was found
      (_, p1) => p1 + String.fromCharCode(...res.slice(2, res.indexOf(13))));
    }

    body = res;
  }

  return [body, type];
} // Watch URL redirects
// browser.webRequest.onBeforeRedirect.addListener(details => {
//   const reqId = verify[details.requestId];
//   if (reqId) {
//     const req = requests[reqId];
//     if (req) req.finalUrl = details.redirectUrl;
//   }
// }, {
//   urls: ['<all_urls>'],
//   types: ['xmlhttprequest'],
// });
// tasks are not necessary now, turned off
// Stop redirects
// browser.webRequest.onHeadersReceived.addListener(details => {
//   const task = tasks[details.requestId];
//   if (task) {
//     delete tasks[details.requestId];
//     if (task === 'Get-Location' && [301, 302, 303].includes(details.statusCode)) {
//       const locationHeader = details.responseHeaders.find(
//         header => header.name.toLowerCase() === 'location');
//       const base64 = locationHeader && locationHeader.value;
//       return {
//         redirectUrl: `data:text/plain;charset=utf-8,${base64 || ''}`,
//       };
//     }
//   }
// }, {
//   urls: ['<all_urls>'],
//   types: ['xmlhttprequest'],
// }, ['blocking', 'responseHeaders']);
// browser.webRequest.onCompleted.addListener(details => {
//   delete tasks[details.requestId];
// }, {
//   urls: ['<all_urls>'],
//   types: ['xmlhttprequest'],
// });
// browser.webRequest.onErrorOccurred.addListener(details => {
//   delete tasks[details.requestId];
// }, {
//   urls: ['<all_urls>'],
//   types: ['xmlhttprequest'],
// });


async function confirmInstall({
  code,
  from,
  url
}, {
  tab = {}
}) {
  if (!code) code = (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["request"])(url)).data; // TODO: display the error in UI

  if (!Object(_script__WEBPACK_IMPORTED_MODULE_5__["isUserScript"])(code)) throw Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["i18n"])('msgInvalidScript');
  _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(url, code, 3000);
  const confirmKey = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getUniqId"])();
  const {
    active,
    id: tabId,
    incognito
  } = tab; // Not testing tab.pendingUrl because it will be always equal to `url`

  const canReplaceCurTab = (!incognito || IS_FIREFOX) && (url === from || _cache__WEBPACK_IMPORTED_MODULE_4__["default"].has(`autoclose:${tabId}`) || /^(chrome:\/\/(newtab|startpage)\/|about:(home|newtab))$/.test(from));
  /** @namespace VMConfirmCache */

  _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(`confirm-${confirmKey}`, {
    incognito,
    url,
    from,
    tabId,
    ff: _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox
  });
  const confirmUrl = CONFIRM_URL_BASE + confirmKey;
  const {
    windowId
  } = canReplaceCurTab ? await browser.tabs.update(tabId, {
    url: confirmUrl
  }) : await _message__WEBPACK_IMPORTED_MODULE_7__["commands"].TabOpen({
    url: confirmUrl,
    active: !!active
  }, {
    tab
  });

  if (active && windowId !== tab.windowId) {
    await browser.windows.update(windowId, {
      focused: true
    });
  }
}

const whitelistRe = new RegExp(`^https://(${['greasyfork\\.org/scripts/%/code/', 'openuserjs\\.org/install/%/', 'github\\.com/%/%/raw/%/', 'github\\.com/%/%/releases/%/download/', 'raw\\.githubusercontent\\.com(/%){3}/', 'gist\\.github\\.com/.*?/'].join('|')})%?\\.user\\.js([?#]|$)`.replace(/%/g, '[^/]*'));
const blacklistRe = new RegExp(`^https://(${['(gist\\.)?github\\.com', 'greasyfork\\.org', 'openuserjs\\.org'].join('|')})/`);

const resolveVirtualUrl = url => `${_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"]}options/index.html#scripts/${+url.split('#')[1]}`; // FF can't intercept virtual .user.js URL via webRequest, so we redirect it explicitly


const virtualUrlRe = IS_FIREFOX && new RegExp(`^(view-source:)?(${_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"].replace('://', '$&)?')}[^/]*\\.user\\.js#\\d+`);

const maybeRedirectVirtualUrlFF = virtualUrlRe && ((tabId, src) => {
  if (virtualUrlRe.test(src)) {
    browser.tabs.update(tabId, {
      url: resolveVirtualUrl(src)
    });
  }
});

if (virtualUrlRe) {
  const listener = (tabId, {
    url
  }) => url && maybeRedirectVirtualUrlFF(tabId, url);

  const apiEvent = browser.tabs.onUpdated;
  const addListener = apiEvent.addListener.bind(apiEvent, listener);

  try {
    addListener({
      properties: ['url']
    });
  } catch (e) {
    addListener();
  }
}

browser.tabs.onCreated.addListener(tab => {
  const {
    id,
    title,
    url
  } = tab;
  /* Determining if this tab can be auto-closed (replaced, actually).
     FF>=68 allows reading file: URL only in the tab's content script so the tab must stay open. */

  if ((!url.startsWith('file:') || _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox < 68) && /\.user\.js([?#]|$)/.test(tab.pendingUrl || url)) {
    _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(`autoclose:${id}`, true, 10e3);
  }

  if (virtualUrlRe && url === 'about:blank') {
    maybeRedirectVirtualUrlFF(id, title);
  }
});
browser.webRequest.onBeforeRequest.addListener(req => {
  const {
    method,
    tabId,
    url
  } = req;

  if (method !== 'GET') {
    return;
  } // open a real URL for simplified userscript URL listed in devtools of the web page


  if (url.startsWith(_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"])) {
    return {
      redirectUrl: resolveVirtualUrl(url)
    };
  }

  if (!_cache__WEBPACK_IMPORTED_MODULE_4__["default"].has(`bypass:${url}`) && (!blacklistRe.test(url) || whitelistRe.test(url))) {
    maybeInstallUserJs(tabId, url);
    return {
      redirectUrl: 'javascript:void 0'
    }; // eslint-disable-line no-script-url
  }
}, {
  urls: [// 1. *:// comprises only http/https
  // 2. the API ignores #hash part
  // 3. Firefox: onBeforeRequest does not work with file:// or moz-extension://
  '*://*/*.user.js', '*://*/*.user.js?*', 'file://*/*.user.js', 'file://*/*.user.js?*', `${_init__WEBPACK_IMPORTED_MODULE_6__["extensionRoot"]}*.user.js`],
  types: ['main_frame']
}, ['blocking']);

async function maybeInstallUserJs(tabId, url) {
  const {
    data: code
  } = (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["request"])(url).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"])) || {};

  if (code && Object(_script__WEBPACK_IMPORTED_MODULE_5__["parseMeta"])(code).name) {
    const tab = tabId >= 0 && (await browser.tabs.get(tabId)) || {};
    confirmInstall({
      code,
      url,
      from: tab.url
    }, {
      tab
    });
  } else {
    _cache__WEBPACK_IMPORTED_MODULE_4__["default"].put(`bypass:${url}`, true, 10e3);
    if (tabId >= 0) browser.tabs.update(tabId, {
      url
    });
  }
} // In Firefox with production code of Violentmonkey, scripts can be injected before `tabs.onUpdated` is fired.
// Ref: https://github.com/violentmonkey/violentmonkey/issues/1255


browser.tabs.onRemoved.addListener(tabId => {
  clearRequestsByTabId(tabId);
});
function clearRequestsByTabId(tabId) {
  const set = tabRequests[tabId];

  if (set) {
    delete tabRequests[tabId];
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["forEachEntry"], set, ([id]) => _message__WEBPACK_IMPORTED_MODULE_7__["commands"].AbortRequest(id));
  }
}
/**
 * Imitating https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
 * Per the specification https://tools.ietf.org/html/rfc7230 the header name is within ASCII,
 * but we'll try encoding it, if necessary, to handle invalid server responses.
 */

function encodeWebRequestHeader({
  name,
  value,
  binaryValue
}) {
  return `${string2byteString(name)}: ${binaryValue ? Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["buffer2string"])(binaryValue) : string2byteString(value)}\r\n`;
}
/**
 * Returns a UTF8-encoded binary string i.e. one byte per character.
 * Returns the original string in case it was already within ASCII.
 */


function string2byteString(str) {
  if (!/[\u0080-\uFFFF]/.test(str)) return str;
  if (!encoder) encoder = new TextEncoder();
  return Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["buffer2string"])(encoder.encode(str));
}
/** @typedef {{
  anonymous: boolean
  blobbed: boolean
  cb: function(Object)
  chunked: boolean
  coreId: number
  eventsToNotify: string[]
  id: number
  noNativeCookie: boolean
  responseHeaders: string
  storeId: string
  tabId: number
  xhr: XMLHttpRequest
}} VMHttpRequest */

/***/ }),

/***/ "./src/background/utils/script.js":
/*!****************************************!*\
  !*** ./src/background/utils/script.js ***!
  \****************************************/
/*! exports provided: isUserScript, parseMeta, getDefaultCustom, newScript, getNameURI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUserScript", function() { return isUserScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseMeta", function() { return parseMeta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultCustom", function() { return getDefaultCustom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newScript", function() { return newScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNameURI", function() { return getNameURI; });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");







Object.assign(_message__WEBPACK_IMPORTED_MODULE_4__["commands"], {
  /** @return {string} */
  CacheNewScript(data) {
    const id = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getUniqId"])();
    _cache__WEBPACK_IMPORTED_MODULE_6__["default"].put(`new-${id}`, newScript(data));
    return id;
  },

  /** @return {VMScript} */
  NewScript(id) {
    return id && _cache__WEBPACK_IMPORTED_MODULE_6__["default"].get(`new-${id}`) || newScript();
  },

  ParseMeta: parseMeta
});
function isUserScript(text) {
  if (/^\s*</.test(text)) return false; // HTML

  if (text.indexOf('// ==UserScript==') < 0) return false; // Lack of meta block

  return true;
}
const arrayType = {
  default: () => [],
  transform: (res, val) => {
    res.push(val);
    return res;
  }
};
const defaultType = {
  default: () => null,
  transform: (res, val) => res == null ? val : res
};
const metaTypes = {
  include: arrayType,
  exclude: arrayType,
  match: arrayType,
  excludeMatch: arrayType,
  require: arrayType,
  resource: {
    default: () => ({}),
    transform: (res, val) => {
      const pair = val.match(/^(\w\S*)\s+(.*)/);
      if (pair) res[pair[1]] = pair[2];
      return res;
    }
  },
  grant: arrayType,
  noframes: {
    default: () => false,
    transform: () => true
  }
};
const metaOptionalTypes = {
  antifeature: arrayType,
  compatible: arrayType,
  connect: arrayType
};
function parseMeta(code) {
  // initialize meta
  const meta = safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_3__["mapEntry"], metaTypes, ([, value]) => value.default());
  const metaBody = code.match(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_2__["METABLOCK_RE"])[1] || '';
  metaBody.replace(/(?:^|\n)\s*\/\/\x20(@\S+)(.*)/g, (_match, rawKey, rawValue) => {
    const [keyName, locale] = rawKey.slice(1).split(':');
    const camelKey = keyName.replace(/[-_](\w)/g, (m, g) => g.toUpperCase());
    const key = locale ? `${camelKey}:${locale.toLowerCase()}` : camelKey;
    const val = rawValue.trim();
    const metaType = metaTypes[key] || metaOptionalTypes[key] || defaultType;
    let oldValue = meta[key];
    if (typeof oldValue === 'undefined') oldValue = metaType.default();
    meta[key] = metaType.transform(oldValue, val);
  });
  meta.resources = meta.resource;
  delete meta.resource; // @homepageURL: compatible with @homepage

  if (!meta.homepageURL && meta.homepage) meta.homepageURL = meta.homepage;
  return meta;
}
function getDefaultCustom() {
  return {
    origInclude: true,
    origExclude: true,
    origMatch: true,
    origExcludeMatch: true
  };
}
function newScript(data) {
  const state = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
    url: '*://*/*',
    name: '',
    date: new Date().toLocaleString()
  }, data);

  const code = Object(_options__WEBPACK_IMPORTED_MODULE_5__["getOption"])('scriptTemplate').replace(/{{(\w+)}}/g, (str, name) => {
    const value = state[name];
    return value == null ? str : value;
  });
  const script = {
    custom: getDefaultCustom(),
    config: {
      enabled: 1,
      shouldUpdate: 1
    },
    meta: parseMeta(code),
    props: {}
  };
  return {
    script,
    code
  };
}
function getNameURI(script) {
  const ns = script.meta.namespace || '';
  const name = script.meta.name || '';
  let nameURI = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["encodeFilename"])(`${ns}\n${name}\n`);
  if (!ns && !name) nameURI += script.props.id || '';
  return nameURI;
}

/***/ }),

/***/ "./src/background/utils/search.js":
/*!****************************************!*\
  !*** ./src/background/utils/search.js ***!
  \****************************************/
/*! exports provided: loadQuery, dumpQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadQuery", function() { return loadQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dumpQuery", function() { return dumpQuery; });
function loadQuery(string) {
  return string.split('&').reduce((data, piece) => {
    const [key, val] = piece.split('=').map(decodeURIComponent);
    data[key] = val;
    return data;
  }, {});
}
function dumpQuery(dict) {
  return Object.entries(dict).map(keyVal => keyVal.map(encodeURIComponent).join('=')).join('&');
}

/***/ }),

/***/ "./src/background/utils/storage-fetch.js":
/*!***********************************************!*\
  !*** ./src/background/utils/storage-fetch.js ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/storage */ "./src/common/storage.js");



/** @type { function(url, options, check): Promise<void> } or throws on error */

_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].cache.fetch = cacheOrFetch({
  init(options) {
    return _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, options, {
      responseType: 'blob'
    });
  },

  async transform(response, url, options, check) {
    const [type, body] = await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].cache.makeRaw(response, true);
    await (check == null ? void 0 : check(url, response.data, type));
    return `${type},${body}`;
  }

});
/** @type { function(url, options): Promise<void> } or throws on error */

_Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].require.fetch = cacheOrFetch({
  transform: ({
    data
  }, url) => /^\s*</.test(data) ? Promise.reject(`NOT_JS: ${url} "${data.slice(0, 100).trim().replace(/\s{2,}/g, ' ')}"`) : data
});

function cacheOrFetch(handlers = {}) {
  const requests = {};
  const {
    init,
    transform
  } = handlers;
  /** @this VMStorageBase */

  return function cacheOrFetchHandler(...args) {
    const [url] = args;
    const promise = requests[url] || (requests[url] = safeCall(doFetch, this, ...args));
    return promise;
  };
  /** @this VMStorageBase */

  async function doFetch(...args) {
    const [url, options] = args;

    try {
      const res = await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["request"])(url, (init == null ? void 0 : init(options)) || options);

      if (await isModified(res, url)) {
        const result = transform ? await transform(res, ...args) : res.data;
        await this.set(url, result);
      }
    } catch (err) {
      if (false) {}
      throw err;
    } finally {
      delete requests[url];
    }
  }
}

async function isModified({
  headers
}, url) {
  const mod = headers.get('etag') || +new Date(headers.get('last-modified')) || +new Date(headers.get('date'));

  if (!mod || mod !== (await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].mod.getOne(url))) {
    if (mod) await _Users_ZhaoJun_Desktop_violentmonkey_src_common_storage__WEBPACK_IMPORTED_MODULE_2__["default"].mod.set(url, mod);
    return true;
  }
}

/***/ }),

/***/ "./src/background/utils/tabs.js":
/*!**************************************!*\
  !*** ./src/background/utils/tabs.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/common/ua */ "./src/common/ua.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");







const openers = {};
Object.assign(_message__WEBPACK_IMPORTED_MODULE_5__["commands"], {
  /**
   * @param {string} [pathId] - path or id to add to #scripts route in dashboard,
     if absent a new script will be created for active tab's URL
   * @returns {Promise<{id: number}>}
   */
  async OpenEditor(pathId) {
    if (!pathId) {
      const {
        tab,
        domain
      } = await _message__WEBPACK_IMPORTED_MODULE_5__["commands"].GetTabDomain();
      const id = domain && _message__WEBPACK_IMPORTED_MODULE_5__["commands"].CacheNewScript({
        url: (tab.pendingUrl || tab.url).split(/[#?]/)[0],
        name: `${Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])('scriptTemplateEdited') ? '' : '- '}${domain}`
      });
      pathId = `_new${id ? `/${id}` : ''}`;
    }

    const url = `${_init__WEBPACK_IMPORTED_MODULE_4__["extensionRoot"]}options/index.html#scripts/${pathId}`; // Firefox until v56 doesn't support moz-extension:// pattern in browser.tabs.query()

    for (const view of browser.extension.getViews()) {
      if (view.location.href === url) {
        // deep-copying to avoid dead objects
        const tab = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_2__["deepCopy"])((await view.browser.tabs.getCurrent()));
        browser.tabs.update(tab.id, {
          active: true
        });
        browser.windows.update(tab.windowId, {
          focused: true
        });
        return tab;
      }
    }

    return _message__WEBPACK_IMPORTED_MODULE_5__["commands"].TabOpen({
      url,
      maybeInWindow: true
    });
  },

  /** @return {Promise<{ id: number } | chrome.tabs.Tab>} new tab is returned for internal calls */
  async TabOpen({
    url,
    active = true,
    container,
    insert = true,
    maybeInWindow = false,
    pinned
  }, src = {}) {
    // src.tab may be absent when invoked from popup (e.g. edit/create buttons)
    const srcTab = src.tab || (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getActiveTab"])()) || {}; // src.url may be absent when invoked directly as commands.TabOpen

    const srcUrl = src.url;
    const isInternal = !srcUrl || srcUrl.startsWith(_init__WEBPACK_IMPORTED_MODULE_4__["extensionRoot"]); // only incognito storeId may be specified when opening in an incognito window

    const {
      incognito,
      windowId
    } = srcTab; // Chrome can't open chrome-xxx: URLs in incognito windows

    let storeId = srcTab.cookieStoreId;

    if (storeId && !incognito) {
      storeId = getContainerId(isInternal ? 0 : container) || storeId;
    }

    if (storeId) storeId = {
      cookieStoreId: storeId
    }; // URL needs to be expanded for `canOpenIncognito` below

    if (!/^[-\w]+:/.test(url)) {
      url = isInternal ? browser.runtime.getURL(url) : Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["getFullUrl"])(url, srcUrl);
    }

    const canOpenIncognito = !incognito || IS_FIREFOX || !/^(chrome[-\w]*):/.test(url);
    let newTab;

    if (maybeInWindow && browser.windows && Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])('editorWindow')
    /* cookieStoreId in windows.create() is supported since FF64 https://bugzil.la/1393570
     * and a workaround is too convoluted to add it for such an ancient version */
    && (!storeId || _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox >= 64)) {
      const wndOpts = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        url,
        incognito: canOpenIncognito && incognito
      }, Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])('editorWindowSimple') && {
        type: 'popup'
      }, {}, !IS_FIREFOX && {
        focused: !!active
      }, {}, storeId);

      const pos = Object(_options__WEBPACK_IMPORTED_MODULE_6__["getOption"])('editorWindowPos');
      const hasPos = pos && 'top' in pos;
      const wnd = (await browser.windows.create(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, wndOpts, {}, pos)).catch(hasPos && _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"])) || hasPos && (await browser.windows.create(wndOpts));
      newTab = wnd.tabs[0];
    }

    if (!newTab) {
      newTab = await browser.tabs.create(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        url,
        // normalizing as boolean because the API requires strict types
        active: !!active,
        pinned: !!pinned
      }, storeId, {}, canOpenIncognito && _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        windowId
      }, insert && {
        index: srcTab.index + 1
      }, {}, _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].openerTabIdSupported && {
        openerTabId: srcTab.id
      })));
    }

    const {
      id
    } = newTab;

    if (active && newTab.windowId !== windowId) {
      await browser.windows.update(newTab.windowId, {
        focused: true
      });
    }

    openers[id] = srcTab.id;
    return isInternal ? newTab : {
      id
    };
  },

  /** @return {void} */
  TabClose({
    id
  } = {}, src) {
    var _src$tab;

    const tabId = id || (src == null ? void 0 : (_src$tab = src.tab) == null ? void 0 : _src$tab.id);
    if (tabId >= 0) browser.tabs.remove(tabId);
  },

  TabFocus(_, src) {
    browser.tabs.update(src.tab.id, {
      active: true
    }).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"]);
    browser.windows.update(src.tab.windowId, {
      focused: true
    }).catch(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["noop"]);
  }

}); // Firefox Android does not support `openerTabId` field, it fails if this field is passed
// XXX openerTabId seems buggy on Chrome, https://crbug.com/967150
// It seems to do nothing even set successfully with `browser.tabs.update`.

_Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].ready.then(() => {
  Object.defineProperties(_Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"], {
    openerTabIdSupported: {
      value: !IS_FIREFOX || _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].firefox >= 57 && _Users_ZhaoJun_Desktop_violentmonkey_src_common_ua__WEBPACK_IMPORTED_MODULE_3__["default"].os !== 'android'
    }
  });
});
browser.tabs.onRemoved.addListener(id => {
  const openerId = openers[id];

  if (openerId >= 0) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_1__["sendTabCmd"])(openerId, 'TabClosed', id);
    delete openers[id];
  }
});

function getContainerId(index) {
  return index === 0 && 'firefox-default' || index > 0 && `firefox-container-${index}`;
}

/***/ }),

/***/ "./src/background/utils/template-hook.js":
/*!***********************************************!*\
  !*** ./src/background/utils/template-hook.js ***!
  \***********************************************/
/*! exports provided: SCRIPT_TEMPLATE, resetScriptTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCRIPT_TEMPLATE", function() { return SCRIPT_TEMPLATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetScriptTemplate", function() { return resetScriptTemplate; });
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");


const SCRIPT_TEMPLATE = 'scriptTemplate';
const SCRIPT_TEMPLATE_EDITED = `${SCRIPT_TEMPLATE}Edited`;
const INITIAL_TEMPLATE = `\
// ==UserScript==
// @name New Script
// @namespace Violentmonkey Scripts
// @match {{url}}
// @grant none
// ==/UserScript==
`;
_init__WEBPACK_IMPORTED_MODULE_0__["postInitialize"].push(() => {
  let edited = Object(_options__WEBPACK_IMPORTED_MODULE_1__["getOption"])(SCRIPT_TEMPLATE_EDITED); // Preserve an edited template

  if (edited) return;
  const template = Object(_options__WEBPACK_IMPORTED_MODULE_1__["getOption"])(SCRIPT_TEMPLATE); // When updating from an old version, set the edited flag retroactively

  if (edited == null) {
    edited = template !== INITIAL_TEMPLATE;
    if (edited) Object(_options__WEBPACK_IMPORTED_MODULE_1__["setOption"])(SCRIPT_TEMPLATE_EDITED, true);else resetScriptTemplate(); // When updating VM, update to the new default template
  } else if (template !== Object(_options__WEBPACK_IMPORTED_MODULE_1__["getDefaultOption"])(SCRIPT_TEMPLATE)) {
    resetScriptTemplate();
  }
});
function resetScriptTemplate(changes = {}) {
  const defaultTemplate = Object(_options__WEBPACK_IMPORTED_MODULE_1__["getDefaultOption"])(SCRIPT_TEMPLATE);
  let template = changes[SCRIPT_TEMPLATE];

  if (!template) {
    template = defaultTemplate;
    changes[SCRIPT_TEMPLATE] = template;
    Object(_options__WEBPACK_IMPORTED_MODULE_1__["setOption"])(SCRIPT_TEMPLATE, template);
  }

  const edited = template !== defaultTemplate;

  if (edited !== changes[SCRIPT_TEMPLATE_EDITED]) {
    changes[SCRIPT_TEMPLATE_EDITED] = edited;
    Object(_options__WEBPACK_IMPORTED_MODULE_1__["setOption"])(SCRIPT_TEMPLATE_EDITED, edited);
  }
}

/***/ }),

/***/ "./src/background/utils/tester.js":
/*!****************************************!*\
  !*** ./src/background/utils/tester.js ***!
  \****************************************/
/*! exports provided: testGlob, testMatch, testScript, testBlacklist, resetBlacklist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testGlob", function() { return testGlob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testMatch", function() { return testMatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testScript", function() { return testScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testBlacklist", function() { return testBlacklist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetBlacklist", function() { return resetBlacklist; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common/tld */ "./src/common/tld.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache */ "./src/background/utils/cache.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "./src/background/utils/init.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");





Object.assign(_message__WEBPACK_IMPORTED_MODULE_3__["commands"], {
  TestBlacklist: testBlacklist
});
_init__WEBPACK_IMPORTED_MODULE_2__["postInitialize"].push(resetBlacklist);
_Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["initTLD"](true);
const RE_MATCH_PARTS = /(.*?):\/\/([^/]*)\/(.*)/;
let blacklistRules = [];
Object(_options__WEBPACK_IMPORTED_MODULE_4__["hookOptions"])(changes => {
  if ('blacklist' in changes) resetBlacklist(changes.blacklist || '');
});
const RE_HTTP_OR_HTTPS = /^https?$/i;
/*
 Simple FIFO queue for the results of testBlacklist, cached separately from the main |cache|
 because the blacklist is updated only once in a while so its entries would be crowding
 the main cache and reducing its performance (objects with lots of keys are slow to access).

 We also don't need to auto-expire the entries after a timeout.
 The only limit we're concerned with is the overall memory used.
 The limit is specified in the amount of unicode characters (string length) for simplicity.
 Disregarding deduplication due to interning, the actual memory used is approximately twice as big:
 2 * keyLength + objectStructureOverhead * objectCount
*/

const MAX_BL_CACHE_LENGTH = 100e3;
let blCache = {};
let blCacheSize = 0;

function testRules(url, rules, prefix, ruleBuilder) {
  return rules.some(rule => {
    const key = `${prefix}:${rule}`;
    const matcher = _cache__WEBPACK_IMPORTED_MODULE_1__["default"].get(key) || _cache__WEBPACK_IMPORTED_MODULE_1__["default"].put(key, ruleBuilder(rule));
    return matcher.test(url);
  });
}
/**
 * Test glob rules like `@include` and `@exclude`.
 */


function testGlob(url, rules) {
  return testRules(url, rules, 're', autoReg);
}
/**
 * Test match rules like `@match` and `@exclude_match`.
 */

function testMatch(url, rules) {
  return testRules(url, rules, 'match', matchTester);
}
function testScript(url, script) {
  _cache__WEBPACK_IMPORTED_MODULE_1__["default"].batch(true);
  const {
    custom,
    meta
  } = script;
  const mat = mergeLists(custom.origMatch && meta.match, custom.match);
  const inc = mergeLists(custom.origInclude && meta.include, custom.include);
  const exc = mergeLists(custom.origExclude && meta.exclude, custom.exclude);
  const excMat = mergeLists(custom.origExcludeMatch && meta.excludeMatch, custom.excludeMatch); // match all if no @match or @include rule

  let ok = !mat.length && !inc.length; // @match

  ok = ok || testMatch(url, mat); // @include

  ok = ok || testGlob(url, inc); // @exclude-match

  ok = ok && !testMatch(url, excMat); // @exclude

  ok = ok && !testGlob(url, exc);
  _cache__WEBPACK_IMPORTED_MODULE_1__["default"].batch(false);
  return ok;
}

function mergeLists(...args) {
  return args.reduce((res, item) => item ? res.concat(item) : res, []);
}

function str2RE(str) {
  const re = str.replace(/([.?+[\]{}()|^$])/g, '\\$1').replace(/\*/g, '.*?');
  return re;
}

function bindRE(re) {
  return re.test.bind(re);
}

function autoReg(str) {
  // regexp mode: case-insensitive per GM documentation
  if (str.length > 1 && str[0] === '/' && str[str.length - 1] === '/') {
    let re;

    try {
      re = new RegExp(str.slice(1, -1), 'i');
    } catch (e) {
      /* ignore */
    }

    return {
      test: re ? bindRE(re) : () => false
    };
  } // glob mode: case-insensitive to match GM4 & Tampermonkey bugged behavior


  const reStr = str2RE(str.toLowerCase());

  if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["isReady"]() && str.includes('.tld/')) {
    const reTldStr = reStr.replace('\\.tld/', '((?:\\.[-\\w]+)+)/');
    return {
      test: tstr => {
        const matches = tstr.toLowerCase().match(reTldStr);

        if (matches) {
          const suffix = matches[1].slice(1);
          if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["getPublicSuffix"](suffix) === suffix) return true;
        }

        return false;
      }
    };
  }

  const re = new RegExp(`^${reStr}$`, 'i'); // String with wildcards

  return {
    test: bindRE(re)
  };
}

function matchScheme(rule, data) {
  // exact match
  if (rule === data) return 1; // * = http | https
  // support http*

  if (['*', 'http*'].includes(rule) && RE_HTTP_OR_HTTPS.test(data)) return 1;
  return 0;
}

const RE_STR_ANY = '(?:|.*?\\.)';
const RE_STR_TLD = '((?:\\.[-\\w]+)+)';

function hostMatcher(rule) {
  // * matches all
  if (rule === '*') {
    return () => 1;
  } // *.example.com
  // www.google.*
  // www.google.tld


  const ruleLC = rule.toLowerCase(); // host matching is case-insensitive

  let prefix = '';
  let base = ruleLC;
  let suffix = '';

  if (rule.startsWith('*.')) {
    base = base.slice(2);
    prefix = RE_STR_ANY;
  }

  if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["isReady"]() && rule.endsWith('.tld')) {
    base = base.slice(0, -4);
    suffix = RE_STR_TLD;
  }

  const re = new RegExp(`^${prefix}${str2RE(base)}${suffix}$`);
  return data => {
    // exact match, case-insensitive
    data = data.toLowerCase();
    if (ruleLC === data) return 1; // full check

    const matches = data.match(re);

    if (matches) {
      const [, tldStr] = matches;
      if (!tldStr) return 1;
      const tldSuffix = tldStr.slice(1);
      return _Users_ZhaoJun_Desktop_violentmonkey_src_common_tld__WEBPACK_IMPORTED_MODULE_0__["getPublicSuffix"](tldSuffix) === tldSuffix;
    }

    return 0;
  };
}

function pathMatcher(rule) {
  const iHash = rule.indexOf('#');
  let iQuery = rule.indexOf('?');
  let strRe = str2RE(rule);
  if (iQuery > iHash) iQuery = -1;

  if (iHash < 0) {
    if (iQuery < 0) strRe = `^${strRe}(?:[?#]|$)`;else strRe = `^${strRe}(?:#|$)`;
  }

  return bindRE(new RegExp(strRe));
}

function matchTester(rule) {
  let test;

  if (rule === '<all_urls>') {
    test = () => true;
  } else {
    const ruleParts = rule.match(RE_MATCH_PARTS);

    if (ruleParts) {
      const matchHost = hostMatcher(ruleParts[2]);
      const matchPath = pathMatcher(ruleParts[3]);

      test = url => {
        const parts = url.match(RE_MATCH_PARTS);
        return !!ruleParts && !!parts && matchScheme(ruleParts[1], parts[1]) && matchHost(parts[2]) && matchPath(parts[3]);
      };
    } else {
      // Ignore invalid match rules
      test = () => false;
    }
  }

  return {
    test
  };
}

function testBlacklist(url) {
  let res = blCache[url];

  if (res === undefined) {
    const rule = blacklistRules.find(({
      test
    }) => test(url));
    res = (rule == null ? void 0 : rule.reject) && rule.text;
    updateBlacklistCache(url, res || false);
  }

  return res;
}
function resetBlacklist(list) {
  _cache__WEBPACK_IMPORTED_MODULE_1__["default"].batch(true);
  const rules = list == null ? Object(_options__WEBPACK_IMPORTED_MODULE_4__["getOption"])('blacklist') : list;

  if (false) {} // XXX compatible with {Array} list in v2.6.1-


  blacklistRules = (Array.isArray(rules) ? rules : (rules || '').split('\n')).map(text => {
    text = text.trim();
    if (!text || text.startsWith('#')) return null;
    const mode = text.startsWith('@') && text.split(/\s/, 1)[0];
    const rule = mode ? text.slice(mode.length + 1).trim() : text;
    const reject = mode !== '@include' && mode !== '@match'; // @include and @match = whitelist

    const {
      test
    } = mode === '@include' || mode === '@exclude' && autoReg(rule) || !mode && !rule.includes('/') && matchTester(`*://${rule}/*`) // domain
    || matchTester(rule); // @match and @exclude-match

    return {
      reject,
      test,
      text
    };
  }).filter(Boolean);
  blCache = {};
  blCacheSize = 0;
  _cache__WEBPACK_IMPORTED_MODULE_1__["default"].batch(false);
}

function updateBlacklistCache(key, value) {
  blCache[key] = value;
  blCacheSize += key.length;

  if (blCacheSize > MAX_BL_CACHE_LENGTH) {
    Object.keys(blCache).some(k => {
      blCacheSize -= k.length;
      delete blCache[k]; // reduce the cache to 75% so that this function doesn't run too often.

      return blCacheSize < MAX_BL_CACHE_LENGTH * 3 / 4;
    });
  }
}

/***/ }),

/***/ "./src/background/utils/update.js":
/*!****************************************!*\
  !*** ./src/background/utils/update.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/consts */ "./src/common/consts.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "./src/background/utils/db.js");
/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./script */ "./src/background/utils/script.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./options */ "./src/background/utils/options.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");






Object.assign(_message__WEBPACK_IMPORTED_MODULE_5__["commands"], {
  /** @return {Promise<true?>} */
  async CheckUpdate(id) {
    const script = Object(_db__WEBPACK_IMPORTED_MODULE_2__["getScriptById"])(id);
    const results = await checkAllAndNotify([script]);
    return results[0];
  },

  /** @return {Promise<boolean>} */
  async CheckUpdateAll() {
    Object(_options__WEBPACK_IMPORTED_MODULE_4__["setOption"])('lastUpdate', Date.now());
    const toUpdate = Object(_db__WEBPACK_IMPORTED_MODULE_2__["getScripts"])().filter(item => item.config.shouldUpdate);
    const results = await checkAllAndNotify(toUpdate);
    return results.includes(true);
  }

});

async function checkAllAndNotify(scripts) {
  const notes = [];
  const results = await Promise.all(scripts.map(item => checkUpdate(item, notes)));

  if (notes.length === 1) {
    notify(notes[0]);
  } else if (notes.length) {
    notify({
      // FF doesn't show notifications of type:'list' so we'll use `text` everywhere
      text: notes.map(n => n.text).join('\n'),
      onClick: browser.runtime.openOptionsPage
    });
  }

  return results;
}

const processes = {}; // resolves to true if successfully updated

function checkUpdate(script, notes) {
  const {
    id
  } = script.props;
  const promise = processes[id] || (processes[id] = doCheckUpdate(script, notes));
  return promise;
}

async function doCheckUpdate(script, notes) {
  const {
    id
  } = script.props;
  let msgOk;
  let msgErr;
  let resourceOpts;

  try {
    const {
      update
    } = await Object(_db__WEBPACK_IMPORTED_MODULE_2__["parseScript"])({
      id,
      code: await downloadUpdate(script),
      update: {
        checking: false
      }
    });
    msgOk = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgScriptUpdated', [Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["getScriptName"])(update)]);
    resourceOpts = {
      cache: 'no-cache'
    };
    return true;
  } catch (update) {
    msgErr = update.error; // Either proceed with normal fetch on no-update or skip it altogether on error

    resourceOpts = !update.error && !update.checking && {};
    if (false) {}
  } finally {
    if (resourceOpts && !_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["IS_DEV"]) {
      // DEVresource
      msgErr = await Object(_db__WEBPACK_IMPORTED_MODULE_2__["fetchResources"])(script, null, resourceOpts);
      if (false) {}
    }

    if (canNotify(script) && (msgOk || msgErr)) {
      notes.push({
        script,
        text: safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["trueJoin"], [msgOk, msgErr], '\n')
      });
    }

    delete processes[id];
  }
}

async function downloadUpdate({
  props: {
    id
  },
  meta,
  custom
}) {
  const downloadURL = custom.downloadURL || meta.downloadURL || custom.lastInstallURL;
  let updateURL = custom.updateURL || meta.updateURL || downloadURL;

  if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["IS_DEV"] && updateURL) {
    if (meta.dev) {
      const urls = updateURL.split('/');
      updateURL = `http://127.0.0.1:${meta.dev}/${urls[urls.length - 1]}`;
    } else {
      updateURL = null;
    } // console.info('downloadUpdate', id, updateURL);

  }

  if (!updateURL) throw false;
  let errorMessage;
  const update = {};
  const result = {
    update,
    where: {
      id
    }
  };
  announce(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgCheckingForUpdate'));

  try {
    const {
      data
    } = await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["request"])(updateURL, {
      // TODO: do a HEAD request first to get ETag header and compare to storage.mod
      cache: 'no-cache',
      headers: {
        Accept: 'text/x-userscript-meta,*/*'
      }
    });
    const {
      version
    } = Object(_script__WEBPACK_IMPORTED_MODULE_3__["parseMeta"])(data);

    if (_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["IS_DEV"]) {
      if (meta.version === version) throw false;
      console.info('update', meta.name, version, Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["compareVersion"])(meta.version, version));
      return data;
    }

    if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["compareVersion"])(meta.version, version) >= 0) {
      announce(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgNoUpdate'), {
        checking: false
      });
    } else if (!downloadURL) {
      announce(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgNewVersion'), {
        checking: false
      });
    } else {
      announce(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgUpdating'));
      errorMessage = Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgErrorFetchingScript');
      return (await Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["request"])(downloadURL, {
        cache: 'no-cache'
      })).data;
    }
  } catch (error) {
    if (false) {}
    announce(errorMessage || Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('msgErrorFetchingUpdateInfo'), {
      error
    });
  }

  throw update;

  function announce(message, {
    error,
    checking = !error
  } = {}) {
    Object.assign(update, {
      message,
      checking,
      error: error ? `${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('genericError')} ${error.status}, ${error.url}` : null // `null` is transferable in Chrome unlike `undefined`

    });
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendCmd"])(_Users_ZhaoJun_Desktop_violentmonkey_src_common_consts__WEBPACK_IMPORTED_MODULE_1__["CMD_SCRIPT_UPDATE"], result);
  }
}

function canNotify(script) {
  var _script$config$notify;

  const allowed = Object(_options__WEBPACK_IMPORTED_MODULE_4__["getOption"])('notifyUpdates');
  return Object(_options__WEBPACK_IMPORTED_MODULE_4__["getOption"])('notifyUpdatesGlobal') ? allowed : (_script$config$notify = script.config.notifyUpdates) != null ? _script$config$notify : allowed;
}

function notify({
  script,
  text,
  onClick = () => _message__WEBPACK_IMPORTED_MODULE_5__["commands"].OpenEditor(script.props.id)
}) {
  _message__WEBPACK_IMPORTED_MODULE_5__["commands"].Notification({
    text,
    // FF doesn't show the name of the extension in the title of the notification
    title: IS_FIREFOX ? `${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('titleScriptUpdated')} - ${Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["i18n"])('extName')}` : ''
  }, undefined, {
    onClick
  });
}

/***/ }),

/***/ "./src/background/utils/values.js":
/*!****************************************!*\
  !*** ./src/background/utils/values.js ***!
  \****************************************/
/*! exports provided: resetValueOpener, addValueOpener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetValueOpener", function() { return resetValueOpener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addValueOpener", function() { return addValueOpener; });
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/common */ "./src/common/index.js");
/* harmony import */ var _Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/object */ "./src/common/object.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "./src/background/utils/db.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message */ "./src/background/utils/message.js");




const openers = {}; // { scriptId: { tabId: { frameId: 1, ... }, ... } }

let cache = {}; // { scriptId: { key: { last: value, tabId: { frameId: value } } } }

let updateScheduled;
Object.assign(_message__WEBPACK_IMPORTED_MODULE_3__["commands"], {
  /** @return {Promise<Object>} */
  async GetValueStore(id) {
    const stores = await Object(_db__WEBPACK_IMPORTED_MODULE_2__["getValueStoresByIds"])([id]);
    return stores[id] || {};
  },

  /** @param {{ where, store }[]} data
   * @return {Promise<void>} */
  async SetValueStores(data) {
    // Value store will be replaced soon.
    const stores = data.reduce((res, {
      where,
      store
    }) => {
      var _getScript;

      const id = where.id || ((_getScript = Object(_db__WEBPACK_IMPORTED_MODULE_2__["getScript"])(where)) == null ? void 0 : _getScript.props.id);
      if (id) res[id] = store;
      return res;
    }, {});
    await Promise.all([Object(_db__WEBPACK_IMPORTED_MODULE_2__["dumpValueStores"])(stores), broadcastValueStores(groupStoresByFrame(stores))]);
  },

  /** @return {void} */
  UpdateValue({
    id,
    key,
    value = null
  }, src) {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(cache, [id, key, 'last'], value);
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(cache, [id, key, src.tab.id, src.frameId], value);
    updateLater();
  }

});
browser.tabs.onRemoved.addListener(resetValueOpener);
browser.tabs.onReplaced.addListener((addedId, removedId) => resetValueOpener(removedId));
function resetValueOpener(tabId) {
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], openers, ([id, openerTabs]) => {
    if (tabId in openerTabs) {
      delete openerTabs[tabId];
      if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(openerTabs)) delete openers[id];
    }
  });
}
function addValueOpener(tabId, frameId, scriptIds) {
  scriptIds.forEach(id => {
    Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(openers, [id, tabId, frameId], 1);
  });
}

async function updateLater() {
  while (!updateScheduled) {
    updateScheduled = true;
    await 0;
    const currentCache = cache;
    cache = {};
    await doUpdate(currentCache);
    updateScheduled = false;
    if (Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(cache)) break;
  }
}

async function doUpdate(currentCache) {
  const ids = Object.keys(currentCache);
  const valueStores = await Object(_db__WEBPACK_IMPORTED_MODULE_2__["getValueStoresByIds"])(ids);
  ids.forEach(id => {
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], currentCache[id], ([key, {
      last
    }]) => {
      Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(valueStores, [id, key], last || undefined);
    });
  });
  await Promise.all([Object(_db__WEBPACK_IMPORTED_MODULE_2__["dumpValueStores"])(valueStores), broadcastValueStores(groupCacheByFrame(currentCache), {
    partial: true
  })]);
}

async function broadcastValueStores(tabFrameData, {
  partial
} = {}) {
  const tasks = [];

  for (const [tabId, frames] of Object.entries(tabFrameData)) {
    for (const [frameId, frameData] of Object.entries(frames)) {
      if (!Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(frameData)) {
        if (partial) frameData.partial = true;
        tasks.push(Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common__WEBPACK_IMPORTED_MODULE_0__["sendTabCmd"])(+tabId, 'UpdatedValues', frameData, {
          frameId: +frameId
        }));
        if (tasks.length === 20) await Promise.all(tasks.splice(0)); // throttling
      }
    }
  }

  await Promise.all(tasks);
} // Returns per tab/frame data with only the changed values


function groupCacheByFrame(cacheData) {
  const toSend = {};
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], cacheData, ([id, scriptData]) => {
    const dataEntries = Object.entries(scriptData);
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], openers[id], ([tabId, frames]) => {
      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachKey"], frames, frameId => {
        dataEntries.forEach(([key, history]) => {
          var _history$tabId;

          // Skipping this frame if its last recorded value is identical
          if (history.last !== ((_history$tabId = history[tabId]) == null ? void 0 : _history$tabId[frameId])) {
            Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(toSend, [tabId, frameId, id, key], history.last);
          }
        });
      });
    });
  });
  return toSend;
} // Returns per tab/frame data


function groupStoresByFrame(stores) {
  const toSend = {};
  safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], stores, ([id, store]) => {
    safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachEntry"], openers[id], ([tabId, frames]) => {
      safeCall(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["forEachKey"], frames, frameId => {
        Object(_Users_ZhaoJun_Desktop_violentmonkey_src_common_object__WEBPACK_IMPORTED_MODULE_1__["objectSet"])(toSend, [tabId, frameId, id], store);
      });
    });
  });
  return toSend;
}

/***/ }),

/***/ "./src/common/events.js":
/*!******************************!*\
  !*** ./src/common/events.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EventEmitter; });
class EventEmitter {
  constructor(allowed) {
    this.events = {};
    this.allowed = allowed;
  }

  checkType(type) {
    if (this.allowed && !this.allowed.includes(type)) {
      throw new Error(`Unknown event type: ${type}`);
    }
  }

  on(type, handle) {
    this.checkType(type);
    const {
      events
    } = this;
    let handlers = events[type];

    if (!handlers) {
      handlers = [];
      events[type] = handlers;
    }

    return () => this.off(type, handle);
  }

  off(type, handle) {
    this.checkType(type);
    const handlers = this.events[type];

    if (handlers) {
      const i = handlers.indexOf(handle);
      if (i >= 0) handlers.splice(i, 1);
    }
  }

  emit(type, data) {
    this.checkType(type);
    const handlers = this.events[type];

    if (handlers) {
      const evt = {
        type,
        data,
        defaultPrevented: false,

        preventDefault() {
          evt.defaultPrevented = true;
        }

      };
      handlers.some(handle => {
        handle(evt);
        return evt.defaultPrevented;
      });
    }
  }

}

/***/ }),

/***/ "./src/common/tld.js":
/*!***************************!*\
  !*** ./src/common/tld.js ***!
  \***************************/
/*! exports provided: initTLD, isReady, getDomain, getSubdomain, getPublicSuffix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initTLD", function() { return initTLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReady", function() { return isReady; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDomain", function() { return getDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSubdomain", function() { return getSubdomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPublicSuffix", function() { return getPublicSuffix; });
/* harmony import */ var tldjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tldjs */ "./node_modules/tldjs/index.js");
/* harmony import */ var tldjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tldjs__WEBPACK_IMPORTED_MODULE_0__);
 // import { fromUserSettings } from 'tldjs';
// import Trie from 'tldjs/lib/suffix-trie';
// import { request } from '#/common';
// let tldjs;
// export function initTLD(remote) {
//   // TLD rules are too large to be packed, download them at runtime.
//   const url = 'https://violentmonkey.top/static/tld-rules.json';
//   const key = 'dat:tldRules';
//   browser.storage.local.get(key)
//   .then(({ [key]: tldRules }) => {
//     if (tldRules) return tldRules;
//     if (!remote) return Promise.reject('ignore TLD');
//     return request(url, { responseType: 'json' })
//     .then(({ data: rules }) => {
//       console.info('Downloaded public suffix data');
//       return browser.storage.local.set({ [key]: rules })
//       .then(() => rules);
//     });
//   })
//   .then(tldRules => {
//     console.info('Initialized TLD');
//     tldjs = fromUserSettings({ rules: Trie.fromJson(tldRules) });
//   })
//   .catch(err => {
//     if (process.env.DEBUG) console.error(err);
//     console.info('Failed initializing TLD');
//   });
// }

function initTLD() {}

function exportMethod(key) {
  return (...args) => tldjs__WEBPACK_IMPORTED_MODULE_0___default.a && tldjs__WEBPACK_IMPORTED_MODULE_0___default.a[key](...args);
}

function isReady() {
  return !!tldjs__WEBPACK_IMPORTED_MODULE_0___default.a;
}
const getDomain = exportMethod('getDomain');
const getSubdomain = exportMethod('getSubdomain');
const getPublicSuffix = exportMethod('getPublicSuffix');

/***/ })

/******/ });}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy9icm93c2VyL2RlZmF1bHRPcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmZtcGVnL2ZmbXBlZy9zcmMvYnJvd3Nlci9mZXRjaEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy9icm93c2VyL2dldENyZWF0ZUZGbXBlZ0NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy9icm93c2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmZtcGVnL2ZmbXBlZy9zcmMvY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmZtcGVnL2ZmbXBlZy9zcmMvY3JlYXRlRkZtcGVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmZtcGVnL2ZmbXBlZy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy91dGlscy9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy91dGlscy9wYXJzZUFyZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmZm1wZWcvZmZtcGVnL3NyYy91dGlscy9wYXJzZVByb2dyZXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamJpbmFyeS9kaXN0L2Jyb3dzZXIvamJpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamRhdGF2aWV3L2Rpc3Qvbm9kZS9qZGF0YXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21wZWd0c190b19tcDQvbXBlZ3RzX3RvX21wNC9hZHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvaDI2NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXBlZ3RzX3RvX21wNC9tcGVndHNfdG9fbXA0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvbXA0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvbXBlZ3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvcGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXVybC9yZXNvbHZlLXVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wbHVnaW4vZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3BsdWdpbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9zeW5jL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvc3luYy9kcm9wYm94LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3N5bmMvZ29vZ2xlZHJpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvc3luYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9zeW5jL29uZWRyaXZlLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3N5bmMvd2ViZGF2LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL2Flcy1kZWNyeXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvY2xpcGJvYXJkLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL2RiLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy9ob3RrZXlzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL2ljb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvaW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy9tM3U4LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL21lcmdlLXZpZGVvLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL21lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvbm90aWZpY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy9vcHRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3BhdGNoLWRiLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3BvcHVwLXRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvcHJlaW5qZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3JlcXVlc3RzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3NjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy9zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvc3RvcmFnZS1mZXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy90YWJzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3RlbXBsYXRlLWhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvdXRpbHMvdGVzdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3V0aWxzL3VwZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC91dGlscy92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi90bGQuanMiXSwibmFtZXMiOlsiaG9va09wdGlvbnMiLCJjaGFuZ2VzIiwiYXV0b1VwZGF0ZSIsIlNDUklQVF9URU1QTEFURSIsInJlc2V0U2NyaXB0VGVtcGxhdGUiLCJzZW5kQ21kIiwiT2JqZWN0IiwiYXNzaWduIiwiY29tbWFuZHMiLCJHZXREYXRhIiwiaWRzIiwiZGF0YSIsImdldERhdGEiLCJzeW5jIiwiR2V0SW5qZWN0ZWQiLCJ1cmwiLCJmb3JjZUNvbnRlbnQiLCJzcmMiLCJmcmFtZUlkIiwidGFiIiwidGFiSWQiLCJpZCIsInJlc2V0VmFsdWVPcGVuZXIiLCJjbGVhclJlcXVlc3RzQnlUYWJJZCIsInJlcyIsImdldEluamVjdGVkU2NyaXB0cyIsImZlZWRiYWNrIiwiaW5qZWN0IiwidmFsT3BJZHMiLCJpc1BvcHVwU2hvd24iLCJwb3B1cFRhYnMiLCJsZW5ndGgiLCJzZXRUaW1lb3V0IiwiSW5qZWN0aW9uRmVlZGJhY2siLCJhZGRWYWx1ZU9wZW5lciIsIkdldFRhYkRvbWFpbiIsImdldEFjdGl2ZVRhYiIsInBlbmRpbmdVcmwiLCJob3N0IiwibWF0Y2giLCJkb21haW4iLCJ0bGQiLCJTZXRUaW1lb3V0IiwibXMiLCJtYWtlUGF1c2UiLCJjb21tYW5kc1RvU3luYyIsImNvbW1hbmRzVG9TeW5jSWZUcnV0aHkiLCJoYW5kbGVDb21tYW5kTWVzc2FnZSIsInJlcSIsImNtZCIsImluY2x1ZGVzIiwiaW50ZXJ2YWwiLCJJU19ERVYiLCJnZXRPcHRpb24iLCJUSU1FT1VUXzI0SE9VUlMiLCJlbGFwc2VkIiwiRGF0ZSIsIm5vdyIsImNsZWFyVGltZW91dCIsInRpbWVyIiwiTWF0aCIsIm1pbiIsIlRJTUVPVVRfTUFYIiwiaW5pdEJ1aWxkaW4iLCJyZXF1ZXN0IiwiQlVJTERfSU5fU0NSSVBUX1NSQyIsImNhY2hlIiwiaGVhZGVycyIsIkFjY2VwdCIsIlBhcnNlU2NyaXB0IiwiY29kZSIsImN1c3RvbSIsImJ1aWxkSW4iLCJ3aGVyZSIsImluaXRpYWxpemUiLCJnbG9iYWwiLCJkZWVwQ29weSIsImJyb3dzZXIiLCJydW50aW1lIiwib25NZXNzYWdlIiwiYWRkTGlzdGVuZXIiLCJJU19GSVJFRk9YIiwiYXJncyIsImNhdGNoIiwiZSIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImNvbnNvbGUiLCJpbmZvIiwiY2hlY2tSZW1vdmUiLCJzZXRJbnRlcnZhbCIsImFwaSIsImNocm9tZSIsImRlY2xhcmF0aXZlQ29udGVudCIsIm9uUGFnZUNoYW5nZWQiLCJnZXRSdWxlcyIsInJ1bGUiLCJuZXdJZCIsInByb2Nlc3MiLCJyZW1vdmVSdWxlcyIsImFkZFJ1bGVzIiwiY29uZGl0aW9ucyIsIlBhZ2VTdGF0ZU1hdGNoZXIiLCJwYWdlVXJsIiwidXJsQ29udGFpbnMiLCJhY3Rpb25zIiwiUmVxdWVzdENvbnRlbnRTY3JpcHQiLCJqcyIsImdldE1hbmlmZXN0IiwiY29udGVudF9zY3JpcHRzIiwiRXZlbnRFbWl0dGVyIiwic2NyaXB0IiwidXBkYXRlIiwibGlzdCIsImdldFNjcmlwdHMiLCJnZXQiLCJHZXRTY3JpcHRDb2RlIiwicmVtb3ZlIiwiTWFya1JlbW92ZWQiLCJyZW1vdmVkIiwic2VydmljZU5hbWVzIiwic2VydmljZUNsYXNzZXMiLCJzZXJ2aWNlcyIsImF1dG9TeW5jIiwiZGVib3VuY2UiLCJUSU1FT1VUX0hPVVIiLCJ3b3JraW5nIiwicmVzb2x2ZSIsInN5bmNDb25maWciLCJnZXRJdGVtRmlsZW5hbWUiLCJuYW1lIiwidXJpIiwiaXNTY3JpcHRGaWxlIiwidGVzdCIsImdldFVSSSIsImkiLCJpbmRleE9mIiwidmVyc2lvbiIsInNsaWNlIiwic3BsaXQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlcnIiLCJpbml0Q29uZmlnIiwia2V5IiwiZGVmIiwia2V5cyIsIm5vcm1hbGl6ZUtleXMiLCJ1bnNoaWZ0Iiwic2V0IiwidmFsdWUiLCJzZXRPcHRpb24iLCJpbml0IiwiY29uZmlnIiwic2VydmljZUNvbmZpZyIsImdldEtleXMiLCJ2YWwiLCJmb3JFYWNoRW50cnkiLCJrIiwidiIsImNsZWFyIiwic2VydmljZVN0YXRlIiwidmFsaWRTdGF0ZXMiLCJpbml0aWFsU3RhdGUiLCJvbkNoYW5nZSIsInN0YXRlIiwibmV3U3RhdGUiLCJ3YXJuIiwiaXMiLCJzdGF0ZXMiLCJlbnN1cmVBcnJheSIsImdldFN0YXRlcyIsIm1hcCIsInNlcnZpY2UiLCJkaXNwbGF5TmFtZSIsImF1dGhTdGF0ZSIsInN5bmNTdGF0ZSIsImxhc3RTeW5jIiwicHJvZ3Jlc3MiLCJwcm9wZXJ0aWVzIiwidXNlckNvbmZpZyIsImdldFVzZXJDb25maWciLCJnZXRTY3JpcHREYXRhIiwic3luY1ZlcnNpb24iLCJleHRyYSIsInByb3BzIiwib2JqZWN0UGljayIsIm1vcmUiLCJlbmFibGVkIiwic2hvdWxkVXBkYXRlIiwibGFzdFVwZGF0ZWQiLCJwYXJzZVNjcmlwdERhdGEiLCJyYXciLCJvYmoiLCJKU09OIiwicGFyc2UiLCJvYmplY3RQdXJpZnkiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwic2VydmljZUZhY3RvcnkiLCJiYXNlIiwiU2VydmljZSIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiZXh0ZW5kIiwiZXh0ZW5kU2VydmljZSIsIm9wdGlvbnMiLCJjcmVhdGUiLCJvblN0YXRlQ2hhbmdlIiwiQmFzZVNlcnZpY2UiLCJkZWxheVRpbWUiLCJ1cmxQcmVmaXgiLCJtZXRhRmlsZSIsImF1dGhUeXBlIiwibm9vcCIsInNldFVzZXJDb25maWciLCJmaW5pc2hlZCIsInRvdGFsIiwibGFzdEZldGNoIiwic3RhcnRTeW5jIiwic3luY0ZhY3RvcnkiLCJldmVudHMiLCJnZXRFdmVudEVtaXR0ZXIiLCJsb2ciLCJwcm9taXNlIiwiZGVib3VuY2VkUmVzb2x2ZSIsInNob3VsZFN5bmMiLCJnZXRDdXJyZW50IiwiZ2V0UmVhZHkiLCJ0aGVuIiwiZXJyb3IiLCJwcmVwYXJlSGVhZGVycyIsInByZXBhcmUiLCJpbml0VG9rZW4iLCJ1c2VyIiwidHlwZSIsImNoZWNrU3luYyIsImFjcXVpcmVMb2NrIiwicmVsZWFzZUxvY2siLCJoYW5kbGVNZXRhRXJyb3IiLCJnZXRNZXRhIiwidG9rZW4iLCJBdXRob3JpemF0aW9uIiwibG9hZERhdGEiLCJkZWxheSIsInRzIiwic3RhcnRzV2l0aCIsInByZWZpeCIsImdldExvY2FsRGF0YSIsInBsdWdpblNjcmlwdCIsImdldFN5bmNEYXRhIiwicmVtb3RlTWV0YSIsImFsbCIsInJlbW90ZURhdGEiLCJsb2NhbERhdGEiLCJyZW1vdGVNZXRhRGF0YSIsInJlbW90ZU1ldGFJbmZvIiwicmVtb3RlVGltZXN0YW1wIiwidGltZXN0YW1wIiwicmVtb3RlQ2hhbmdlZCIsImdsb2JhbExhc3RNb2RpZmllZCIsInJlbW90ZUl0ZW1NYXAiLCJsb2NhbE1ldGEiLCJmaXJzdFN5bmMiLCJvdXRkYXRlZCIsInB1dExvY2FsIiwicHV0UmVtb3RlIiwiZGVsUmVtb3RlIiwiZGVsTG9jYWwiLCJ1cGRhdGVMb2NhbCIsInJlZHVjZSIsIml0ZW0iLCJpdGVtSW5mbyIsIm1vZGlmaWVkIiwicG9zaXRpb24iLCJsYXN0TW9kaWZpZWQiLCJyZW1vdGVJbmZvIiwicmVtb3RlSXRlbSIsInB1c2giLCJsb2NhbCIsInJlbW90ZSIsInByb21pc2VRdWV1ZSIsIm9iamVjdFNldCIsInB1dCIsInN0cmluZ2lmeSIsInVwZGF0ZXMiLCJ1cGRhdGVTY3JpcHRJbmZvIiwic29ydFNjcmlwdHMiLCJjaGFuZ2VkIiwic2NyaXB0cyIsInByb21pc2VzIiwiZXJyb3JzIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJlZ2lzdGVyIiwiRmFjdG9yeSIsImdldFNlcnZpY2UiLCJzeW5jT25lIiwiYXV0aG9yaXplIiwicmV2b2tlIiwic2V0Q29uZmlnIiwib3BlbkF1dGhQYWdlIiwicmVkaXJlY3RVcmkiLCJ1bnJlZ2lzdGVyV2ViUmVxdWVzdCIsIndlYlJlcXVlc3QiLCJvbkJlZm9yZVJlcXVlc3QiLCJ1cmxzIiwidHlwZXMiLCJ0YWJzIiwiY2hlY2tBdXRoIiwiY2FuY2VsIiwicmVtb3ZlTGlzdGVuZXIiLCJjbGllbnRfaWQiLCJyZWRpcmVjdF91cmkiLCJlc2NSRSIsImVzY0Z1bmMiLCJtIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwianNvblN0cmluZ2lmeVNhZmUiLCJzdHJpbmciLCJyZXBsYWNlIiwiRHJvcGJveCIsIm1ldGhvZCIsInN0YXR1cyIsImJvZHkiLCJwYXRoIiwicmVzcG9uc2VUeXBlIiwiZW50cmllcyIsIm5vcm1hbGl6ZSIsIm1vZGUiLCJwYXJhbXMiLCJyZXNwb25zZV90eXBlIiwiZHVtcFF1ZXJ5IiwiYXV0aG9yaXplZCIsImxvYWRRdWVyeSIsImFjY2Vzc190b2tlbiIsInVpZCIsInNpemUiLCJjbGllbnRfc2VjcmV0Iiwic2NvcGUiLCJVTkFVVEhPUklaRUQiLCJHb29nbGVEcml2ZSIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJncmFudF90eXBlIiwicmVxdWVzdFVzZXIiLCJhY2Nlc3NfdHlwZSIsIm5vdGlmeSIsInRpdGxlIiwib2JqZWN0R2V0Iiwic3BhY2VzIiwiZmllbGRzIiwiZmlsZXMiLCJtZXRhSXRlbSIsImdvdE1ldGEiLCJwcm9tcHQiLCJib3VuZGFyeSIsImdldFVuaXFJZCIsIm1ldGFkYXRhIiwicGFyZW50cyIsImpvaW4iLCJTeW5jQXV0aG9yaXplIiwiU3luY1Jldm9rZSIsIlN5bmNTdGFydCIsIlN5bmNTZXRDb25maWciLCJPbmVEcml2ZSIsImhlYWRlciIsImZpbGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ1c2VyX2lkIiwiS0VZX0NISUxEUkVOIiwiU3ltYm9sIiwiWE5vZGUiLCJub2RlIiwibnNNYXAiLCJwYXJzZUF0dHJzIiwicGFyc2VOYW1lIiwiZnJvbVhNTCIsInhtbCIsInBhcnNlciIsIkRPTVBhcnNlciIsImRvYyIsInBhcnNlRnJvbVN0cmluZyIsImF0dHJzIiwiYXR0cmlidXRlcyIsImF0dHIiLCIkIiwibm9kZVR5cGUiLCJ0YWdOYW1lIiwibnMiLCJ0ZXh0IiwidGV4dENvbnRlbnQiLCJ0cmltIiwiY2hpbGRyZW4iLCJjaGlsZCIsImNhbGxiYWNrIiwiZ2V0Q2FsbGJhY2siLCJmaW5kIiwiREVGQVVMVF9DT05GSUciLCJzZXJ2ZXJVcmwiLCJhbm9ueW1vdXMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiV2ViREFWIiwiZW5kc1dpdGgiLCJVUkwiLCJhdXRoIiwid2luZG93IiwiYnRvYSIsImNhbGwiLCJjcmVkZW50aWFscyIsIm1rZGlyIiwicmVhZGRpciIsImRlcHRoIiwiaXRlbXMiLCJwcm9wIiwiZGlzcGxheU5hbWVOb2RlIiwidW5kZWZpbmVkIiwiaHJlZiIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwibG9jayIsIklmIiwicmVtb3ZlUGFkZGluZyIsImJ1ZmZlciIsIm91dHB1dEJ5dGVzIiwiYnl0ZUxlbmd0aCIsInBhZGRpbmdCeXRlcyIsIkRhdGFWaWV3IiwiZ2V0VWludDgiLCJBRVNEZWNyeXB0b3IiLCJyY29uIiwic3ViTWl4IiwiVWludDMyQXJyYXkiLCJpbnZTdWJNaXgiLCJzQm94IiwiaW52U0JveCIsImluaXRUYWJsZSIsInVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyIsImFycmF5QnVmZmVyIiwidmlldyIsIm5ld0FycmF5IiwiZ2V0VWludDMyIiwic3ViTWl4MCIsInN1Yk1peDEiLCJzdWJNaXgyIiwic3ViTWl4MyIsImludlN1Yk1peDAiLCJpbnZTdWJNaXgxIiwiaW52U3ViTWl4MiIsImludlN1Yk1peDMiLCJkIiwieCIsInhpIiwic3giLCJ4MiIsIng0IiwieDgiLCJ0IiwiZXhwYW5kS2V5Iiwia2V5QnVmZmVyIiwic2FtZUtleSIsIm9mZnNldCIsImtleVNpemUiLCJrc1Jvd3MiLCJrc1JvdyIsImludktzUm93Iiwia2V5U2NoZWR1bGUiLCJpbnZLZXlTY2hlZHVsZSIsInNib3giLCJwcmV2IiwibmV0d29ya1RvSG9zdE9yZGVyU3dhcCIsIndvcmQiLCJkZWNyeXB0IiwiaW5wdXRBcnJheUJ1ZmZlciIsImFlc0lWIiwicmVtb3ZlUEtDUzdQYWRkaW5nIiwiblJvdW5kcyIsImludlNCT1giLCJpbml0VmVjdG9yIiwiaW5pdFZlY3RvcjAiLCJpbml0VmVjdG9yMSIsImluaXRWZWN0b3IyIiwiaW5pdFZlY3RvcjMiLCJpbnB1dEludDMyIiwiSW50MzJBcnJheSIsIm91dHB1dEludDMyIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzMCIsInMxIiwiczIiLCJzMyIsImlucHV0V29yZHMwIiwiaW5wdXRXb3JkczEiLCJpbnB1dFdvcmRzMiIsImlucHV0V29yZHMzIiwic3dhcFdvcmQiLCJkZXN0cm95IiwiaW5pdENhY2hlIiwibGlmZXRpbWUiLCJDYWNoZUxvYWQiLCJDYWNoZUhpdCIsImhpdCIsIkNhY2hlUG9wIiwicG9wIiwidGV4dGFyZWEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGlwYm9hcmREYXRhIiwiU2V0Q2xpcGJvYXJkIiwiZm9jdXMiLCJyZXQiLCJleGVjQ29tbWFuZCIsImFwcGVuZENoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInByZXZlbnREZWZhdWx0Iiwic2V0RGF0YSIsInN0b3JlIiwic3RvcmFnZSIsInNldERhdGFDYWNoZSIsImRhdGFDYWNoZSIsIm9uRHVtcCIsInNjcmlwdE1hcCIsIkNoZWNrUG9zaXRpb24iLCJDaGVja1JlbW92ZSIsIkdldFNjcmlwdCIsImdldFNjcmlwdCIsIkV4cG9ydFppcCIsInZhbHVlcyIsImdldFByb3BzSWQiLCJjb2RlTWFwIiwiZ2V0TXVsdGkiLCJnZXRPbmUiLCJHZXRTY3JpcHRWZXIiLCJvcHRzIiwibWV0YSIsIk1vdmUiLCJnZXRTY3JpcHRCeUlkIiwiaW5kZXgiLCJzcGxpY2UiLCJub3JtYWxpemVQb3NpdGlvbiIsIlJlbW92ZVNjcmlwdCIsIlBhcnNlTWV0YSIsInBhcnNlTWV0YSIsInBhcnNlU2NyaXB0IiwiVXBkYXRlU2NyaXB0SW5mbyIsIlZhY3V1bSIsInZhY3V1bSIsInByZUluaXRpYWxpemUiLCJsYXN0VmVyc2lvbiIsInBhdGNoREIiLCJzdG9yZUluZm8iLCJpZE1hcCIsInVyaU1hcCIsIm1vZHMiLCJyZXNVcmxzIiwicmVtZW1iZXJVcmwiLCJfIiwiZ2V0SW50IiwiZ2V0TmFtZVVSSSIsImdldERlZmF1bHRDdXN0b20iLCJtYXgiLCJwYXRoTWFwIiwiZ3JhbnQiLCJTZXQiLCJyZXF1aXJlIiwicmVzb3VyY2VzIiwiaWNvbiIsIm1vZCIsInJlbW92ZU11bHRpIiwiZGVmYXVsdEluamVjdEludG8iLCJJTkpFQ1RfUEFHRSIsImNvbXBhcmVWZXJzaW9uIiwiSU5KRUNUX0FVVE8iLCJ1cGRhdGVMYXN0TW9kaWZpZWQiLCJkdW1wIiwic29ydCIsImEiLCJiIiwiZ2V0VmFsdWVTdG9yZXNCeUlkcyIsImR1bXBWYWx1ZVN0b3JlcyIsInZhbHVlRGljdCIsIkVOVl9DQUNIRV9LRVlTIiwiRU5WX1JFUV9LRVlTIiwiRU5WX1ZBTFVFX0lEUyIsIkdNVkFMVUVTX1JFIiwiUlVOX0FUX1JFIiwiZ2V0U2NyaXB0c0J5VVJMIiwiaXNUb3AiLCJhbGxTY3JpcHRzIiwidGVzdEJsYWNrbGlzdCIsIm5vZnJhbWVzIiwidGVzdFNjcmlwdCIsImRpc2FibGVkSWRzIiwiZW52U3RhcnQiLCJlbnZEZWxheWVkIiwiYnVpbGRQYXRoTWFwIiwicnVuQXQiLCJlbnYiLCJzb21lIiwicmVhZEVudmlyb25tZW50RGF0YSIsIlNUT1JBR0VfUk9VVEVTIiwicmV0cmllZFN0b3JhZ2VLZXlzIiwiaXNSZXRyeSIsImFyZWEiLCJzcmNJZHMiLCJnZXRLZXkiLCJlcnIyIiwiZ2V0SWNvbkNhY2hlIiwiaWNvblVybHMiLCJpc1JlbW90ZSIsIm1ha2VEYXRhVXJpIiwiZm9yY2UiLCJ0b1JlbW92ZSIsIlRJTUVPVVRfV0VFSyIsImdldFVVSUQiLCJybmQiLCJVaW50MTZBcnJheSIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInNhdmVTY3JpcHQiLCJvbGRTY3JpcHQiLCJ1dWlkIiwicmFuZG9tVVVJRCIsImkxOG4iLCJDTURfU0NSSVBUX1VQREFURSIsInJlc3VsdCIsIm1lc3NhZ2UiLCJpc05ldyIsIm5ld1NjcmlwdCIsIkNNRF9TQ1JJUFRfQUREIiwiaG9tZXBhZ2VVUkwiLCJmcm9tIiwibGFzdEluc3RhbGxVUkwiLCJmZXRjaFJlc291cmNlcyIsInBsdWdpbkV2ZW50cyIsImVtaXQiLCJiYXNlVXJsIiwiZnVsbFVybCIsImdldEZ1bGxVcmwiLCJyZXNvdXJjZUNhY2hlIiwicmVxT3B0aW9ucyIsInNuYXRjaCIsInZhbGlkYXRvciIsImNvbnRlbnRzIiwiZmV0Y2giLCJ2YWxpZGF0ZUltYWdlIiwiaWdub3JlRGVwc0Vycm9ycyIsInRydWVKb2luIiwiZm9ybWF0SHR0cEVycm9yIiwiYnVmIiwiYmxvYlVybCIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJvbkRvbmUiLCJyZXZva2VPYmplY3RVUkwiLCJpbWFnZSIsIkltYWdlIiwib25sb2FkIiwib25lcnJvciIsIl92YWN1dW1pbmciLCJudW1GaXhlcyIsInJlc29sdmVTZWxmIiwiciIsInRvRmV0Y2giLCJrZXlzVG9SZW1vdmUiLCJ2YWx1ZUtleXMiLCJjYWNoZUtleXMiLCJyZXF1aXJlS2V5cyIsImNvZGVLZXlzIiwibWFwcGluZ3MiLCJmb3JFYWNoS2V5Iiwic3Vic3RvcmUiLCJ0b3VjaCIsInNjcmlwdElkIiwiZm9yRWFjaFZhbHVlIiwiZ2V0U2NyaXB0TmFtZSIsImZpeGVzIiwib24iLCJvZmYiLCJmaXJlIiwiZnVuYyIsInBvc3RJbml0aWFsaXplIiwib25Db21tYW5kIiwiT3BlbkVkaXRvciIsInJvdXRlIiwiVGFiT3BlbiIsIkNBQ0hFX0RVUkFUSU9OIiwiR2V0SW1hZ2VEYXRhIiwibG9hZEltYWdlRGF0YSIsImJhc2U2NCIsIlNldEJhZGdlIiwic2V0QmFkZ2UiLCJicm93c2VyQWN0aW9uIiwiaWdub3JlRXJyb3JzIiwibGFzdEVycm9yIiwibWFrZU1ldGhvZCIsImZuIiwiYmFkZ2VzIiwiS0VZX0lTX0FQUExJRUQiLCJLRVlfU0hPV19CQURHRSIsIktFWV9CQURHRV9DT0xPUiIsIktFWV9CQURHRV9DT0xPUl9CTE9DS0VEIiwiaXNBcHBsaWVkIiwic2hvd0JhZGdlIiwiYmFkZ2VDb2xvciIsImJhZGdlQ29sb3JCbG9ja2VkIiwidGl0bGVCbGFja2xpc3RlZCIsInRpdGxlTm9uaW5qZWN0YWJsZSIsImljb25DYWNoZSIsImpvYnMiLCJzZXRJY29uIiwidXBkYXRlQmFkZ2UiLCJ1cGRhdGVCYWRnZUNvbG9yIiwidXBkYXRlU3RhdGUiLCJmb3JFYWNoVGFiIiwib25SZW1vdmVkIiwib25VcGRhdGVkIiwiZmF2SWNvblVybCIsInVuaXF1ZSIsInNldEJhZGdlVGV4dCIsInNldEJhZGdlQmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJibG9ja2VkIiwiaW5qZWN0YWJsZSIsIklOSkVDVEFCTEVfVEFCX1VSTF9SRSIsImJsYWNrbGlzdGVkIiwic2V0VGl0bGUiLCJpY29uRGF0YSIsIm4iLCJpbWciLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJnZXRJbWFnZURhdGEiLCJleHRlbnNpb25Sb290IiwiZ2V0VVJMIiwibWFpbiIsInJ1biIsInRzTGlzdCIsInN0YXR1c0xpc3QiLCJtZWRpYUZpbGVMaXN0IiwiQUVTIiwiaXYiLCJkZWNyeXB0b3IiLCJzdHJpbmdUb0J1ZmZlciIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZG93bmxvYWRNM3U4IiwibTN1OCIsImxpbWl0IiwibGluZSIsInRvTG93ZXJDYXNlIiwidHNVcmwiLCJnZXRBRVMiLCJkb3dubG9hZFRTIiwiYWpheCIsInN1Y2Nlc3MiLCJmYWlsIiwidHNVcmkiLCJiYXNlVVJMIiwiZGVjcnlwdFRzIiwiVWludDhBcnJheSIsInJldHJ5IiwiZG93bmxvYWQiLCJwcm9jTGlzdCIsInMiLCJkZWFsVFMiLCJvbnByb2dyZXNzIiwiaWkiLCJtcDRCeUpiaW5hcnkiLCJkYXRhQ2h1bmtzIiwiYmxvYiIsImpCaW5hcnkiLCJsb2FkIiwiTVBFR1RTIiwibXBlZ3RzIiwic3RhcnQiLCJnZXRUaW1lIiwibXA0T2JqIiwibXBlZ3RzX3RvX21wNCIsImRvd25sb2FkTGluayIsInRvVVJJIiwicmF3RGF0YSIsImRvd25sb2FkcyIsImZpbGVuYW1lIiwiZmlsZU5hbWUiLCJkb3dubG9hZElkIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJvcGVuIiwic2VuZCIsImNyZWF0ZUZGbXBlZyIsImZldGNoRmlsZSIsImZmbXBlZyIsImNvcmVQYXRoIiwibWVyZ2UiLCJ2aWRlbyIsImF1ZGlvIiwiRlMiLCJodHRwUmVxdWVzdCIsInJlcXVlc3RzIiwiZXZlbnRzVG9Ob3RpZnkiLCJsb2FkZWQiLCJtZXJnZVZpZGVvIiwicHAiLCJfbG9hZGVkIiwiX3RvdGFsIiwicHJlbG9hZHMiLCJ2aWRlb09wdHMiLCJhdWRpb09wdHMiLCJ2YWxzIiwib3V0Iiwibm90aWZpY2F0aW9ucyIsImljb25VcmwiLCJkZWZhdWx0SW1hZ2UiLCJpc0NsaWNrYWJsZSIsImJyb2FkY2FzdCIsInNlbmRNZXNzYWdlIiwic2VuZE1lc3NhZ2VPcklnbm9yZSIsInF1ZXJ5Iiwib3BlbmVycyIsIk5vdGlmaWNhdGlvbiIsImJnRXh0cmFzIiwibm90aWZpY2F0aW9uSWQiLCJvbkNsaWNrIiwiUmVtb3ZlTm90aWZpY2F0aW9uIiwib25DbGlja2VkIiwib3BlbmVySWQiLCJzZW5kVGFiQ21kIiwib25DbG9zZWQiLCJHZXRBbGxPcHRpb25zIiwiR2V0T3B0aW9ucyIsImRlZmF1bHRzIiwibWFwRW50cnkiLCJTZXRPcHRpb25zIiwiaG9va3MiLCJpbml0SG9va3MiLCJjYWxsSG9va3NMYXRlciIsImNhbGxIb29rcyIsImluaXRQZW5kaW5nIiwiZmlyZUNoYW5nZSIsIm1haW5LZXkiLCJnZXREZWZhdWx0T3B0aW9uIiwib3B0aW9uS2V5Iiwib3B0aW9uVmFsdWUiLCJob29rIiwiaW5kZXhlZERCIiwib25zdWNjZXNzIiwidHJhbnNmb3JtIiwib251cGdyYWRlbmVlZGVkIiwiZGIiLCJ0eCIsInRyYW5zYWN0aW9uIiwicHJvY2Vzc2luZyIsImRvbmUiLCJnZXRBbGwiLCJzdG9yZU5hbWUiLCJvYmplY3RTdG9yZSIsInRyYW5zZm9ybVNjcmlwdCIsImFsbFZhbHVlcyIsImFsbENhY2hlIiwiYWxsUmVxdWlyZSIsIm9yaWdJbmNsdWRlIiwib3JpZ0V4Y2x1ZGUiLCJvcmlnTWF0Y2giLCJvcmlnRXhjbHVkZU1hdGNoIiwib25Db25uZWN0Iiwib25Qb3B1cE9wZW5lZCIsInByZWZldGNoU2V0UG9wdXAiLCJicm93c2VyX2FjdGlvbiIsImRlZmF1bHRfcG9wdXAiLCJwb3J0Iiwib25EaXNjb25uZWN0Iiwib25Qb3B1cENsb3NlZCIsIlNldFBvcHVwIiwiQVBJX0NPTkZJRyIsIlRJTUVfQUZURVJfU0VORCIsIlRJTUVfQUZURVJfUkVDRUlWRSIsIlRJTUVfS0VFUF9EQVRBIiwiY2FjaGVDb2RlIiwib25EaXNwb3NlIiwicmNzIiwicmNzUHJvbWlzZSIsInVucmVnaXN0ZXIiLCJJTkpFQ1RfSU5UTyIsIktFWV9FWFBPU0UiLCJLRVlfREVGX0lOSkVDVF9JTlRPIiwiS0VZX1hIUl9JTkpFQ1QiLCJleHBvc2UiLCJpbmplY3RJbnRvIiwieGhySW5qZWN0Iiwib25PcHRpb25DaGFuZ2VkIiwiZmVlZElkIiwicHJvY2Vzc0ZlZWRiYWNrIiwiZGVsIiwiY2FjaGVLZXkiLCJlbnZLZXkiLCJwcmVwYXJlU2NyaXB0IiwibmVlZHNJbmplY3Rpb24iLCJleGVjdXRlU2NyaXB0IiwicHJvcHNUb0NsZWFyIiwib25DaGFuZ2VkIiwiZGJLZXlzIiwiY2FjaGVWYWx1ZXMiLCJnZXRWYWx1ZXMiLCJkaXJ0eSIsIm5vcm1hbGl6ZVJlYWxtIiwiaGFzT3duUHJvcGVydHkiLCJJTkpFQ1RfTUFQUElORyIsInRvZ2dsZVhockluamVjdCIsInRvZ2dsZVByZWluamVjdCIsInNpdGUiLCJpc0V4cG9zZWQiLCJlbmFibGUiLCJvbk9mZiIsIm9uU2VuZEhlYWRlcnMiLCJvbkhlYWRlcnNSZWNlaXZlZCIsIk9uSGVhZGVyc1JlY2VpdmVkT3B0aW9ucyIsIkVYVFJBX0hFQURFUlMiLCJoYXMiLCJwcmVwYXJlWGhyQmxvYiIsInJlc3BvbnNlSGVhZGVycyIsImRldGVjdFN0cmljdENzcCIsImZvcmNlQ29udGVudEluamVjdGlvbiIsInByZXBhcmVTY3JpcHRzIiwiaXNMYXRlIiwiaGFzTW9yZSIsImV2ZXJ5Iiwic2NyIiwiaXNDb250ZW50UmVhbG0iLCJ1YSIsInJlZ2lzdGVyU2NyaXB0RGF0YUZGIiwiZGF0YUtleSIsInJlcGxhY2VXaXRoRnVsbFdpZHRoRm9ybSIsImlzQ29udGVudCIsInJlcXMiLCJyZXFzU2xpY2VzIiwiY29uY2F0IiwiaGFzUmVxcyIsImluamVjdGVkQ29kZSIsIm1ldGFTdHIiLCJNRVRBQkxPQ0tfUkUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyZXNvbHZlRGF0YUNvZGVTdHIiLCJ2bVJlc29sdmUiLCJ2bURhdGEiLCJhbGxGcmFtZXMiLCJjb250ZW50U2NyaXB0cyIsIm1hdGNoZXMiLCJyZWFsbSIsIklOSkVDVF9DT05URU5UIiwicmVxSGFuZGxlciIsIlZNX1ZFUklGWSIsIkNPTkZJUk1fVVJMX0JBU0UiLCJ2ZXJpZnkiLCJ0YWJSZXF1ZXN0cyIsImVuY29kZXIiLCJldnQiLCJjdXJyZW50IiwiQ29uZmlybUluc3RhbGwiLCJjb25maXJtSW5zdGFsbCIsIkNoZWNrSW5zdGFsbGVyVGFiIiwiSHR0cFJlcXVlc3QiLCJBYm9ydFJlcXVlc3QiLCJhYm9ydCIsImNsZWFyUmVxdWVzdCIsIlJldm9rZUJsb2IiLCJzcGVjaWFsSGVhZGVycyIsIkhlYWRlckluamVjdG9yIiwiYXBpRmlsdGVyIiwiT25CZWZvcmVTZW5kSGVhZGVyc09wdGlvbnMiLCJoZWFkZXJzVG9JbmplY3QiLCJpc1ZtVmVyaWZ5IiwiaXNOb3RDb29raWUiLCJpc1NlbmRhYmxlIiwiaXNTZW5kYWJsZUFub24iLCJSRV9TRVRfQ09PS0lFIiwiUkVfU0VUX0NPT0tJRV9WQUxVRSIsIlJFX1NFVF9DT09LSUVfQVRUUiIsIlNBTUVfU0lURV9NQVAiLCJzdHJpY3QiLCJsYXgiLCJub25lIiwic2V0Q29va2llSW5TdG9yZSIsImhlYWRlclZhbHVlIiwiZXhlYyIsIm9wdFN0ciIsIm9wdCIsImlzSG9zdCIsImxhc3RJbmRleCIsInNhbWVTaXRlIiwiY29va2llcyIsImV4cGlyYXRpb25EYXRlIiwiZXhwaXJlcyIsImh0dHBPbmx5Iiwic2VjdXJlIiwic3RvcmVJZCIsImFwaUV2ZW50cyIsIm9uQmVmb3JlU2VuZEhlYWRlcnMiLCJsaXN0ZW5lciIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdElkIiwicmVxSWQiLCJjb3JlSWQiLCJub05hdGl2ZUNvb2tpZSIsImgiLCJlbmNvZGVXZWJSZXF1ZXN0SGVhZGVyIiwiYWRkIiwiaXNFbXB0eSIsIkNIVU5LX1NJWkUiLCJibG9iMmNodW5rIiwiYmxvYjJiYXNlNjQiLCJibG9iMm9iamVjdFVybCIsInhockNhbGxiYWNrV3JhcHBlciIsImxhc3RQcm9taXNlIiwiY29udGVudFR5cGUiLCJkYXRhU2l6ZSIsIm51bUNodW5rcyIsInJlc3BvbnNlVGV4dCIsImJsb2JiZWQiLCJjaHVua2VkIiwiZ2V0Q2h1bmsiLCJnZXRSZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJnZXRSZXNwb25zZUhlYWRlciIsImNlaWwiLCJzaG91bGROb3RpZnkiLCJzaG91bGRTZW5kUmVzcG9uc2UiLCJjYiIsImZpbmFsVXJsIiwicmVzcG9uc2VVUkwiLCJjaHVuayIsInBvcyIsImxhc3QiLCJpc1NwZWNpYWxIZWFkZXIiLCJsb3dlckhlYWRlciIsImluY29nbml0byIsIm92ZXJyaWRlTWltZVR5cGUiLCJ4aHJUeXBlIiwidm1IZWFkZXJzIiwiZGVjb2RlQm9keSIsInNob3VsZFNlbmRDb29raWVzIiwic2V0UmVxdWVzdEhlYWRlciIsImxvd2VyTmFtZSIsInRpbWVvdXQiLCJnZXRBbGxDb29raWVTdG9yZXMiLCJ0YWJJZHMiLCJmaXJlZm94IiwiZmlyc3RQYXJ0eURvbWFpbiIsImMiLCJzZXNzaW9uIiwib25sb2FkZW5kIiwid2FzQmxvYiIsInN0cmluZzJ1aW50OGFycmF5IiwiYXRvYiIsInAxIiwiaXNVc2VyU2NyaXB0IiwiY29uZmlybUtleSIsImFjdGl2ZSIsImNhblJlcGxhY2VDdXJUYWIiLCJmZiIsImNvbmZpcm1VcmwiLCJ3aW5kb3dJZCIsIndpbmRvd3MiLCJmb2N1c2VkIiwid2hpdGVsaXN0UmUiLCJSZWdFeHAiLCJibGFja2xpc3RSZSIsInJlc29sdmVWaXJ0dWFsVXJsIiwidmlydHVhbFVybFJlIiwibWF5YmVSZWRpcmVjdFZpcnR1YWxVcmxGRiIsImFwaUV2ZW50IiwiYmluZCIsIm9uQ3JlYXRlZCIsInJlZGlyZWN0VXJsIiwibWF5YmVJbnN0YWxsVXNlckpzIiwiYmluYXJ5VmFsdWUiLCJzdHJpbmcyYnl0ZVN0cmluZyIsImJ1ZmZlcjJzdHJpbmciLCJDYWNoZU5ld1NjcmlwdCIsIk5ld1NjcmlwdCIsImFycmF5VHlwZSIsImRlZmF1bHQiLCJkZWZhdWx0VHlwZSIsIm1ldGFUeXBlcyIsImluY2x1ZGUiLCJleGNsdWRlIiwiZXhjbHVkZU1hdGNoIiwicmVzb3VyY2UiLCJwYWlyIiwibWV0YU9wdGlvbmFsVHlwZXMiLCJhbnRpZmVhdHVyZSIsImNvbXBhdGlibGUiLCJjb25uZWN0IiwibWV0YUJvZHkiLCJfbWF0Y2giLCJyYXdLZXkiLCJyYXdWYWx1ZSIsImtleU5hbWUiLCJsb2NhbGUiLCJjYW1lbEtleSIsImciLCJ0b1VwcGVyQ2FzZSIsIm1ldGFUeXBlIiwib2xkVmFsdWUiLCJob21lcGFnZSIsImRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsIm5hbWVzcGFjZSIsIm5hbWVVUkkiLCJlbmNvZGVGaWxlbmFtZSIsInBpZWNlIiwiZGljdCIsImtleVZhbCIsImNhY2hlT3JGZXRjaCIsImNoZWNrIiwibWFrZVJhdyIsImhhbmRsZXJzIiwiY2FjaGVPckZldGNoSGFuZGxlciIsImRvRmV0Y2giLCJpc01vZGlmaWVkIiwicGF0aElkIiwiZXh0ZW5zaW9uIiwiZ2V0Vmlld3MiLCJsb2NhdGlvbiIsIm1heWJlSW5XaW5kb3ciLCJjb250YWluZXIiLCJpbnNlcnQiLCJwaW5uZWQiLCJzcmNUYWIiLCJzcmNVcmwiLCJpc0ludGVybmFsIiwiY29va2llU3RvcmVJZCIsImdldENvbnRhaW5lcklkIiwiY2FuT3BlbkluY29nbml0byIsIm5ld1RhYiIsInduZE9wdHMiLCJoYXNQb3MiLCJ3bmQiLCJvcGVuZXJUYWJJZFN1cHBvcnRlZCIsIm9wZW5lclRhYklkIiwiVGFiQ2xvc2UiLCJUYWJGb2N1cyIsInJlYWR5IiwiZGVmaW5lUHJvcGVydGllcyIsIm9zIiwiU0NSSVBUX1RFTVBMQVRFX0VESVRFRCIsIklOSVRJQUxfVEVNUExBVEUiLCJlZGl0ZWQiLCJ0ZW1wbGF0ZSIsImRlZmF1bHRUZW1wbGF0ZSIsIlRlc3RCbGFja2xpc3QiLCJyZXNldEJsYWNrbGlzdCIsIlJFX01BVENIX1BBUlRTIiwiYmxhY2tsaXN0UnVsZXMiLCJibGFja2xpc3QiLCJSRV9IVFRQX09SX0hUVFBTIiwiTUFYX0JMX0NBQ0hFX0xFTkdUSCIsImJsQ2FjaGUiLCJibENhY2hlU2l6ZSIsInRlc3RSdWxlcyIsInJ1bGVzIiwicnVsZUJ1aWxkZXIiLCJtYXRjaGVyIiwidGVzdEdsb2IiLCJhdXRvUmVnIiwidGVzdE1hdGNoIiwibWF0Y2hUZXN0ZXIiLCJiYXRjaCIsIm1hdCIsIm1lcmdlTGlzdHMiLCJpbmMiLCJleGMiLCJleGNNYXQiLCJvayIsInN0cjJSRSIsInJlIiwiYmluZFJFIiwicmVTdHIiLCJyZVRsZFN0ciIsInRzdHIiLCJzdWZmaXgiLCJtYXRjaFNjaGVtZSIsIlJFX1NUUl9BTlkiLCJSRV9TVFJfVExEIiwiaG9zdE1hdGNoZXIiLCJydWxlTEMiLCJ0bGRTdHIiLCJ0bGRTdWZmaXgiLCJwYXRoTWF0Y2hlciIsImlIYXNoIiwiaVF1ZXJ5Iiwic3RyUmUiLCJydWxlUGFydHMiLCJtYXRjaEhvc3QiLCJtYXRjaFBhdGgiLCJwYXJ0cyIsInVwZGF0ZUJsYWNrbGlzdENhY2hlIiwiQ2hlY2tVcGRhdGUiLCJyZXN1bHRzIiwiY2hlY2tBbGxBbmROb3RpZnkiLCJDaGVja1VwZGF0ZUFsbCIsInRvVXBkYXRlIiwibm90ZXMiLCJjaGVja1VwZGF0ZSIsIm9wZW5PcHRpb25zUGFnZSIsInByb2Nlc3NlcyIsImRvQ2hlY2tVcGRhdGUiLCJtc2dPayIsIm1zZ0VyciIsInJlc291cmNlT3B0cyIsImRvd25sb2FkVXBkYXRlIiwiY2hlY2tpbmciLCJjYW5Ob3RpZnkiLCJkb3dubG9hZFVSTCIsInVwZGF0ZVVSTCIsImRldiIsImVycm9yTWVzc2FnZSIsImFubm91bmNlIiwiYWxsb3dlZCIsIm5vdGlmeVVwZGF0ZXMiLCJ1cGRhdGVTY2hlZHVsZWQiLCJHZXRWYWx1ZVN0b3JlIiwic3RvcmVzIiwiU2V0VmFsdWVTdG9yZXMiLCJicm9hZGNhc3RWYWx1ZVN0b3JlcyIsImdyb3VwU3RvcmVzQnlGcmFtZSIsIlVwZGF0ZVZhbHVlIiwidXBkYXRlTGF0ZXIiLCJvblJlcGxhY2VkIiwiYWRkZWRJZCIsInJlbW92ZWRJZCIsIm9wZW5lclRhYnMiLCJzY3JpcHRJZHMiLCJjdXJyZW50Q2FjaGUiLCJkb1VwZGF0ZSIsInZhbHVlU3RvcmVzIiwiZ3JvdXBDYWNoZUJ5RnJhbWUiLCJwYXJ0aWFsIiwidGFiRnJhbWVEYXRhIiwidGFza3MiLCJmcmFtZXMiLCJmcmFtZURhdGEiLCJjYWNoZURhdGEiLCJ0b1NlbmQiLCJzY3JpcHREYXRhIiwiZGF0YUVudHJpZXMiLCJoaXN0b3J5IiwiY2hlY2tUeXBlIiwiaGFuZGxlIiwiZGVmYXVsdFByZXZlbnRlZCIsImluaXRUTEQiLCJleHBvcnRNZXRob2QiLCJ0bGRqcyIsImlzUmVhZHkiLCJnZXREb21haW4iLCJnZXRTdWJkb21haW4iLCJnZXRQdWJsaWNTdWZmaXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFBQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLFFBQVEsb0JBQW9CO1FBQzVCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsaUJB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVFQUF1RSxPQUFPO0FBQzlFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0EsaUZBQWlGLGNBQWM7QUFDL0Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZSxrRUFBa0U7QUFDckYsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzdEJhOztBQUViO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFBQTtBQUFB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dGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSnNvbnBDYWxsYmFjayhkYXRhKSB7XG4gXHRcdHZhciBjaHVua0lkcyA9IGRhdGFbMF07XG4gXHRcdHZhciBtb3JlTW9kdWxlcyA9IGRhdGFbMV07XG4gXHRcdHZhciBleGVjdXRlTW9kdWxlcyA9IGRhdGFbMl07XG5cbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdO1xuIFx0XHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdHJlc29sdmVzLnB1c2goaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKTtcbiBcdFx0XHR9XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbiBcdFx0fVxuIFx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmKHBhcmVudEpzb25wRnVuY3Rpb24pIHBhcmVudEpzb25wRnVuY3Rpb24oZGF0YSk7XG5cbiBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4gXHRcdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuIFx0XHR9XG5cbiBcdFx0Ly8gYWRkIGVudHJ5IG1vZHVsZXMgZnJvbSBsb2FkZWQgY2h1bmsgdG8gZGVmZXJyZWQgbGlzdFxuIFx0XHRkZWZlcnJlZE1vZHVsZXMucHVzaC5hcHBseShkZWZlcnJlZE1vZHVsZXMsIGV4ZWN1dGVNb2R1bGVzIHx8IFtdKTtcblxuIFx0XHQvLyBydW4gZGVmZXJyZWQgbW9kdWxlcyB3aGVuIGFsbCBjaHVua3MgcmVhZHlcbiBcdFx0cmV0dXJuIGNoZWNrRGVmZXJyZWRNb2R1bGVzKCk7XG4gXHR9O1xuIFx0ZnVuY3Rpb24gY2hlY2tEZWZlcnJlZE1vZHVsZXMoKSB7XG4gXHRcdHZhciByZXN1bHQ7XG4gXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkZWZlcnJlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHR2YXIgZGVmZXJyZWRNb2R1bGUgPSBkZWZlcnJlZE1vZHVsZXNbaV07XG4gXHRcdFx0dmFyIGZ1bGZpbGxlZCA9IHRydWU7XG4gXHRcdFx0Zm9yKHZhciBqID0gMTsgaiA8IGRlZmVycmVkTW9kdWxlLmxlbmd0aDsgaisrKSB7XG4gXHRcdFx0XHR2YXIgZGVwSWQgPSBkZWZlcnJlZE1vZHVsZVtqXTtcbiBcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rc1tkZXBJZF0gIT09IDApIGZ1bGZpbGxlZCA9IGZhbHNlO1xuIFx0XHRcdH1cbiBcdFx0XHRpZihmdWxmaWxsZWQpIHtcbiBcdFx0XHRcdGRlZmVycmVkTW9kdWxlcy5zcGxpY2UoaS0tLCAxKTtcbiBcdFx0XHRcdHJlc3VsdCA9IF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gZGVmZXJyZWRNb2R1bGVbMF0pO1xuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdHJldHVybiByZXN1bHQ7XG4gXHR9XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4gXHQvLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbiBcdC8vIFByb21pc2UgPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG4gXHR2YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuIFx0XHRcImJhY2tncm91bmQvaW5kZXhcIjogMFxuIFx0fTtcblxuIFx0dmFyIGRlZmVycmVkTW9kdWxlcyA9IFtdO1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHR2YXIganNvbnBBcnJheSA9IHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXSA9IHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXSB8fCBbXTtcbiBcdHZhciBvbGRKc29ucEZ1bmN0aW9uID0ganNvbnBBcnJheS5wdXNoLmJpbmQoanNvbnBBcnJheSk7XG4gXHRqc29ucEFycmF5LnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjaztcbiBcdGpzb25wQXJyYXkgPSBqc29ucEFycmF5LnNsaWNlKCk7XG4gXHRmb3IodmFyIGkgPSAwOyBpIDwganNvbnBBcnJheS5sZW5ndGg7IGkrKykgd2VicGFja0pzb25wQ2FsbGJhY2soanNvbnBBcnJheVtpXSk7XG4gXHR2YXIgcGFyZW50SnNvbnBGdW5jdGlvbiA9IG9sZEpzb25wRnVuY3Rpb247XG5cblxuIFx0Ly8gYWRkIGVudHJ5IG1vZHVsZSB0byBkZWZlcnJlZCBsaXN0XG4gXHRkZWZlcnJlZE1vZHVsZXMucHVzaChbXCIuL3NyYy9iYWNrZ3JvdW5kL2luZGV4LmpzXCIsXCJwdWJsaWMvbGliL3RsZGpzXCIsXCJjb21tb25cIl0pO1xuIFx0Ly8gcnVuIGRlZmVycmVkIG1vZHVsZXMgd2hlbiByZWFkeVxuIFx0cmV0dXJuIGNoZWNrRGVmZXJyZWRNb2R1bGVzKCk7XG4iLCJjb25zdCByZXNvbHZlVVJMID0gcmVxdWlyZSgncmVzb2x2ZS11cmwnKTtcbmNvbnN0IHsgZGV2RGVwZW5kZW5jaWVzIH0gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcblxuLypcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYnJvd3NlciBlbnZpcm9ubWVudFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29yZVBhdGg6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXG4gICAgPyByZXNvbHZlVVJMKCcvbm9kZV9tb2R1bGVzL0BmZm1wZWcvY29yZS9kaXN0L2ZmbXBlZy1jb3JlLmpzJylcbiAgICA6IGBodHRwczovL3VucGtnLmNvbS9AZmZtcGVnL2NvcmVAJHtkZXZEZXBlbmRlbmNpZXNbJ0BmZm1wZWcvY29yZSddLnN1YnN0cmluZygxKX0vZGlzdC9mZm1wZWctY29yZS5qc2AsXG59O1xuIiwiY29uc3QgcmVzb2x2ZVVSTCA9IHJlcXVpcmUoJ3Jlc29sdmUtdXJsJyk7XG5cbmNvbnN0IHJlYWRGcm9tQmxvYk9yRmlsZSA9IChibG9iKSA9PiAoXG4gIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoZmlsZVJlYWRlci5yZXN1bHQpO1xuICAgIH07XG4gICAgZmlsZVJlYWRlci5vbmVycm9yID0gKHsgdGFyZ2V0OiB7IGVycm9yOiB7IGNvZGUgfSB9IH0pID0+IHtcbiAgICAgIHJlamVjdChFcnJvcihgRmlsZSBjb3VsZCBub3QgYmUgcmVhZCEgQ29kZT0ke2NvZGV9YCkpO1xuICAgIH07XG4gICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgfSlcbik7XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKF9kYXRhKSA9PiB7XG4gIGxldCBkYXRhID0gX2RhdGE7XG4gIGlmICh0eXBlb2YgX2RhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIF9kYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8qIEZyb20gYmFzZTY0IGZvcm1hdCAqL1xuICAgIGlmICgvZGF0YTpfZGF0YVxcLyhbYS16QS1aXSopO2Jhc2U2NCwoW15cIl0qKS8udGVzdChfZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBhdG9iKF9kYXRhLnNwbGl0KCcsJylbMV0pXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKTtcbiAgICAvKiBGcm9tIHJlbW90ZSBzZXJ2ZXIvVVJMICovXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHJlc29sdmVVUkwoX2RhdGEpKTtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICB9XG4gIC8qIEZyb20gQmxvYiBvciBGaWxlICovXG4gIH0gZWxzZSBpZiAoX2RhdGEgaW5zdGFuY2VvZiBGaWxlIHx8IF9kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIGRhdGEgPSBhd2FpdCByZWFkRnJvbUJsb2JPckZpbGUoX2RhdGEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5jb25zdCByZXNvbHZlVVJMID0gcmVxdWlyZSgncmVzb2x2ZS11cmwnKTtcbmNvbnN0IHsgbG9nIH0gPSByZXF1aXJlKCcuLi91dGlscy9sb2cnKTtcblxuLypcbiAqIEZldGNoIGRhdGEgZnJvbSByZW1vdGUgVVJMIGFuZCBjb252ZXJ0IHRvIGJsb2IgVVJMXG4gKiB0byBhdm9pZCBDT1JTIGlzc3VlXG4gKi9cbmNvbnN0IHRvQmxvYlVSTCA9IGFzeW5jICh1cmwsIG1pbWVUeXBlKSA9PiB7XG4gIGxvZygnaW5mbycsIGBmZXRjaCAke3VybH1gKTtcbiAgY29uc3QgYnVmID0gYXdhaXQgKGF3YWl0IGZldGNoKHVybCkpLmFycmF5QnVmZmVyKCk7XG4gIGxvZygnaW5mbycsIGAke3VybH0gZmlsZSBzaXplID0gJHtidWYuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZdLCB7IHR5cGU6IG1pbWVUeXBlIH0pO1xuICBjb25zdCBibG9iVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgbG9nKCdpbmZvJywgYCR7dXJsfSBibG9iIFVSTCA9ICR7YmxvYlVSTH1gKTtcbiAgcmV0dXJuIGJsb2JVUkw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jICh7IGNvcmVQYXRoOiBfY29yZVBhdGggfSkgPT4ge1xuICBpZiAodHlwZW9mIF9jb3JlUGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBFcnJvcignY29yZVBhdGggc2hvdWxkIGJlIGEgc3RyaW5nIScpO1xuICB9XG4gIGNvbnN0IGNvcmVSZW1vdGVQYXRoID0gcmVzb2x2ZVVSTChfY29yZVBhdGgpO1xuICBjb25zdCBjb3JlUGF0aCA9IGF3YWl0IHRvQmxvYlVSTChcbiAgICBjb3JlUmVtb3RlUGF0aCxcbiAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICk7XG4gIGNvbnN0IHdhc21QYXRoID0gYXdhaXQgdG9CbG9iVVJMKFxuICAgIGNvcmVSZW1vdGVQYXRoLnJlcGxhY2UoJ2ZmbXBlZy1jb3JlLmpzJywgJ2ZmbXBlZy1jb3JlLndhc20nKSxcbiAgICAnYXBwbGljYXRpb24vd2FzbScsXG4gICk7XG4gIGNvbnN0IHdvcmtlclBhdGggPSBhd2FpdCB0b0Jsb2JVUkwoXG4gICAgY29yZVJlbW90ZVBhdGgucmVwbGFjZSgnZmZtcGVnLWNvcmUuanMnLCAnZmZtcGVnLWNvcmUud29ya2VyLmpzJyksXG4gICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICApO1xuICBpZiAodHlwZW9mIGNyZWF0ZUZGbXBlZ0NvcmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2NyaXB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICBsb2coJ2luZm8nLCAnZmZtcGVnLWNvcmUuanMgc2NyaXB0IGxvYWRlZCcpO1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgICAgICAgIGNvcmVQYXRoLFxuICAgICAgICAgIHdhc21QYXRoLFxuICAgICAgICAgIHdvcmtlclBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNjcmlwdC5zcmMgPSBjb3JlUGF0aDtcbiAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGV2ZW50SGFuZGxlcik7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG4gIH1cbiAgbG9nKCdpbmZvJywgJ2ZmbXBlZy1jb3JlLmpzIHNjcmlwdCBpcyBsb2FkZWQgYWxyZWFkeScpO1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgIGNvcmVQYXRoLFxuICAgIHdhc21QYXRoLFxuICAgIHdvcmtlclBhdGgsXG4gIH0pO1xufTtcbiIsImNvbnN0IGRlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi9kZWZhdWx0T3B0aW9ucycpO1xuY29uc3QgZ2V0Q3JlYXRlRkZtcGVnQ29yZSA9IHJlcXVpcmUoJy4vZ2V0Q3JlYXRlRkZtcGVnQ29yZScpO1xuY29uc3QgZmV0Y2hGaWxlID0gcmVxdWlyZSgnLi9mZXRjaEZpbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmF1bHRPcHRpb25zLFxuICBnZXRDcmVhdGVGRm1wZWdDb3JlLFxuICBmZXRjaEZpbGUsXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmF1bHRBcmdzOiBbXG4gICAgLyogYXJnc1swXSBpcyBhbHdheXMgdGhlIGJpbmFyeSBwYXRoICovXG4gICAgJy4vZmZtcGVnJyxcbiAgICAvKiBEaXNhYmxlIGludGVyYWN0aW9uIG1vZGUgKi9cbiAgICAnLW5vc3RkaW4nLFxuICAgIC8qIEZvcmNlIHRvIG92ZXJyaWRlIG91dHB1dCBmaWxlICovXG4gICAgJy15JyxcbiAgXSxcbiAgYmFzZU9wdGlvbnM6IHtcbiAgICAvKiBGbGFnIHRvIHR1cm4gb24vb2ZmIGxvZyBtZXNzYWdlcyBpbiBjb25zb2xlICovXG4gICAgbG9nOiBmYWxzZSxcbiAgICAvKlxuICAgICAqIEN1c3RvbSBsb2dnZXIgdG8gZ2V0IGZmbXBlZy53YXNtIG91dHB1dCBtZXNzYWdlcy5cbiAgICAgKiBhIHNhbXBsZSBsb2dnZXIgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogbG9nZ2VyID0gKHsgdHlwZSwgbWVzc2FnZSB9KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyh0eXBlLCBtZXNzYWdlKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiB0eXBlIGNhbiBiZSBvbmUgb2YgZm9sbG93aW5nOlxuICAgICAqXG4gICAgICogaW5mbzogaW50ZXJuYWwgd29ya2Zsb3cgZGVidWcgbWVzc2FnZXNcbiAgICAgKiBmZmVycjogZmZtcGVnIG5hdGl2ZSBzdGRlcnIgb3V0cHV0XG4gICAgICogZmZvdXQ6IGZmbXBlZyBuYXRpdmUgc3Rkb3V0IG91dHB1dFxuICAgICAqL1xuICAgIGxvZ2dlcjogKCkgPT4ge30sXG4gICAgLypcbiAgICAgKiBQcm9ncmVzcyBoYW5kbGVyIHRvIGdldCBjdXJyZW50IHByb2dyZXNzIG9mIGZmbXBlZyBjb21tYW5kLlxuICAgICAqIGEgc2FtcGxlIHByb2dyZXNzIGhhbmRsZXIgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogcHJvZ3Jlc3MgPSAoeyByYXRpbyB9KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhyYXRpbyk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogcmF0aW8gaXMgYSBmbG9hdCBudW1iZXIgYmV0d2VlbiAwIHRvIDEuXG4gICAgICovXG4gICAgcHJvZ3Jlc3M6ICgpID0+IHt9LFxuICAgIC8qXG4gICAgICogUGF0aCB0byBmaW5kL2Rvd25sb2FkIGZmbXBlZy53YXNtLWNvcmUsXG4gICAgICogdGhpcyB2YWx1ZSBzaG91bGQgYmUgb3ZlcndyaXRlbiBieSBgZGVmYXVsdE9wdGlvbnNgIGluXG4gICAgICogZWFjaCBlbnZpcm9ubWVudC5cbiAgICAgKi9cbiAgICBjb3JlUGF0aDogJycsXG4gIH0sXG59O1xuIiwiY29uc3QgeyBkZWZhdWx0QXJncywgYmFzZU9wdGlvbnMgfSA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5jb25zdCB7IHNldExvZ2dpbmcsIHNldEN1c3RvbUxvZ2dlciwgbG9nIH0gPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpO1xuY29uc3QgcGFyc2VQcm9ncmVzcyA9IHJlcXVpcmUoJy4vdXRpbHMvcGFyc2VQcm9ncmVzcycpO1xuY29uc3QgcGFyc2VBcmdzID0gcmVxdWlyZSgnLi91dGlscy9wYXJzZUFyZ3MnKTtcbmNvbnN0IHsgZGVmYXVsdE9wdGlvbnMsIGdldENyZWF0ZUZGbXBlZ0NvcmUgfSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuY29uc3QgeyB2ZXJzaW9uIH0gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxuY29uc3QgTk9fTE9BRCA9IEVycm9yKCdmZm1wZWcud2FzbSBpcyBub3QgcmVhZHksIG1ha2Ugc3VyZSB5b3UgaGF2ZSBjb21wbGV0ZWQgbG9hZCgpLicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChfb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBsb2c6IGxvZ2dpbmcsXG4gICAgbG9nZ2VyLFxuICAgIHByb2dyZXNzOiBvcHRQcm9ncmVzcyxcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7XG4gICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4uX29wdGlvbnMsXG4gIH07XG4gIGxldCBDb3JlID0gbnVsbDtcbiAgbGV0IGZmbXBlZyA9IG51bGw7XG4gIGxldCBydW5SZXNvbHZlID0gbnVsbDtcbiAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgbGV0IHByb2dyZXNzID0gb3B0UHJvZ3Jlc3M7XG4gIGNvbnN0IGRldGVjdENvbXBsZXRpb24gPSAobWVzc2FnZSkgPT4ge1xuICAgIGlmIChtZXNzYWdlID09PSAnRkZNUEVHX0VORCcgJiYgcnVuUmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgcnVuUmVzb2x2ZSgpO1xuICAgICAgcnVuUmVzb2x2ZSA9IG51bGw7XG4gICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXJzZU1lc3NhZ2UgPSAoeyB0eXBlLCBtZXNzYWdlIH0pID0+IHtcbiAgICBsb2codHlwZSwgbWVzc2FnZSk7XG4gICAgcGFyc2VQcm9ncmVzcyhtZXNzYWdlLCBwcm9ncmVzcyk7XG4gICAgZGV0ZWN0Q29tcGxldGlvbihtZXNzYWdlKTtcbiAgfTtcblxuICAvKlxuICAgKiBMb2FkIGZmbXBlZy53YXNtLWNvcmUgc2NyaXB0LlxuICAgKiBJbiBicm93c2VyIGVudmlyb25tZW50LCB0aGUgZmZtcGVnLndhc20tY29yZSBzY3JpcHQgaXMgZmV0Y2ggZnJvbVxuICAgKiBDRE4gYW5kIGNhbiBiZSBhc3NpZ24gdG8gYSBsb2NhbCBwYXRoIGJ5IGFzc2lnbmluZyBgY29yZVBhdGhgLlxuICAgKiBJbiBub2RlIGVudmlyb25tZW50LCB3ZSB1c2UgZHluYW1pYyByZXF1aXJlIGFuZCB0aGUgZGVmYXVsdCBgY29yZVBhdGhgXG4gICAqIGlzIGAkZmZtcGVnL2NvcmVgLlxuICAgKlxuICAgKiBUeXBpY2FsbHkgdGhlIGxvYWQoKSBmdW5jIG1pZ2h0IHRha2UgZmV3IHNlY29uZHMgdG8gbWludXRlcyB0byBjb21wbGV0ZSxcbiAgICogYmV0dGVyIHRvIGRvIGl0IGFzIGVhcmx5IGFzIHBvc3NpYmxlLlxuICAgKlxuICAgKi9cbiAgY29uc3QgbG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICBsb2coJ2luZm8nLCAnbG9hZCBmZm1wZWctY29yZScpO1xuICAgIGlmIChDb3JlID09PSBudWxsKSB7XG4gICAgICBsb2coJ2luZm8nLCAnbG9hZGluZyBmZm1wZWctY29yZScpO1xuICAgICAgLypcbiAgICAgICAqIEluIG5vZGUgZW52aXJvbm1lbnQsIGFsbCBwYXRocyBhcmUgdW5kZWZpbmVkIGFzIHRoZXJlXG4gICAgICAgKiBpcyBubyBuZWVkIHRvIHNldCB0aGVtLlxuICAgICAgICovXG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyZWF0ZUZGbXBlZ0NvcmUsXG4gICAgICAgIGNvcmVQYXRoLFxuICAgICAgICB3b3JrZXJQYXRoLFxuICAgICAgICB3YXNtUGF0aCxcbiAgICAgIH0gPSBhd2FpdCBnZXRDcmVhdGVGRm1wZWdDb3JlKG9wdGlvbnMpO1xuICAgICAgQ29yZSA9IGF3YWl0IGNyZWF0ZUZGbXBlZ0NvcmUoe1xuICAgICAgICAvKlxuICAgICAgICAgKiBBc3NpZ24gbWFpblNjcmlwdFVybE9yQmxvYiBmaXhlcyBjaHJvbWUgZXh0ZW5zaW9uIHdlYiB3b3JrZXIgaXNzdWVcbiAgICAgICAgICogYXMgdGhlcmUgaXMgbm8gZG9jdW1lbnQuY3VycmVudFNjcmlwdCBpbiB0aGUgY29udGV4dCBvZiBjb250ZW50X3NjcmlwdHNcbiAgICAgICAgICovXG4gICAgICAgIG1haW5TY3JpcHRVcmxPckJsb2I6IGNvcmVQYXRoLFxuICAgICAgICBwcmludEVycjogKG1lc3NhZ2UpID0+IHBhcnNlTWVzc2FnZSh7IHR5cGU6ICdmZmVycicsIG1lc3NhZ2UgfSksXG4gICAgICAgIHByaW50OiAobWVzc2FnZSkgPT4gcGFyc2VNZXNzYWdlKHsgdHlwZTogJ2Zmb3V0JywgbWVzc2FnZSB9KSxcbiAgICAgICAgLypcbiAgICAgICAgICogbG9jYXRlRmlsZSBvdmVycmlkZXMgcGF0aHMgb2YgZmlsZXMgdGhhdCBpcyBsb2FkZWQgYnkgbWFpbiBzY3JpcHQgKGZmbXBlZy1jb3JlLmpzKS5cbiAgICAgICAgICogSXQgaXMgY3JpdGljYWwgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnQgYW5kIHdlIG92ZXJyaWRlIGJvdGggd2FzbSBhbmQgd29ya2VyIHBhdGhzXG4gICAgICAgICAqIGFzIHdlIGFyZSB1c2luZyBibG9iIFVSTCBpbnN0ZWFkIG9mIG9yaWdpbmFsIFVSTCB0byBhdm9pZCBjcm9zcyBvcmlnaW4gaXNzdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbG9jYXRlRmlsZTogKHBhdGgsIHByZWZpeCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3YXNtUGF0aCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgJiYgcGF0aC5lbmRzV2l0aCgnZmZtcGVnLWNvcmUud2FzbScpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3YXNtUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd29ya2VyUGF0aCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgJiYgcGF0aC5lbmRzV2l0aCgnZmZtcGVnLWNvcmUud29ya2VyLmpzJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlclBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBwYXRoO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBmZm1wZWcgPSBDb3JlLmN3cmFwKCdwcm94eV9tYWluJywgJ251bWJlcicsIFsnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICAgIGxvZygnaW5mbycsICdmZm1wZWctY29yZSBsb2FkZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ2ZmbXBlZy53YXNtIHdhcyBsb2FkZWQsIHlvdSBzaG91bGQgbm90IGxvYWQgaXQgYWdhaW4sIHVzZSBmZm1wZWcuaXNMb2FkZWQoKSB0byBjaGVjayBuZXh0IHRpbWUuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBDb3JlIGlzIGxvYWRlZC5cbiAgICovXG4gIGNvbnN0IGlzTG9hZGVkID0gKCkgPT4gQ29yZSAhPT0gbnVsbDtcblxuICAvKlxuICAgKiBSdW4gZmZtcGVnIGNvbW1hbmQuXG4gICAqIFRoaXMgaXMgdGhlIG1ham9yIGZ1bmN0aW9uIGluIGZmbXBlZy53YXNtLCB5b3UgY2FuIGp1c3QgaW1hZ2luZSBpdFxuICAgKiBhcyBmZm1wZWcgbmF0aXZlIGNsaSBhbmQgd2hhdCB5b3UgbmVlZCB0byBwYXNzIGlzIHRoZSBzYW1lLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiBjb252ZXJ0IG5hdGl2ZSBjb21tYW5kIGJlbG93OlxuICAgKlxuICAgKiBgYGBcbiAgICogJCBmZm1wZWcgLWkgdmlkZW8uYXZpIC1jOnYgbGlieDI2NCB2aWRlby5tcDRcbiAgICogYGBgXG4gICAqXG4gICAqIFRvXG4gICAqXG4gICAqIGBgYFxuICAgKiBhd2FpdCBmZm1wZWcucnVuKCctaScsICd2aWRlby5hdmknLCAnLWM6dicsICdsaWJ4MjY0JywgJ3ZpZGVvLm1wNCcpO1xuICAgKiBgYGBcbiAgICpcbiAgICovXG4gIGNvbnN0IHJ1biA9ICguLi5fYXJncykgPT4ge1xuICAgIGxvZygnaW5mbycsIGBydW4gZmZtcGVnIGNvbW1hbmQ6ICR7X2FyZ3Muam9pbignICcpfWApO1xuICAgIGlmIChDb3JlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBOT19MT0FEO1xuICAgIH0gZWxzZSBpZiAocnVubmluZykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2ZmbXBlZy53YXNtIGNhbiBvbmx5IHJ1biBvbmUgY29tbWFuZCBhdCBhIHRpbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgYXJncyA9IFsuLi5kZWZhdWx0QXJncywgLi4uX2FyZ3NdLmZpbHRlcigocykgPT4gcy5sZW5ndGggIT09IDApO1xuICAgICAgICBydW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgZmZtcGVnKC4uLnBhcnNlQXJncyhDb3JlLCBhcmdzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogUnVuIEZTIG9wZXJhdGlvbnMuXG4gICAqIEZvciBpbnB1dC9vdXRwdXQgZmlsZSBvZiBmZm1wZWcud2FzbSwgaXQgaXMgcmVxdWlyZWQgdG8gc2F2ZSB0aGVtIHRvIE1FTUZTXG4gICAqIGZpcnN0IHNvIHRoYXQgZmZtcGVnLndhc20gaXMgYWJsZSB0byBjb25zdW1lIHRoZW0uIEhlcmUgd2UgcmVseSBvbiB0aGUgRlNcbiAgICogbWV0aG9kcyBwcm92aWRlZCBieSBFbXNjcmlwdGVuLlxuICAgKlxuICAgKiBDb21tb24gbWV0aG9kcyB0byB1c2UgYXJlOlxuICAgKiBmZm1wZWcuRlMoJ3dyaXRlRmlsZScsICd2aWRlby5hdmknLCBuZXcgVWludDhBcnJheSguLi4pKTogd3JpdGVGaWxlIHdyaXRlc1xuICAgKiBkYXRhIHRvIE1FTUZTLiBZb3UgbmVlZCB0byB1c2UgVWludDhBcnJheSBmb3IgYmluYXJ5IGRhdGEuXG4gICAqIGZmbXBlZy5GUygncmVhZEZpbGUnLCAndmlkZW8ubXA0Jyk6IHJlYWRGaWxlIGZyb20gTUVNRlMuXG4gICAqIGZmbXBlZy5GUygndW5saW5rJywgJ3ZpZGVvLm1hcCcpOiBkZWxldGUgZmlsZSBmcm9tIE1FTUZTLlxuICAgKlxuICAgKiBGb3IgbW9yZSBpbmZvLCBjaGVjayBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvYXBpX3JlZmVyZW5jZS9GaWxlc3lzdGVtLUFQSS5odG1sXG4gICAqXG4gICAqL1xuICBjb25zdCBGUyA9IChtZXRob2QsIC4uLmFyZ3MpID0+IHtcbiAgICBsb2coJ2luZm8nLCBgcnVuIEZTLiR7bWV0aG9kfSAke2FyZ3MubWFwKChhcmcpID0+ICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IGFyZyA6IGA8JHthcmcubGVuZ3RofSBieXRlcyBiaW5hcnkgZmlsZT5gKSkuam9pbignICcpfWApO1xuICAgIGlmIChDb3JlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBOT19MT0FEO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmV0ID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IENvcmUuRlNbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3JlYWRkaXInKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYGZmbXBlZy5GUygncmVhZGRpcicsICcke2FyZ3NbMF19JykgZXJyb3IuIENoZWNrIGlmIHRoZSBwYXRoIGV4aXN0cywgZXg6IGZmbXBlZy5GUygncmVhZGRpcicsICcvJylgKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdyZWFkRmlsZScpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgZmZtcGVnLkZTKCdyZWFkRmlsZScsICcke2FyZ3NbMF19JykgZXJyb3IuIENoZWNrIGlmIHRoZSBwYXRoIGV4aXN0c2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKCdPb3BzLCBzb21ldGhpbmcgd2VudCB3cm9uZyBpbiBGUyBvcGVyYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBmb3JjaWJseSB0ZXJtaW5hdGUgdGhlIGZmbXBlZyBwcm9ncmFtLlxuICAgKi9cbiAgY29uc3QgZXhpdCA9ICgpID0+IHtcbiAgICBpZiAoQ29yZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgTk9fTE9BRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgQ29yZS5leGl0KDEpO1xuICAgICAgQ29yZSA9IG51bGw7XG4gICAgICBmZm1wZWcgPSBudWxsO1xuICAgICAgcnVuUmVzb2x2ZSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNldFByb2dyZXNzID0gKF9wcm9ncmVzcykgPT4ge1xuICAgIHByb2dyZXNzID0gX3Byb2dyZXNzO1xuICB9O1xuXG4gIGNvbnN0IHNldExvZ2dlciA9IChfbG9nZ2VyKSA9PiB7XG4gICAgc2V0Q3VzdG9tTG9nZ2VyKF9sb2dnZXIpO1xuICB9O1xuXG4gIHNldExvZ2dpbmcobG9nZ2luZyk7XG4gIHNldEN1c3RvbUxvZ2dlcihsb2dnZXIpO1xuXG4gIGxvZygnaW5mbycsIGB1c2UgZmZtcGVnLndhc20gdiR7dmVyc2lvbn1gKTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb2dyZXNzLFxuICAgIHNldExvZ2dlcixcbiAgICBzZXRMb2dnaW5nLFxuICAgIGxvYWQsXG4gICAgaXNMb2FkZWQsXG4gICAgcnVuLFxuICAgIGV4aXQsXG4gICAgRlMsXG4gIH07XG59O1xuIiwicmVxdWlyZSgncmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lJyk7XG5jb25zdCBjcmVhdGVGRm1wZWcgPSByZXF1aXJlKCcuL2NyZWF0ZUZGbXBlZycpO1xuY29uc3QgeyBmZXRjaEZpbGUgfSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLypcbiAgICogQ3JlYXRlIGZmbXBlZyBpbnN0YW5jZS5cbiAgICogRWFjaCBmZm1wZWcgaW5zdGFuY2Ugb3ducyBhbiBpc29sYXRlZCBNRU1GUyBhbmQgd29ya3NcbiAgICogaW5kZXBlbmRlbnRseS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBmZm1wZWcgPSBjcmVhdGVGRm1wZWcoe1xuICAgKiAgbG9nOiB0cnVlLFxuICAgKiAgbG9nZ2VyOiAoKSA9PiB7fSxcbiAgICogIHByb2dyZXNzOiAoKSA9PiB7fSxcbiAgICogIGNvcmVQYXRoOiAnJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEZvciB0aGUgdXNhZ2Ugb2YgdGhlc2UgZm91ciBhcmd1bWVudHMsIGNoZWNrIGNvbmZpZy5qc1xuICAgKlxuICAgKi9cbiAgY3JlYXRlRkZtcGVnLFxuICAvKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGZldGNoaW5nIGZpbGVzIGZyb20gdmFyaW91cyByZXNvdXJjZS5cbiAgICogU29tZXRpbWVzIHRoZSB2aWRlby9hdWRpbyBmaWxlIHlvdSB3YW50IHRvIHByb2Nlc3MgbWF5IGxvY2F0ZWRcbiAgICogaW4gYSByZW1vdGUgVVJMIGFuZCBzb21ld2hlcmUgaW4geW91ciBsb2NhbCBmaWxlIHN5c3RlbS5cbiAgICpcbiAgICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gaGVscHMgeW91IHRvIGZldGNoIHRvIGZpbGUgYW5kIHJldHVybiBhblxuICAgKiBVaW50OEFycmF5IHZhcmlhYmxlIGZvciBmZm1wZWcud2FzbSB0byBjb25zdW1lLlxuICAgKlxuICAgKi9cbiAgZmV0Y2hGaWxlLFxufTtcbiIsImxldCBsb2dnaW5nID0gZmFsc2U7XG5sZXQgY3VzdG9tTG9nZ2VyID0gKCkgPT4ge307XG5cbmNvbnN0IHNldExvZ2dpbmcgPSAoX2xvZ2dpbmcpID0+IHtcbiAgbG9nZ2luZyA9IF9sb2dnaW5nO1xufTtcblxuY29uc3Qgc2V0Q3VzdG9tTG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICBjdXN0b21Mb2dnZXIgPSBsb2dnZXI7XG59O1xuXG5jb25zdCBsb2cgPSAodHlwZSwgbWVzc2FnZSkgPT4ge1xuICBjdXN0b21Mb2dnZXIoeyB0eXBlLCBtZXNzYWdlIH0pO1xuICBpZiAobG9nZ2luZykge1xuICAgIGNvbnNvbGUubG9nKGBbJHt0eXBlfV0gJHttZXNzYWdlfWApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nZ2luZyxcbiAgc2V0TG9nZ2luZyxcbiAgc2V0Q3VzdG9tTG9nZ2VyLFxuICBsb2csXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAoQ29yZSwgYXJncykgPT4ge1xuICBjb25zdCBhcmdzUHRyID0gQ29yZS5fbWFsbG9jKGFyZ3MubGVuZ3RoICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xuICBhcmdzLmZvckVhY2goKHMsIGlkeCkgPT4ge1xuICAgIGNvbnN0IGJ1ZiA9IENvcmUuX21hbGxvYyhzLmxlbmd0aCArIDEpO1xuICAgIENvcmUud3JpdGVBc2NpaVRvTWVtb3J5KHMsIGJ1Zik7XG4gICAgQ29yZS5zZXRWYWx1ZShhcmdzUHRyICsgKFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogaWR4KSwgYnVmLCAnaTMyJyk7XG4gIH0pO1xuICByZXR1cm4gW2FyZ3MubGVuZ3RoLCBhcmdzUHRyXTtcbn07XG4iLCJsZXQgZHVyYXRpb24gPSAwO1xubGV0IHJhdGlvID0gMDtcblxuY29uc3QgdHMyc2VjID0gKHRzKSA9PiB7XG4gIGNvbnN0IFtoLCBtLCBzXSA9IHRzLnNwbGl0KCc6Jyk7XG4gIHJldHVybiAocGFyc2VGbG9hdChoKSAqIDYwICogNjApICsgKHBhcnNlRmxvYXQobSkgKiA2MCkgKyBwYXJzZUZsb2F0KHMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAobWVzc2FnZSwgcHJvZ3Jlc3MpID0+IHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJyAgRHVyYXRpb24nKSkge1xuICAgICAgY29uc3QgdHMgPSBtZXNzYWdlLnNwbGl0KCcsICcpWzBdLnNwbGl0KCc6ICcpWzFdO1xuICAgICAgY29uc3QgZCA9IHRzMnNlYyh0cyk7XG4gICAgICBwcm9ncmVzcyh7IGR1cmF0aW9uOiBkLCByYXRpbyB9KTtcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCB8fCBkdXJhdGlvbiA+IGQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5zdGFydHNXaXRoKCdmcmFtZScpIHx8IG1lc3NhZ2Uuc3RhcnRzV2l0aCgnc2l6ZScpKSB7XG4gICAgICBjb25zdCB0cyA9IG1lc3NhZ2Uuc3BsaXQoJ3RpbWU9JylbMV0uc3BsaXQoJyAnKVswXTtcbiAgICAgIGNvbnN0IHQgPSB0czJzZWModHMpO1xuICAgICAgcmF0aW8gPSB0IC8gZHVyYXRpb247XG4gICAgICBwcm9ncmVzcyh7IHJhdGlvLCB0aW1lOiB0IH0pO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5zdGFydHNXaXRoKCd2aWRlbzonKSkge1xuICAgICAgcHJvZ3Jlc3MoeyByYXRpbzogMSB9KTtcbiAgICAgIGR1cmF0aW9uID0gMDtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiIWZ1bmN0aW9uKGUpe3ZhciBpPXRoaXM7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZShpLHJlcXVpcmUoXCJqZGF0YXZpZXdcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiamRhdGF2aWV3XCJdLGZ1bmN0aW9uKHQpe3JldHVybiBlKGksdCl9KTppLmpCaW5hcnk9ZShpLGkuakRhdGFWaWV3KX0oZnVuY3Rpb24oaCxpKXtcInVzZSBzdHJpY3RcIjt2YXIgbyx1LG49aC5kb2N1bWVudDtcImF0b2JcImluIGgmJlwiYnRvYVwiaW4gaHx8KG89XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsdT1bLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsNjIsLTEsLTEsLTEsNjMsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwtMSwtMSwtMSwtMSwtMSwtMSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSwtMSwtMSwtMSwtMSwtMV0saC5idG9hfHwoaC5idG9hPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpLG4scj10Lmxlbmd0aCxhPTAscz1cIlwiO2E8cjspe2lmKGU9MjU1JnQuY2hhckNvZGVBdChhKyspLGE9PXIpe3MrPW8uY2hhckF0KGU+PjIpLHMrPW8uY2hhckF0KCgzJmUpPDw0KSxzKz1cIj09XCI7YnJlYWt9aWYoaT10LmNoYXJDb2RlQXQoYSsrKSxhPT1yKXtzKz1vLmNoYXJBdChlPj4yKSxzKz1vLmNoYXJBdCgoMyZlKTw8NHwoMjQwJmkpPj40KSxzKz1vLmNoYXJBdCgoMTUmaSk8PDIpLHMrPVwiPVwiO2JyZWFrfW49dC5jaGFyQ29kZUF0KGErKykscys9by5jaGFyQXQoZT4+Mikscys9by5jaGFyQXQoKDMmZSk8PDR8KDI0MCZpKT4+NCkscys9by5jaGFyQXQoKDE1JmkpPDwyfCgxOTImbik+PjYpLHMrPW8uY2hhckF0KDYzJm4pfXJldHVybiBzfSksaC5hdG9ifHwoaC5hdG9iPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpLG4scixhPXQubGVuZ3RoLHM9MCxvPVwiXCI7czxhOyl7Zm9yKDtlPXVbMjU1JnQuY2hhckNvZGVBdChzKyspXSxzPGEmJi0xPT1lOyk7aWYoLTE9PWUpYnJlYWs7Zm9yKDtpPXVbMjU1JnQuY2hhckNvZGVBdChzKyspXSxzPGEmJi0xPT1pOyk7aWYoLTE9PWkpYnJlYWs7bys9U3RyaW5nLmZyb21DaGFyQ29kZShlPDwyfCg0OCZpKT4+NCk7ZG97aWYoNjE9PShuPTI1NSZ0LmNoYXJDb2RlQXQocysrKSkpcmV0dXJuIG99d2hpbGUobj11W25dLHM8YSYmLTE9PW4pO2lmKC0xPT1uKWJyZWFrO28rPVN0cmluZy5mcm9tQ2hhckNvZGUoKDE1JmkpPDw0fCg2MCZuKT4+Mik7ZG97aWYoNjE9PShyPTI1NSZ0LmNoYXJDb2RlQXQocysrKSkpcmV0dXJuIG99d2hpbGUocj11W3JdLHM8YSYmLTE9PXIpO2lmKC0xPT1yKWJyZWFrO28rPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMmbik8PDZ8cil9cmV0dXJuIG99KSk7dmFyIGM9aC5Qcm9taXNlfHxmdW5jdGlvbih0KXt0aGlzLnRoZW49dH07ZnVuY3Rpb24gZih0LGUpe3JldHVybiBlJiZ0IGluc3RhbmNlb2YgZX1mdW5jdGlvbiByKHQpe2Zvcih2YXIgZT0xLGk9YXJndW1lbnRzLmxlbmd0aDtlPGk7KytlKXt2YXIgbixyPWFyZ3VtZW50c1tlXTtmb3IobiBpbiByKXZvaWQgMCE9PXJbbl0mJih0W25dPXJbbl0pfXJldHVybiB0fWZ1bmN0aW9uIGwodCl7cmV0dXJuIGFyZ3VtZW50c1swXT1lKHQpLHIuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIGEodCxlLGkpe3JldHVybiBmKGksRnVuY3Rpb24pP2kuY2FsbCh0LGUuY29udGV4dHNbMF0pOml9ZnVuY3Rpb24gdChzKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMsZT10Lmxlbmd0aC0xLHI9cy5sZW5ndGgtMSxpPXRbZV07aWYodC5sZW5ndGg9MStyLCFmKGksRnVuY3Rpb24pKXt2YXIgYT10aGlzO3JldHVybiBuZXcgYyhmdW5jdGlvbihpLG4pe3Rbcl09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD9uKHQpOmkoZSl9LHMuYXBwbHkoYSx0KX0pfXRbZV09dm9pZCAwLHRbcl09aSxzLmFwcGx5KHRoaXMsdCl9fWZ1bmN0aW9uIHModCxlKXtyZXR1cm4gZih0LHMpP3QuYXMoZSk6KGYodCxpKXx8KHQ9bmV3IGkodCx2b2lkIDAsdm9pZCAwLGU/ZVtcImpCaW5hcnkubGl0dGxlRW5kaWFuXCJdOnZvaWQgMCkpLGYodGhpcyxzKT8odGhpcy52aWV3PXQsdGhpcy52aWV3LnNlZWsoMCksdGhpcy5jb250ZXh0cz1bXSx0aGlzLmFzKGUsITApKTpuZXcgcyh0LGUpKX12YXIgZT0oZT1PYmplY3QuY3JlYXRlKXx8ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGU9dCxuZXcgZX0scD1zLnByb3RvdHlwZSx5PXAudHlwZVNldD17fTtwLnRvVmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIGEodGhpcyx0aGlzLHQpfSxwLl9uYW1lZD1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIHQuZGlzcGxheU5hbWU9ZStcIiBAIFwiKyh2b2lkIDAhPT1pP2k6dGhpcy52aWV3LnRlbGwoKSksdH07dmFyIGQ9T2JqZWN0LmRlZmluZVByb3BlcnR5O2lmKDEsZCl0cnl7ZCh7fSxcInhcIix7fSl9Y2F0Y2godCl7ZD12b2lkIDB9ZWxzZSBkPWZ1bmN0aW9uKHQsZSxpLG4pe24mJih0W2VdPWkudmFsdWUpfTt2YXIgdj1cImpCaW5hcnkuQ2FjaGVcIixiPTA7ZnVuY3Rpb24gZyh0KXtyZXR1cm4gbChnLnByb3RvdHlwZSx0KX1mdW5jdGlvbiB3KGkpe3JldHVybiBsKHcucHJvdG90eXBlLGkse2NyZWF0ZVByb3BlcnR5OmZ1bmN0aW9uKHQpe3ZhciBlPShpLmNyZWF0ZVByb3BlcnR5fHx3LnByb3RvdHlwZS5jcmVhdGVQcm9wZXJ0eSkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBlLmdldEJhc2VUeXBlJiYoZS5iYXNlVHlwZT1lLmJpbmFyeS5nZXRUeXBlKGUuZ2V0QmFzZVR5cGUoZS5iaW5hcnkuY29udGV4dHNbMF0pKSksZX19KX1wLl9nZXRDYWNoZWQ9ZnVuY3Rpb24odCxlLGkpe2lmKHQuaGFzT3duUHJvcGVydHkodGhpcy5jYWNoZUtleSkpcmV0dXJuIHRbdGhpcy5jYWNoZUtleV07ZT1lLmNhbGwodGhpcyx0KTtyZXR1cm4gZCh0LHRoaXMuY2FjaGVLZXkse3ZhbHVlOmV9LGkpLGV9LHAuZ2V0Q29udGV4dD1mdW5jdGlvbihlKXtzd2l0Y2godHlwZW9mIGUpe2Nhc2VcInVuZGVmaW5lZFwiOmU9MDtjYXNlXCJudW1iZXJcIjpyZXR1cm4gdGhpcy5jb250ZXh0c1tlXTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gdGhpcy5nZXRDb250ZXh0KGZ1bmN0aW9uKHQpe3JldHVybiBlIGluIHR9KTtjYXNlXCJmdW5jdGlvblwiOmZvcih2YXIgdD0wLGk9dGhpcy5jb250ZXh0cy5sZW5ndGg7dDxpO3QrKyl7dmFyIG49dGhpcy5jb250ZXh0c1t0XTtpZihlLmNhbGwodGhpcyxuKSlyZXR1cm4gbn19fSxwLmluQ29udGV4dD1mdW5jdGlvbih0LGUpe3RoaXMuY29udGV4dHMudW5zaGlmdCh0KTtlPWUuY2FsbCh0aGlzKTtyZXR1cm4gdGhpcy5jb250ZXh0cy5zaGlmdCgpLGV9LGcucHJvdG90eXBlPXtpbmhlcml0OmZ1bmN0aW9uKG4sYSl7dmFyIHIscz10aGlzO2Z1bmN0aW9uIHQodCxlKXt2YXIgaT1zW3RdO2kmJihyPXJ8fGwocyksZS5jYWxsKHIsaSksclt0XT1udWxsKX1yZXR1cm4gdChcInBhcmFtc1wiLGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLGk9dC5sZW5ndGg7ZTxpO2UrKyl0aGlzW3RbZV1dPW5bZV19KSx0KFwic2V0UGFyYW1zXCIsZnVuY3Rpb24odCl7dC5hcHBseSh0aGlzLG4pfSksdChcInR5cGVQYXJhbXNcIixmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxpPXQubGVuZ3RoO2U8aTtlKyspe3ZhciBuPXRbZV0scj10aGlzW25dO3ImJih0aGlzW25dPWEocikpfX0pLHQoXCJyZXNvbHZlXCIsZnVuY3Rpb24odCl7dC5jYWxsKHRoaXMsYSl9KSxyfHxzfSxjcmVhdGVQcm9wZXJ0eTpmdW5jdGlvbih0KXtyZXR1cm4gbCh0aGlzLHtiaW5hcnk6dCx2aWV3OnQudmlld30pfSx0b1ZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuITEhPT1lJiZcInN0cmluZ1wiPT10eXBlb2YgdD90aGlzLmJpbmFyeS5nZXRDb250ZXh0KHQpW3RdOmEodGhpcyx0aGlzLmJpbmFyeSx0KX19LHcucHJvdG90eXBlPWwoKHMuVHlwZT1nKS5wcm90b3R5cGUse3NldFBhcmFtczpmdW5jdGlvbigpe3RoaXMuYmFzZVR5cGUmJih0aGlzLnR5cGVQYXJhbXM9W1wiYmFzZVR5cGVcIl0uY29uY2F0KHRoaXMudHlwZVBhcmFtc3x8W10pKX0sYmFzZVJlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iaW5hcnkucmVhZCh0aGlzLmJhc2VUeXBlKX0sYmFzZVdyaXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmJpbmFyeS53cml0ZSh0aGlzLmJhc2VUeXBlLHQpfX0pLHIody5wcm90b3R5cGUse3JlYWQ6dy5wcm90b3R5cGUuYmFzZVJlYWQsd3JpdGU6dy5wcm90b3R5cGUuYmFzZVdyaXRlfSkscy5UZW1wbGF0ZT13LHAuYXM9ZnVuY3Rpb24odCxlKXtlPWU/dGhpczpsKHRoaXMpO3JldHVybiBlLnR5cGVTZXQ9KHQ9dHx8eSk9PT15fHx5LmlzUHJvdG90eXBlT2YodCk/dDpsKHksdCksZS5jYWNoZUtleT12LGUuY2FjaGVLZXk9ZS5fZ2V0Q2FjaGVkKHQsZnVuY3Rpb24oKXtyZXR1cm4gditcIi5cIisgKytifSwhMCksZX0scC5zZWVrPWZ1bmN0aW9uKHQsZSl7aWYodD10aGlzLnRvVmFsdWUodCksdm9pZCAwPT09ZSlyZXR1cm4gdGhpcy52aWV3LnNlZWsodCk7dmFyIGk9dGhpcy52aWV3LnRlbGwoKTt0aGlzLnZpZXcuc2Vlayh0KTtlPWUuY2FsbCh0aGlzKTtyZXR1cm4gdGhpcy52aWV3LnNlZWsoaSksZX0scC50ZWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy50ZWxsKCl9LHAuc2tpcD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNlZWsodGhpcy50ZWxsKCkrdGhpcy50b1ZhbHVlKHQpLGUpfSxwLnNsaWNlPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gbmV3IHModGhpcy52aWV3LnNsaWNlKHQsZSxpKSx0aGlzLnR5cGVTZXQpfSxwLl9nZXRUeXBlPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHR5cGVvZiB0KXtjYXNlXCJzdHJpbmdcIjppZighKHQgaW4gdGhpcy50eXBlU2V0KSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiK3QpO3JldHVybiB0aGlzLl9nZXRUeXBlKHRoaXMudHlwZVNldFt0XSxlKTtjYXNlXCJudW1iZXJcIjpyZXR1cm4gdGhpcy5fZ2V0VHlwZSh5LmJpdGZpZWxkLFt0XSk7Y2FzZVwib2JqZWN0XCI6aWYoZih0LGcpKXt2YXIgaT10aGlzO3JldHVybiB0LmluaGVyaXQoZXx8W10sZnVuY3Rpb24odCl7cmV0dXJuIGkuZ2V0VHlwZSh0KX0pfXJldHVybiBmKHQsQXJyYXkpP3RoaXMuX2dldENhY2hlZCh0LGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldFR5cGUodFswXSx0LnNsaWNlKDEpKX0sITApOnRoaXMuX2dldENhY2hlZCh0LGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldFR5cGUoeS5vYmplY3QsW3RdKX0sITEpfX0scC5nZXRUeXBlPWZ1bmN0aW9uKHQsZSl7ZT10aGlzLl9nZXRUeXBlKHQsZSk7cmV0dXJuIGUmJiFmKHQsZykmJihlLm5hbWU9XCJvYmplY3RcIj09dHlwZW9mIHQ/Zih0LEFycmF5KT90WzBdK1wiKFwiK3Quc2xpY2UoMSkuam9pbihcIiwgXCIpK1wiKVwiOlwib2JqZWN0XCI6U3RyaW5nKHQpKSxlfSxwLl9hY3Rpb249ZnVuY3Rpb24odCxlLGkpe2lmKHZvaWQgMCE9PXQpe3Q9dGhpcy5nZXRUeXBlKHQpO3ZhciBuPXRoaXMuX25hbWVkKGZ1bmN0aW9uKCl7cmV0dXJuIGkuY2FsbCh0aGlzLHQuY3JlYXRlUHJvcGVydHkodGhpcyksdGhpcy5jb250ZXh0c1swXSl9LFwiW1wiK3QubmFtZStcIl1cIixlKTtyZXR1cm4gdm9pZCAwIT09ZT90aGlzLnNlZWsoZSxuKTpuLmNhbGwodGhpcyl9fSxwLnJlYWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fYWN0aW9uKHQsZSxmdW5jdGlvbih0LGUpe3JldHVybiB0LnJlYWQoZSl9KX0scC5yZWFkQWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZChcImpCaW5hcnkuYWxsXCIsMCl9LHAud3JpdGU9ZnVuY3Rpb24odCxuLGUpe3JldHVybiB0aGlzLl9hY3Rpb24odCxlLGZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy50ZWxsKCk7cmV0dXJuIHQud3JpdGUobixlKSx0aGlzLnRlbGwoKS1pfSl9LHAud3JpdGVBbGw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMud3JpdGUoXCJqQmluYXJ5LmFsbFwiLHQsMCl9LGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPTAsbj1lLmxlbmd0aDtpPG47aSsrKXt2YXIgcj1lW2ldO3lbci50b0xvd2VyQ2FzZSgpXT1sKHQse2RhdGFUeXBlOnJ9KX19KGcoe3BhcmFtczpbXCJsaXR0bGVFbmRpYW5cIl0scmVhZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXdbXCJnZXRcIit0aGlzLmRhdGFUeXBlXSh2b2lkIDAsdGhpcy5saXR0bGVFbmRpYW4pfSx3cml0ZTpmdW5jdGlvbih0KXt0aGlzLnZpZXdbXCJ3cml0ZVwiK3RoaXMuZGF0YVR5cGVdKHQsdGhpcy5saXR0bGVFbmRpYW4pfX0pLFtcIlVpbnQ4XCIsXCJVaW50MTZcIixcIlVpbnQzMlwiLFwiVWludDY0XCIsXCJJbnQ4XCIsXCJJbnQxNlwiLFwiSW50MzJcIixcIkludDY0XCIsXCJGbG9hdDMyXCIsXCJGbG9hdDY0XCIsXCJDaGFyXCJdKSxyKHkse2J5dGU6eS51aW50OCxmbG9hdDp5LmZsb2F0MzIsZG91YmxlOnkuZmxvYXQ2NH0pLHkuYXJyYXk9dyh7cGFyYW1zOltcImJhc2VUeXBlXCIsXCJsZW5ndGhcIl0scmVhZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMudG9WYWx1ZSh0aGlzLmxlbmd0aCk7aWYodGhpcy5iYXNlVHlwZT09PXkudWludDgpcmV0dXJuIHRoaXMudmlldy5nZXRCeXRlcyh0LHZvaWQgMCwhMCwhMCk7aWYodm9pZCAwIT09dClmb3IodmFyIGU9bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSsrKWVbaV09dGhpcy5iYXNlUmVhZCgpO2Vsc2V7dmFyIG49dGhpcy52aWV3LmJ5dGVMZW5ndGg7Zm9yKGU9W107dGhpcy5iaW5hcnkudGVsbCgpPG47KWUucHVzaCh0aGlzLmJhc2VSZWFkKCkpfXJldHVybiBlfSx3cml0ZTpmdW5jdGlvbih0KXtpZih0aGlzLmJhc2VUeXBlPT09eS51aW50OClyZXR1cm4gdGhpcy52aWV3LndyaXRlQnl0ZXModCk7Zm9yKHZhciBlPTAsaT10Lmxlbmd0aDtlPGk7ZSsrKXRoaXMuYmFzZVdyaXRlKHRbZV0pfX0pLHkuYmluYXJ5PXcoe3BhcmFtczpbXCJsZW5ndGhcIixcInR5cGVTZXRcIl0scmVhZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYmluYXJ5LnRlbGwoKSxlPXRoaXMuYmluYXJ5LnNraXAodGhpcy50b1ZhbHVlKHRoaXMubGVuZ3RoKSk7cmV0dXJuIG5ldyBzKHRoaXMudmlldy5zbGljZSh0LGUpLHRoaXMudHlwZVNldCl9LHdyaXRlOmZ1bmN0aW9uKHQpe3RoaXMuYmluYXJ5LndyaXRlKFwiYmxvYlwiLHQucmVhZChcImJsb2JcIiwwKSl9fSkseS5iaXRmaWVsZD1nKHtwYXJhbXM6W1wiYml0U2l6ZVwiXSxyZWFkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5nZXRVbnNpZ25lZCh0aGlzLmJpdFNpemUpfSx3cml0ZTpmdW5jdGlvbih0KXt0aGlzLnZpZXcud3JpdGVVbnNpZ25lZCh0LHRoaXMuYml0U2l6ZSl9fSkseS5ibG9iPWcoe3BhcmFtczpbXCJsZW5ndGhcIl0scmVhZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0Qnl0ZXModGhpcy50b1ZhbHVlKHRoaXMubGVuZ3RoKSl9LHdyaXRlOmZ1bmN0aW9uKHQpe3RoaXMudmlldy53cml0ZUJ5dGVzKHQsITApfX0pLHkuY29uc3Q9dyh7cGFyYW1zOltcImJhc2VUeXBlXCIsXCJ2YWx1ZVwiLFwic3RyaWN0XCJdLHJlYWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJhc2VSZWFkKCk7aWYodGhpcy5zdHJpY3QmJnQhPT10aGlzLnZhbHVlKXtpZihmKHRoaXMuc3RyaWN0LEZ1bmN0aW9uKSlyZXR1cm4gdGhpcy5zdHJpY3QodCk7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgKFwiK3QrXCIgIT09IFwiK3RoaXMudmFsdWUrXCIpLlwiKX1yZXR1cm4gdH0sd3JpdGU6ZnVuY3Rpb24odCl7dGhpcy5iYXNlV3JpdGUodGhpcy5zdHJpY3R8fHZvaWQgMD09PXQ/dGhpcy52YWx1ZTp0KX19KSx5LmVudW09dyh7cGFyYW1zOltcImJhc2VUeXBlXCIsXCJtYXRjaGVzXCJdLHNldFBhcmFtczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgaSBpbiB0aGlzLmJhY2tNYXRjaGVzPXt9LGUpdGhpcy5iYWNrTWF0Y2hlc1tlW2ldXT1pfSxyZWFkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5iYXNlUmVhZCgpO3JldHVybiB0IGluIHRoaXMubWF0Y2hlcz90aGlzLm1hdGNoZXNbdF06dH0sd3JpdGU6ZnVuY3Rpb24odCl7dGhpcy5iYXNlV3JpdGUodCBpbiB0aGlzLmJhY2tNYXRjaGVzP3RoaXMuYmFja01hdGNoZXNbdF06dCl9fSkseS5leHRlbmQ9Zyh7c2V0UGFyYW1zOmZ1bmN0aW9uKCl7dGhpcy5wYXJ0cz1hcmd1bWVudHN9LHJlc29sdmU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMucGFydHMsaT1lLmxlbmd0aCxuPW5ldyBBcnJheShpKSxyPTA7cjxpO3IrKyluW3JdPXQoZVtyXSk7dGhpcy5wYXJ0cz1ufSxyZWFkOmZ1bmN0aW9uKCl7dmFyIGk9dGhpcy5wYXJ0cyxuPXRoaXMuYmluYXJ5LnJlYWQoaVswXSk7cmV0dXJuIHRoaXMuYmluYXJ5LmluQ29udGV4dChuLGZ1bmN0aW9uKCl7Zm9yKHZhciB0PTEsZT1pLmxlbmd0aDt0PGU7dCsrKXIobix0aGlzLnJlYWQoaVt0XSkpfSksbn0sd3JpdGU6ZnVuY3Rpb24oaSl7dmFyIG49dGhpcy5wYXJ0czt0aGlzLmJpbmFyeS5pbkNvbnRleHQoaSxmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9bi5sZW5ndGg7dDxlO3QrKyl0aGlzLndyaXRlKG5bdF0saSl9KX19KSx5LmlmPXcoe3BhcmFtczpbXCJjb25kaXRpb25cIixcInRydWVUeXBlXCIsXCJmYWxzZVR5cGVcIl0sdHlwZVBhcmFtczpbXCJ0cnVlVHlwZVwiLFwiZmFsc2VUeXBlXCJdLGdldEJhc2VUeXBlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRvVmFsdWUodGhpcy5jb25kaXRpb24pP3RoaXMudHJ1ZVR5cGU6dGhpcy5mYWxzZVR5cGV9fSkseS5pZl9ub3Q9eS5pZk5vdD13KHtzZXRQYXJhbXM6ZnVuY3Rpb24odCxlLGkpe3RoaXMuYmFzZVR5cGU9W1wiaWZcIix0LGksZV19fSkseS5sYXp5PXcoe21hcmtlcjpcImpCaW5hcnkuTGF6eVwiLHBhcmFtczpbXCJpbm5lclR5cGVcIixcImxlbmd0aFwiXSxnZXRCYXNlVHlwZTpmdW5jdGlvbigpe3JldHVybltcImJpbmFyeVwiLHRoaXMubGVuZ3RoLHRoaXMuYmluYXJ5LnR5cGVTZXRdfSxyZWFkOmZ1bmN0aW9uKCl7dmFyIGU9ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP1widmFsdWVcImluIGU/ZS52YWx1ZTplLnZhbHVlPWUuYmluYXJ5LnJlYWQoZS5pbm5lclR5cGUpOnIoZSx7d2FzQ2hhbmdlZDohMCx2YWx1ZTp0fSkudmFsdWV9O3JldHVybiBlW3RoaXMubWFya2VyXT0hMCxyKGUse2JpbmFyeTpyKHRoaXMuYmFzZVJlYWQoKSx7Y29udGV4dHM6dGhpcy5iaW5hcnkuY29udGV4dHMuc2xpY2UoKX0pLGlubmVyVHlwZTp0aGlzLmlubmVyVHlwZX0pfSx3cml0ZTpmdW5jdGlvbih0KXt0Lndhc0NoYW5nZWR8fCF0W3RoaXMubWFya2VyXT90aGlzLmJpbmFyeS53cml0ZSh0aGlzLmlubmVyVHlwZSx0KCkpOnRoaXMuYmFzZVdyaXRlKHQuYmluYXJ5KX19KSx5Lm9iamVjdD1nKHtwYXJhbXM6W1wic3RydWN0dXJlXCIsXCJwcm90b1wiXSxyZXNvbHZlOmZ1bmN0aW9uKHQpe3ZhciBlLGk9e307Zm9yKGUgaW4gdGhpcy5zdHJ1Y3R1cmUpaVtlXT1mKHRoaXMuc3RydWN0dXJlW2VdLEZ1bmN0aW9uKT90aGlzLnN0cnVjdHVyZVtlXTp0KHRoaXMuc3RydWN0dXJlW2VdKTt0aGlzLnN0cnVjdHVyZT1pfSxyZWFkOmZ1bmN0aW9uKCl7dmFyIGk9dGhpcyxuPXRoaXMuc3RydWN0dXJlLHI9dGhpcy5wcm90bz9sKHRoaXMucHJvdG8pOnt9O3JldHVybiB0aGlzLmJpbmFyeS5pbkNvbnRleHQocixmdW5jdGlvbigpe2Zvcih2YXIgZSBpbiBuKXRoaXMuX25hbWVkKGZ1bmN0aW9uKCl7dmFyIHQ9ZihuW2VdLEZ1bmN0aW9uKT9uW2VdLmNhbGwoaSxyKTp0aGlzLnJlYWQobltlXSk7dm9pZCAwIT09dCYmKHJbZV09dCl9LGUpLmNhbGwodGhpcyl9KSxyfSx3cml0ZTpmdW5jdGlvbihlKXt2YXIgaT10aGlzLG49dGhpcy5zdHJ1Y3R1cmU7dGhpcy5iaW5hcnkuaW5Db250ZXh0KGUsZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gbil0aGlzLl9uYW1lZChmdW5jdGlvbigpe2Yoblt0XSxGdW5jdGlvbik/ZVt0XT1uW3RdLmNhbGwoaSxlKTp0aGlzLndyaXRlKG5bdF0sZVt0XSl9LHQpLmNhbGwodGhpcyl9KX19KSx5LnNraXA9Zyh7cGFyYW1zOltcImxlbmd0aFwiXSxyZWFkOmZ1bmN0aW9uKCl7dGhpcy52aWV3LnNraXAodGhpcy50b1ZhbHVlKHRoaXMubGVuZ3RoKSl9LHdyaXRlOmZ1bmN0aW9uKCl7dGhpcy5yZWFkKCl9fSkseS5zdHJpbmc9dyh7cGFyYW1zOltcImxlbmd0aFwiLFwiZW5jb2RpbmdcIl0scmVhZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0U3RyaW5nKHRoaXMudG9WYWx1ZSh0aGlzLmxlbmd0aCksdm9pZCAwLHRoaXMuZW5jb2RpbmcpfSx3cml0ZTpmdW5jdGlvbih0KXt0aGlzLnZpZXcud3JpdGVTdHJpbmcodCx0aGlzLmVuY29kaW5nKX19KSx5LnN0cmluZzA9Zyh7cGFyYW1zOltcImxlbmd0aFwiLFwiZW5jb2RpbmdcIl0scmVhZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMudmlldztpZih2b2lkIDAhPT0obj10aGlzLmxlbmd0aCkpcmV0dXJuIHQuZ2V0U3RyaW5nKG4sdm9pZCAwLHRoaXMuZW5jb2RpbmcpLnJlcGxhY2UoL1xcMC4qJC8sXCJcIik7Zm9yKHZhciBlPXQudGVsbCgpLGk9MCxuPXQuYnl0ZUxlbmd0aC1lO2k8biYmdC5nZXRVaW50OCgpOylpKys7ZT10LmdldFN0cmluZyhpLGUsdGhpcy5lbmNvZGluZyk7cmV0dXJuIGk8biYmdC5za2lwKDEpLGV9LHdyaXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudmlldyxpPXZvaWQgMD09PXRoaXMubGVuZ3RoPzE6dGhpcy5sZW5ndGgtdC5sZW5ndGg7ZS53cml0ZVN0cmluZyh0LHZvaWQgMCx0aGlzLmVuY29kaW5nKSwwPGkmJihlLndyaXRlVWludDgoMCksZS5za2lwKGktMSkpfX0pO3MubG9hZERhdGE9dChmdW5jdGlvbih0LGUpe3ZhciBpO2lmKGYodCxoLkJsb2IpKWlmKFwiRmlsZVJlYWRlclwiaW4gaCkoYT1uZXcgRmlsZVJlYWRlcikub25sb2FkPWEub25lcnJvcj1mdW5jdGlvbigpe2UodGhpcy5lcnJvcix0aGlzLnJlc3VsdCl9LGEucmVhZEFzQXJyYXlCdWZmZXIodCk7ZWxzZXt2YXIgbixyLGE9bmV3IEZpbGVSZWFkZXJTeW5jO3RyeXtyPWEucmVhZEFzQXJyYXlCdWZmZXIodCl9Y2F0Y2godCl7bj10fWZpbmFsbHl7ZShuLHIpfX1lbHNlIGlmKDAsXCJzdHJpbmdcIiE9dHlwZW9mIHQpZShuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgc291cmNlIHR5cGUuXCIpKTtlbHNlIGlmKHI9dC5tYXRjaCgvXmRhdGE6KC4rPykoO2Jhc2U2NCk/LCguKikkLykpdHJ5e3ZhciBzPXJbMl0sbz1yWzNdO2UobnVsbCwocz9hdG9iOmRlY29kZVVSSUNvbXBvbmVudCkobykpfWNhdGNoKHQpe2UodCl9ZWxzZVwiWE1MSHR0cFJlcXVlc3RcImluIGg/KChvPW5ldyBYTUxIdHRwUmVxdWVzdCkub3BlbihcIkdFVFwiLHQsITApLFwicmVzcG9uc2VUeXBlXCJpbiBvP28ucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjpcIm92ZXJyaWRlTWltZVR5cGVcImluIG8/by5vdmVycmlkZU1pbWVUeXBlKFwidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZFwiKTpvLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHQtQ2hhcnNldFwiLFwieC11c2VyLWRlZmluZWRcIiksXCJvbmxvYWRcImluIG98fChvLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpezQ9PT10aGlzLnJlYWR5U3RhdGUmJnRoaXMub25sb2FkKCl9KSxpPWZ1bmN0aW9uKHQpe2UobmV3IEVycm9yKHQpKX0sby5vbmxvYWQ9ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5zdGF0dXMmJjIwMCE9PXRoaXMuc3RhdHVzKXJldHVybiBpKFwiSFRUUCBFcnJvciAjXCIrdGhpcy5zdGF0dXMrXCI6IFwiK3RoaXMuc3RhdHVzVGV4dCk7XCJyZXNwb25zZVwiaW4gdGhpc3x8KHRoaXMucmVzcG9uc2U9bmV3IFZCQXJyYXkodGhpcy5yZXNwb25zZUJvZHkpLnRvQXJyYXkoKSksZShudWxsLHRoaXMucmVzcG9uc2UpfSxvLm9uZXJyb3I9ZnVuY3Rpb24oKXtpKFwiTmV0d29yayBlcnJvci5cIil9LG8uc2VuZChudWxsKSk6ZShuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgc291cmNlIHR5cGUuXCIpKX0pLChzLmxvYWQ9dChmdW5jdGlvbih0LGUsaSl7dmFyIG49cy5sb2FkRGF0YSh0KTtzLmxvYWQuZ2V0VHlwZVNldCh0LGUsZnVuY3Rpb24oZSl7bi50aGVuKGZ1bmN0aW9uKHQpe2kobnVsbCxuZXcgcyh0LGUpKX0saSl9KX0pKS5nZXRUeXBlU2V0PWZ1bmN0aW9uKHQsZSxpKXtpKGUpfSxwLl90b1VSST1cIlVSTFwiaW4gaCYmXCJjcmVhdGVPYmplY3RVUkxcImluIFVSTD9mdW5jdGlvbih0KXt2YXIgZT10aGlzLnNlZWsoMCxmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0Qnl0ZXMoKX0pO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtlXSx7dHlwZTp0fSkpfTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnNlZWsoMCxmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0U3RyaW5nKHZvaWQgMCx2b2lkIDAsXCJiaW5hcnlcIil9KTtyZXR1cm5cImRhdGE6XCIrdCtcIjtiYXNlNjQsXCIrYnRvYShlKX0scC5fbWltZVR5cGU9ZnVuY3Rpb24odCl7cmV0dXJuIHR8fHRoaXMudHlwZVNldFtcImpCaW5hcnkubWltZVR5cGVcIl18fFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9O3ZhciBtO3AudG9VUkk9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3RvVVJJKHRoaXMuX21pbWVUeXBlKHQpKX07cmV0dXJuIG4mJigobT1zLmRvd25sb2FkZXI9bi5jcmVhdGVFbGVtZW50KFwiYVwiKSkuc3R5bGUuZGlzcGxheT1cIm5vbmVcIikscC5zYXZlQXM9dChmdW5jdGlvbih0LGUsaSl7XCJzdHJpbmdcIj09dHlwZW9mIHQ/KFwibXNTYXZlQmxvYlwiaW4gbmF2aWdhdG9yP25hdmlnYXRvci5tc1NhdmVCbG9iKG5ldyBCbG9iKFt0aGlzLnJlYWQoXCJibG9iXCIsMCldLHt0eXBlOnRoaXMuX21pbWVUeXBlKGUpfSksdCk6bj8obS5wYXJlbnROb2RlfHxuLmJvZHkuYXBwZW5kQ2hpbGQobSksbS5ocmVmPXRoaXMudG9VUkkoZSksbS5kb3dubG9hZD10LG0uY2xpY2soKSxtLmhyZWY9bS5kb3dubG9hZD1cIlwiKTppKG5ldyBUeXBlRXJyb3IoXCJTYXZpbmcgZnJvbSBXZWIgV29ya2VyIGlzIG5vdCBzdXBwb3J0ZWQuXCIpKSxpKCkpOmkobmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHN0b3JhZ2UgdHlwZS5cIikpfSksc30pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9amJpbmFyeS5qcy5tYXAiLCIhZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIHZhciBnbG9iYWwgPSB0aGlzO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iYWwpO1xufShmdW5jdGlvbihnbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBpcyhvYmosIEN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFwib2JqZWN0XCIgIT0gdHlwZW9mIG9iaiB8fCBudWxsID09PSBvYmogPyAhMSA6IG9iai5jb25zdHJ1Y3RvciA9PT0gQ3RvciB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IFwiICsgQ3Rvci5uYW1lICsgXCJdXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5RnJvbShhcnJheUxpa2UsIGZvcmNlQ29weSkge1xuICAgICAgICByZXR1cm4gIWZvcmNlQ29weSAmJiBpcyhhcnJheUxpa2UsIEFycmF5KSA/IGFycmF5TGlrZSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZWQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwICE9PSB2YWx1ZSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgaWYgKGpEYXRhVmlldy5pcyhidWZmZXIpKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuX2xpdHRsZUVuZGlhbiA9IGRlZmluZWQobGl0dGxlRW5kaWFuLCByZXN1bHQuX2xpdHRsZUVuZGlhbiksIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpEYXRhVmlldy5pcyh0aGlzKSkgcmV0dXJuIG5ldyBqRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICBpZiAodGhpcy5idWZmZXIgPSBidWZmZXIgPSBqRGF0YVZpZXcud3JhcEJ1ZmZlcihidWZmZXIpLCB0aGlzLl9pc0FycmF5QnVmZmVyID0gY29tcGF0aWJpbGl0eS5BcnJheUJ1ZmZlciAmJiBpcyhidWZmZXIsIEFycmF5QnVmZmVyKSwgXG4gICAgICAgIHRoaXMuX2lzUGl4ZWxEYXRhID0gITEsIHRoaXMuX2lzRGF0YVZpZXcgPSBjb21wYXRpYmlsaXR5LkRhdGFWaWV3ICYmIHRoaXMuX2lzQXJyYXlCdWZmZXIsIFxuICAgICAgICB0aGlzLl9pc05vZGVCdWZmZXIgPSAhMCAmJiBjb21wYXRpYmlsaXR5Lk5vZGVCdWZmZXIgJiYgaXMoYnVmZmVyLCBCdWZmZXIpLCAhdGhpcy5faXNOb2RlQnVmZmVyICYmICF0aGlzLl9pc0FycmF5QnVmZmVyICYmICFpcyhidWZmZXIsIEFycmF5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImpEYXRhVmlldyBidWZmZXIgaGFzIGFuIGluY29tcGF0aWJsZSB0eXBlXCIpO1xuICAgICAgICB0aGlzLl9saXR0bGVFbmRpYW4gPSAhIWxpdHRsZUVuZGlhbjtcbiAgICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IFwiYnl0ZUxlbmd0aFwiIGluIGJ1ZmZlciA/IGJ1ZmZlci5ieXRlTGVuZ3RoIDogYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldCA9IGRlZmluZWQoYnl0ZU9mZnNldCwgMCksIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPSBkZWZpbmVkKGJ5dGVMZW5ndGgsIGJ1ZmZlckxlbmd0aCAtIGJ5dGVPZmZzZXQpLCBcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fYml0T2Zmc2V0ID0gMCwgdGhpcy5faXNEYXRhVmlldyA/IHRoaXMuX3ZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSA6IHRoaXMuX2NoZWNrQm91bmRzKGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgsIGJ1ZmZlckxlbmd0aCksIFxuICAgICAgICB0aGlzLl9lbmdpbmVBY3Rpb24gPSB0aGlzLl9pc0RhdGFWaWV3ID8gdGhpcy5fZGF0YVZpZXdBY3Rpb24gOiB0aGlzLl9pc05vZGVCdWZmZXIgPyB0aGlzLl9ub2RlQnVmZmVyQWN0aW9uIDogdGhpcy5faXNBcnJheUJ1ZmZlciA/IHRoaXMuX2FycmF5QnVmZmVyQWN0aW9uIDogdGhpcy5fYXJyYXlBY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENoYXJDb2RlcyhzdHJpbmcpIHtcbiAgICAgICAgaWYgKGNvbXBhdGliaWxpdHkuTm9kZUJ1ZmZlcikgcmV0dXJuIG5ldyBCdWZmZXIoc3RyaW5nLCBcImJpbmFyeVwiKTtcbiAgICAgICAgZm9yICh2YXIgVHlwZSA9IGNvbXBhdGliaWxpdHkuQXJyYXlCdWZmZXIgPyBVaW50OEFycmF5IDogQXJyYXksIGNvZGVzID0gbmV3IFR5cGUoc3RyaW5nLmxlbmd0aCksIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBsZW5ndGggPiBpOyBpKyspIGNvZGVzW2ldID0gMjU1ICYgc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcG93MihuKSB7XG4gICAgICAgIHJldHVybiBuID49IDAgJiYgMzEgPiBuID8gMSA8PCBuIDogcG93MltuXSB8fCAocG93MltuXSA9IE1hdGgucG93KDIsIG4pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVWludDY0KGxvLCBoaSkge1xuICAgICAgICB0aGlzLmxvID0gbG8sIHRoaXMuaGkgPSBoaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50NjQoKSB7XG4gICAgICAgIFVpbnQ2NC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB2YXIgY29tcGF0aWJpbGl0eSA9IHtcbiAgICAgICAgTm9kZUJ1ZmZlcjogITAgJiYgXCJCdWZmZXJcIiBpbiBnbG9iYWwsXG4gICAgICAgIERhdGFWaWV3OiBcIkRhdGFWaWV3XCIgaW4gZ2xvYmFsLFxuICAgICAgICBBcnJheUJ1ZmZlcjogXCJBcnJheUJ1ZmZlclwiIGluIGdsb2JhbCxcbiAgICAgICAgUGl4ZWxEYXRhOiAhMVxuICAgIH0sIFRleHRFbmNvZGVyID0gZ2xvYmFsLlRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciA9IGdsb2JhbC5UZXh0RGVjb2RlcjtcbiAgICBjb21wYXRpYmlsaXR5Lk5vZGVCdWZmZXIgJiYgIWZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXRMRSgxLzAsIDApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb21wYXRpYmlsaXR5Lk5vZGVCdWZmZXIgPSAhMTtcbiAgICAgICAgfVxuICAgIH0obmV3IEJ1ZmZlcig0KSk7XG4gICAgdmFyIGRhdGFUeXBlcyA9IHtcbiAgICAgICAgSW50ODogMSxcbiAgICAgICAgSW50MTY6IDIsXG4gICAgICAgIEludDMyOiA0LFxuICAgICAgICBVaW50ODogMSxcbiAgICAgICAgVWludDE2OiAyLFxuICAgICAgICBVaW50MzI6IDQsXG4gICAgICAgIEZsb2F0MzI6IDQsXG4gICAgICAgIEZsb2F0NjQ6IDhcbiAgICB9O1xuICAgIGpEYXRhVmlldy53cmFwQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGJ1ZmZlcikge1xuICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGlmIChjb21wYXRpYmlsaXR5Lk5vZGVCdWZmZXIpIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKSwgYnVmZmVyLmZpbGwoMCk7IGVsc2UgaWYgKGNvbXBhdGliaWxpdHkuQXJyYXlCdWZmZXIpIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuYnVmZmVyOyBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG5cbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBidWZmZXIgPSBnZXRDaGFyQ29kZXMoYnVmZmVyKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJsZW5ndGhcIiBpbiBidWZmZXIgJiYgIShjb21wYXRpYmlsaXR5Lk5vZGVCdWZmZXIgJiYgaXMoYnVmZmVyLCBCdWZmZXIpIHx8IGNvbXBhdGliaWxpdHkuQXJyYXlCdWZmZXIgJiYgaXMoYnVmZmVyLCBBcnJheUJ1ZmZlcikpICYmIChjb21wYXRpYmlsaXR5Lk5vZGVCdWZmZXIgPyBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcikgOiBjb21wYXRpYmlsaXR5LkFycmF5QnVmZmVyID8gaXMoYnVmZmVyLCBBcnJheUJ1ZmZlcikgfHwgKGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuYnVmZmVyLCBcbiAgICAgICAgICAgIGlzKGJ1ZmZlciwgQXJyYXlCdWZmZXIpIHx8IChidWZmZXIgPSBuZXcgVWludDhBcnJheShhcnJheUZyb20oYnVmZmVyLCAhMCkpLmJ1ZmZlcikpIDogYnVmZmVyID0gYXJyYXlGcm9tKGJ1ZmZlcikpLCBcbiAgICAgICAgICAgIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH0sIGpEYXRhVmlldy5pcyA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcgJiYgdmlldy5qRGF0YVZpZXc7XG4gICAgfSwgakRhdGFWaWV3LmZyb20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBqRGF0YVZpZXcoYXJndW1lbnRzKTtcbiAgICB9LCBqRGF0YVZpZXcuVWludDY0ID0gVWludDY0LCBVaW50NjQucHJvdG90eXBlID0ge1xuICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvICsgcG93MigzMikgKiB0aGlzLmhpO1xuICAgICAgICB9LFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh0aGlzLnZhbHVlT2YoKSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sIFVpbnQ2NC5mcm9tTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IobnVtYmVyIC8gcG93MigzMikpLCBsbyA9IG51bWJlciAtIGhpICogcG93MigzMik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDY0KGxvLCBoaSk7XG4gICAgfSwgakRhdGFWaWV3LkludDY0ID0gSW50NjQsIEludDY0LnByb3RvdHlwZSA9IFwiY3JlYXRlXCIgaW4gT2JqZWN0ID8gT2JqZWN0LmNyZWF0ZShVaW50NjQucHJvdG90eXBlKSA6IG5ldyBVaW50NjQoKSwgXG4gICAgSW50NjQucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGkgPCBwb3cyKDMxKSA/IFVpbnQ2NC5wcm90b3R5cGUudmFsdWVPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLShwb3cyKDMyKSAtIHRoaXMubG8gKyBwb3cyKDMyKSAqIChwb3cyKDMyKSAtIDEgLSB0aGlzLmhpKSk7XG4gICAgfSwgSW50NjQuZnJvbU51bWJlciA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICB2YXIgbG8sIGhpO1xuICAgICAgICBpZiAobnVtYmVyID49IDApIHtcbiAgICAgICAgICAgIHZhciB1bnNpZ25lZCA9IFVpbnQ2NC5mcm9tTnVtYmVyKG51bWJlcik7XG4gICAgICAgICAgICBsbyA9IHVuc2lnbmVkLmxvLCBoaSA9IHVuc2lnbmVkLmhpO1xuICAgICAgICB9IGVsc2UgaGkgPSBNYXRoLmZsb29yKG51bWJlciAvIHBvdzIoMzIpKSwgbG8gPSBudW1iZXIgLSBoaSAqIHBvdzIoMzIpLCBoaSArPSBwb3cyKDMyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ2NChsbywgaGkpO1xuICAgIH07XG4gICAgdmFyIHByb3RvID0gakRhdGFWaWV3LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29tcGF0aWJpbGl0eTogY29tcGF0aWJpbGl0eSxcbiAgICAgICAgakRhdGFWaWV3OiAhMCxcbiAgICAgICAgX2NoZWNrQm91bmRzOiBmdW5jdGlvbihieXRlT2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiBieXRlT2Zmc2V0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2Zmc2V0IGlzIG5vdCBhIG51bWJlci5cIik7XG4gICAgICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgYnl0ZUxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlNpemUgaXMgbm90IGEgbnVtYmVyLlwiKTtcbiAgICAgICAgICAgIGlmICgwID4gYnl0ZUxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMZW5ndGggaXMgbmVnYXRpdmUuXCIpO1xuICAgICAgICAgICAgaWYgKDAgPiBieXRlT2Zmc2V0IHx8IGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoID4gZGVmaW5lZChtYXhMZW5ndGgsIHRoaXMuYnl0ZUxlbmd0aCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiT2Zmc2V0cyBhcmUgb3V0IG9mIGJvdW5kcy5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIF9hY3Rpb246IGZ1bmN0aW9uKHR5cGUsIGlzUmVhZEFjdGlvbiwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuZ2luZUFjdGlvbih0eXBlLCBpc1JlYWRBY3Rpb24sIGRlZmluZWQoYnl0ZU9mZnNldCwgdGhpcy5fb2Zmc2V0KSwgZGVmaW5lZChsaXR0bGVFbmRpYW4sIHRoaXMuX2xpdHRsZUVuZGlhbiksIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RhdGFWaWV3QWN0aW9uOiBmdW5jdGlvbih0eXBlLCBpc1JlYWRBY3Rpb24sIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbiwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPSBieXRlT2Zmc2V0ICsgZGF0YVR5cGVzW3R5cGVdLCBpc1JlYWRBY3Rpb24gPyB0aGlzLl92aWV3W1wiZ2V0XCIgKyB0eXBlXShieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIDogdGhpcy5fdmlld1tcInNldFwiICsgdHlwZV0oYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9hcnJheUJ1ZmZlckFjdGlvbjogZnVuY3Rpb24odHlwZSwgaXNSZWFkQWN0aW9uLCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZWRBcnJheSwgc2l6ZSA9IGRhdGFUeXBlc1t0eXBlXSwgVHlwZWRBcnJheSA9IGdsb2JhbFt0eXBlICsgXCJBcnJheVwiXTtcbiAgICAgICAgICAgIGlmIChsaXR0bGVFbmRpYW4gPSBkZWZpbmVkKGxpdHRsZUVuZGlhbiwgdGhpcy5fbGl0dGxlRW5kaWFuKSwgMSA9PT0gc2l6ZSB8fCAodGhpcy5ieXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCkgJSBzaXplID09PSAwICYmIGxpdHRsZUVuZGlhbikgcmV0dXJuIHR5cGVkQXJyYXkgPSBuZXcgVHlwZWRBcnJheSh0aGlzLmJ1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCwgMSksIFxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gYnl0ZU9mZnNldCArIHNpemUsIGlzUmVhZEFjdGlvbiA/IHR5cGVkQXJyYXlbMF0gOiB0eXBlZEFycmF5WzBdID0gdmFsdWU7XG4gICAgICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShpc1JlYWRBY3Rpb24gPyB0aGlzLmdldEJ5dGVzKHNpemUsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbiwgITApIDogc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZWRBcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ5dGVzLmJ1ZmZlciwgMCwgMSksIGlzUmVhZEFjdGlvbiA/IHR5cGVkQXJyYXlbMF0gOiAodHlwZWRBcnJheVswXSA9IHZhbHVlLCBcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc2V0Qnl0ZXMoYnl0ZU9mZnNldCwgYnl0ZXMsIGxpdHRsZUVuZGlhbikpO1xuICAgICAgICB9LFxuICAgICAgICBfYXJyYXlBY3Rpb246IGZ1bmN0aW9uKHR5cGUsIGlzUmVhZEFjdGlvbiwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZEFjdGlvbiA/IHRoaXNbXCJfZ2V0XCIgKyB0eXBlXShieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIDogdGhpc1tcIl9zZXRcIiArIHR5cGVdKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0Qnl0ZXM6IGZ1bmN0aW9uKGxlbmd0aCwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBkZWZpbmVkKGxpdHRsZUVuZGlhbiwgdGhpcy5fbGl0dGxlRW5kaWFuKSwgYnl0ZU9mZnNldCA9IGRlZmluZWQoYnl0ZU9mZnNldCwgdGhpcy5fb2Zmc2V0KSwgXG4gICAgICAgICAgICBsZW5ndGggPSBkZWZpbmVkKGxlbmd0aCwgdGhpcy5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldCksIHRoaXMuX2NoZWNrQm91bmRzKGJ5dGVPZmZzZXQsIGxlbmd0aCksIFxuICAgICAgICAgICAgYnl0ZU9mZnNldCArPSB0aGlzLmJ5dGVPZmZzZXQsIHRoaXMuX29mZnNldCA9IGJ5dGVPZmZzZXQgLSB0aGlzLmJ5dGVPZmZzZXQgKyBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5faXNBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpIDogKHRoaXMuYnVmZmVyLnNsaWNlIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZSkuY2FsbCh0aGlzLmJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gbGl0dGxlRW5kaWFuIHx8IDEgPj0gbGVuZ3RoID8gcmVzdWx0IDogYXJyYXlGcm9tKHJlc3VsdCkucmV2ZXJzZSgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRCeXRlczogZnVuY3Rpb24obGVuZ3RoLCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRvQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9nZXRCeXRlcyhsZW5ndGgsIGJ5dGVPZmZzZXQsIGRlZmluZWQobGl0dGxlRW5kaWFuLCAhMCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQXJyYXkgPyBhcnJheUZyb20ocmVzdWx0KSA6IHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldEJ5dGVzOiBmdW5jdGlvbihieXRlT2Zmc2V0LCBieXRlcywgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKDAgIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsaXR0bGVFbmRpYW4gPSBkZWZpbmVkKGxpdHRsZUVuZGlhbiwgdGhpcy5fbGl0dGxlRW5kaWFuKSwgYnl0ZU9mZnNldCA9IGRlZmluZWQoYnl0ZU9mZnNldCwgdGhpcy5fb2Zmc2V0KSwgXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tCb3VuZHMoYnl0ZU9mZnNldCwgbGVuZ3RoKSwgIWxpdHRsZUVuZGlhbiAmJiBsZW5ndGggPiAxICYmIChieXRlcyA9IGFycmF5RnJvbShieXRlcywgITApLnJldmVyc2UoKSksIFxuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gdGhpcy5ieXRlT2Zmc2V0LCB0aGlzLl9pc0FycmF5QnVmZmVyKSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKS5zZXQoYnl0ZXMpOyBlbHNlIGlmICh0aGlzLl9pc05vZGVCdWZmZXIpIG5ldyBCdWZmZXIoYnl0ZXMpLmNvcHkodGhpcy5idWZmZXIsIGJ5dGVPZmZzZXQpOyBlbHNlIGZvciAodmFyIGkgPSAwOyBsZW5ndGggPiBpOyBpKyspIHRoaXMuYnVmZmVyW2J5dGVPZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGJ5dGVPZmZzZXQgLSB0aGlzLmJ5dGVPZmZzZXQgKyBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEJ5dGVzOiBmdW5jdGlvbihieXRlT2Zmc2V0LCBieXRlcywgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRCeXRlcyhieXRlT2Zmc2V0LCBieXRlcywgZGVmaW5lZChsaXR0bGVFbmRpYW4sICEwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0cmluZzogZnVuY3Rpb24oYnl0ZUxlbmd0aCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc05vZGVCdWZmZXIpIHJldHVybiBieXRlT2Zmc2V0ID0gZGVmaW5lZChieXRlT2Zmc2V0LCB0aGlzLl9vZmZzZXQpLCBieXRlTGVuZ3RoID0gZGVmaW5lZChieXRlTGVuZ3RoLCB0aGlzLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0KSwgXG4gICAgICAgICAgICB0aGlzLl9jaGVja0JvdW5kcyhieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSwgdGhpcy5fb2Zmc2V0ID0gYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgsIFxuICAgICAgICAgICAgdGhpcy5idWZmZXIudG9TdHJpbmcoZW5jb2RpbmcgfHwgXCJiaW5hcnlcIiwgdGhpcy5ieXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCwgdGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBieXRlcyA9IHRoaXMuX2dldEJ5dGVzKGJ5dGVMZW5ndGgsIGJ5dGVPZmZzZXQsICEwKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9IFwidXRmOFwiID09PSBlbmNvZGluZyA/IFwidXRmLThcIiA6IGVuY29kaW5nIHx8IFwiYmluYXJ5XCIsIFRleHREZWNvZGVyICYmIFwiYmluYXJ5XCIgIT09IGVuY29kaW5nKSByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nKS5kZWNvZGUodGhpcy5faXNBcnJheUJ1ZmZlciA/IGJ5dGVzIDogbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBieXRlTGVuZ3RoID4gaTsgaSsrKSBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICAgICAgICByZXR1cm4gXCJ1dGYtOFwiID09PSBlbmNvZGluZyAmJiAoc3RyaW5nID0gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHJpbmcpKSksIHN0cmluZztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3RyaW5nOiBmdW5jdGlvbihieXRlT2Zmc2V0LCBzdWJTdHJpbmcsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNOb2RlQnVmZmVyKSByZXR1cm4gYnl0ZU9mZnNldCA9IGRlZmluZWQoYnl0ZU9mZnNldCwgdGhpcy5fb2Zmc2V0KSwgdGhpcy5fY2hlY2tCb3VuZHMoYnl0ZU9mZnNldCwgc3ViU3RyaW5nLmxlbmd0aCksIFxuICAgICAgICAgICAgdm9pZCAodGhpcy5fb2Zmc2V0ID0gYnl0ZU9mZnNldCArIHRoaXMuYnVmZmVyLndyaXRlKHN1YlN0cmluZywgdGhpcy5ieXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCwgZW5jb2RpbmcgfHwgXCJiaW5hcnlcIikpO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSBcInV0ZjhcIiA9PT0gZW5jb2RpbmcgPyBcInV0Zi04XCIgOiBlbmNvZGluZyB8fCBcImJpbmFyeVwiO1xuICAgICAgICAgICAgdmFyIGJ5dGVzO1xuICAgICAgICAgICAgVGV4dEVuY29kZXIgJiYgXCJiaW5hcnlcIiAhPT0gZW5jb2RpbmcgPyBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcihlbmNvZGluZykuZW5jb2RlKHN1YlN0cmluZykgOiAoXCJ1dGYtOFwiID09PSBlbmNvZGluZyAmJiAoc3ViU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN1YlN0cmluZykpKSwgXG4gICAgICAgICAgICBieXRlcyA9IGdldENoYXJDb2RlcyhzdWJTdHJpbmcpKSwgdGhpcy5fc2V0Qnl0ZXMoYnl0ZU9mZnNldCwgYnl0ZXMsICEwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2hhcjogZnVuY3Rpb24oYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RyaW5nKDEsIGJ5dGVPZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDaGFyOiBmdW5jdGlvbihieXRlT2Zmc2V0LCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKGJ5dGVPZmZzZXQsIGNoYXJhY3Rlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRlbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgc2VlazogZnVuY3Rpb24oYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrQm91bmRzKGJ5dGVPZmZzZXQsIDApLCB0aGlzLl9vZmZzZXQgPSBieXRlT2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgICBza2lwOiBmdW5jdGlvbihieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWVrKHRoaXMuX29mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICBzbGljZTogZnVuY3Rpb24oc3RhcnQsIGVuZCwgZm9yY2VDb3B5KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgPiBvZmZzZXQgPyBvZmZzZXQgKyBieXRlTGVuZ3RoIDogb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ID0gbm9ybWFsaXplT2Zmc2V0KHN0YXJ0LCB0aGlzLmJ5dGVMZW5ndGgpLCBlbmQgPSBub3JtYWxpemVPZmZzZXQoZGVmaW5lZChlbmQsIHRoaXMuYnl0ZUxlbmd0aCksIHRoaXMuYnl0ZUxlbmd0aCksIFxuICAgICAgICAgICAgZm9yY2VDb3B5ID8gbmV3IGpEYXRhVmlldyh0aGlzLmdldEJ5dGVzKGVuZCAtIHN0YXJ0LCBzdGFydCwgITAsICEwKSwgdm9pZCAwLCB2b2lkIDAsIHRoaXMuX2xpdHRsZUVuZGlhbikgOiBuZXcgakRhdGFWaWV3KHRoaXMuYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyBzdGFydCwgZW5kIC0gc3RhcnQsIHRoaXMuX2xpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIGFsaWduQnk6IGZ1bmN0aW9uKGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpdE9mZnNldCA9IDAsIDEgIT09IGRlZmluZWQoYnl0ZUNvdW50LCAxKSA/IHRoaXMuc2tpcChieXRlQ291bnQgLSAodGhpcy5fb2Zmc2V0ICUgYnl0ZUNvdW50IHx8IGJ5dGVDb3VudCkpIDogdGhpcy5fb2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0RmxvYXQ2NDogZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuX2dldEJ5dGVzKDgsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbiksIHNpZ24gPSAxIC0gMiAqIChiWzddID4+IDcpLCBleHBvbmVudCA9ICgoYls3XSA8PCAxICYgMjU1KSA8PCAzIHwgYls2XSA+PiA0KSAtIDEwMjMsIG1hbnRpc3NhID0gKDE1ICYgYls2XSkgKiBwb3cyKDQ4KSArIGJbNV0gKiBwb3cyKDQwKSArIGJbNF0gKiBwb3cyKDMyKSArIGJbM10gKiBwb3cyKDI0KSArIGJbMl0gKiBwb3cyKDE2KSArIGJbMV0gKiBwb3cyKDgpICsgYlswXTtcbiAgICAgICAgICAgIHJldHVybiAxMDI0ID09PSBleHBvbmVudCA/IDAgIT09IG1hbnRpc3NhID8gMC8wIDogMS8wICogc2lnbiA6IC0xMDIzID09PSBleHBvbmVudCA/IHNpZ24gKiBtYW50aXNzYSAqIHBvdzIoLTEwNzQpIDogc2lnbiAqICgxICsgbWFudGlzc2EgKiBwb3cyKC01MikpICogcG93MihleHBvbmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRGbG9hdDMyOiBmdW5jdGlvbihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fZ2V0Qnl0ZXMoNCwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSwgc2lnbiA9IDEgLSAyICogKGJbM10gPj4gNyksIGV4cG9uZW50ID0gKGJbM10gPDwgMSAmIDI1NSB8IGJbMl0gPj4gNykgLSAxMjcsIG1hbnRpc3NhID0gKDEyNyAmIGJbMl0pIDw8IDE2IHwgYlsxXSA8PCA4IHwgYlswXTtcbiAgICAgICAgICAgIHJldHVybiAxMjggPT09IGV4cG9uZW50ID8gMCAhPT0gbWFudGlzc2EgPyAwLzAgOiAxLzAgKiBzaWduIDogLTEyNyA9PT0gZXhwb25lbnQgPyBzaWduICogbWFudGlzc2EgKiBwb3cyKC0xNDkpIDogc2lnbiAqICgxICsgbWFudGlzc2EgKiBwb3cyKC0yMykpICogcG93MihleHBvbmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXQ2NDogZnVuY3Rpb24oVHlwZSwgYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBkZWZpbmVkKGxpdHRsZUVuZGlhbiwgdGhpcy5fbGl0dGxlRW5kaWFuKSwgYnl0ZU9mZnNldCA9IGRlZmluZWQoYnl0ZU9mZnNldCwgdGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvciAodmFyIHBhcnRzID0gbGl0dGxlRW5kaWFuID8gWyAwLCA0IF0gOiBbIDQsIDAgXSwgaSA9IDA7IDIgPiBpOyBpKyspIHBhcnRzW2ldID0gdGhpcy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIHBhcnRzW2ldLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCA9IGJ5dGVPZmZzZXQgKyA4LCBuZXcgVHlwZShwYXJ0c1swXSwgcGFydHNbMV0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbnQ2NDogZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0NjQoSW50NjQsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFVpbnQ2NDogZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0NjQoVWludDY0LCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0SW50MzI6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9nZXRCeXRlcyg0LCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGJbM10gPDwgMjQgfCBiWzJdIDw8IDE2IHwgYlsxXSA8PCA4IHwgYlswXTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFVpbnQzMjogZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW50MzIoYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSA+Pj4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEludDE2OiBmdW5jdGlvbihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRVaW50MTYoYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSA8PCAxNiA+PiAxNjtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFVpbnQxNjogZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuX2dldEJ5dGVzKDIsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICByZXR1cm4gYlsxXSA8PCA4IHwgYlswXTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEludDg6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRVaW50OChieXRlT2Zmc2V0KSA8PCAyNCA+PiAyNDtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFVpbnQ4OiBmdW5jdGlvbihieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Qnl0ZXMoMSwgYnl0ZU9mZnNldClbMF07XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRCaXRSYW5nZURhdGE6IGZ1bmN0aW9uKGJpdExlbmd0aCwgYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Qml0ID0gKGRlZmluZWQoYnl0ZU9mZnNldCwgdGhpcy5fb2Zmc2V0KSA8PCAzKSArIHRoaXMuX2JpdE9mZnNldCwgZW5kQml0ID0gc3RhcnRCaXQgKyBiaXRMZW5ndGgsIHN0YXJ0ID0gc3RhcnRCaXQgPj4+IDMsIGVuZCA9IGVuZEJpdCArIDcgPj4+IDMsIGIgPSB0aGlzLl9nZXRCeXRlcyhlbmQgLSBzdGFydCwgc3RhcnQsICEwKSwgd2lkZVZhbHVlID0gMDtcbiAgICAgICAgICAgICh0aGlzLl9iaXRPZmZzZXQgPSA3ICYgZW5kQml0KSAmJiAodGhpcy5fYml0T2Zmc2V0IC09IDgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGIubGVuZ3RoOyBsZW5ndGggPiBpOyBpKyspIHdpZGVWYWx1ZSA9IHdpZGVWYWx1ZSA8PCA4IHwgYltpXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGJ5dGVzOiBiLFxuICAgICAgICAgICAgICAgIHdpZGVWYWx1ZTogd2lkZVZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBnZXRTaWduZWQ6IGZ1bmN0aW9uKGJpdExlbmd0aCwgYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gMzIgLSBiaXRMZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnNpZ25lZChiaXRMZW5ndGgsIGJ5dGVPZmZzZXQpIDw8IHNoaWZ0ID4+IHNoaWZ0O1xuICAgICAgICB9LFxuICAgICAgICBnZXRVbnNpZ25lZDogZnVuY3Rpb24oYml0TGVuZ3RoLCBieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXRCaXRSYW5nZURhdGEoYml0TGVuZ3RoLCBieXRlT2Zmc2V0KS53aWRlVmFsdWUgPj4+IC10aGlzLl9iaXRPZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gMzIgPiBiaXRMZW5ndGggPyB2YWx1ZSAmIH4oLTEgPDwgYml0TGVuZ3RoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0QmluYXJ5RmxvYXQ6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIHZhbHVlLCBtYW50U2l6ZSwgZXhwU2l6ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB2YXIgZXhwb25lbnQsIG1hbnRpc3NhLCBzaWduQml0ID0gMCA+IHZhbHVlID8gMSA6IDAsIGVNYXggPSB+KC0xIDw8IGV4cFNpemUgLSAxKSwgZU1pbiA9IDEgLSBlTWF4O1xuICAgICAgICAgICAgMCA+IHZhbHVlICYmICh2YWx1ZSA9IC12YWx1ZSksIDAgPT09IHZhbHVlID8gKGV4cG9uZW50ID0gMCwgbWFudGlzc2EgPSAwKSA6IGlzTmFOKHZhbHVlKSA/IChleHBvbmVudCA9IDIgKiBlTWF4ICsgMSwgXG4gICAgICAgICAgICBtYW50aXNzYSA9IDEpIDogMS8wID09PSB2YWx1ZSA/IChleHBvbmVudCA9IDIgKiBlTWF4ICsgMSwgbWFudGlzc2EgPSAwKSA6IChleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpLCBcbiAgICAgICAgICAgIGV4cG9uZW50ID49IGVNaW4gJiYgZU1heCA+PSBleHBvbmVudCA/IChtYW50aXNzYSA9IE1hdGguZmxvb3IoKHZhbHVlICogcG93MigtZXhwb25lbnQpIC0gMSkgKiBwb3cyKG1hbnRTaXplKSksIFxuICAgICAgICAgICAgZXhwb25lbnQgKz0gZU1heCkgOiAobWFudGlzc2EgPSBNYXRoLmZsb29yKHZhbHVlIC8gcG93MihlTWluIC0gbWFudFNpemUpKSwgZXhwb25lbnQgPSAwKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gW107IG1hbnRTaXplID49IDg7ICkgYi5wdXNoKG1hbnRpc3NhICUgMjU2KSwgbWFudGlzc2EgPSBNYXRoLmZsb29yKG1hbnRpc3NhIC8gMjU2KSwgXG4gICAgICAgICAgICBtYW50U2l6ZSAtPSA4O1xuICAgICAgICAgICAgZm9yIChleHBvbmVudCA9IGV4cG9uZW50IDw8IG1hbnRTaXplIHwgbWFudGlzc2EsIGV4cFNpemUgKz0gbWFudFNpemU7IGV4cFNpemUgPj0gODsgKSBiLnB1c2goMjU1ICYgZXhwb25lbnQpLCBcbiAgICAgICAgICAgIGV4cG9uZW50ID4+Pj0gOCwgZXhwU2l6ZSAtPSA4O1xuICAgICAgICAgICAgYi5wdXNoKHNpZ25CaXQgPDwgZXhwU2l6ZSB8IGV4cG9uZW50KSwgdGhpcy5fc2V0Qnl0ZXMoYnl0ZU9mZnNldCwgYiwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldEZsb2F0MzI6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEJpbmFyeUZsb2F0KGJ5dGVPZmZzZXQsIHZhbHVlLCAyMywgOCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldEZsb2F0NjQ6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEJpbmFyeUZsb2F0KGJ5dGVPZmZzZXQsIHZhbHVlLCA1MiwgMTEsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXQ2NDogZnVuY3Rpb24oVHlwZSwgYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsdWUgJiYgKHZhbHVlID0gVHlwZS5mcm9tTnVtYmVyKHZhbHVlKSksIGxpdHRsZUVuZGlhbiA9IGRlZmluZWQobGl0dGxlRW5kaWFuLCB0aGlzLl9saXR0bGVFbmRpYW4pLCBcbiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBkZWZpbmVkKGJ5dGVPZmZzZXQsIHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBsaXR0bGVFbmRpYW4gPyB7XG4gICAgICAgICAgICAgICAgbG86IDAsXG4gICAgICAgICAgICAgICAgaGk6IDRcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgbG86IDQsXG4gICAgICAgICAgICAgICAgaGk6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBwYXJ0TmFtZSBpbiBwYXJ0cykgdGhpcy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIHBhcnRzW3BhcnROYW1lXSwgdmFsdWVbcGFydE5hbWVdLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gYnl0ZU9mZnNldCArIDg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludDY0OiBmdW5jdGlvbihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXQ2NChJbnQ2NCwgYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFVpbnQ2NDogZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0NjQoVWludDY0LCBieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldFVpbnQzMjogZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy5fc2V0Qnl0ZXMoYnl0ZU9mZnNldCwgWyAyNTUgJiB2YWx1ZSwgdmFsdWUgPj4+IDggJiAyNTUsIHZhbHVlID4+PiAxNiAmIDI1NSwgdmFsdWUgPj4+IDI0IF0sIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRVaW50MTY6IGZ1bmN0aW9uKGJ5dGVPZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEJ5dGVzKGJ5dGVPZmZzZXQsIFsgMjU1ICYgdmFsdWUsIHZhbHVlID4+PiA4ICYgMjU1IF0sIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRVaW50ODogZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEJ5dGVzKGJ5dGVPZmZzZXQsIFsgMjU1ICYgdmFsdWUgXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFVuc2lnbmVkOiBmdW5jdGlvbihieXRlT2Zmc2V0LCB2YWx1ZSwgYml0TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2dldEJpdFJhbmdlRGF0YShiaXRMZW5ndGgsIGJ5dGVPZmZzZXQpLCB3aWRlVmFsdWUgPSBkYXRhLndpZGVWYWx1ZSwgYiA9IGRhdGEuYnl0ZXM7XG4gICAgICAgICAgICB3aWRlVmFsdWUgJj0gfih+KC0xIDw8IGJpdExlbmd0aCkgPDwgLXRoaXMuX2JpdE9mZnNldCksIHdpZGVWYWx1ZSB8PSAoMzIgPiBiaXRMZW5ndGggPyB2YWx1ZSAmIH4oLTEgPDwgYml0TGVuZ3RoKSA6IHZhbHVlKSA8PCAtdGhpcy5fYml0T2Zmc2V0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGJbaV0gPSAyNTUgJiB3aWRlVmFsdWUsIHdpZGVWYWx1ZSA+Pj49IDg7XG4gICAgICAgICAgICB0aGlzLl9zZXRCeXRlcyhkYXRhLnN0YXJ0LCBiLCAhMCk7XG4gICAgICAgIH1cbiAgICB9LCBub2RlTmFtaW5nID0ge1xuICAgICAgICBJbnQ4OiBcIkludDhcIixcbiAgICAgICAgSW50MTY6IFwiSW50MTZcIixcbiAgICAgICAgSW50MzI6IFwiSW50MzJcIixcbiAgICAgICAgVWludDg6IFwiVUludDhcIixcbiAgICAgICAgVWludDE2OiBcIlVJbnQxNlwiLFxuICAgICAgICBVaW50MzI6IFwiVUludDMyXCIsXG4gICAgICAgIEZsb2F0MzI6IFwiRmxvYXRcIixcbiAgICAgICAgRmxvYXQ2NDogXCJEb3VibGVcIlxuICAgIH07XG4gICAgcHJvdG8uX25vZGVCdWZmZXJBY3Rpb24gPSBmdW5jdGlvbih0eXBlLCBpc1JlYWRBY3Rpb24sIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gYnl0ZU9mZnNldCArIGRhdGFUeXBlc1t0eXBlXTtcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZU5hbWluZ1t0eXBlXSArIChcIkludDhcIiA9PT0gdHlwZSB8fCBcIlVpbnQ4XCIgPT09IHR5cGUgPyBcIlwiIDogbGl0dGxlRW5kaWFuID8gXCJMRVwiIDogXCJCRVwiKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVPZmZzZXQgKz0gdGhpcy5ieXRlT2Zmc2V0LCBpc1JlYWRBY3Rpb24gPyB0aGlzLmJ1ZmZlcltcInJlYWRcIiArIG5vZGVOYW1lXShieXRlT2Zmc2V0KSA6IHRoaXMuYnVmZmVyW1wid3JpdGVcIiArIG5vZGVOYW1lXSh2YWx1ZSwgYnl0ZU9mZnNldCk7XG4gICAgfTtcbiAgICBmb3IgKHZhciB0eXBlIGluIGRhdGFUeXBlcykgIWZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcHJvdG9bXCJnZXRcIiArIHR5cGVdID0gZnVuY3Rpb24oYnl0ZU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9uKHR5cGUsICEwLCBieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9LCBwcm90b1tcInNldFwiICsgdHlwZV0gPSBmdW5jdGlvbihieXRlT2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb24odHlwZSwgITEsIGJ5dGVPZmZzZXQsIGxpdHRsZUVuZGlhbiwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIH0odHlwZSk7XG4gICAgcHJvdG8uX3NldEludDMyID0gcHJvdG8uX3NldFVpbnQzMiwgcHJvdG8uX3NldEludDE2ID0gcHJvdG8uX3NldFVpbnQxNiwgcHJvdG8uX3NldEludDggPSBwcm90by5fc2V0VWludDgsIFxuICAgIHByb3RvLnNldFNpZ25lZCA9IHByb3RvLnNldFVuc2lnbmVkO1xuICAgIGZvciAodmFyIG1ldGhvZCBpbiBwcm90bykgXCJzZXRcIiA9PT0gbWV0aG9kLnNsaWNlKDAsIDMpICYmICFmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHByb3RvW1wid3JpdGVcIiArIHR5cGVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgdm9pZCAwKSwgdGhpc1tcInNldFwiICsgdHlwZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KG1ldGhvZC5zbGljZSgzKSk7XG4gICAgcmV0dXJuIGpEYXRhVmlldztcbn0pOyIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290LkFEVFMgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRyZXR1cm4ge1xuXHRcdEFEVFNQYWNrZXQ6IHtcblx0XHRcdF9zdGFydDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5iaW5hcnkudGVsbCgpIH0sXG5cdFx0XHRfc3luY1dvcmQ6IFsnY29uc3QnLCAxMiwgMHhmZmYsIHRydWVdLFxuXHRcdFx0dmVyc2lvbjogWydlbnVtJywgMSwgWydtcGVnLTQnLCAnbXBlZy0yJ11dLFxuXHRcdFx0bGF5ZXI6IFsnY29uc3QnLCAyLCAwXSxcblx0XHRcdGlzUHJvdGVjdGlvbkFic2VudDogMSxcblx0XHRcdHByb2ZpbGVNaW51c09uZTogMiwgLy8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX09iamVjdF9UeXBlcyBtaW51cyBvbmVcblx0XHRcdHNhbXBsaW5nRnJlcTogWydlbnVtJywgNCwgWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF1dLCAvLyBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jU2FtcGxpbmdfRnJlcXVlbmNpZXNcblx0XHRcdF9wcml2YXRlU3RyZWFtOiAxLFxuXHRcdFx0Y2hhbm5lbENvbmZpZzogMywgLy8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0NoYW5uZWxfQ29uZmlndXJhdGlvbnNcblx0XHRcdF9yZXNlcnZlZDogNCwgLy8gb3JpZ2luYWxpdHksIGhvbWUsIGNvcHlyaWdodGVkLCBjb3B5cmlnaHQgc3RhcnQgYml0c1xuXHRcdFx0ZnJhbWVMZW5ndGg6IDEzLFxuXHRcdFx0YnVmZmVyRnVsbG5lc3M6IDExLFxuXHRcdFx0YWFjRnJhbWVzQ291bnRNaW51c09uZTogMixcblx0XHRcdGRhdGE6IFsnYmxvYicsIGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0LmZyYW1lTGVuZ3RoIC0gKHRoaXMuYmluYXJ5LnRlbGwoKSAtIGNvbnRleHQuX3N0YXJ0KSB9XVxuXHRcdH1cblx0fTtcbn0pKTsiLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsnamJpbmFyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2piaW5hcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5IMjY0ID0gZmFjdG9yeShyb290LmpCaW5hcnkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGpCaW5hcnkpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHJldHVybiB7XG5cdFx0RXhwR29sb21iOiBqQmluYXJ5LlR5cGUoe1xuXHRcdFx0cGFyYW1zOiBbJ2lzU2lnbmVkJ10sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBjb3VudCA9IDA7XG5cdFx0XHRcdHdoaWxlICghdGhpcy5iaW5hcnkucmVhZCgxKSkgY291bnQrKztcblx0XHRcdFx0dmFyIHZhbHVlID0gKDEgPDwgY291bnQpIHwgdGhpcy5iaW5hcnkucmVhZChjb3VudCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmlzU2lnbmVkID8gKHZhbHVlICYgMSA/IC0odmFsdWUgPj4gMSkgOiB2YWx1ZSA+PiAxKSA6IHZhbHVlIC0gMTtcblx0XHRcdH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzU2lnbmVkKSB7XG5cdFx0XHRcdFx0dmFsdWUgPDw9IDE7XG5cdFx0XHRcdFx0aWYgKHZhbHVlIDw9IDApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gLXZhbHVlIHwgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUrKztcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUudG9TdHJpbmcoMikubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLmJpbmFyeS53cml0ZShsZW5ndGggLSAxLCAwKTtcblx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUobGVuZ3RoLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRPcHRpb25hbDogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0ICAgIHBhcmFtczogWydiYXNlVHlwZSddLFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAodGhpcy5iaW5hcnkucmVhZCgxKSkgcmV0dXJuIHRoaXMuYmFzZVJlYWQoKTtcblx0XHRcdH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuYmluYXJ5LndyaXRlKHZhbHVlICE9IG51bGwgPyAxIDogMCk7XG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5iYXNlV3JpdGUodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRTY2FsaW5nTGlzdDogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChzaXplKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVR5cGUgPSBbJ2FycmF5JywgeyAvKiBUT0RPOiBpbXBsZW1lbnQgc2NhbGluZyBsaXN0ICovIH0sIHNpemVdO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0U1BTOiBbXG5cdFx0XHQnZXh0ZW5kJyxcblx0XHRcdHtcblx0XHRcdFx0cHJvZmlsZV9pZGM6ICd1aW50OCcsXG5cdFx0XHRcdGNvbnN0cmFpbnRfc2V0X2ZsYWdzOiBbJ2FycmF5JywgMSwgOF0sXG5cdFx0XHRcdGxldmVsX2lkYzogJ3VpbnQ4Jyxcblx0XHRcdFx0c2VxX3BhcmFtZXRlcl9zZXRfaWQ6ICdFeHBHb2xvbWInXG5cdFx0XHR9LFxuXHRcdFx0WydpZicsIGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBbMTAwLCAxMTAsIDEyMiwgMjQ0LCA0NCwgODMsIDg2LCAxMThdLmluZGV4T2YoY29udGV4dC5wcm9maWxlX2lkYykgPj0gMCB9LCB7XG5cdFx0XHRcdGNocm9tYV9mb3JtYXQ6IFsnZW51bScsICdFeHBHb2xvbWInLCBbJ01PTk8nLCAnWVVWNDIwJywgJ1lVVjQyMicsICdZVVY0NDQnXV0sXG5cdFx0XHRcdHNlcGFyYXRlX2NvbG9yX3BsYW5lX2ZsYWc6IFsnaWYnLCBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gY29udGV4dC5jaHJvbWFfZm9ybWF0ID09PSAnWVVWNDQ0JyB9LCAxXSxcblx0XHRcdFx0Yml0X2RlcHRoX2x1bWFfbWludXM4OiAnRXhwR29sb21iJyxcblx0XHRcdFx0Yml0X2RlcHRoX2Nocm9tYV9taW51czg6ICdFeHBHb2xvbWInLFxuXHRcdFx0XHRxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWc6IDEsXG5cdFx0XHRcdHNjYWxpbmdfbWF0cml4OiBbJ09wdGlvbmFsJywge1xuXHRcdFx0XHRcdHNjYWxpbmdMaXN0NHg0OiBbJ2FycmF5JywgWydTY2FsaW5nTGlzdCcsIDE2XSwgNl0sXG5cdFx0XHRcdFx0c2NhbGluZ0xpc3Q4eDg6IFsnYXJyYXknLCBbJ1NjYWxpbmdMaXN0JywgNjRdLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJpbmFyeS5nZXRDb250ZXh0KDEpLmNocm9tYV9mb3JtYXQgIT09ICdZVVY0NDQnID8gMiA6IDYgfV1cblx0XHRcdFx0fV1cblx0XHRcdH1dLFxuXHRcdFx0e1xuXHRcdFx0XHRsb2cyX21heF9mcmFtZV9udW1fbWludXM0OiAnRXhwR29sb21iJyxcblx0XHRcdFx0cGljX29yZGVyX2NudF90eXBlOiAnRXhwR29sb21iJyxcblx0XHRcdFx0cGljX29yZGVyOiBbJ2lmX25vdCcsICdwaWNfb3JkZXJfY250X3R5cGUnLCB7bG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0OiAnRXhwR29sb21iJ30sIFtcblx0XHRcdFx0XHQnaWYnLFxuXHRcdFx0XHRcdGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0LnBpY19vcmRlcl9jbnRfdHlwZSA9PT0gMSB9LFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnOiAxLFxuXHRcdFx0XHRcdFx0b2Zmc2V0X2Zvcl9ub25fcmVmX3BpYzogWydFeHBHb2xvbWInLCB0cnVlXSxcblx0XHRcdFx0XHRcdG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZDogWydFeHBHb2xvbWInLCB0cnVlXSxcblx0XHRcdFx0XHRcdF9udW1fcmVmX2ZyYW1lc19pbl9waWNfb3JkZXJfY250X2N5Y2xlOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdFx0XHRcdFx0YmFzZVR5cGU6ICdFeHBHb2xvbWInLFxuXHRcdFx0XHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHRoaXMuYmFzZVdyaXRlKGNvbnRleHQub2Zmc2V0X2Zvcl9yZWZfZnJhbWUubGVuZ3RoKSB9XG5cdFx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHRcdG9mZnNldF9mb3JfcmVmX2ZyYW1lOiBbJ2FycmF5JywgWydFeHBHb2xvbWInLCB0cnVlXSwgZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIGNvbnRleHQuX251bV9yZWZfZnJhbWVzX2luX3BpY19vcmRlcl9jbnRfY3ljbGUgfV1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdF1dLFxuXHRcdFx0XHRtYXhfbnVtX3JlZl9mcmFtZXM6ICdFeHBHb2xvbWInLFxuXHRcdFx0XHRnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWc6IDEsXG5cdFx0XHRcdHBpY193aWR0aF9pbl9tYnNfbWludXNfMTogJ0V4cEdvbG9tYicsXG5cdFx0XHRcdHBpY19oZWlnaHRfaW5fbWFwX3VuaXRzX21pbnVzXzE6ICdFeHBHb2xvbWInLFxuXHRcdFx0XHRmcmFtZV9tYnNfb25seV9mbGFnOiAxLFxuXHRcdFx0XHRtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnOiBbJ2lmX25vdCcsICdmcmFtZV9tYnNfb25seV9mbGFnJywgMV0sXG5cdFx0XHRcdGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWc6IDEsXG5cdFx0XHRcdGZyYW1lX2Nyb3BwaW5nOiBbJ09wdGlvbmFsJywge1xuXHRcdFx0XHRcdGxlZnQ6ICdFeHBHb2xvbWInLFxuXHRcdFx0XHRcdHJpZ2h0OiAnRXhwR29sb21iJyxcblx0XHRcdFx0XHR0b3A6ICdFeHBHb2xvbWInLFxuXHRcdFx0XHRcdGJvdHRvbTogJ0V4cEdvbG9tYidcblx0XHRcdFx0fV1cblx0XHRcdFx0Ly8gVE9ETzogYWRkIFZVSSBwYXJhbWV0ZXJzXG5cdFx0XHR9XG5cdFx0XSxcblxuXHRcdE5BTFVuaXQ6IGpCaW5hcnkuVHlwZSh7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBzeW5jID0gdGhpcy5iaW5hcnkucmVhZChbJ2Jsb2InLCAzXSk7IC8vIFswLCAwLCAxXSBvciBbMCwgMCwgMCwgMV1cblx0XHRcdFx0aWYgKHN5bmNbMl0gPT09IDApIHRoaXMuYmluYXJ5LnNraXAoMSk7XG5cdFx0XHRcdHZhciBlbmQgPSB0aGlzLmJpbmFyeS52aWV3LmJ5dGVMZW5ndGgsIHBvcyA9IHRoaXMuYmluYXJ5LnRlbGwoKTtcblx0XHRcdFx0dmFyIGJ5dGVzID0gdGhpcy5iaW5hcnkuc2tpcCgwLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZpZXcuZ2V0Qnl0ZXMoKSB9KTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aCAtIDM7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChieXRlc1tpXSA9PT0gMCAmJiBieXRlc1tpICsgMV0gPT09IDAgJiYgKGJ5dGVzW2kgKyAyXSA9PT0gMSB8fCAoYnl0ZXNbaSArIDJdID09PSAwICYmIGJ5dGVzW2kgKyAzXSA9PT0gMSkpKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyBpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBkYXRhID0gdGhpcy5iaW5hcnkucmVhZChbJ2Jsb2InLCBlbmQgLSBwb3NdKTtcblx0XHRcdFx0Ly8gVE9ETzogaWRlYWxseSB0aGVyZSBzaG91bGQgYmUgQW5uZXguQiBjb252ZXJzaW9uIGZyb20gWzAsIDAsIDMsIFg9MC4uM10gdG8gWzAsIDAsIFhdXG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fVxuXHRcdH0pXG5cdH07XG59KSk7IiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbJ2pkYXRhdmlldycsICdqYmluYXJ5JywgJy4vbXA0JywgJy4vaDI2NCcsICcuL3BlcycsICcuL2FkdHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqZGF0YXZpZXcnKSwgcmVxdWlyZSgnamJpbmFyeScpLCByZXF1aXJlKCcuL21wNCcpLCByZXF1aXJlKCcuL2gyNjQnKSwgcmVxdWlyZSgnLi9wZXMnKSwgcmVxdWlyZSgnLi9hZHRzJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QubXBlZ3RzX3RvX21wNCA9IGZhY3Rvcnkocm9vdC5qRGF0YVZpZXcsIHJvb3QuakJpbmFyeSwgcm9vdC5NUDQsIHJvb3QuSDI2NCwgcm9vdC5QRVMsIHJvb3QuQURUUyk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoakRhdGFWaWV3LCBqQmluYXJ5LCBNUDQsIEgyNjQsIFBFUywgQURUUykge1xuXHQndXNlIHN0cmljdCc7XG5cblxuXHQvKipcblx0ICogQ29waWVkIGZyb20gbXV4LmpzID0+IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL211eC5qcy9ibG9iLzk1NzQ0MWQ0NDMwN2E0N2Q4MDFhZjNkYjVjNTEwNzJlZDI0MWY4YzIvbGliL2NvZGVjcy9oMjY0LmpzI0wyNjZcblx0ICogRXhwdW5nZSBhbnkgXCJFbXVsYXRpb24gUHJldmVudGlvblwiIGJ5dGVzIGZyb20gYSBcIlJhdyBCeXRlXG5cdCAqIFNlcXVlbmNlIFBheWxvYWRcIlxuXHQgKiBAcGFyYW0gZGF0YSB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgUkJTUCBmcm9tIGEgTkFMXG5cdCAqIHVuaXRcblx0ICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIFJCU1Agd2l0aG91dCBhbnkgRW11bGF0aW9uXG5cdCAqIFByZXZlbnRpb24gQnl0ZXNcblx0ICovXG5cdHZhciBkaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdHZhclxuXHRcdGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcblx0XHRlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRuZXdMZW5ndGgsIG5ld0RhdGE7XG5cblx0XHQvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG5cdFx0d2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG5cdFx0aWYgKGRhdGFbaV0gPT09IDAgJiYgZGF0YVtpICsgMV0gPT09IDAgJiYgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcblx0XHRcdGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucy5wdXNoKGkgKyAyKTtcblx0XHRcdGkgKz0gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuXHRcdC8vIGFycmF5XG5cdFx0aWYgKGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuXHRcdG5ld0xlbmd0aCA9IGxlbmd0aCAtIGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucy5sZW5ndGg7XG5cdFx0bmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG5cdFx0dmFyIHNvdXJjZUluZGV4ID0gMDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuXHRcdGlmIChzb3VyY2VJbmRleCA9PT0gZW11bGF0aW9uUHJldmVudGlvbkJ5dGVzUG9zaXRpb25zWzBdKSB7XG5cdFx0XHQvLyBTa2lwIHRoaXMgYnl0ZVxuXHRcdFx0c291cmNlSW5kZXgrKztcblx0XHRcdC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG5cdFx0XHRlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMuc2hpZnQoKTtcblx0XHR9XG5cdFx0bmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdEYXRhO1xuXHR9O1xuXG5cblx0cmV0dXJuIGZ1bmN0aW9uIChtcGVndHMpIHtcblx0XHR2YXIgcGFja2V0cyA9IG1wZWd0cy5yZWFkKCdGaWxlJyk7XG5cdFx0XG5cdFx0Ly8gZXh0cmFjdGluZyBhbmQgY29uY2F0ZW5hdGluZyByYXcgc3RyZWFtIHBhcnRzXG5cdFx0dmFyIHN0cmVhbSA9IG5ldyBqRGF0YVZpZXcobXBlZ3RzLnZpZXcuYnl0ZUxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHBhY2tldHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwYWNrZXQgPSBwYWNrZXRzW2ldLCBhZGFwdGF0aW9uID0gcGFja2V0LmFkYXB0YXRpb25GaWVsZCwgcGF5bG9hZCA9IHBhY2tldC5wYXlsb2FkO1xuXHRcdFx0aWYgKHBheWxvYWQgJiYgcGF5bG9hZC5fcmF3U3RyZWFtKSB7XG5cdFx0XHRcdHN0cmVhbS53cml0ZUJ5dGVzKHBheWxvYWQuX3Jhd1N0cmVhbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBwZXNTdHJlYW0gPSBuZXcgakJpbmFyeShzdHJlYW0uc2xpY2UoMCwgc3RyZWFtLnRlbGwoKSksIFBFUyksXG5cdFx0XHRhdWRpb1N0cmVhbSA9IG5ldyBqQmluYXJ5KHN0cmVhbS5ieXRlTGVuZ3RoLCBBRFRTKSxcblx0XHRcdHNhbXBsZXMgPSBbXSxcblx0XHRcdGF1ZGlvU2FtcGxlcyA9IFtdO1xuXG5cdFx0c3RyZWFtID0gbmV3IGpEYXRhVmlldyhzdHJlYW0uYnl0ZUxlbmd0aCk7XG5cdFx0XG5cdFx0d2hpbGUgKHBlc1N0cmVhbS50ZWxsKCkgPCBwZXNTdHJlYW0udmlldy5ieXRlTGVuZ3RoKSB7XG5cdFx0XHR2YXIgcGFja2V0ID0gcGVzU3RyZWFtLnJlYWQoJ1BFU1BhY2tldCcpO1xuXG5cdFx0XHRpZiAocGFja2V0LnN0cmVhbUlkID09PSAweEMwKSB7XG5cdFx0XHRcdC8vIDB4QzAgbWVhbnMgd2UgaGF2ZSBnb3QgZmlyc3QgYXVkaW8gc3RyZWFtXG5cdFx0XHRcdGF1ZGlvU3RyZWFtLndyaXRlKCdibG9iJywgcGFja2V0LmRhdGEpO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZiAocGFja2V0LnN0cmVhbUlkID09PSAweEUwKSB7XG5cdFx0XHRcdHZhciBuYWxTdHJlYW0gPSBuZXcgakJpbmFyeShwYWNrZXQuZGF0YSwgSDI2NCksXG5cdFx0XHRcdFx0cHRzID0gcGFja2V0LnB0cyxcblx0XHRcdFx0XHRkdHMgPSBwYWNrZXQuZHRzLFxuXHRcdFx0XHRcdGN1clNhbXBsZSA9IHtvZmZzZXQ6IHN0cmVhbS50ZWxsKCksIHB0czogcHRzLCBkdHM6IGR0cyAhPT0gdW5kZWZpbmVkID8gZHRzIDogcHRzfTtcblx0XHRcdFx0XG5cdFx0XHRcdHNhbXBsZXMucHVzaChjdXJTYW1wbGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY29sbGVjdGluZyBpbmZvIGZyb20gSC4yNjQgTkFMIHVuaXRzXG5cdFx0XHRcdHdoaWxlIChuYWxTdHJlYW0udGVsbCgpIDwgbmFsU3RyZWFtLnZpZXcuYnl0ZUxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBuYWxVbml0ID0gbmFsU3RyZWFtLnJlYWQoJ05BTFVuaXQnKTtcblx0XHRcdFx0XHRzd2l0Y2ggKG5hbFVuaXRbMF0gJiAweDFGKSB7XG5cdFx0XHRcdFx0XHRjYXNlIDc6XG5cdFx0XHRcdFx0XHRcdGlmICghc3BzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHNwcyA9IG5hbFVuaXQ7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHRvIGdldCBjb3JyZWN0IHdpZHRoICYgaGVpZ2h0XG5cdFx0XHRcdFx0XHRcdFx0Ly8gU2VlIGh0dHA6Ly9ibG9nLjUxY3RvLmNvbS9kYW5pZWxsbGYvMTc1ODExNVxuXHRcdFx0XHRcdFx0XHRcdHZhciBzcHNJbmZvID0gbmV3IGpCaW5hcnkoZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyhzcHMuc3ViYXJyYXkoMSkpLCBIMjY0KS5yZWFkKCdTUFMnKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgd2lkdGggPSAoc3BzSW5mby5waWNfd2lkdGhfaW5fbWJzX21pbnVzXzEgKyAxKSAqIDE2O1xuXHRcdFx0XHRcdFx0XHRcdHZhciBoZWlnaHQgPSAoMiAtIHNwc0luZm8uZnJhbWVfbWJzX29ubHlfZmxhZykgKiAoc3BzSW5mby5waWNfaGVpZ2h0X2luX21hcF91bml0c19taW51c18xICsgMSkgKiAxNjtcblx0XHRcdFx0XHRcdFx0XHR2YXIgY3JvcHBpbmcgPSBzcHNJbmZvLmZyYW1lX2Nyb3BwaW5nO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjcm9wcGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGggLT0gMiAqIChjcm9wcGluZy5sZWZ0ICsgY3JvcHBpbmcucmlnaHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aGVpZ2h0IC09IDIgKiAoY3JvcHBpbmcudG9wICsgY3JvcHBpbmcuYm90dG9tKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgODpcblx0XHRcdFx0XHRcdFx0aWYgKCFwcHMpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcHBzID0gbmFsVW5pdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSA1OlxuXHRcdFx0XHRcdFx0XHRjdXJTYW1wbGUuaXNJRFIgPSB0cnVlO1xuXHRcdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0c3RyZWFtLndyaXRlVWludDMyKG5hbFVuaXQubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0c3RyZWFtLndyaXRlQnl0ZXMobmFsVW5pdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHNhbXBsZXMucHVzaCh7b2Zmc2V0OiBzdHJlYW0udGVsbCgpfSk7XG5cblx0XHR2YXIgc2l6ZXMgPSBbXSxcblx0XHRcdGR0c0RpZmZzID0gW10sXG5cdFx0XHRhY2Nlc3NJbmRleGVzID0gW10sXG5cdFx0XHRwdHNfZHRzX0RpZmZzID0gW10sXG5cdFx0XHRjdXJyZW50ID0gc2FtcGxlc1swXSxcblx0XHRcdGZyYW1lUmF0ZSA9IHtzdW06IDAsIGNvdW50OiAwfSxcblx0XHRcdGR1cmF0aW9uID0gMDtcblx0XHRcblx0XHQvLyBjYWxjdWxhdGluZyBQVFMvRFRTIGRpZmZlcmVuY2VzIGFuZCBjb2xsZWN0aW5nIGtleWZyYW1lc1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzYW1wbGVzLmxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG5leHQgPSBzYW1wbGVzW2kgKyAxXTtcblx0XHRcdHNpemVzLnB1c2gobmV4dC5vZmZzZXQgLSBjdXJyZW50Lm9mZnNldCk7XG5cdFx0XHR2YXIgZHRzRGlmZiA9IG5leHQuZHRzIC0gY3VycmVudC5kdHM7XG5cdFx0XHRpZiAoZHRzRGlmZikge1xuXHRcdFx0XHRkdHNEaWZmcy5wdXNoKHtzYW1wbGVfY291bnQ6IDEsIHNhbXBsZV9kZWx0YTogZHRzRGlmZn0pO1xuXHRcdFx0XHRkdXJhdGlvbiArPSBkdHNEaWZmO1xuXHRcdFx0XHRmcmFtZVJhdGUuc3VtICs9IGR0c0RpZmY7XG5cdFx0XHRcdGZyYW1lUmF0ZS5jb3VudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZHRzRGlmZnMubGVuZ3RoKys7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudC5pc0lEUikge1xuXHRcdFx0XHRhY2Nlc3NJbmRleGVzLnB1c2goaSArIDEpO1xuXHRcdFx0fVxuXHRcdFx0cHRzX2R0c19EaWZmcy5wdXNoKHtcblx0XHRcdFx0Zmlyc3RfY2h1bms6IHB0c19kdHNfRGlmZnMubGVuZ3RoICsgMSxcblx0XHRcdFx0c2FtcGxlX2NvdW50OiAxLFxuXHRcdFx0XHRzYW1wbGVfb2Zmc2V0OiBjdXJyZW50LmR0c0ZpeCA9IGN1cnJlbnQucHRzIC0gY3VycmVudC5kdHNcblx0XHRcdH0pO1xuXHRcdFx0Y3VycmVudCA9IG5leHQ7XG5cdFx0fVxuXHRcdFxuXHRcdGZyYW1lUmF0ZSA9IE1hdGgucm91bmQoZnJhbWVSYXRlLnN1bSAvIGZyYW1lUmF0ZS5jb3VudCk7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGR0c0RpZmZzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZHRzRGlmZnNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkdHNEaWZmc1tpXSA9IHtmaXJzdF9jaHVuazogaSArIDEsIHNhbXBsZV9jb3VudDogMSwgc2FtcGxlX2RlbHRhOiBmcmFtZVJhdGV9O1xuXHRcdFx0XHRkdXJhdGlvbiArPSBmcmFtZVJhdGU7XG5cdFx0XHRcdC8vc2FtcGxlc1tpICsgMV0uZHRzID0gc2FtcGxlc1tpXS5kdHMgKyBmcmFtZVJhdGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2tpbmcgaWYgRFRTIGRpZmZlcmVuY2VzIGFyZSBzYW1lIGV2ZXJ5d2hlcmUgdG8gcGFjayB0aGVtIGludG8gb25lIGl0ZW1cblx0XHRcblx0XHR2YXIgZHRzRGlmZnNTYW1lID0gdHJ1ZTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gZHRzRGlmZnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChkdHNEaWZmc1tpXS5zYW1wbGVfZGVsdGEgIT09IGR0c0RpZmZzWzBdLnNhbXBsZV9kZWx0YSkge1xuXHRcdFx0XHRkdHNEaWZmc1NhbWUgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChkdHNEaWZmc1NhbWUpIHtcblx0XHRcdGR0c0RpZmZzID0gW3tmaXJzdF9jaHVuazogMSwgc2FtcGxlX2NvdW50OiBzaXplcy5sZW5ndGgsIHNhbXBsZV9kZWx0YTogZHRzRGlmZnNbMF0uc2FtcGxlX2RlbHRhfV07XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGRpbmcgYXVkaW8gbWV0YWRhdGFcblxuXHRcdHZhciBhdWRpb1N0YXJ0ID0gc3RyZWFtLnRlbGwoKSxcblx0XHRcdGF1ZGlvU2l6ZSA9IGF1ZGlvU3RyZWFtLnRlbGwoKSxcblx0XHRcdGF1ZGlvU2l6ZXMgPSBbXSxcblx0XHRcdGF1ZGlvSGVhZGVyLFxuXHRcdFx0bWF4QXVkaW9TaXplID0gMDtcblx0XHRcdFxuXHRcdGF1ZGlvU3RyZWFtLnNlZWsoMCk7XG5cdFx0XG5cdFx0d2hpbGUgKGF1ZGlvU3RyZWFtLnRlbGwoKSA8IGF1ZGlvU2l6ZSkge1xuXHRcdFx0YXVkaW9IZWFkZXIgPSBhdWRpb1N0cmVhbS5yZWFkKCdBRFRTUGFja2V0Jyk7XG5cdFx0XHRhdWRpb1NpemVzLnB1c2goYXVkaW9IZWFkZXIuZGF0YS5sZW5ndGgpO1xuXHRcdFx0aWYgKGF1ZGlvSGVhZGVyLmRhdGEubGVuZ3RoID4gbWF4QXVkaW9TaXplKSB7XG5cdFx0XHRcdG1heEF1ZGlvU2l6ZSA9IGF1ZGlvSGVhZGVyLmRhdGEubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0c3RyZWFtLndyaXRlQnl0ZXMoYXVkaW9IZWFkZXIuZGF0YSk7XG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGluZyByZXN1bHRpbmcgTVA0XG5cblx0XHR2YXIgbXA0ID0gbmV3IGpCaW5hcnkoc3RyZWFtLmJ5dGVMZW5ndGgsIE1QNCk7XG5cdFx0XG5cdFx0dmFyIHRyYWsgPSBbe1xuXHRcdFx0YXRvbXM6IHtcblx0XHRcdFx0dGtoZDogW3tcblx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdGZsYWdzOiAxNSxcblx0XHRcdFx0XHR0cmFja19JRDogMSxcblx0XHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRcdFx0bGF5ZXI6IDAsXG5cdFx0XHRcdFx0YWx0ZXJuYXRlX2dyb3VwOiAwLFxuXHRcdFx0XHRcdHZvbHVtZTogMSxcblx0XHRcdFx0XHRtYXRyaXg6IHtcblx0XHRcdFx0XHRcdGE6IDEsIGI6IDAsIHg6IDAsXG5cdFx0XHRcdFx0XHRjOiAwLCBkOiAxLCB5OiAwLFxuXHRcdFx0XHRcdFx0dTogMCwgdjogMCwgdzogMVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZGltZW5zaW9uczoge1xuXHRcdFx0XHRcdFx0aG9yejogd2lkdGgsXG5cdFx0XHRcdFx0XHR2ZXJ0OiBoZWlnaHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1dLFxuXHRcdFx0XHRtZGlhOiBbe1xuXHRcdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0XHRtZGhkOiBbe1xuXHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0dGltZXNjYWxlOiA5MDAwMCxcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRsYW5nOiAndW5kJ1xuXHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRoZGxyOiBbe1xuXHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0aGFuZGxlcl90eXBlOiAndmlkZScsXG5cdFx0XHRcdFx0XHRcdG5hbWU6ICdWaWRlb0hhbmRsZXInXG5cdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdG1pbmY6IFt7XG5cdFx0XHRcdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dm1oZDogW3tcblx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMSxcblx0XHRcdFx0XHRcdFx0XHRcdGdyYXBoaWNzbW9kZTogMCxcblx0XHRcdFx0XHRcdFx0XHRcdG9wY29sb3I6IHtyOiAwLCBnOiAwLCBiOiAwfVxuXHRcdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRcdGRpbmY6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRkcmVmOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW50cmllczogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICd1cmwgJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxvY2F0aW9uOiAnJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0c3RibDogW3tcblx0XHRcdFx0XHRcdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0c2Q6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbnRyaWVzOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogJ2F2YzEnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YV9yZWZlcmVuY2VfaW5kZXg6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkaW1lbnNpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGhvcno6IHdpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0OiBoZWlnaHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHV0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGhvcno6IDcyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0OiA3MlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZyYW1lX2NvdW50OiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tcHJlc3Nvcm5hbWU6ICcnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwdGg6IDI0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXRvbXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXZjQzogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2ZpbGVJbmRpY2F0aW9uOiBzcHNJbmZvLnByb2ZpbGVfaWRjLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2ZpbGVDb21wYXRpYmlsaXR5OiBwYXJzZUludChzcHNJbmZvLmNvbnN0cmFpbnRfc2V0X2ZsYWdzLmpvaW4oJycpLCAyKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsZXZlbEluZGljYXRpb246IHNwc0luZm8ubGV2ZWxfaWRjLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxlbmd0aFNpemVNaW51c09uZTogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXFQYXJhbVNldHM6IFtzcHNdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBpY3RQYXJhbVNldHM6IFtwcHNdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0dHM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbnRyaWVzOiBkdHNEaWZmc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RzczogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IGFjY2Vzc0luZGV4ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN0dHM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbnRyaWVzOiBwdHNfZHRzX0RpZmZzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHNjOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW50cmllczogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpcnN0X2NodW5rOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtcGxlc19wZXJfY2h1bms6IHNpemVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHN6OiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtcGxlX3NpemU6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtcGxlX2NvdW50OiBzaXplcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtcGxlX3NpemVzOiBzaXplc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RjbzogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IFsweDI4XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XVxuXHRcdFx0fVxuXHRcdH1dO1xuXG5cdFx0aWYgKGF1ZGlvU2l6ZSA+IDApIHtcblx0XHRcdHRyYWsucHVzaCh7XG5cdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0dGtoZDogW3tcblx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRmbGFnczogMTUsXG5cdFx0XHRcdFx0XHR0cmFja19JRDogMixcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0XHRcdGxheWVyOiAwLFxuXHRcdFx0XHRcdFx0YWx0ZXJuYXRlX2dyb3VwOiAxLFxuXHRcdFx0XHRcdFx0dm9sdW1lOiAxLFxuXHRcdFx0XHRcdFx0bWF0cml4OiB7XG5cdFx0XHRcdFx0XHRcdGE6IDEsIGI6IDAsIHg6IDAsXG5cdFx0XHRcdFx0XHRcdGM6IDAsIGQ6IDEsIHk6IDAsXG5cdFx0XHRcdFx0XHRcdHU6IDAsIHY6IDAsIHc6IDFcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb25zOiB7XG5cdFx0XHRcdFx0XHRcdGhvcno6IDAsXG5cdFx0XHRcdFx0XHRcdHZlcnQ6IDBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRtZGlhOiBbe1xuXHRcdFx0XHRcdFx0YXRvbXM6IHtcblx0XHRcdFx0XHRcdFx0bWRoZDogW3tcblx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdHRpbWVzY2FsZTogOTAwMDAsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdGxhbmc6ICdlbmcnXG5cdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRoZGxyOiBbe1xuXHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0aGFuZGxlcl90eXBlOiAnc291bicsXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogJ1NvdW5kSGFuZGxlcidcblx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdG1pbmY6IFt7XG5cdFx0XHRcdFx0XHRcdFx0YXRvbXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHNtaGQ6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRiYWxhbmNlOiAwXG5cdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdGRpbmY6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZHJlZjogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICd1cmwgJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxvY2F0aW9uOiAnJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0Ymw6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RzZDogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICdtcDRhJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YV9yZWZlcmVuY2VfaW5kZXg6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNoYW5uZWxjb3VudDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtcGxlc2l6ZTogMTYsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZXJhdGU6IDIyMDUwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhdG9tczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVzZHM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZWN0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRvcl90eXBlOiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV4dF90eXBlOiAxMjgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGVuZ3RoOiAzNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlc19pZDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1fcHJpb3JpdHk6IDBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JfdHlwZTogNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleHRfdHlwZTogMTI4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxlbmd0aDogMjAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogJ21wZWc0X2F1ZGlvJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1fdHlwZTogJ2F1ZGlvJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1cHN0cmVhbV9mbGFnOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ1ZmZlcl9zaXplOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heEJpdHJhdGU6IE1hdGgucm91bmQobWF4QXVkaW9TaXplIC8gKGR1cmF0aW9uIC8gOTAwMDAgLyBhdWRpb1NpemVzLmxlbmd0aCkpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGF2Z0JpdHJhdGU6IE1hdGgucm91bmQoKHN0cmVhbS50ZWxsKCkgLSBhdWRpb1N0YXJ0KSAvIChkdXJhdGlvbiAvIDkwMDAwKSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JfdHlwZTogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleHRfdHlwZTogMTI4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxlbmd0aDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhdWRpb19wcm9maWxlOiBhdWRpb0hlYWRlci5wcm9maWxlTWludXNPbmUgKyAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsaW5nX2ZyZXE6IGF1ZGlvSGVhZGVyLnNhbXBsaW5nRnJlcSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGFubmVsQ29uZmlnOiBhdWRpb0hlYWRlci5jaGFubmVsQ29uZmlnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXNjcmlwdG9yX3R5cGU6IDYsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXh0X3R5cGU6IDEyOCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsZW5ndGg6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2w6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3R0czogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVudHJpZXM6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZV9jb3VudDogYXVkaW9TaXplcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZV9kZWx0YTogTWF0aC5yb3VuZChkdXJhdGlvbiAvIGF1ZGlvU2l6ZXMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHNjOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW50cmllczogW3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zmlyc3RfY2h1bms6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZXNfcGVyX2NodW5rOiBhdWRpb1NpemVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4OiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN0c3o6IFt7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmxhZ3M6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGVfc2l6ZTogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNhbXBsZV9jb3VudDogYXVkaW9TaXplcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1wbGVfc2l6ZXM6IGF1ZGlvU2l6ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGNvOiBbe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWdzOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW50cmllczogWzB4MjggKyBhdWRpb1N0YXJ0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1dXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGNyZWF0aW9uVGltZSA9IG5ldyBEYXRlKCk7XG5cblx0XHRtcDQud3JpdGUoJ0ZpbGUnLCB7XG5cdFx0XHRmdHlwOiBbe1xuXHRcdFx0XHRtYWpvcl9icmFuZDogJ2lzb20nLFxuXHRcdFx0XHRtaW5vcl92ZXJzaW9uOiA1MTIsXG5cdFx0XHRcdGNvbXBhdGlibGVfYnJhbmRzOiBbJ2lzb20nLCAnaXNvMicsICdhdmMxJywgJ21wNDEnXVxuXHRcdFx0fV0sXG5cdFx0XHRtZGF0OiBbe1xuXHRcdFx0XHRfcmF3RGF0YTogc3RyZWFtLmdldEJ5dGVzKHN0cmVhbS50ZWxsKCksIDApXG5cdFx0XHR9XSxcblx0XHRcdG1vb3Y6IFt7XG5cdFx0XHRcdGF0b21zOiB7XG5cdFx0XHRcdFx0bXZoZDogW3tcblx0XHRcdFx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRcdFx0XHRmbGFnczogMCxcblx0XHRcdFx0XHRcdGNyZWF0aW9uX3RpbWU6IGNyZWF0aW9uVGltZSxcblx0XHRcdFx0XHRcdG1vZGlmaWNhdGlvbl90aW1lOiBjcmVhdGlvblRpbWUsXG5cdFx0XHRcdFx0XHR0aW1lc2NhbGU6IDkwMDAwLFxuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0cmF0ZTogMSxcblx0XHRcdFx0XHRcdHZvbHVtZTogMSxcblx0XHRcdFx0XHRcdG1hdHJpeDoge1xuXHRcdFx0XHRcdFx0XHRhOiAxLCBiOiAwLCB4OiAwLFxuXHRcdFx0XHRcdFx0XHRjOiAwLCBkOiAxLCB5OiAwLFxuXHRcdFx0XHRcdFx0XHR1OiAwLCB2OiAwLCB3OiAxXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bmV4dF90cmFja19JRDogMlxuXHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdHRyYWs6IHRyYWtcblx0XHRcdFx0fVxuXHRcdFx0fV1cblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gbXA0LnNsaWNlKDAsIG1wNC50ZWxsKCkpO1xuXHR9O1xufSkpOyIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoWydqYmluYXJ5J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnamJpbmFyeScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290Lk1QNCA9IGZhY3Rvcnkocm9vdC5qQmluYXJ5KTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChqQmluYXJ5KSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdGltZUJhc2lzID0gbmV3IERhdGUoMTk3MCwgMCwgMSkgLSBuZXcgRGF0ZSgxOTA0LCAwLCAxKTtcblxuXHRmdW5jdGlvbiBhdG9tRmlsdGVyKHR5cGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGF0b20pIHtcblx0XHRcdHJldHVybiBhdG9tLnR5cGUgPT09IHR5cGU7XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0U2hvcnROYW1lOiBbJ3N0cmluZzAnLCA0XSxcblx0XHRcblx0XHRSYXRlOiBbJ0ZpeGVkUG9pbnQnLCAnaW50MzInLCAxNl0sXG5cblx0XHREaW1lbnNpb25zOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdHNldFBhcmFtczogZnVuY3Rpb24gKGl0ZW1UeXBlKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVR5cGUgPSB7XG5cdFx0XHRcdFx0aG9yejogaXRlbVR5cGUsXG5cdFx0XHRcdFx0dmVydDogaXRlbVR5cGVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdEJveEhlYWRlcjoge1xuXHRcdFx0X2JlZ2luOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbmFyeS50ZWxsKCk7XG5cdFx0XHR9LFxuXHRcdFx0X3NpemU6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0XHRiYXNlVHlwZTogJ3VpbnQzMicsXG5cdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IGNvbnRleHQuc2l6ZTtcblx0XHRcdFx0XHR0aGlzLmJhc2VXcml0ZShzaXplID8gKHNpemUgPCBNYXRoLnBvdygyLCAzMikgPyBzaXplIDogMSkgOiAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHR0eXBlOiAnU2hvcnROYW1lJyxcblx0XHRcdHNpemU6IGpCaW5hcnkuVHlwZSh7XG5cdFx0XHRcdHJlYWQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0XHRcdFx0dmFyIF9zaXplID0gY29udGV4dC5fc2l6ZTtcblx0XHRcdFx0XHRzd2l0Y2ggKF9zaXplKSB7XG5cdFx0XHRcdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLmJpbmFyeS52aWV3LmJ5dGVMZW5ndGggLSB0aGlzLmJpbmFyeS50ZWxsKCkgKyA4O1xuXHRcdFx0XHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy5iaW5hcnkucmVhZCgndWludDY0Jyk7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gX3NpemU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID49IE1hdGgucG93KDIsIDMyKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUoJ3VpbnQ2NCcsIHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdFx0X2VuZDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuX2JlZ2luICsgY29udGV4dC5zaXplO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRGdWxsQm94OiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCB7XG5cdFx0XHR2ZXJzaW9uOiAndWludDgnLFxuXHRcdFx0ZmxhZ3M6IDI0XG5cdFx0fV0sXG5cblx0XHRCb3g6IGpCaW5hcnkuVHlwZSh7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBoZWFkZXIgPSB0aGlzLmJpbmFyeS5za2lwKDAsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5yZWFkKCdCb3hIZWFkZXInKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHZhciBib3ggPSB0aGlzLmJpbmFyeS5yZWFkKGhlYWRlci50eXBlKSB8fCBoZWFkZXI7XG5cdFx0XHRcdGlmIChib3ggPT09IGhlYWRlcikgY29uc29sZS5sb2coaGVhZGVyLnR5cGUpO1xuXHRcdFx0XHR0aGlzLmJpbmFyeS5zZWVrKGhlYWRlci5fZW5kKTtcblx0XHRcdFx0cmV0dXJuIGJveDtcblx0XHRcdH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKGJveCkge1xuXHRcdFx0XHR0aGlzLmJpbmFyeS53cml0ZShib3gudHlwZSwgYm94KTtcblx0XHRcdFx0dmFyIHNpemUgPSB0aGlzLmJpbmFyeS50ZWxsKCkgLSBib3guX2JlZ2luO1xuXHRcdFx0XHR0aGlzLmJpbmFyeS5zZWVrKGJveC5fYmVnaW4sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLndyaXRlKCd1aW50MzInLCBzaXplKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRUaW1lOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdHBhcmFtczogWydiYXNlVHlwZSddLFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgaW50VGltZSA9IHRoaXMuYmFzZVJlYWQoKTtcblx0XHRcdFx0aWYgKGludFRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoaW50VGltZSArIHRpbWVCYXNpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHRcdFx0dGhpcy5iYXNlV3JpdGUoKHRpbWUgLSB0aW1lQmFzaXMpID4+PiAwKTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdEZpeGVkUG9pbnQ6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0cGFyYW1zOiBbJ2Jhc2VUeXBlJ10sXG5cdFx0XHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChiYXNlVHlwZSwgc2hpZnQpIHtcblx0XHRcdFx0dGhpcy5jb2VmID0gMSA8PCBzaGlmdDtcblx0XHRcdH0sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJhc2VSZWFkKCkgLyB0aGlzLmNvZWY7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmJhc2VXcml0ZSh2YWx1ZSAqIHRoaXMuY29lZik7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRBdG9tczogakJpbmFyeS5UeXBlKHtcblx0XHRcdHBhcmFtczogWydlbmQnXSxcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGF0b21zID0ge30sIGVuZCA9IHRoaXMudG9WYWx1ZSh0aGlzLmVuZCkgfHwgdGhpcy5iaW5hcnkuZ2V0Q29udGV4dCgnX2VuZCcpLl9lbmQ7XG5cdFx0XHRcdHdoaWxlICh0aGlzLmJpbmFyeS50ZWxsKCkgPCBlbmQpIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHRoaXMuYmluYXJ5LnJlYWQoJ0JveCcpO1xuXHRcdFx0XHRcdChhdG9tc1tpdGVtLnR5cGVdIHx8IChhdG9tc1tpdGVtLnR5cGVdID0gW10pKS5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhdG9tcztcblx0XHRcdH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKHBhcmVudCkge1xuXHRcdFx0XHRmb3IgKHZhciB0eXBlIGluIHBhcmVudCkge1xuXHRcdFx0XHRcdHZhciBhdG9tcyA9IHBhcmVudFt0eXBlXTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXRvbXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGF0b21zW2ldLnR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkud3JpdGUoJ0JveCcsIGF0b21zW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdENoaWxkQXRvbXM6IHtcblx0XHRcdGF0b21zOiAnQXRvbXMnXG5cdFx0fSxcblxuXHRcdE11bHRpQm94OiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCAnQ2hpbGRBdG9tcyddLFxuXG5cdFx0VHJhbnNmb3JtYXRpb25NYXRyaXg6IHtcblx0XHRcdGE6IFsnRml4ZWRQb2ludCcsICd1aW50MzInLCAxNl0sXG5cdFx0XHRiOiBbJ0ZpeGVkUG9pbnQnLCAndWludDMyJywgMTZdLFxuXHRcdFx0dTogWydGaXhlZFBvaW50JywgJ3VpbnQzMicsIDMwXSxcblx0XHRcdGM6IFsnRml4ZWRQb2ludCcsICd1aW50MzInLCAxNl0sXG5cdFx0XHRkOiBbJ0ZpeGVkUG9pbnQnLCAndWludDMyJywgMTZdLFxuXHRcdFx0djogWydGaXhlZFBvaW50JywgJ3VpbnQzMicsIDMwXSxcblx0XHRcdHg6IFsnRml4ZWRQb2ludCcsICd1aW50MzInLCAxNl0sXG5cdFx0XHR5OiBbJ0ZpeGVkUG9pbnQnLCAndWludDMyJywgMTZdLFxuXHRcdFx0dzogWydGaXhlZFBvaW50JywgJ3VpbnQzMicsIDMwXVxuXHRcdH0sXG5cblx0XHRWb2x1bWU6IFsnRml4ZWRQb2ludCcsICd1aW50MTYnLCA4XSxcblxuXHRcdEZCVmVyc2lvbmFibGU6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAodHlwZTAsIHR5cGUxKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVR5cGUgPSBbJ2lmJywgJ3ZlcnNpb24nLCB0eXBlMSwgdHlwZTBdO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0RkJVaW50OiBbJ0ZCVmVyc2lvbmFibGUnLCAndWludDMyJywgJ3VpbnQ2NCddLFxuXG5cdFx0RkJUaW1lOiBbJ1RpbWUnLCAnRkJVaW50J10sXG5cblx0XHRUaW1lc3RhbXBCb3g6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRjcmVhdGlvbl90aW1lOiAnRkJUaW1lJyxcblx0XHRcdG1vZGlmaWNhdGlvbl90aW1lOiAnRkJUaW1lJ1xuXHRcdH1dLFxuXG5cdFx0RHVyYXRpb25Cb3g6IFsnZXh0ZW5kJywgJ1RpbWVzdGFtcEJveCcsIHtcblx0XHRcdHRpbWVzY2FsZTogJ3VpbnQzMicsXG5cdFx0XHRkdXJhdGlvbjogJ0ZCVWludCdcblx0XHR9XSxcblxuXHRcdGZ0eXA6IFsnZXh0ZW5kJywgJ0JveEhlYWRlcicsIHtcblx0XHRcdG1ham9yX2JyYW5kOiAnU2hvcnROYW1lJyxcblx0XHRcdG1pbm9yX3ZlcnNpb246ICd1aW50MzInLFxuXHRcdFx0Y29tcGF0aWJsZV9icmFuZHM6IFsnYXJyYXknLCAnU2hvcnROYW1lJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuYmluYXJ5LmdldENvbnRleHQoMSkuX2VuZCAtIHRoaXMuYmluYXJ5LnRlbGwoKSkgLyA0IH1dXG5cdFx0fV0sXG5cblx0XHRmcmVlOiAnQm94SGVhZGVyJyxcblxuXHRcdFJhd0RhdGE6IHtcblx0XHRcdF9yYXdEYXRhOiBbJ2Jsb2InLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJpbmFyeS5nZXRDb250ZXh0KCdfZW5kJykuX2VuZCAtIHRoaXMuYmluYXJ5LnRlbGwoKSB9XVxuXHRcdH0sXG5cblx0XHRtZGF0OiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCAnUmF3RGF0YSddLFxuXG5cdFx0UGFyYW1TZXRzOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdHNldFBhcmFtczogZnVuY3Rpb24gKG51bVR5cGUpIHtcblx0XHRcdFx0dGhpcy5iYXNlVHlwZSA9IFsnRHluYW1pY0FycmF5JywgbnVtVHlwZSwgakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRcdFx0YmFzZVR5cGU6IHtcblx0XHRcdFx0XHRcdGxlbmd0aDogJ3VpbnQxNicsXG5cdFx0XHRcdFx0XHRwYXJhbVNldDogWydibG9iJywgJ2xlbmd0aCddXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iYXNlUmVhZCgpLnBhcmFtU2V0O1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChwYXJhbVNldCkge1xuXHRcdFx0XHRcdFx0dGhpcy5iYXNlV3JpdGUoe1xuXHRcdFx0XHRcdFx0XHRsZW5ndGg6IHBhcmFtU2V0Lmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0cGFyYW1TZXQ6IHBhcmFtU2V0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdGF2Y0M6IFsnZXh0ZW5kJywgJ0JveEhlYWRlcicsIHtcblx0XHRcdHZlcnNpb246IFsnY29uc3QnLCAndWludDgnLCAxXSxcblx0XHRcdHByb2ZpbGVJbmRpY2F0aW9uOiAndWludDgnLFxuXHRcdFx0cHJvZmlsZUNvbXBhdGliaWxpdHk6ICd1aW50OCcsXG5cdFx0XHRsZXZlbEluZGljYXRpb246ICd1aW50OCcsXG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnY29uc3QnLCA2LCAtMV0sXG5cdFx0XHRsZW5ndGhTaXplTWludXNPbmU6IDIsXG5cdFx0XHRfcmVzZXJ2ZWQyOiBbJ2NvbnN0JywgMywgLTFdLFxuXHRcdFx0c2VxUGFyYW1TZXRzOiBbJ1BhcmFtU2V0cycsIDVdLFxuXHRcdFx0cGljdFBhcmFtU2V0czogWydQYXJhbVNldHMnLCAndWludDgnXVxuXHRcdH1dLFxuXG5cdFx0bW9vdjogJ011bHRpQm94JyxcblxuXHRcdG12aGQ6IFsnZXh0ZW5kJywgJ0R1cmF0aW9uQm94Jywge1xuXHRcdFx0cmF0ZTogJ1JhdGUnLFxuXHRcdFx0dm9sdW1lOiAnVm9sdW1lJyxcblx0XHRcdF9yZXNlcnZlZDogWydza2lwJywgMTBdLFxuXHRcdFx0bWF0cml4OiAnVHJhbnNmb3JtYXRpb25NYXRyaXgnLFxuXHRcdFx0X3Jlc2VydmVkMjogWydza2lwJywgMjRdLFxuXHRcdFx0bmV4dF90cmFja19JRDogJ3VpbnQzMidcblx0XHR9XSxcblxuXHRcdHRyYWs6ICdNdWx0aUJveCcsXG5cblx0XHR0a2hkOiBbJ2V4dGVuZCcsICdUaW1lc3RhbXBCb3gnLCB7XG5cdFx0XHR0cmFja19JRDogJ3VpbnQzMicsXG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDRdLFxuXHRcdFx0ZHVyYXRpb246ICdGQlVpbnQnLFxuXHRcdFx0X3Jlc2VydmVkMjogWydza2lwJywgOF0sXG5cdFx0XHRsYXllcjogJ2ludDE2Jyxcblx0XHRcdGFsdGVybmF0ZV9ncm91cDogJ3VpbnQxNicsXG5cdFx0XHR2b2x1bWU6ICdWb2x1bWUnLFxuXHRcdFx0X3Jlc2VydmVkMzogWydza2lwJywgMl0sXG5cdFx0XHRtYXRyaXg6ICdUcmFuc2Zvcm1hdGlvbk1hdHJpeCcsXG5cdFx0XHRkaW1lbnNpb25zOiBbJ0RpbWVuc2lvbnMnLCAnUmF0ZSddXG5cdFx0fV0sXG5cblx0XHR0cmVmOiAnTXVsdGlCb3gnLFxuXG5cdFx0VHJhY2tSZWZlcmVuY2VUeXBlQm94OiBbJ2V4dGVuZCcsICdCb3hIZWFkZXInLCB7XG5cdFx0XHR0cmFja19JRHM6IFsnYXJyYXknLCAndWludDMyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuYmluYXJ5LmdldENvbnRleHQoMSkuX2VuZCAtIHRoaXMuYmluYXJ5LnRlbGwoKSkgLyA0IH1dXG5cdFx0fV0sXG5cblx0XHRoaW50OiAnVHJhY2tSZWZlcmVuY2VUeXBlQm94JyxcblxuXHRcdGNkc2M6ICdUcmFja1JlZmVyZW5jZVR5cGVCb3gnLFxuXG5cdFx0aGluZDogJ1RyYWNrUmVmZXJlbmNlVHlwZUJveCcsXG5cblx0XHRtZGlhOiAnTXVsdGlCb3gnLFxuXG5cdFx0bWRoZDogWydleHRlbmQnLCAnRHVyYXRpb25Cb3gnLCB7XG5cdFx0XHRfcGFkZGluZzogMSxcblx0XHRcdGxhbmc6IGpCaW5hcnkuVHlwZSh7XG5cdFx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcblx0XHRcdFx0XHRcdFN0cmluZyxcblx0XHRcdFx0XHRcdHRoaXMuYmluYXJ5LnJlYWQoWydhcnJheScsIDUsIDNdKS5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIGNvZGUgKyAweDYwIH0pXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmJpbmFyeS53cml0ZSg1LCB2YWx1ZS5jaGFyQ29kZUF0KGkpIC0gMHg2MCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHRcdF9yZXNlcnZlZDogWydza2lwJywgMl1cblx0XHR9XSxcblxuXHRcdGhkbHI6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDRdLFxuXHRcdFx0aGFuZGxlcl90eXBlOiAnU2hvcnROYW1lJyxcblx0XHRcdF9zZXRfaGFuZGxlcl90eXBlOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHRcdFx0XHR0aGlzLmJpbmFyeS5nZXRDb250ZXh0KGF0b21GaWx0ZXIoJ3RyYWsnKSkuX2hhbmRsZXJfdHlwZSA9IGNvbnRleHQuaGFuZGxlcl90eXBlO1xuXHRcdFx0fSxcblx0XHRcdF9yZXNlcnZlZDI6IFsnc2tpcCcsIDEyXSxcblx0XHRcdG5hbWU6ICdzdHJpbmcwJ1xuXHRcdH1dLFxuXG5cdFx0bWluZjogJ011bHRpQm94JyxcblxuXHRcdHZtaGQ6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRncmFwaGljc21vZGU6ICd1aW50MTYnLFxuXHRcdFx0b3Bjb2xvcjoge1xuXHRcdFx0XHRyOiAndWludDE2Jyxcblx0XHRcdFx0ZzogJ3VpbnQxNicsXG5cdFx0XHRcdGI6ICd1aW50MTYnXG5cdFx0XHR9XG5cdFx0fV0sXG5cblx0XHRzbWhkOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0YmFsYW5jZTogWydGaXhlZFBvaW50JywgJ2ludDE2JywgOF0sXG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDJdXG5cdFx0fV0sXG5cblx0XHRobWhkOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0bWF4UERVc2l6ZTogJ3VpbnQxNicsXG5cdFx0XHRhdmdQRFVzaXplOiAndWludDE2Jyxcblx0XHRcdG1heGJpdHJhdGU6ICd1aW50MzInLFxuXHRcdFx0YXZnYml0cmF0ZTogJ3VpbnQzMicsXG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDRdXG5cdFx0fV0sXG5cblx0XHRzdGJsOiAnTXVsdGlCb3gnLFxuXG5cdFx0U2FtcGxlRW50cnk6IFsnZXh0ZW5kJywgJ0JveEhlYWRlcicsIHtcblx0XHRcdF9yZXNlcnZlZDogWydza2lwJywgNl0sXG5cdFx0XHRkYXRhX3JlZmVyZW5jZV9pbmRleDogJ3VpbnQxNidcblx0XHR9XSxcblxuXHRcdGJ0cnQ6IFsnZXh0ZW5kJywgJ0JveEhlYWRlcicsIHtcblx0XHRcdGJ1ZmZlclNpemVEQjogJ3VpbnQzMicsXG5cdFx0XHRtYXhCaXRyYXRlOiAndWludDMyJyxcblx0XHRcdGF2Z0JpdHJhdGU6ICd1aW50MzInXG5cdFx0fV0sXG5cblx0XHRtZXR4OiBbJ2V4dGVuZCcsICdTYW1wbGVFbnRyeScsIHtcblx0XHRcdGNvbnRlbnRfZW5jb2Rpbmc6ICdzdHJpbmcwJyxcblx0XHRcdG5hbWVzcGFjZTogJ3N0cmluZzAnLFxuXHRcdFx0c2NoZW1hX2xvY2F0aW9uOiAnc3RyaW5nMCcsXG5cdFx0XHRiaXRyYXRlYm94OiAnYnRydCdcblx0XHR9XSxcblxuXHRcdG1ldHQ6IFsnZXh0ZW5kJywgJ1NhbXBsZUVudHJ5Jywge1xuXHRcdFx0Y29udGVudF9lbmNvZGluZzogJ3N0cmluZzAnLFxuXHRcdFx0bWltZV9mb3JtYXQ6ICdzdHJpbmcwJyxcblx0XHRcdGJpdHJhdGVib3g6ICdidHJ0J1xuXHRcdH1dLFxuXG5cdFx0cGFzcDogWydleHRlbmQnLCAnQm94SGVhZGVyJywge1xuXHRcdFx0c3BhY2luZzogWydEaW1lbnNpb25zJywgJ3VpbnQzMiddXG5cdFx0fV0sXG5cblx0XHRDbGFwSW5uZXJGb3JtYXQ6IFsnRGltZW5zaW9ucycsIHtcblx0XHRcdE46ICd1aW50MzInLFxuXHRcdFx0RDogJ3VpbnQzMidcblx0XHR9XSxcblxuXHRcdGNsYXA6IFsnZXh0ZW5kJywgJ0JveEhlYWRlcicsIHtcblx0XHRcdGNsZWFuQXBlcnR1cmU6ICdDbGFwSW5uZXJGb3JtYXQnLFxuXHRcdFx0b2ZmOiAnQ2xhcElubmVyRm9ybWF0J1xuXHRcdH1dLFxuXG5cdFx0VmlzdWFsU2FtcGxlRW50cnk6IFsnZXh0ZW5kJywgJ1NhbXBsZUVudHJ5Jywge1xuXHRcdFx0X3Jlc2VydmVkOiBbJ3NraXAnLCAxNl0sXG5cdFx0XHRkaW1lbnNpb25zOiBbJ0RpbWVuc2lvbnMnLCAndWludDE2J10sXG5cdFx0XHRyZXNvbHV0aW9uOiBbJ0RpbWVuc2lvbnMnLCAnUmF0ZSddLFxuXHRcdFx0X3Jlc2VydmVkMjogWydza2lwJywgNF0sXG5cdFx0XHRmcmFtZV9jb3VudDogWydjb25zdCcsICd1aW50MTYnLCAxXSxcblx0XHRcdGNvbXByZXNzb3JuYW1lOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdFx0YmFzZVR5cGU6IHtcblx0XHRcdFx0XHRsZW5ndGg6ICd1aW50OCcsXG5cdFx0XHRcdFx0c3RyaW5nOiBbJ3N0cmluZycsICdsZW5ndGgnXSxcblx0XHRcdFx0XHRfc2tpcDogWydza2lwJywgZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIDMyIC0gMSAtIGNvbnRleHQubGVuZ3RoIH1dXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iYXNlUmVhZCgpLnN0cmluZztcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHtcblx0XHRcdFx0XHRcdGxlbmd0aDogdmFsdWUubGVuZ3RoLFxuXHRcdFx0XHRcdFx0c3RyaW5nOiB2YWx1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHRcdGRlcHRoOiAndWludDE2Jyxcblx0XHRcdF9yZXNlcnZlZDM6IFsnY29uc3QnLCAnaW50MTYnLCAtMV1cblx0XHR9LCBqQmluYXJ5LlR5cGUoe1xuXHRcdFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9uYWwgPSB7XG5cdFx0XHRcdFx0Y2xlYW5hcGVydHVyZTogJ2NsYXAnLFxuXHRcdFx0XHRcdHBpeGVsYXNwZWN0cmF0aW86ICdwYXNwJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGV4dGVuc2lvbiA9IHt9O1xuXG5cdFx0XHRcdGZvciAodmFyIHByb3BOYW1lIGluIHRoaXMub3B0aW9uYWwpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMub3B0aW9uYWxbcHJvcE5hbWVdO1xuXHRcdFx0XHRcdHZhciBhdG9tID0gdGhpcy5iaW5hcnkuc2tpcCgwLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlYWQoJ0JveEhlYWRlcicpIH0pO1xuXHRcdFx0XHRcdGlmIChhdG9tLnR5cGUgPT09IHR5cGUpIHtcblx0XHRcdFx0XHRcdGV4dGVuc2lvbltwcm9wTmFtZV0gPSB0aGlzLmJpbmFyeS5yZWFkKHR5cGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBleHRlbnNpb247XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChib3gpIHtcblx0XHRcdFx0Zm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5vcHRpb25hbCkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IGJveFtwcm9wTmFtZV07XG5cdFx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmJpbmFyeS53cml0ZSh0aGlzLm9wdGlvbmFsW3Byb3BOYW1lXSwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pLCAnQ2hpbGRBdG9tcyddLFxuXG5cdFx0QXVkaW9TYW1wbGVFbnRyeTogWydleHRlbmQnLCAnU2FtcGxlRW50cnknLCB7XG5cdFx0XHRfcmVzZXJ2ZWQ6IFsnc2tpcCcsIDhdLFxuXHRcdFx0Y2hhbm5lbGNvdW50OiAndWludDE2Jyxcblx0XHRcdHNhbXBsZXNpemU6ICd1aW50MTYnLFxuXHRcdFx0X3Jlc2VydmVkMjogWydza2lwJywgNF0sXG5cdFx0XHRzYW1wbGVyYXRlOiAnUmF0ZSdcblx0XHR9LCAnQ2hpbGRBdG9tcyddLFxuXG5cdFx0RHluYW1pY0FycmF5OiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdHNldFBhcmFtczogZnVuY3Rpb24gKGxlbmd0aFR5cGUsIGl0ZW1UeXBlKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVR5cGUgPSB7XG5cdFx0XHRcdFx0bGVuZ3RoOiBsZW5ndGhUeXBlLFxuXHRcdFx0XHRcdGFycmF5OiBbJ2FycmF5JywgaXRlbVR5cGUsICdsZW5ndGgnXVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmFzZVJlYWQoKS5hcnJheTtcblx0XHRcdH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKGFycmF5KSB7XG5cdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHtcblx0XHRcdFx0XHRsZW5ndGg6IGFycmF5Lmxlbmd0aCxcblx0XHRcdFx0XHRhcnJheTogYXJyYXlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRBcnJheUJveDogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChlbnRyeVR5cGUpIHtcblx0XHRcdFx0dGhpcy5iYXNlVHlwZSA9IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRcdFx0ZW50cmllczogWydEeW5hbWljQXJyYXknLCAndWludDMyJywgZW50cnlUeXBlXVxuXHRcdFx0XHR9XTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdHN0c2Q6IFsnQXJyYXlCb3gnLCBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdGdldEJhc2VUeXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB7c291bjogJ0F1ZGlvU2FtcGxlRW50cnknLCB2aWRlOiAnVmlzdWFsU2FtcGxlRW50cnknLCBtZXRhOiAnQm94J31bdGhpcy5iaW5hcnkuZ2V0Q29udGV4dChhdG9tRmlsdGVyKCd0cmFrJykpLl9oYW5kbGVyX3R5cGVdIHx8ICdTYW1wbGVFbnRyeSc7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHR2YXIgcG9zID0gdGhpcy5iaW5hcnkudGVsbCgpO1xuXHRcdFx0XHR0aGlzLmJhc2VXcml0ZSh2YWx1ZSk7XG5cdFx0XHRcdHZhciBzaXplID0gdGhpcy5iaW5hcnkudGVsbCgpIC0gcG9zO1xuXHRcdFx0XHR0aGlzLmJpbmFyeS5zZWVrKHBvcywgZnVuY3Rpb24gKCkgeyB0aGlzLndyaXRlKCd1aW50MzInLCBzaXplKSB9KTtcblx0XHRcdH1cblx0XHR9KV0sXG5cblx0XHRzdGRwOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0cHJpb3JpdGllczogWydhcnJheScsICd1aW50MTYnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJpbmFyeS5nZXRDb250ZXh0KGF0b21GaWx0ZXIoJ3N0YmwnKSkuX3NhbXBsZV9jb3VudCB9XVxuXHRcdH1dLFxuXG5cdFx0c3RzbDogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdF9yZXNlcnZlZDogNyxcblx0XHRcdGNvbnN0cmFpbnRfZmxhZzogJ2Jvb2wnLFxuXHRcdFx0c2NhbGVfbWV0aG9kOiBbJ2VudW0nLCAndWludDgnLCBbZmFsc2UsICdmaWxsJywgJ2hpZGRlbicsICdtZWV0JywgJ3NsaWNlLXgnLCAnc2xpY2UteSddXSxcblx0XHRcdGRpc3BsYXlfY2VudGVyOiBbJ0RpbWVuc2lvbnMnLCAnaW50MTYnXVxuXHRcdH1dLFxuXG5cdFx0c3R0czogWydBcnJheUJveCcsIHtcblx0XHRcdHNhbXBsZV9jb3VudDogJ3VpbnQzMicsXG5cdFx0XHRzYW1wbGVfZGVsdGE6ICd1aW50MzInXG5cdFx0fV0sXG5cblx0XHRjdHRzOiBbJ0FycmF5Qm94Jywge1xuXHRcdFx0c2FtcGxlX2NvdW50OiAndWludDMyJyxcblx0XHRcdHNhbXBsZV9vZmZzZXQ6ICd1aW50MzInXG5cdFx0fV0sXG5cblx0XHRzdHNzOiBbJ0FycmF5Qm94JywgJ3VpbnQzMiddLFxuXG5cdFx0c3RzaDogWydBcnJheUJveCcsIHtcblx0XHRcdHNoYWRvd2VkX3NhbXBsZV9udW1iZXI6ICd1aW50MzInLFxuXHRcdFx0c3luY19zYW1wbGVfbnVtYmVyOiAndWludDMyJ1xuXHRcdH1dLFxuXG5cdFx0RXh0ZW5kZWRCb29sZWFuOiBbJ2VudW0nLCAyLCBbdW5kZWZpbmVkLCB0cnVlLCBmYWxzZV1dLFxuXG5cdFx0c2R0cDogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdGRlcGVuZGVuY2llczogWydhcnJheScsIHtcblx0XHRcdFx0X3Jlc2VydmVkOiAyLFxuXHRcdFx0XHRzYW1wbGVfZGVwZW5kc19vbjogJ0V4dGVuZGVkQm9vbGVhbicsXG5cdFx0XHRcdHNhbXBsZV9pc19kZXBlbmRlZF9vbjogJ0V4dGVuZGVkQm9vbGVhbicsXG5cdFx0XHRcdHNhbXBsZV9oYXNfcmVkdW5kYW5jeTogJ0V4dGVuZGVkQm9vbGVhbidcblx0XHRcdH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuYmluYXJ5LmdldENvbnRleHQoYXRvbUZpbHRlcignc3RibCcpKS5fc2FtcGxlX2NvdW50IH1dXG5cdFx0fV0sXG5cblx0XHRlZHRzOiAnTXVsdGlCb3gnLFxuXG5cdFx0ZWxzdDogWydBcnJheUJveCcsIHtcblx0XHRcdHNlZ21lbnRfZHVyYXRpb246ICdGQlVpbnQnLFxuXHRcdFx0bWVkaWFfdGltZTogWydGQlZlcnNpb25hYmxlJywgJ2ludDMyJywgJ2ludDY0J10sXG5cdFx0XHRtZWRpYV9yYXRlOiAnUmF0ZSdcblx0XHR9XSxcblxuXHRcdGRpbmY6ICdNdWx0aUJveCcsXG5cblx0XHQndXJsICc6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRsb2NhdGlvbjogJ3N0cmluZzAnXG5cdFx0fV0sXG5cblx0XHQndXJuICc6IFsnZXh0ZW5kJywgJ0Z1bGxCb3gnLCB7XG5cdFx0XHRuYW1lOiAnc3RyaW5nMCcsXG5cdFx0XHRsb2NhdGlvbjogJ3N0cmluZzAnXG5cdFx0fV0sXG5cblx0XHRkcmVmOiBbJ0FycmF5Qm94JywgJ0JveCddLFxuXG5cdFx0c3RzejogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdHNhbXBsZV9zaXplOiAndWludDMyJyxcblx0XHRcdHNhbXBsZV9jb3VudDogJ3VpbnQzMicsXG5cdFx0XHRfc2FtcGxlX2NvdW50X3RvX3N0Ymw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0XHRcdHRoaXMuYmluYXJ5LmdldENvbnRleHQoYXRvbUZpbHRlcignc3RibCcpKS5fc2FtcGxlX2NvdW50ID0gY29udGV4dC5zYW1wbGVfY291bnQ7XG5cdFx0XHR9LFxuXHRcdFx0c2FtcGxlX3NpemVzOiBbJ2lmX25vdCcsICdzYW1wbGVfc2l6ZScsXG5cdFx0XHRcdFsnYXJyYXknLCAndWludDMyJywgJ3NhbXBsZV9jb3VudCddXG5cdFx0XHRdXG5cdFx0fV0sXG5cblx0XHRzdHoyOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0X3Jlc2VydmVkOiBbJ3NraXAnLCAzXSxcblx0XHRcdGZpZWxkX3NpemU6ICd1aW50OCcsXG5cdFx0XHRzYW1wbGVfY291bnQ6ICd1aW50MzInLFxuXHRcdFx0X3NhbXBsZV9jb3VudF90b19zdGJsOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHRcdFx0XHR0aGlzLmJpbmFyeS5nZXRDb250ZXh0KGF0b21GaWx0ZXIoJ3N0YmwnKSkuX3NhbXBsZV9jb3VudCA9IGNvbnRleHQuc2FtcGxlX2NvdW50O1xuXHRcdFx0fSxcblx0XHRcdHNhbXBsZV9zaXplczogW1xuXHRcdFx0XHQnYXJyYXknLFxuXHRcdFx0XHRqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdFx0XHRnZXRCYXNlVHlwZTogZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIGNvbnRleHQuZmllbGRfc2l6ZSB9XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHQnc2FtcGxlX2NvdW50J1xuXHRcdFx0XVxuXHRcdH1dLFxuXG5cdFx0c3RzYzogWydBcnJheUJveCcsIHtcblx0XHRcdGZpcnN0X2NodW5rOiAndWludDMyJyxcblx0XHRcdHNhbXBsZXNfcGVyX2NodW5rOiAndWludDMyJyxcblx0XHRcdHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleDogJ3VpbnQzMidcblx0XHR9XSxcblxuXHRcdHN0Y286IFsnQXJyYXlCb3gnLCAndWludDMyJ10sXG5cblx0XHRjbzY0OiBbJ0FycmF5Qm94JywgJ3VpbnQ2NCddLFxuXG5cdFx0cGFkYjogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdHBhZHM6IFsnRHluYW1pY0FycmF5JywgJ3VpbnQzMicsIGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0XHRiYXNlVHlwZToge1xuXHRcdFx0XHRcdF9za2lwOiBbJ2NvbnN0JywgMSwgMF0sXG5cdFx0XHRcdFx0cGFkOiAzXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iYXNlUmVhZCgpLnBhZDtcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChwYWQpIHtcblx0XHRcdFx0XHR0aGlzLmJhc2VXcml0ZSh7cGFkOiBwYWR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSldXG5cdFx0fV0sXG5cblx0XHRzdWJzOiBbJ0FycmF5Qm94Jywge1xuXHRcdFx0c2FtcGxlX2RlbHRhOiAndWludDMyJyxcblx0XHRcdHN1YnNhbXBsZXM6IFsnRHluYW1pY0FycmF5JywgJ3VpbnQxNicsIHtcblx0XHRcdFx0c3Vic2FtcGxlX3NpemU6IFsnRkJWZXJzaW9uYWJsZScsICd1aW50MTYnLCAndWludDMyJ10sXG5cdFx0XHRcdHN1YnNhbXBsZV9wcmlvcml0eTogJ3VpbnQ4Jyxcblx0XHRcdFx0ZGlzY2FyZGFibGU6ICd1aW50OCcsXG5cdFx0XHRcdF9yZXNlcnZlZDogWydza2lwJywgNF1cblx0XHRcdH1dXG5cdFx0fV0sXG5cblx0XHRtdmV4OiAnTXVsdGlCb3gnLFxuXG5cdFx0bWVoZDogWydleHRlbmQnLCAnRnVsbEJveCcsIHtcblx0XHRcdGZyYWdtZW50X2R1cmF0aW9uOiAnRkJVaW50J1xuXHRcdH1dLFxuXG5cdFx0ZXNkc19zZWN0aW9uOiBbJ2V4dGVuZCcsIHtcblx0XHRcdGRlc2NyaXB0b3JfdHlwZTogJ3VpbnQ4Jyxcblx0XHRcdGV4dF90eXBlOiBqQmluYXJ5LlR5cGUoe1xuXHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIG5leHRfYnl0ZSA9IHRoaXMuYmluYXJ5LnJlYWQoJ3VpbnQ4Jyk7XG5cdFx0XHRcdFx0aWYgKG5leHRfYnl0ZSA9PT0gMHg4MCB8fCBuZXh0X2J5dGUgPT09IDB4ODEgfHwgbmV4dF9ieXRlID09PSAweEZFKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmJpbmFyeS5za2lwKDIpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5leHRfYnl0ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5iaW5hcnkuc2tpcCgtMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKGZpbGxlcikge1xuXHRcdFx0XHRcdGlmIChmaWxsZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5iaW5hcnkud3JpdGUoJ2Jsb2InLCBbZmlsbGVyLCBmaWxsZXIsIGZpbGxlcl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHRcdGxlbmd0aDogJ3VpbnQ4J1xuXHRcdH0sIGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0Z2V0QmFzZVR5cGU6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0XHRcdHN3aXRjaCAoY29udGV4dC5kZXNjcmlwdG9yX3R5cGUpIHtcblx0XHRcdFx0XHRjYXNlIDM6IHJldHVybiB7XG5cdFx0XHRcdFx0XHRlc19pZDogJ3VpbnQxNicsXG5cdFx0XHRcdFx0XHRzdHJlYW1fcHJpb3JpdHk6ICd1aW50OCdcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2FzZSA0OiByZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogWydlbnVtJywgJ3VpbnQ4Jywge1xuXHRcdFx0XHRcdFx0XHQxOiAndjEnLFxuXHRcdFx0XHRcdFx0XHQyOiAndjInLFxuXHRcdFx0XHRcdFx0XHQzMjogJ21wZWc0X3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0MzM6ICdtcGVnNF9hdmNfc3BzJyxcblx0XHRcdFx0XHRcdFx0MzQ6ICdtcGVnNF9hdmNfcHBzJyxcblx0XHRcdFx0XHRcdFx0NjQ6ICdtcGVnNF9hdWRpbycsXG5cdFx0XHRcdFx0XHRcdDk2OiAnbXBlZzJfc2ltcGxlX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0OTc6ICdtcGVnMl9tYWluX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0OTg6ICdtcGVnMl9zbnJfdmlkZW8nLFxuXHRcdFx0XHRcdFx0XHQ5OTogJ21wZWcyX3NwYXRpYWxfdmlkZW8nLFxuXHRcdFx0XHRcdFx0XHQxMDA6ICdtcGVnMl9oaWdoX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0MTAxOiAnbXBlZzJfNDIyX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0MTAyOiAnbXBlZzRfYWR0c19tYWluJyxcblx0XHRcdFx0XHRcdFx0MTAzOiAnbXBlZzRfYWR0c19sb3dfY29tcGxleGl0eScsXG5cdFx0XHRcdFx0XHRcdDEwNDogJ21wZWc0X2FkdHNfc2NhbGVhYmxlX3NhbXBsaW5nJyxcblx0XHRcdFx0XHRcdFx0MTA1OiAnbXBlZzJfYWR0c19tYWluJyxcblx0XHRcdFx0XHRcdFx0MTA2OiAnbXBlZzFfdmlkZW8nLFxuXHRcdFx0XHRcdFx0XHQxMDc6ICdtcGVnMV9hZHRzJyxcblx0XHRcdFx0XHRcdFx0MTA4OiAnanBlZ192aWRlbycsXG5cdFx0XHRcdFx0XHRcdDE5MjogJ3ByaXZhdGVfYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQyMDg6ICdwcml2YXRlX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0MjI0OiAncGNtX2xpdHRsZV9lbmRpYW5fYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQyMjU6ICd2b3JiaXNfYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQyMjY6ICdkb2xieV92M19hdWRpbycsXG5cdFx0XHRcdFx0XHRcdDIyNzogJ2FsYXdfYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQyMjg6ICdtdWxhd19hdWRpbycsXG5cdFx0XHRcdFx0XHRcdDIyOTogJ2FkcGNtX2F1ZGlvJyxcblx0XHRcdFx0XHRcdFx0MjMwOiAncGNtX2JpZ19lbmRpYW5fYXVkaW8nLFxuXHRcdFx0XHRcdFx0XHQyNDA6ICd5djEyX3ZpZGVvJyxcblx0XHRcdFx0XHRcdFx0MjQxOiAnaDI2NF92aWRlbycsXG5cdFx0XHRcdFx0XHRcdDI0MjogJ2gyNjNfdmlkZW8nLFxuXHRcdFx0XHRcdFx0XHQyNDM6ICdoMjYxX3ZpZGVvJ1xuXHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRzdHJlYW1fdHlwZTogWydlbnVtJywgNiwgW1xuXHRcdFx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdFx0XHQnb2JqZWN0Jyxcblx0XHRcdFx0XHRcdFx0J2Nsb2NrJyxcblx0XHRcdFx0XHRcdFx0J3NjZW5lJyxcblx0XHRcdFx0XHRcdFx0J3Zpc3VhbCcsXG5cdFx0XHRcdFx0XHRcdCdhdWRpbycsXG5cdFx0XHRcdFx0XHRcdCdtcGVnLTcnLFxuXHRcdFx0XHRcdFx0XHQnaXBtcCcsXG5cdFx0XHRcdFx0XHRcdCdvY2knLFxuXHRcdFx0XHRcdFx0XHQnbXBlZy1qYXZhJ1xuXHRcdFx0XHRcdFx0XV0sXG5cdFx0XHRcdFx0XHR1cHN0cmVhbV9mbGFnOiAxLFxuXHRcdFx0XHRcdFx0X3Jlc2VydmVkOiBbJ2NvbnN0JywgMSwgMV0sXG5cdFx0XHRcdFx0XHRidWZmZXJfc2l6ZTogMjQsXG5cdFx0XHRcdFx0XHRtYXhCaXRyYXRlOiAndWludDMyJyxcblx0XHRcdFx0XHRcdGF2Z0JpdHJhdGU6ICd1aW50MzInXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNhc2UgNTogcmV0dXJuIHtcblx0XHRcdFx0XHRcdGF1ZGlvX3Byb2ZpbGU6IFsnZW51bScsIDUsIFtcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0J2FhYy1tYWluJyxcblx0XHRcdFx0XHRcdFx0J2FhYy1sYycsXG5cdFx0XHRcdFx0XHRcdCdhYWMtc3NyJyxcblx0XHRcdFx0XHRcdFx0J2FhYy1sdHAnLFxuXHRcdFx0XHRcdFx0XHQnc2JyJyxcblx0XHRcdFx0XHRcdFx0J2FhYy1zY2FsYWJsZScsXG5cdFx0XHRcdFx0XHRcdCd0d2ludnEnLFxuXHRcdFx0XHRcdFx0XHQnY2VscCcsXG5cdFx0XHRcdFx0XHRcdCdoeHZjJyxcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0J3R0c2knLFxuXHRcdFx0XHRcdFx0XHQnbWFpbi1zeW50aGVzaXMnLFxuXHRcdFx0XHRcdFx0XHQnd2F2ZXRhYmxlLXN5bnRoZXNpcycsXG5cdFx0XHRcdFx0XHRcdCdnZW5lcmFsLW1pZGknLFxuXHRcdFx0XHRcdFx0XHQnYWxnb3JpdGhtaWMtc3ludGhlc2lzLWFuZC1hdWRpby1lZmZlY3RzJyxcblx0XHRcdFx0XHRcdFx0J2VyLWFhYy1sYycsXG5cdFx0XHRcdFx0XHRcdCdyZXNlcnZlZCcsXG5cdFx0XHRcdFx0XHRcdCdlci1hYWMtbHRwJyxcblx0XHRcdFx0XHRcdFx0J2VyLWFhYy1zY2FsYWJsZScsXG5cdFx0XHRcdFx0XHRcdCdlci10d2ludnEnLFxuXHRcdFx0XHRcdFx0XHQnZXItYnNhYycsXG5cdFx0XHRcdFx0XHRcdCdlci1hYWMtbGQnLFxuXHRcdFx0XHRcdFx0XHQnZXItY2VscCcsXG5cdFx0XHRcdFx0XHRcdCdlci1odnhjJyxcblx0XHRcdFx0XHRcdFx0J2VyLWhpbG4nLFxuXHRcdFx0XHRcdFx0XHQnZXItcGFyYW1ldHJpYycsXG5cdFx0XHRcdFx0XHRcdCdzc2MnLFxuXHRcdFx0XHRcdFx0XHQncHMnLFxuXHRcdFx0XHRcdFx0XHQnbXBlZy1zdXJyb3VuZCdcblx0XHRcdFx0XHRcdF1dLFxuXHRcdFx0XHRcdFx0c2FtcGxpbmdfZnJlcTogakJpbmFyeS5UeXBlKHtcblx0XHRcdFx0XHRcdFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5mcmVxTGlzdCA9IFs5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLCAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsIDgwMDAsIDczNTBdO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZyZXFJbmRleCA9IHRoaXMuYmluYXJ5LnJlYWQoNCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZyZXFJbmRleCAhPT0gMTUgPyB0aGlzLmZyZXFMaXN0W2ZyZXFJbmRleF0gOiB0aGlzLmJpbmFyeS5yZWFkKDI0KTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBmcmVxSW5kZXggPSB0aGlzLmZyZXFMaXN0LmluZGV4T2YodmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChmcmVxSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmJpbmFyeS53cml0ZSg0LCBmcmVxSW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmJpbmFyeS53cml0ZSg0LCAxNSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmJpbmFyeS53cml0ZSgyNCwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0XHRjaGFubmVsQ29uZmlnOiA0LFxuXHRcdFx0XHRcdFx0ZnJhbWVMZW5ndGg6IFsnZW51bScsIDEsIFsxMDI0LCA5NjBdXSxcblx0XHRcdFx0XHRcdGRlcGVuZHNPbkNvcmVDb2RlcjogMSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbkZsYWc6IDFcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2FzZSA2OiByZXR1cm4ge1xuXHRcdFx0XHRcdFx0c2w6IFsnY29uc3QnLCAndWludDgnLCAyXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KV0sXG5cblx0XHRlc2RzOiBbJ2V4dGVuZCcsICdGdWxsQm94Jywge1xuXHRcdFx0c2VjdGlvbnM6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0XHRiYXNlVHlwZTogJ2VzZHNfc2VjdGlvbicsXG5cdFx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgZW5kID0gdGhpcy5iaW5hcnkuZ2V0Q29udGV4dCgnX2VuZCcpLl9lbmQsIHNlY3Rpb25zID0gW107XG5cdFx0XHRcdFx0d2hpbGUgKHRoaXMuYmluYXJ5LnRlbGwoKSA8IGVuZCkge1xuXHRcdFx0XHRcdFx0c2VjdGlvbnMucHVzaCh0aGlzLmJhc2VSZWFkKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc2VjdGlvbnM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAoc2VjdGlvbnMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VjdGlvbnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHNlY3Rpb25zW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fV0sXG5cblx0XHRGaWxlOiBbJ0F0b21zJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5iaW5hcnkudmlldy5ieXRlTGVuZ3RoIH1dXG5cdH07XG59KSk7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsnamJpbmFyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2piaW5hcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5NUEVHVFMgPSBmYWN0b3J5KHJvb3QuakJpbmFyeSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoakJpbmFyeSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0cmV0dXJuIHtcblx0XHRQQ1I6IHtcblx0XHRcdHB0czogMzMsXG5cdFx0XHRfcmVzZXJ2ZWQ6IDYsXG5cdFx0XHRleHRlbnNpb246IDlcblx0XHR9LFxuXG5cdFx0RHluYW1pY0FycmF5OiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdHNldFBhcmFtczogZnVuY3Rpb24gKGxlbmd0aFR5cGUsIGl0ZW1UeXBlKSB7XG5cdFx0XHRcdHRoaXMuYmFzZVR5cGUgPSB7XG5cdFx0XHRcdFx0bGVuZ3RoOiBsZW5ndGhUeXBlLFxuXHRcdFx0XHRcdGFycmF5OiBbJ2FycmF5JywgaXRlbVR5cGUsICdsZW5ndGgnXVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmFzZVJlYWQoKS5hcnJheTtcblx0XHRcdH0sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKGFycmF5KSB7XG5cdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHtcblx0XHRcdFx0XHRsZW5ndGg6IGFycmF5Lmxlbmd0aCxcblx0XHRcdFx0XHRhcnJheTogYXJyYXlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRGaWVsZDogWydEeW5hbWljQXJyYXknLCAndWludDgnLCAndWludDgnXSxcblxuXHRcdEZsYWc6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0YmFzZVR5cGU6IDEsXG5cdFx0XHRwYXJhbXM6IFsnZGVwZW5kZW50RmllbGQnXSxcblx0XHRcdHdyaXRlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcblx0XHRcdFx0dGhpcy5iYXNlV3JpdGUodGhpcy5kZXBlbmRlbnRGaWVsZCBpbiBjb250ZXh0ID8gMSA6IDApO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0RmxhZ0RlcGVuZGVudDogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRwYXJhbXM6IFsnZmxhZ0ZpZWxkJywgJ2Jhc2VUeXBlJ10sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbmFyeS5yZWFkKFsnaWYnLCB0aGlzLmZsYWdGaWVsZCwgdGhpcy5iYXNlVHlwZV0pO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0QWRhcHRhdGlvbkZpZWxkOiB7XG5cdFx0XHRsZW5ndGg6ICd1aW50OCcsXG5cdFx0XHRfZW5kT2Y6IGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiB0aGlzLmJpbmFyeS50ZWxsKCkgKyBjb250ZXh0Lmxlbmd0aCB9LFxuXHRcdFx0ZGlzY29udGludWl0eTogMSxcblx0XHRcdHJhbmRvbUFjY2VzczogMSxcblx0XHRcdHByaW9yaXR5OiAxLFxuXHRcdFx0X2hhc1BDUjogWydGbGFnJywgJ3BjciddLFxuXHRcdFx0X2hhc09QQ1I6IFsnRmxhZycsICdvcGNyJ10sXG5cdFx0XHRfaGFzU3BsaWNpbmdQb2ludDogWydGbGFnJywgJ3NwbGljZUNvdW50ZG93biddLFxuXHRcdFx0X2hhc1RyYW5zcG9ydFByaXZhdGVEYXRhOiBbJ0ZsYWcnLCAncHJpdmF0ZURhdGEnXSxcblx0XHRcdF9oYXNFeHRlbnNpb246IFsnRmxhZycsICdleHRlbnNpb24nXSxcblx0XHRcdHBjcjogWydGbGFnRGVwZW5kZW50JywgJ19oYXNQQ1InLCAnUENSJ10sXG5cdFx0XHRvcGNyOiBbJ0ZsYWdEZXBlbmRlbnQnLCAnX2hhc09QQ1InLCAnUENSJ10sXG5cdFx0XHRzcGxpY2VDb3VudGRvd246IFsnRmxhZ0RlcGVuZGVudCcsICdfaGFzU3BsaWNpbmdQb2ludCcsICd1aW50OCddLFxuXHRcdFx0cHJpdmF0ZURhdGE6IFsnRmxhZ0RlcGVuZGVudCcsICdfaGFzVHJhbnNwb3J0UHJpdmF0ZURhdGEnLCAnRmllbGQnXSxcblx0XHRcdGV4dGVuc2lvbjogWydGbGFnRGVwZW5kZW50JywgJ19oYXNFeHRlbnNpb24nLCAnRmllbGQnXSxcblx0XHRcdF90b0VuZDogZnVuY3Rpb24gKGNvbnRleHQpIHsgdGhpcy5iaW5hcnkuc2Vlayhjb250ZXh0Ll9lbmRPZikgfVxuXHRcdH0sXG5cblx0XHRFUzoge1xuXHRcdFx0X3Jhd1N0cmVhbTogWydibG9iJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5iaW5hcnkuZ2V0Q29udGV4dCgxKS5fZW5kb2YgLSB0aGlzLmJpbmFyeS50ZWxsKCkgfV1cblx0XHR9LFxuXG5cdFx0UEFUSXRlbTogWydhcnJheScsIHtcblx0XHRcdHByb2dyYW1OdW1iZXI6ICd1aW50MTYnLFxuXHRcdFx0X3Jlc2VydmVkOiAzLFxuXHRcdFx0cGlkOiAxM1xuXHRcdH0sIGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0Ll9kYXRhTGVuZ3RoIC8gNCB9XSxcblxuXHRcdFBNVEhlYWRlcjoge1xuXHRcdFx0X3Jlc2VydmVkOiAzLFxuXHRcdFx0cGNyUElEOiAxMyxcblx0XHRcdF9yZXNlcnZlZDI6IDQsXG5cdFx0XHRwcm9ncmFtRGVzY3JpcHRvcnM6IFsnRHluYW1pY0FycmF5JywgMTIsICd1aW50OCddXG5cdFx0fSxcblxuXHRcdFBNVEl0ZW06IHtcblx0XHRcdHN0cmVhbVR5cGU6ICd1aW50OCcsXG5cdFx0XHRfcmVzZXJ2ZWQ6IDMsXG5cdFx0XHRlbGVtZW50YXJ5UElEOiAxMyxcblx0XHRcdF9yZXNlcnZlZDI6IDQsXG5cdFx0XHRlc0luZm86IFsnRHluYW1pY0FycmF5JywgMTIsICd1aW50OCddXG5cdFx0fSxcblxuXHRcdFByaXZhdGVTZWN0aW9uOiBbJ2V4dGVuZCcsIHtcblx0XHRcdHBvaW50ZXJGaWVsZDogWydpZicsICdwYXlsb2FkU3RhcnQnLCAndWludDgnXSxcblx0XHRcdHRhYmxlSWQ6IFsnZW51bScsICd1aW50OCcsIFsnUEFUJywgJ0NBVCcsICdQTVQnXV0sXG5cdFx0XHRpc0xvbmdTZWN0aW9uOiAxLFxuXHRcdFx0aXNQcml2YXRlOiAxLFxuXHRcdFx0X3Jlc2VydmVkOiAyLFxuXHRcdFx0X3NlY3Rpb25MZW5ndGg6IDEyXG5cdFx0fSwgWydpZicsICdpc0xvbmdTZWN0aW9uJywge1xuXHRcdFx0XHR0YWJsZUlkRXh0OiAndWludDE2Jyxcblx0XHRcdFx0X3Jlc2VydmVkOiAyLFxuXHRcdFx0XHR2ZXJzaW9uTnVtYmVyOiA1LFxuXHRcdFx0XHRjdXJyZW50TmV4dEluZGljYXRvcjogMSxcblx0XHRcdFx0c2VjdGlvbk51bWJlcjogJ3VpbnQ4Jyxcblx0XHRcdFx0bGFzdFNlY3Rpb25OdW1iZXI6ICd1aW50OCcsXG5cblx0XHRcdFx0X2RhdGFMZW5ndGg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuYmluYXJ5LmdldENvbnRleHQoMSkuX3NlY3Rpb25MZW5ndGggLSA5IH0sXG5cblx0XHRcdFx0ZGF0YTogakJpbmFyeS5UeXBlKHtcblx0XHRcdFx0XHRyZWFkOiBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgZGF0YSwgZmlsZSA9IHRoaXMuYmluYXJ5LmdldENvbnRleHQoMyksIGRhdGFMZW5ndGggPSBoZWFkZXIuX2RhdGFMZW5ndGg7XG5cblx0XHRcdFx0XHRcdHN3aXRjaCAodGhpcy5iaW5hcnkuZ2V0Q29udGV4dCgxKS50YWJsZUlkKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ1BBVCc6XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IHRoaXMuYmluYXJ5LnJlYWQoJ1BBVEl0ZW0nKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChoZWFkZXIuc2VjdGlvbk51bWJlciA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWxlLnBhdCA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsZS5wYXRbZGF0YVtpXS5waWRdID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdQTVQnOlxuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSB0aGlzLmJpbmFyeS5yZWFkKCdQTVRIZWFkZXInKTtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGEubWFwcGluZ3MgPSBbXTtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGFMZW5ndGggLT0gNCArIGRhdGEucHJvZ3JhbURlc2NyaXB0b3JzLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChkYXRhTGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1hcHBpbmcgPSB0aGlzLmJpbmFyeS5yZWFkKCdQTVRJdGVtJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhLm1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhTGVuZ3RoIC09IDUgKyBtYXBwaW5nLmVzSW5mby5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGhlYWRlci5zZWN0aW9uTnVtYmVyID09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpbGUucG10ID0ge307XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLm1hcHBpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbWFwcGluZyA9IGRhdGEubWFwcGluZ3NbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWxlLnBtdFttYXBwaW5nLmVsZW1lbnRhcnlQSURdID0gbWFwcGluZztcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSxcblxuXHRcdFx0XHRjcmMzMjogJ3VpbnQzMidcblx0XHRcdH0sXG5cdFx0XHRbJ2Jsb2InLCAnX3NlY3Rpb25MZW5ndGgnXVxuXHRcdF1dLFxuXG5cdFx0UGFja2V0OiB7XG5cdFx0XHRfc3RhcnRvZjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5iaW5hcnkudGVsbCgpIH0sXG5cdFx0XHRfZW5kb2Y6IGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0Ll9zdGFydG9mICsgMTg4IH0sXG5cblx0XHRcdF9zeW5jQnl0ZTogWydjb25zdCcsICd1aW50OCcsIDB4NDcsIHRydWVdLFxuXG5cdFx0XHR0cmFuc3BvcnRFcnJvcjogMSxcblx0XHRcdHBheWxvYWRTdGFydDogMSxcblx0XHRcdHRyYW5zcG9ydFByaW9yaXR5OiAxLFxuXHRcdFx0cGlkOiAxMyxcblxuXHRcdFx0c2NyYW1ibGluZ0NvbnRyb2w6IDIsXG5cdFx0XHRfaGFzQWRhcHRhdGlvbkZpZWxkOiBbJ0ZsYWcnLCAnYWRhcHRhdGlvbkZpZWxkJ10sXG5cdFx0XHRfaGFzUGF5bG9hZDogWydGbGFnJywgJ3BheWxvYWQnXSxcblx0XHRcdGNvbnRDb3VudGVyOiA0LFxuXG5cdFx0XHRhZGFwdGF0aW9uRmllbGQ6IFsnRmxhZ0RlcGVuZGVudCcsICdfaGFzQWRhcHRhdGlvbkZpZWxkJywgJ0FkYXB0YXRpb25GaWVsZCddLFxuXG5cdFx0XHRwYXlsb2FkOiBbJ0ZsYWdEZXBlbmRlbnQnLCAnX2hhc1BheWxvYWQnLCBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdFx0Z2V0QmFzZVR5cGU6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0XHRcdFx0dmFyIHBpZCA9IGNvbnRleHQucGlkLCBmaWxlID0gdGhpcy5iaW5hcnkuZ2V0Q29udGV4dCgxKTtcblx0XHRcdFx0XHRpZiAocGlkIDwgMiB8fCBwaWQgaW4gZmlsZS5wYXQpIHtcblx0XHRcdFx0XHRcdHJldHVybiAnUHJpdmF0ZVNlY3Rpb24nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGlkIGluIGZpbGUucG10KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ0VTJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pXSxcblxuXHRcdFx0X3RvRW5kOiBmdW5jdGlvbiAoY29udGV4dCkgeyB0aGlzLmJpbmFyeS5zZWVrKGNvbnRleHQuX2VuZG9mKSB9XG5cdFx0fSxcblxuXHRcdEZpbGU6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0YmFzZVR5cGU6IFsnYXJyYXknLCAnUGFja2V0J10sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMucGF0ID0ge307XG5cdFx0XHRcdHRoaXMucG10ID0ge307XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmluYXJ5LmluQ29udGV4dCh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYuYmFzZVJlYWQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0dGhpcy5iaW5hcnkuaW5Db250ZXh0KHRoaXMsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRzZWxmLmJhc2VXcml0ZShwYWNrZXRzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSlcblx0fTtcbn0pKTsiLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsnamJpbmFyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2piaW5hcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5QRVMgPSBmYWN0b3J5KHJvb3QuakJpbmFyeSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoakJpbmFyeSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0cmV0dXJuIHtcblx0XHRGbGFnOiBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdGJhc2VUeXBlOiAxLFxuXHRcdFx0cGFyYW1zOiBbJ2RlcGVuZGVudEZpZWxkJ10sXG5cdFx0XHR3cml0ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG5cdFx0XHRcdHRoaXMuYmFzZVdyaXRlKHRoaXMuZGVwZW5kZW50RmllbGQgaW4gY29udGV4dCA/IDEgOiAwKTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdEZsYWdEZXBlbmRlbnQ6IGpCaW5hcnkuVGVtcGxhdGUoe1xuXHRcdFx0cGFyYW1zOiBbJ2ZsYWdGaWVsZCcsICdiYXNlVHlwZSddLFxuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW5hcnkucmVhZChbJ2lmJywgdGhpcy5mbGFnRmllbGQsIHRoaXMuYmFzZVR5cGVdKTtcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdFBFU1RpbWVTdGFtcDogakJpbmFyeS5UZW1wbGF0ZSh7XG5cdFx0XHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwcmVmaXgpIHtcblx0XHRcdFx0dmFyIHNraXBCaXQgPSBbJ2NvbnN0JywgMSwgMSwgdHJ1ZV07XG5cdFx0XHRcdHRoaXMuYmFzZVR5cGUgPSB7XG5cdFx0XHRcdFx0X3ByZWZpeDogWydjb25zdCcsIDQsIHByZWZpeCwgdHJ1ZV0sXG5cdFx0XHRcdFx0aGlQYXJ0OiAzLFxuXHRcdFx0XHRcdF9za2lwMTogc2tpcEJpdCxcblx0XHRcdFx0XHRtaWRQYXJ0OiAxNSxcblx0XHRcdFx0XHRfc2tpcDI6IHNraXBCaXQsXG5cdFx0XHRcdFx0bG9QYXJ0OiAxNSxcblx0XHRcdFx0XHRfc2tpcDM6IHNraXBCaXRcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IHRoaXMuYmFzZVJlYWQoKTtcblx0XHRcdFx0cmV0dXJuIHBhcnRzLmxvUGFydCB8IChwYXJ0cy5taWRQYXJ0IDw8IDE1KSB8IChwYXJ0cy5oaVBhcnQgPDwgMzApO1xuXHRcdFx0fSxcblx0XHRcdHdyaXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0dGhpcy5iYXNlV3JpdGUoe1xuXHRcdFx0XHRcdGhpUGFydDogdmFsdWUgPj4+IDMwLFxuXHRcdFx0XHRcdG1pZFBhcnQ6ICh2YWx1ZSA+Pj4gMTUpICYgfigtMSA8PCAxNSksXG5cdFx0XHRcdFx0bG9QYXJ0OiB2YWx1ZSAmIH4oLTEgPDwgMTUpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pLFxuXG5cdFx0UEVTUGFja2V0OiBbJ2V4dGVuZCcsIHtcblx0XHRcdF9zdGFydENvZGUwOiBbJ2NvbnN0JywgJ3VpbnQ4JywgMCwgdHJ1ZV0sXG5cdFx0XHRfc3RhcnRDb2RlMTogWydjb25zdCcsICd1aW50OCcsIDAsIHRydWVdLFxuXHRcdFx0X3N0YXJ0Q29kZTI6IFsnY29uc3QnLCAndWludDgnLCAxLCB0cnVlXSxcblx0XHRcdHN0cmVhbUlkOiAndWludDgnLFxuXHRcdFx0bGVuZ3RoOiAndWludDE2Jyxcblx0XHRcdF9lbmQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0XHRcdHZhciBwb3MgPSB0aGlzLmJpbmFyeS50ZWxsKCksIGxlbmd0aCA9IGNvbnRleHQubGVuZ3RoO1xuXG5cdFx0XHRcdGlmIChsZW5ndGgpIHtcblx0XHRcdFx0XHRwb3MgKz0gbGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChwb3MgPiB0aGlzLnZpZXcuYnl0ZUxlbmd0aCAtIDQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwb3M7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBieXRlcyA9IHRoaXMuYmluYXJ5LnJlYWQoWydibG9iJywgNF0sIHBvcyk7XG5cdFx0XHRcdFx0aWYgKGJ5dGVzWzBdID09PSAwICYmIGJ5dGVzWzFdID09PSAwICYmIGJ5dGVzWzJdID09PSAxICYmIChieXRlc1szXSAmIDB4ODApKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcG9zO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3MgLT0gbGVuZ3RoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Lypcblx0XHRcdFx0bm90IHN1cmUgaWYgaXQgY29ycmVjdGx5IGNvdmVycyBjYXNlcyB3aGVyZSBgbGVuZ3RoYD09MFxuXHRcdFx0XHQoYWNjb3JkaW5nIHRvIHNwZWNpZmljYXRpb24sIGl0IG1heSBiZSB3cml0dGVuIGFzIHplcm8gZm9yIHZpZGVvIHN0cmVhbXMgb2YgdW5kZWZpbmVkIGxlbmd0aClcblx0XHRcdFx0YnV0IHNob3VsZCB3b3JrIGZvciBILjI2NCBzdHJlYW1zIHNpbmNlIE5BTCB1bml0IHR5cGVzIGFsd2F5cyBoYXZlIGNsZWFyIGhpZ2hlc3QgYml0IChgZm9yYmlkZGVuX3plcm9fYml0YClcblx0XHRcdFx0Ki9cblx0XHRcdFx0dmFyIGZpbGVFbmQgPSB0aGlzLnZpZXcuYnl0ZUxlbmd0aCwgYnl0ZXMgPSB0aGlzLmJpbmFyeS5yZWFkKCdibG9iJywgcG9zKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSA0OyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYnl0ZXNbaV0gPT09IDAgJiYgYnl0ZXNbaSArIDFdID09PSAwICYmIGJ5dGVzW2kgKyAyXSA9PT0gMSAmJiAoYnl0ZXNbaSArIDNdICYgMHg4MCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwb3MgKyBpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmlsZUVuZDtcblx0XHRcdH1cblx0XHR9LCBqQmluYXJ5LlRlbXBsYXRlKHtcblx0XHRcdGJhc2VUeXBlOiB7XG5cdFx0XHRcdF9tYXJrZXI6IFsnY29uc3QnLCAyLCAyLCB0cnVlXSxcblx0XHRcdFx0c2NyYW1ibGluZ0NvbnRyb2w6IFsnZW51bScsIDIsIFsnbm90X3NjcmFtYmxlZCddXSxcblx0XHRcdFx0cHJpb3JpdHk6IDEsXG5cdFx0XHRcdGRhdGFBbGlnbm1lbnRJbmRpY2F0b3I6IDEsXG5cdFx0XHRcdGhhc0NvcHlyaWdodDogMSxcblx0XHRcdFx0aXNPcmlnaW5hbDogMSxcblx0XHRcdFx0X2hhc1BUUzogWydGbGFnJywgJ3B0cyddLFxuXHRcdFx0XHRfaGFzRFRTOiBbJ0ZsYWcnLCAnZHRzJ10sXG5cdFx0XHRcdF9oYXNFU0NSOiBbJ0ZsYWcnLCAnZXNjciddLFxuXHRcdFx0XHRfaGFzRVNSYXRlOiBbJ0ZsYWcnLCAnZXNSYXRlJ10sXG5cdFx0XHRcdGRzbVRyaWNrTW9kZTogMSxcblx0XHRcdFx0X2hhc0FkZGl0aW9uYWxDb3B5SW5mbzogWydGbGFnJywgJ2FkZGl0aW9uYWxDb3B5SW5mbyddLFxuXHRcdFx0XHRfaGFzUEVTQ1JDOiBbJ0ZsYWcnLCAncGVzQ1JDJ10sXG5cdFx0XHRcdF9oYXNFeHRlbnNpb246IFsnRmxhZycsICdleHRlbnNpb24nXSxcblx0XHRcdFx0ZGF0YUxlbmd0aDogJ3VpbnQ4Jyxcblx0XHRcdFx0X2hlYWRlckVuZDogZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIHRoaXMuYmluYXJ5LnRlbGwoKSArIGNvbnRleHQuZGF0YUxlbmd0aCB9LFxuXHRcdFx0XHRwdHM6IFsnRmxhZ0RlcGVuZGVudCcsICdfaGFzUFRTJywgWydpZicsICdfaGFzRFRTJywgWydQRVNUaW1lU3RhbXAnLCAzXSwgWydQRVNUaW1lU3RhbXAnLCAyXV1dLFxuXHRcdFx0XHRkdHM6IFsnRmxhZ0RlcGVuZGVudCcsICdfaGFzRFRTJywgWydQRVNUaW1lU3RhbXAnLCAxXV0sXG5cdFx0XHRcdF90b0hlYWRlckVuZDogZnVuY3Rpb24gKGNvbnRleHQpIHsgdGhpcy5iaW5hcnkuc2Vlayhjb250ZXh0Ll9oZWFkZXJFbmQpIH1cblx0XHRcdH0sXG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBwb3MgPSB0aGlzLmJpbmFyeS50ZWxsKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmFzZVJlYWQoKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHRoaXMuYmluYXJ5LnNlZWsocG9zKTtcblx0XHRcdFx0XHR0aGlzLmJpbmFyeS52aWV3LmFsaWduQnkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pLCB7XG5cdFx0XHRkYXRhOiBbJ2Jsb2InLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJpbmFyeS5nZXRDb250ZXh0KCdfZW5kJykuX2VuZCAtIHRoaXMuYmluYXJ5LnRlbGwoKSB9XVxuXHRcdH1dXG5cdH07XG59KSk7IiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCBpbiBtb2Rlcm4gZW5naW5lc1xuICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTQgU2ltb24gTHlkZWxsXHJcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcclxuXHJcbnZvaWQgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmYWN0b3J5KVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3QucmVzb2x2ZVVybCA9IGZhY3RvcnkoKVxyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgZnVuY3Rpb24gcmVzb2x2ZVVybCgvKiAuLi51cmxzICovKSB7XHJcbiAgICB2YXIgbnVtVXJscyA9IGFyZ3VtZW50cy5sZW5ndGhcclxuXHJcbiAgICBpZiAobnVtVXJscyA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlVXJsIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudDsgZ290IG5vbmUuXCIpXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKVxyXG4gICAgYmFzZS5ocmVmID0gYXJndW1lbnRzWzBdXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGJhc2UuaHJlZlxyXG4gICAgfVxyXG5cclxuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdXHJcbiAgICBoZWFkLmluc2VydEJlZm9yZShiYXNlLCBoZWFkLmZpcnN0Q2hpbGQpXHJcblxyXG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKVxyXG4gICAgdmFyIHJlc29sdmVkXHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IG51bVVybHM7IGluZGV4KyspIHtcclxuICAgICAgYS5ocmVmID0gYXJndW1lbnRzW2luZGV4XVxyXG4gICAgICByZXNvbHZlZCA9IGEuaHJlZlxyXG4gICAgICBiYXNlLmhyZWYgPSByZXNvbHZlZFxyXG4gICAgfVxyXG5cclxuICAgIGhlYWQucmVtb3ZlQ2hpbGQoYmFzZSlcclxuXHJcbiAgICByZXR1cm4gcmVzb2x2ZWRcclxuICB9XHJcblxyXG4gIHJldHVybiByZXNvbHZlVXJsXHJcblxyXG59KSk7XHJcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0ICcjL2NvbW1vbi9icm93c2VyJztcbmltcG9ydCB7IGdldEFjdGl2ZVRhYiwgbWFrZVBhdXNlLCBzZW5kQ21kLCByZXF1ZXN0IH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgQlVJTERfSU5fU0NSSVBUX1NSQywgVElNRU9VVF8yNEhPVVJTLCBUSU1FT1VUX01BWCwgSVNfREVWIH0gZnJvbSAnIy9jb21tb24vY29uc3RzJztcbmltcG9ydCB7IGRlZXBDb3B5IH0gZnJvbSAnIy9jb21tb24vb2JqZWN0JztcbmltcG9ydCAqIGFzIHRsZCBmcm9tICcjL2NvbW1vbi90bGQnO1xuaW1wb3J0ICogYXMgc3luYyBmcm9tICcuL3N5bmMnO1xuaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGdldERhdGEsIGNoZWNrUmVtb3ZlIH0gZnJvbSAnLi91dGlscy9kYic7XG5pbXBvcnQgeyBpbml0aWFsaXplIH0gZnJvbSAnLi91dGlscy9pbml0JztcbmltcG9ydCB7IGdldE9wdGlvbiwgaG9va09wdGlvbnMgfSBmcm9tICcuL3V0aWxzL29wdGlvbnMnO1xuaW1wb3J0IHsgcG9wdXBUYWJzIH0gZnJvbSAnLi91dGlscy9wb3B1cC10cmFja2VyJztcbmltcG9ydCB7IGdldEluamVjdGVkU2NyaXB0cyB9IGZyb20gJy4vdXRpbHMvcHJlaW5qZWN0JztcbmltcG9ydCB7IFNDUklQVF9URU1QTEFURSwgcmVzZXRTY3JpcHRUZW1wbGF0ZSB9IGZyb20gJy4vdXRpbHMvdGVtcGxhdGUtaG9vayc7XG5pbXBvcnQgeyByZXNldFZhbHVlT3BlbmVyLCBhZGRWYWx1ZU9wZW5lciB9IGZyb20gJy4vdXRpbHMvdmFsdWVzJztcbmltcG9ydCB7IGNsZWFyUmVxdWVzdHNCeVRhYklkIH0gZnJvbSAnLi91dGlscy9yZXF1ZXN0cyc7XG5pbXBvcnQgJy4vdXRpbHMvY2xpcGJvYXJkJztcbmltcG9ydCAnLi91dGlscy9ob3RrZXlzJztcbmltcG9ydCAnLi91dGlscy9pY29uJztcbmltcG9ydCAnLi91dGlscy9ub3RpZmljYXRpb25zJztcbmltcG9ydCAnLi91dGlscy9zY3JpcHQnO1xuaW1wb3J0ICcuL3V0aWxzL3RhYnMnO1xuaW1wb3J0ICcuL3V0aWxzL3Rlc3Rlcic7XG5pbXBvcnQgJy4vdXRpbHMvdXBkYXRlJztcblxuaG9va09wdGlvbnMoKGNoYW5nZXMpID0+IHtcbiAgaWYgKCdhdXRvVXBkYXRlJyBpbiBjaGFuZ2VzKSB7XG4gICAgYXV0b1VwZGF0ZSgpO1xuICB9XG4gIGlmIChTQ1JJUFRfVEVNUExBVEUgaW4gY2hhbmdlcykge1xuICAgIHJlc2V0U2NyaXB0VGVtcGxhdGUoY2hhbmdlcyk7XG4gIH1cbiAgc2VuZENtZCgnVXBkYXRlT3B0aW9ucycsIGNoYW5nZXMpO1xufSk7XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8eyBzY3JpcHRzOiBWTVNjcmlwdFtdLCBjYWNoZTogT2JqZWN0LCBzeW5jOiBPYmplY3QgfT59ICovXG4gIGFzeW5jIEdldERhdGEoaWRzKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldERhdGEoaWRzKTtcbiAgICBkYXRhLnN5bmMgPSBzeW5jLmdldFN0YXRlcygpO1xuICAgIHJldHVybiBkYXRhO1xuICB9LFxuICAvKiogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSAqL1xuICBhc3luYyBHZXRJbmplY3RlZCh7IHVybCwgZm9yY2VDb250ZW50IH0sIHNyYykge1xuICAgIGNvbnN0IHsgZnJhbWVJZCwgdGFiIH0gPSBzcmM7XG4gICAgY29uc3QgdGFiSWQgPSB0YWIuaWQ7XG4gICAgaWYgKCF1cmwpIHVybCA9IHNyYy51cmwgfHwgdGFiLnVybDtcbiAgICBpZiAoIWZyYW1lSWQpIHtcbiAgICAgIHJlc2V0VmFsdWVPcGVuZXIodGFiSWQpO1xuICAgICAgY2xlYXJSZXF1ZXN0c0J5VGFiSWQodGFiSWQpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBnZXRJbmplY3RlZFNjcmlwdHModXJsLCB0YWJJZCwgZnJhbWVJZCwgZm9yY2VDb250ZW50KTtcbiAgICBjb25zdCB7IGZlZWRiYWNrLCBpbmplY3QsIHZhbE9wSWRzIH0gPSByZXM7XG4gICAgaW5qZWN0LmlzUG9wdXBTaG93biA9IHBvcHVwVGFic1t0YWJJZF07XG4gICAgLy8gSW5qZWN0aW5nIGtub3duIGNvbnRlbnQgc2NyaXB0cyB3aXRob3V0IHdhaXRpbmcgZm9yIEluamVjdGlvbkZlZWRiYWNrIG1lc3NhZ2UuXG4gICAgLy8gUnVubmluZyBpbiBhIHNlcGFyYXRlIHRhc2sgYmVjYXVzZSBpdCBtYXkgdGFrZSBhIGxvbmcgdGltZSB0byBzZXJpYWxpemUgZGF0YS5cbiAgICBpZiAoZmVlZGJhY2subGVuZ3RoKSB7XG4gICAgICBzZXRUaW1lb3V0KGNvbW1hbmRzLkluamVjdGlvbkZlZWRiYWNrLCAwLCB7IGZlZWRiYWNrIH0sIHNyYyk7XG4gICAgfVxuICAgIGFkZFZhbHVlT3BlbmVyKHRhYklkLCBmcmFtZUlkLCB2YWxPcElkcyk7XG4gICAgcmV0dXJuIGluamVjdDtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gKi9cbiAgYXN5bmMgR2V0VGFiRG9tYWluKCkge1xuICAgIGNvbnN0IHRhYiA9IGF3YWl0IGdldEFjdGl2ZVRhYigpIHx8IHt9O1xuICAgIGNvbnN0IHVybCA9IHRhYi5wZW5kaW5nVXJsIHx8IHRhYi51cmwgfHwgJyc7XG4gICAgY29uc3QgaG9zdCA9IHVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW14vXSspfCQvKVsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFiLFxuICAgICAgZG9tYWluOiBob3N0ICYmIHRsZC5nZXREb21haW4oaG9zdCkgfHwgaG9zdCxcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogVGltZXJzIGluIGNvbnRlbnQgc2NyaXB0cyBhcmUgc2hhcmVkIHdpdGggdGhlIHdlYiBwYWdlIHNvIGl0IGNhbiBjbGVhciB0aGVtLlxuICAgKiBhd2FpdCBzZW5kQ21kKCdTZXRUaW1lb3V0JywgMTAwKSBpbiBpbmplY3RlZC9jb250ZW50XG4gICAqIGF3YWl0IGJyaWRnZS5zZW5kKCdTZXRUaW1lb3V0JywgMTAwKSBpbiBpbmplY3RlZC93ZWJcbiAgICovXG4gIFNldFRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbXMgPiAwICYmIG1ha2VQYXVzZShtcyk7XG4gIH0sXG59KTtcblxuLy8gY29tbWFuZHMgdG8gc3luYyB1bmNvbmRpdGlvbmFsbHkgcmVnYXJkbGVzcyBvZiB0aGUgcmV0dXJuZWQgdmFsdWUgZnJvbSB0aGUgaGFuZGxlclxuY29uc3QgY29tbWFuZHNUb1N5bmMgPSBbXG4gICdNYXJrUmVtb3ZlZCcsXG4gICdNb3ZlJyxcbiAgJ1BhcnNlU2NyaXB0JyxcbiAgJ1JlbW92ZVNjcmlwdCcsXG4gICdVcGRhdGVTY3JpcHRJbmZvJyxcbl07XG4vLyBjb21tYW5kcyB0byBzeW5jIG9ubHkgaWYgdGhlIGhhbmRsZXIgcmV0dXJucyBhIHRydXRoeSB2YWx1ZVxuY29uc3QgY29tbWFuZHNUb1N5bmNJZlRydXRoeSA9IFtcbiAgJ0NoZWNrUmVtb3ZlJyxcbiAgJ0NoZWNrVXBkYXRlJyxcbiAgJ0NoZWNrVXBkYXRlQWxsJyxcbl07XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNvbW1hbmRNZXNzYWdlKHJlcSwgc3JjKSB7XG4gIGNvbnN0IHsgY21kIH0gPSByZXE7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGNvbW1hbmRzW2NtZF0/LihyZXEuZGF0YSwgc3JjKTtcbiAgaWYgKGNvbW1hbmRzVG9TeW5jLmluY2x1ZGVzKGNtZClcbiAgfHwgcmVzICYmIGNvbW1hbmRzVG9TeW5jSWZUcnV0aHkuaW5jbHVkZXMoY21kKSkge1xuICAgIHN5bmMuc3luYygpO1xuICB9XG4gIC8vIGB1bmRlZmluZWRgIGlzIG5vdCB0cmFuc2ZlcmFibGUsIGJ1dCBgbnVsbGAgaXNcbiAgcmV0dXJuIHJlcyA/PyBudWxsO1xufVxuXG5mdW5jdGlvbiBhdXRvVXBkYXRlKCkge1xuICBjb25zdCBpbnRlcnZhbCA9IElTX0RFViA/IDEwMDAgOiAoK2dldE9wdGlvbignYXV0b1VwZGF0ZScpIHx8IDApICogVElNRU9VVF8yNEhPVVJTO1xuICBpZiAoIWludGVydmFsKSByZXR1cm47XG4gIGxldCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGdldE9wdGlvbignbGFzdFVwZGF0ZScpO1xuICBpZiAoZWxhcHNlZCA+PSBpbnRlcnZhbCkge1xuICAgIGhhbmRsZUNvbW1hbmRNZXNzYWdlKHsgY21kOiAnQ2hlY2tVcGRhdGVBbGwnIH0pO1xuICAgIGVsYXBzZWQgPSAwO1xuICB9XG4gIGNsZWFyVGltZW91dChhdXRvVXBkYXRlLnRpbWVyKTtcbiAgYXV0b1VwZGF0ZS50aW1lciA9IHNldFRpbWVvdXQoYXV0b1VwZGF0ZSwgTWF0aC5taW4oVElNRU9VVF9NQVgsIGludGVydmFsIC0gZWxhcHNlZCkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0QnVpbGRpbigpIHtcbiAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCByZXF1ZXN0KEJVSUxEX0lOX1NDUklQVF9TUkMsIHtcbiAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ3RleHQveC11c2Vyc2NyaXB0LW1ldGEsKi8qJyB9LFxuICB9KTtcblxuICBjb25zdCByZXMgPSBhd2FpdCBjb21tYW5kcy5QYXJzZVNjcmlwdCh7XG4gICAgdXJsOiBCVUlMRF9JTl9TQ1JJUFRfU1JDLFxuICAgIGNvZGU6IGRhdGEsXG4gICAgY3VzdG9tOiB7IGJ1aWxkSW46IHRydWUgfSxcbiAgfSk7XG4gIHN5bmMuc3luYygpO1xuXG4gIGlmIChyZXMud2hlcmUuaWQgIT09IDEpIHtcbiAgICB0aHJvdyBgd3JvbmcgaWQ6ICR7cmVzLndoZXJlLmlkfWA7XG4gIH1cbn1cblxuaW5pdGlhbGl6ZSgoKSA9PiB7XG4gIGdsb2JhbC5oYW5kbGVDb21tYW5kTWVzc2FnZSA9IGhhbmRsZUNvbW1hbmRNZXNzYWdlO1xuICBnbG9iYWwuZGVlcENvcHkgPSBkZWVwQ29weTtcbiAgYnJvd3Nlci5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihcbiAgICBJU19GSVJFRk9YIC8vIGluIEZGIGEgcmVqZWN0ZWQgUHJvbWlzZSB2YWx1ZSBpcyB0cmFuc2ZlcnJlZCBvbmx5IGlmIGl0J3MgYW4gRXJyb3Igb2JqZWN0XG4gICAgICA/ICguLi5hcmdzKSA9PiBoYW5kbGVDb21tYW5kTWVzc2FnZSguLi5hcmdzKS5jYXRjaChlID0+IChcbiAgICAgICAgUHJvbWlzZS5yZWplY3QoZSBpbnN0YW5jZW9mIEVycm9yID8gZSA6IG5ldyBFcnJvcihlKSlcbiAgICAgICkpIC8vIERpZG4ndCB1c2UgYHRocm93YCB0byBhdm9pZCBpbnRlcnJ1cHRpb24gaW4gZGV2dG9vbHMgd2l0aCBwYXVzZS1vbi1leGNlcHRpb24gZW5hYmxlZC5cbiAgICAgIDogaGFuZGxlQ29tbWFuZE1lc3NhZ2UsXG4gICk7XG5cbiAgLy8gY2hlY2sgYW5kIGluc3RhbGwgdGhlIGJ1aWxkLWluIHNjcmlwdFxuICBpbml0QnVpbGRpbigpO1xuICBjb25zb2xlLmluZm8oJ2luaXRCdWlsZGluLi4uJyk7XG4gIHNldFRpbWVvdXQoYXV0b1VwZGF0ZSwgSVNfREVWID8gMSA6IDJlNCk7XG4gIHN5bmMuaW5pdGlhbGl6ZSgpO1xuICBjaGVja1JlbW92ZSgpO1xuICBzZXRJbnRlcnZhbChjaGVja1JlbW92ZSwgVElNRU9VVF8yNEhPVVJTKTtcbiAgY29uc3QgYXBpID0gZ2xvYmFsLmNocm9tZS5kZWNsYXJhdGl2ZUNvbnRlbnQ7XG4gIGlmIChhcGkpIHtcbiAgICAvLyBVc2luZyBkZWNsYXJhdGl2ZUNvbnRlbnQgdG8gcnVuIGNvbnRlbnQgc2NyaXB0cyBlYXJsaWVyIHRoYW4gZG9jdW1lbnRfc3RhcnRcbiAgICBhcGkub25QYWdlQ2hhbmdlZC5nZXRSdWxlcyhhc3luYyAoW3J1bGVdKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IHJ1bGU/LmlkO1xuICAgICAgY29uc3QgbmV3SWQgPSBwcm9jZXNzLmVudi5JTklUX0ZVTkNfTkFNRTtcbiAgICAgIGlmIChpZCA9PT0gbmV3SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGF3YWl0IGJyb3dzZXIuZGVjbGFyYXRpdmVDb250ZW50Lm9uUGFnZUNoYW5nZWQucmVtb3ZlUnVsZXMoW2lkXSk7XG4gICAgICB9XG4gICAgICBhcGkub25QYWdlQ2hhbmdlZC5hZGRSdWxlcyhbe1xuICAgICAgICBpZDogbmV3SWQsXG4gICAgICAgIGNvbmRpdGlvbnM6IFtcbiAgICAgICAgICBuZXcgYXBpLlBhZ2VTdGF0ZU1hdGNoZXIoe1xuICAgICAgICAgICAgcGFnZVVybDogeyB1cmxDb250YWluczogJzovLycgfSwgLy8gZXNzZW50aWFsbHkgbGlrZSA8YWxsX3VybHM+XG4gICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICBuZXcgYXBpLlJlcXVlc3RDb250ZW50U2NyaXB0KHtcbiAgICAgICAgICAgIGpzOiBicm93c2VyLnJ1bnRpbWUuZ2V0TWFuaWZlc3QoKS5jb250ZW50X3NjcmlwdHNbMF0uanMsXG4gICAgICAgICAgICAvLyBOb3QgdXNpbmcgYGFsbEZyYW1lczp0cnVlYCBhcyB0aGVyZSdzIG5vIGltcHJvdmVtZW50IGluIGZyYW1lc1xuICAgICAgICAgIH0pLFxuICAgICAgICBdLFxuICAgICAgfV0pO1xuICAgIH0pO1xuICB9XG59KTtcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnIy9jb21tb24vZXZlbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEV2ZW50RW1pdHRlcihbXG4gICdzY3JpcHRFZGl0JyxcbiAgJ3NjcmlwdENoYW5nZWQnLFxuXSk7XG4iLCJpbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4uL3V0aWxzL21lc3NhZ2UnO1xuaW1wb3J0IHsgZ2V0U2NyaXB0cyB9IGZyb20gJy4uL3V0aWxzL2RiJztcblxuZXhwb3J0IGNvbnN0IHNjcmlwdCA9IHtcbiAgLyoqXG4gICAqIFVwZGF0ZSBhbiBleGlzdGluZyBzY3JpcHQgaWRlbnRpZmllZCBieSB0aGUgcHJvdmlkZWQgaWRcbiAgICogQHBhcmFtIHt7IGlkLCBjb2RlLCBtZXNzYWdlLCBpc05ldywgY29uZmlnLCBjdXN0b20sIHByb3BzLCB1cGRhdGUgfX0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHsgaXNOZXc/LCB1cGRhdGUsIHdoZXJlIH0+fVxuICAgKi9cbiAgdXBkYXRlOiBjb21tYW5kcy5QYXJzZVNjcmlwdCxcbiAgLyoqXG4gICAqIExpc3QgYWxsIGF2YWlsYWJsZSBzY3JpcHRzLCB3aXRob3V0IHNjcmlwdCBjb2RlXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Vk1TY3JpcHRbXT59XG4gICAqL1xuICBsaXN0OiBhc3luYyAoKSA9PiBnZXRTY3JpcHRzKCksXG4gIC8qKlxuICAgKiBHZXQgc2NyaXB0IGNvZGUgb2YgYW4gZXhpc3Rpbmcgc2NyaXB0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAqL1xuICBnZXQ6IGNvbW1hbmRzLkdldFNjcmlwdENvZGUsXG4gIC8qKlxuICAgKiBSZW1vdmUgc2NyaXB0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgcmVtb3ZlOiBpZCA9PiBjb21tYW5kcy5NYXJrUmVtb3ZlZCh7IGlkLCByZW1vdmVkOiB0cnVlIH0pLFxufTtcbiIsImltcG9ydCB7XG4gIGRlYm91bmNlLCBub3JtYWxpemVLZXlzLCByZXF1ZXN0LCBub29wLCBtYWtlUGF1c2UsIGVuc3VyZUFycmF5LCBzZW5kQ21kLFxufSBmcm9tICcjL2NvbW1vbic7XG5pbXBvcnQgeyBUSU1FT1VUX0hPVVIgfSBmcm9tICcjL2NvbW1vbi9jb25zdHMnO1xuaW1wb3J0IHtcbiAgZm9yRWFjaEVudHJ5LCBvYmplY3RTZXQsIG9iamVjdFBpY2ssXG59IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQge1xuICBnZXRFdmVudEVtaXR0ZXIsIGdldE9wdGlvbiwgc2V0T3B0aW9uLCBob29rT3B0aW9ucyxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgc29ydFNjcmlwdHMsXG4gIHVwZGF0ZVNjcmlwdEluZm8sXG59IGZyb20gJy4uL3V0aWxzL2RiJztcbmltcG9ydCB7IHNjcmlwdCBhcyBwbHVnaW5TY3JpcHQgfSBmcm9tICcuLi9wbHVnaW4nO1xuXG5jb25zdCBzZXJ2aWNlTmFtZXMgPSBbXTtcbmNvbnN0IHNlcnZpY2VDbGFzc2VzID0gW107XG5jb25zdCBzZXJ2aWNlcyA9IHt9O1xuY29uc3QgYXV0b1N5bmMgPSBkZWJvdW5jZShzeW5jLCBUSU1FT1VUX0hPVVIpO1xubGV0IHdvcmtpbmcgPSBQcm9taXNlLnJlc29sdmUoKTtcbmxldCBzeW5jQ29uZmlnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXRlbUZpbGVuYW1lKHsgbmFtZSwgdXJpIH0pIHtcbiAgLy8gV2hlbiBnZXQgb3IgcmVtb3ZlLCBjdXJyZW50IG5hbWUgc2hvdWxkIGJlIHByZWZlcmVkXG4gIGlmIChuYW1lKSByZXR1cm4gbmFtZTtcbiAgLy8gb3RoZXJ3aXNlIHVyaSBkZXJpdmVkIG5hbWUgc2hvdWxkIGJlIHByZWZlcmVkXG4gIC8vIHVyaSBpcyBhbHJlYWR5IGVuY29kZWQgYnkgYGVuY29kZUZpbGVuYW1lYFxuICByZXR1cm4gYHZtQDItJHt1cml9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NjcmlwdEZpbGUobmFtZSkge1xuICByZXR1cm4gL152bSg/OkBcXGQrKT8tLy50ZXN0KG5hbWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSSShuYW1lKSB7XG4gIGNvbnN0IGkgPSBuYW1lLmluZGV4T2YoJy0nKTtcbiAgY29uc3QgWywgdmVyc2lvbl0gPSBuYW1lLnNsaWNlKDAsIGkpLnNwbGl0KCdAJyk7XG4gIGlmICh2ZXJzaW9uID09PSAnMicpIHtcbiAgICAvLyB1cmkgaXMgZW5jb2RlZCBieSBgZW5jb2RlZEZpbGVuYW1lYCwgc28gd2Ugc2hvdWxkIG5vdCBkZWNvZGUgaXQgaGVyZVxuICAgIHJldHVybiBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobmFtZS5zbGljZSgzKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBuYW1lLnNsaWNlKDMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb25maWcoKSB7XG4gIGZ1bmN0aW9uIGdldChrZXksIGRlZikge1xuICAgIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlzKGtleSk7XG4gICAga2V5cy51bnNoaWZ0KCdzeW5jJyk7XG4gICAgcmV0dXJuIGdldE9wdGlvbihrZXlzLCBkZWYpO1xuICB9XG4gIGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IG5vcm1hbGl6ZUtleXMoa2V5KTtcbiAgICBrZXlzLnVuc2hpZnQoJ3N5bmMnKTtcbiAgICBzZXRPcHRpb24oa2V5cywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgbGV0IGNvbmZpZyA9IGdldE9wdGlvbignc3luYycpO1xuICAgIGlmICghY29uZmlnIHx8ICFjb25maWcuc2VydmljZXMpIHtcbiAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgc2VydmljZXM6IHt9LFxuICAgICAgfTtcbiAgICAgIHNldChbXSwgY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgaW5pdCgpO1xuICByZXR1cm4geyBnZXQsIHNldCB9O1xufVxuZnVuY3Rpb24gc2VydmljZUNvbmZpZyhuYW1lKSB7XG4gIGZ1bmN0aW9uIGdldEtleXMoa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IG5vcm1hbGl6ZUtleXMoa2V5KTtcbiAgICBrZXlzLnVuc2hpZnQoJ3NlcnZpY2VzJywgbmFtZSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KGtleSwgZGVmKSB7XG4gICAgcmV0dXJuIHN5bmNDb25maWcuZ2V0KGdldEtleXMoa2V5KSwgZGVmKTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGtleTo6Zm9yRWFjaEVudHJ5KChbaywgdl0pID0+IHtcbiAgICAgICAgc3luY0NvbmZpZy5zZXQoZ2V0S2V5cyhrKSwgdik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3luY0NvbmZpZy5zZXQoZ2V0S2V5cyhrZXkpLCB2YWwpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBzeW5jQ29uZmlnLnNldChnZXRLZXlzKCksIHt9KTtcbiAgfVxuICByZXR1cm4geyBnZXQsIHNldCwgY2xlYXIgfTtcbn1cbmZ1bmN0aW9uIHNlcnZpY2VTdGF0ZSh2YWxpZFN0YXRlcywgaW5pdGlhbFN0YXRlLCBvbkNoYW5nZSkge1xuICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGUgfHwgdmFsaWRTdGF0ZXNbMF07XG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gc2V0KG5ld1N0YXRlKSB7XG4gICAgaWYgKHZhbGlkU3RhdGVzLmluY2x1ZGVzKG5ld1N0YXRlKSkge1xuICAgICAgc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGlmIChvbkNoYW5nZSkgb25DaGFuZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHN0YXRlOicsIG5ld1N0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldCgpO1xuICB9XG4gIGZ1bmN0aW9uIGlzKHN0YXRlcykge1xuICAgIHJldHVybiBlbnN1cmVBcnJheShzdGF0ZXMpLmluY2x1ZGVzKHN0YXRlKTtcbiAgfVxuICByZXR1cm4geyBnZXQsIHNldCwgaXMgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0ZXMoKSB7XG4gIHJldHVybiBzZXJ2aWNlTmFtZXMubWFwKChuYW1lKSA9PiB7XG4gICAgY29uc3Qgc2VydmljZSA9IHNlcnZpY2VzW25hbWVdO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBzZXJ2aWNlLm5hbWUsXG4gICAgICBkaXNwbGF5TmFtZTogc2VydmljZS5kaXNwbGF5TmFtZSxcbiAgICAgIGF1dGhTdGF0ZTogc2VydmljZS5hdXRoU3RhdGUuZ2V0KCksXG4gICAgICBzeW5jU3RhdGU6IHNlcnZpY2Uuc3luY1N0YXRlLmdldCgpLFxuICAgICAgbGFzdFN5bmM6IHNlcnZpY2UuY29uZmlnLmdldCgnbWV0YScsIHt9KS5sYXN0U3luYyxcbiAgICAgIHByb2dyZXNzOiBzZXJ2aWNlLnByb2dyZXNzLFxuICAgICAgcHJvcGVydGllczogc2VydmljZS5wcm9wZXJ0aWVzLFxuICAgICAgdXNlckNvbmZpZzogc2VydmljZS5nZXRVc2VyQ29uZmlnKCksXG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNjcmlwdERhdGEoc2NyaXB0LCBzeW5jVmVyc2lvbiwgZXh0cmEpIHtcbiAgbGV0IGRhdGE7XG4gIGlmIChzeW5jVmVyc2lvbiA9PT0gMikge1xuICAgIGRhdGEgPSB7XG4gICAgICB2ZXJzaW9uOiBzeW5jVmVyc2lvbixcbiAgICAgIGN1c3RvbTogc2NyaXB0LmN1c3RvbSxcbiAgICAgIGNvbmZpZzogc2NyaXB0LmNvbmZpZyxcbiAgICAgIHByb3BzOiBvYmplY3RQaWNrKHNjcmlwdC5wcm9wcywgWydsYXN0VXBkYXRlZCddKSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKHN5bmNWZXJzaW9uID09PSAxKSB7XG4gICAgZGF0YSA9IHtcbiAgICAgIHZlcnNpb246IHN5bmNWZXJzaW9uLFxuICAgICAgbW9yZToge1xuICAgICAgICBjdXN0b206IHNjcmlwdC5jdXN0b20sXG4gICAgICAgIGVuYWJsZWQ6IHNjcmlwdC5jb25maWcuZW5hYmxlZCxcbiAgICAgICAgdXBkYXRlOiBzY3JpcHQuY29uZmlnLnNob3VsZFVwZGF0ZSxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IHNjcmlwdC5wcm9wcy5sYXN0VXBkYXRlZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCBleHRyYSk7XG59XG5mdW5jdGlvbiBwYXJzZVNjcmlwdERhdGEocmF3KSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHJhdyk7XG4gICAgZGF0YS5jb2RlID0gb2JqLmNvZGU7XG4gICAgaWYgKG9iai52ZXJzaW9uID09PSAyKSB7XG4gICAgICBkYXRhLmNvbmZpZyA9IG9iai5jb25maWc7XG4gICAgICBkYXRhLmN1c3RvbSA9IG9iai5jdXN0b207XG4gICAgICBkYXRhLnByb3BzID0gb2JqLnByb3BzO1xuICAgIH0gZWxzZSBpZiAob2JqLnZlcnNpb24gPT09IDEpIHtcbiAgICAgIGlmIChvYmoubW9yZSkge1xuICAgICAgICBkYXRhLmN1c3RvbSA9IG9iai5tb3JlLmN1c3RvbTtcbiAgICAgICAgZGF0YS5jb25maWcgPSBvYmplY3RQdXJpZnkoe1xuICAgICAgICAgIGVuYWJsZWQ6IG9iai5tb3JlLmVuYWJsZWQsXG4gICAgICAgICAgc2hvdWxkVXBkYXRlOiBvYmoubW9yZS51cGRhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhLnByb3BzID0gb2JqZWN0UHVyaWZ5KHtcbiAgICAgICAgICBsYXN0VXBkYXRlZDogb2JqLm1vcmUubGFzdFVwZGF0ZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRhdGEuY29kZSA9IHJhdztcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0UHVyaWZ5KG9iaikge1xuICAvLyBSZW1vdmUga2V5cyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIG9iai5mb3JFYWNoKG9iamVjdFB1cmlmeSk7XG4gIH0gZWxzZSBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgb2JqOjpmb3JFYWNoRW50cnkoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGVsc2Ugb2JqZWN0UHVyaWZ5KHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBzZXJ2aWNlRmFjdG9yeShiYXNlKSB7XG4gIGNvbnN0IFNlcnZpY2UgPSBmdW5jdGlvbiBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfTtcbiAgU2VydmljZS5wcm90b3R5cGUgPSBiYXNlO1xuICBTZXJ2aWNlLmV4dGVuZCA9IGV4dGVuZFNlcnZpY2U7XG4gIHJldHVybiBTZXJ2aWNlO1xufVxuZnVuY3Rpb24gZXh0ZW5kU2VydmljZShvcHRpb25zKSB7XG4gIHJldHVybiBzZXJ2aWNlRmFjdG9yeShPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpLCBvcHRpb25zKSk7XG59XG5cbmNvbnN0IG9uU3RhdGVDaGFuZ2UgPSBkZWJvdW5jZSgoKSA9PiB7XG4gIHNlbmRDbWQoJ1VwZGF0ZVN5bmMnLCBnZXRTdGF0ZXMoKSk7XG59KTtcblxuZXhwb3J0IGNvbnN0IEJhc2VTZXJ2aWNlID0gc2VydmljZUZhY3Rvcnkoe1xuICBuYW1lOiAnYmFzZScsXG4gIGRpc3BsYXlOYW1lOiAnQmFzZVNlcnZpY2UnLFxuICBkZWxheVRpbWU6IDEwMDAsXG4gIHVybFByZWZpeDogJycsXG4gIG1ldGFGaWxlOiAnVmlvbGVudG1vbmtleScsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBhdXRoVHlwZTogJ29hdXRoJyxcbiAgfSxcbiAgZ2V0VXNlckNvbmZpZzogbm9vcCxcbiAgc2V0VXNlckNvbmZpZzogbm9vcCxcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzID0ge1xuICAgICAgZmluaXNoZWQ6IDAsXG4gICAgICB0b3RhbDogMCxcbiAgICB9O1xuICAgIHRoaXMuY29uZmlnID0gc2VydmljZUNvbmZpZyh0aGlzLm5hbWUpO1xuICAgIHRoaXMuYXV0aFN0YXRlID0gc2VydmljZVN0YXRlKFtcbiAgICAgICdpZGxlJyxcbiAgICAgICduby1hdXRoJyxcbiAgICAgICdpbml0aWFsaXppbmcnLFxuICAgICAgJ2F1dGhvcml6aW5nJywgLy8gaW4gY2FzZSBzb21lIHNlcnZpY2VzIHJlcXVpcmUgYXN5bmNocm9ub3VzIHJlcXVlc3RzIHRvIGdldCBhY2Nlc3NfdG9rZW5zXG4gICAgICAnYXV0aG9yaXplZCcsXG4gICAgICAndW5hdXRob3JpemVkJyxcbiAgICAgICdlcnJvcicsXG4gICAgXSwgbnVsbCwgb25TdGF0ZUNoYW5nZSk7XG4gICAgdGhpcy5zeW5jU3RhdGUgPSBzZXJ2aWNlU3RhdGUoW1xuICAgICAgJ2lkbGUnLFxuICAgICAgJ3JlYWR5JyxcbiAgICAgICdzeW5jaW5nJyxcbiAgICAgICdlcnJvcicsXG4gICAgXSwgbnVsbCwgb25TdGF0ZUNoYW5nZSk7XG4gICAgdGhpcy5sYXN0RmV0Y2ggPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0aGlzLnN0YXJ0U3luYyA9IHRoaXMuc3luY0ZhY3RvcnkoKTtcbiAgICBjb25zdCBldmVudHMgPSBnZXRFdmVudEVtaXR0ZXIoKTtcbiAgICBbJ29uJywgJ29mZicsICdmaXJlJ11cbiAgICAuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzW2tleV0gPSAoLi4uYXJncykgPT4geyBldmVudHNba2V5XSguLi5hcmdzKTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgbG9nKC4uLmFyZ3MpIHtcbiAgICBjb25zb2xlLmxvZyguLi5hcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH0sXG4gIHN5bmNGYWN0b3J5KCkge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGxldCBkZWJvdW5jZWRSZXNvbHZlO1xuICAgIGNvbnN0IHNob3VsZFN5bmMgPSAoKSA9PiB0aGlzLmF1dGhTdGF0ZS5pcygnYXV0aG9yaXplZCcpICYmIGdldEN1cnJlbnQoKSA9PT0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IGdldFJlYWR5ID0gKCkgPT4ge1xuICAgICAgaWYgKCFzaG91bGRTeW5jKCkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHRoaXMubG9nKCdSZWFkeSB0byBzeW5jOicsIHRoaXMuZGlzcGxheU5hbWUpO1xuICAgICAgdGhpcy5zeW5jU3RhdGUuc2V0KCdyZWFkeScpO1xuICAgICAgd29ya2luZyA9IHdvcmtpbmcudGhlbigoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBkZWJvdW5jZWRSZXNvbHZlID0gZGVib3VuY2UocmVzb2x2ZSwgMTAgKiAxMDAwKTtcbiAgICAgICAgZGVib3VuY2VkUmVzb2x2ZSgpO1xuICAgICAgfSkpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRTeW5jKCkpIHJldHVybiB0aGlzLnN5bmMoKTtcbiAgICAgICAgdGhpcy5zeW5jU3RhdGUuc2V0KCdpZGxlJyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHsgY29uc29sZS5lcnJvcihlcnIpOyB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgZGVib3VuY2VkUmVzb2x2ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSB3b3JraW5nO1xuICAgIH07XG4gICAgZnVuY3Rpb24gc3RhcnRTeW5jKCkge1xuICAgICAgaWYgKCFwcm9taXNlKSBnZXRSZWFkeSgpO1xuICAgICAgaWYgKGRlYm91bmNlZFJlc29sdmUpIGRlYm91bmNlZFJlc29sdmUoKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnRTeW5jO1xuICB9LFxuICBwcmVwYXJlSGVhZGVycygpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgfSxcbiAgcHJlcGFyZSgpIHtcbiAgICB0aGlzLmF1dGhTdGF0ZS5zZXQoJ2luaXRpYWxpemluZycpO1xuICAgIHJldHVybiAodGhpcy5pbml0VG9rZW4oKSA/IFByb21pc2UucmVzb2x2ZSh0aGlzLnVzZXIoKSkgOiBQcm9taXNlLnJlamVjdCh7XG4gICAgICB0eXBlOiAnbm8tYXV0aCcsXG4gICAgfSkpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0KCdhdXRob3JpemVkJyk7XG4gICAgfSwgKGVycikgPT4ge1xuICAgICAgaWYgKFsnbm8tYXV0aCcsICd1bmF1dGhvcml6ZWQnXS5pbmNsdWRlcyhlcnI/LnR5cGUpKSB7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnNldChlcnIudHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnNldCgnZXJyb3InKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3luY1N0YXRlLnNldCgnaWRsZScpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9LFxuICBjaGVja1N5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlcGFyZSgpXG4gICAgLnRoZW4oKCkgPT4gdGhpcy5zdGFydFN5bmMoKSk7XG4gIH0sXG4gIHVzZXI6IG5vb3AsXG4gIGFjcXVpcmVMb2NrOiBub29wLFxuICByZWxlYXNlTG9jazogbm9vcCxcbiAgaGFuZGxlTWV0YUVycm9yKGVycikge1xuICAgIHRocm93IGVycjtcbiAgfSxcbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoeyBuYW1lOiB0aGlzLm1ldGFGaWxlIH0pXG4gICAgLnRoZW4oZGF0YSA9PiBKU09OLnBhcnNlKGRhdGEpKVxuICAgIC5jYXRjaChlcnIgPT4gdGhpcy5oYW5kbGVNZXRhRXJyb3IoZXJyKSlcbiAgICAudGhlbihkYXRhID0+ICh7XG4gICAgICBuYW1lOiB0aGlzLm1ldGFGaWxlLFxuICAgICAgZGF0YSxcbiAgICB9KSk7XG4gIH0sXG4gIGluaXRUb2tlbigpIHtcbiAgICB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmNvbmZpZy5nZXQoJ3Rva2VuJyk7XG4gICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSB0b2tlbiA/IGBCZWFyZXIgJHt0b2tlbn1gIDogbnVsbDtcbiAgICByZXR1cm4gISF0b2tlbjtcbiAgfSxcbiAgbG9hZERhdGEob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcHJvZ3Jlc3MgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBkZWxheSA9IHRoaXMuZGVsYXlUaW1lIH0gPSBvcHRpb25zO1xuICAgIGxldCBsYXN0RmV0Y2ggPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGxhc3RGZXRjaCA9IHRoaXMubGFzdEZldGNoXG4gICAgICAudGhlbih0cyA9PiBtYWtlUGF1c2UoZGVsYXkgLSAoRGF0ZS5ub3coKSAtIHRzKSkpXG4gICAgICAudGhlbigoKSA9PiBEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMubGFzdEZldGNoID0gbGFzdEZldGNoO1xuICAgIH1cbiAgICBwcm9ncmVzcy50b3RhbCArPSAxO1xuICAgIG9uU3RhdGVDaGFuZ2UoKTtcbiAgICByZXR1cm4gbGFzdEZldGNoLnRoZW4oKCkgPT4ge1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgbGV0IHsgdXJsIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHVybCA9IChvcHRpb25zLnByZWZpeCA/PyB0aGlzLnVybFByZWZpeCkgKyB1cmw7XG4gICAgICByZXR1cm4gcmVxdWVzdCh1cmwsIG9wdGlvbnMpO1xuICAgIH0pXG4gICAgLnRoZW4oKHsgZGF0YSB9KSA9PiAoeyBkYXRhIH0pLCBlcnJvciA9PiAoeyBlcnJvciB9KSlcbiAgICAudGhlbigoeyBkYXRhLCBlcnJvciB9KSA9PiB7XG4gICAgICBwcm9ncmVzcy5maW5pc2hlZCArPSAxO1xuICAgICAgb25TdGF0ZUNoYW5nZSgpO1xuICAgICAgaWYgKGVycm9yKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG4gIH0sXG4gIGdldExvY2FsRGF0YSgpIHtcbiAgICByZXR1cm4gcGx1Z2luU2NyaXB0Lmxpc3QoKTtcbiAgfSxcbiAgZ2V0U3luY0RhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWV0YSgpXG4gICAgLnRoZW4ocmVtb3RlTWV0YSA9PiBQcm9taXNlLmFsbChbXG4gICAgICByZW1vdGVNZXRhLFxuICAgICAgdGhpcy5saXN0KCksXG4gICAgICB0aGlzLmdldExvY2FsRGF0YSgpLFxuICAgIF0pKTtcbiAgfSxcbiAgc3luYygpIHtcbiAgICB0aGlzLnByb2dyZXNzID0ge1xuICAgICAgZmluaXNoZWQ6IDAsXG4gICAgICB0b3RhbDogMCxcbiAgICB9O1xuICAgIHRoaXMuc3luY1N0YXRlLnNldCgnc3luY2luZycpO1xuICAgIC8vIEF2b2lkIHNpbXVsdGFuZW91cyByZXF1ZXN0c1xuICAgIHJldHVybiB0aGlzLnByZXBhcmUoKVxuICAgIC50aGVuKCgpID0+IHRoaXMuZ2V0U3luY0RhdGEoKSlcbiAgICAudGhlbihkYXRhID0+IFByb21pc2UucmVzb2x2ZSh0aGlzLmFjcXVpcmVMb2NrKCkpLnRoZW4oKCkgPT4gZGF0YSkpXG4gICAgLnRoZW4oKFtyZW1vdGVNZXRhLCByZW1vdGVEYXRhLCBsb2NhbERhdGFdKSA9PiB7XG4gICAgICBjb25zdCByZW1vdGVNZXRhRGF0YSA9IHJlbW90ZU1ldGEuZGF0YSB8fCB7fTtcbiAgICAgIGNvbnN0IHJlbW90ZU1ldGFJbmZvID0gcmVtb3RlTWV0YURhdGEuaW5mbyB8fCB7fTtcbiAgICAgIGNvbnN0IHJlbW90ZVRpbWVzdGFtcCA9IHJlbW90ZU1ldGFEYXRhLnRpbWVzdGFtcCB8fCAwO1xuICAgICAgbGV0IHJlbW90ZUNoYW5nZWQgPSAhcmVtb3RlVGltZXN0YW1wXG4gICAgICAgIHx8IE9iamVjdC5rZXlzKHJlbW90ZU1ldGFJbmZvKS5sZW5ndGggIT09IHJlbW90ZURhdGEubGVuZ3RoO1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGdsb2JhbExhc3RNb2RpZmllZCA9IGdldE9wdGlvbignbGFzdE1vZGlmaWVkJyk7XG4gICAgICBjb25zdCByZW1vdGVJdGVtTWFwID0ge307XG4gICAgICBjb25zdCBsb2NhbE1ldGEgPSB0aGlzLmNvbmZpZy5nZXQoJ21ldGEnLCB7fSk7XG4gICAgICBjb25zdCBmaXJzdFN5bmMgPSAhbG9jYWxNZXRhLnRpbWVzdGFtcDtcbiAgICAgIGNvbnN0IG91dGRhdGVkID0gZmlyc3RTeW5jIHx8IHJlbW90ZVRpbWVzdGFtcCA+IGxvY2FsTWV0YS50aW1lc3RhbXA7XG4gICAgICB0aGlzLmxvZygnRmlyc3Qgc3luYzonLCBmaXJzdFN5bmMpO1xuICAgICAgdGhpcy5sb2coJ091dGRhdGVkOicsIG91dGRhdGVkLCAnKCcsICdsb2NhbDonLCBsb2NhbE1ldGEudGltZXN0YW1wLCAncmVtb3RlOicsIHJlbW90ZVRpbWVzdGFtcCwgJyknKTtcbiAgICAgIGNvbnN0IHB1dExvY2FsID0gW107XG4gICAgICBjb25zdCBwdXRSZW1vdGUgPSBbXTtcbiAgICAgIGNvbnN0IGRlbFJlbW90ZSA9IFtdO1xuICAgICAgY29uc3QgZGVsTG9jYWwgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZUxvY2FsID0gW107XG4gICAgICByZW1vdGVNZXRhRGF0YS5pbmZvID0gcmVtb3RlRGF0YS5yZWR1Y2UoKGluZm8sIGl0ZW0pID0+IHtcbiAgICAgICAgcmVtb3RlSXRlbU1hcFtpdGVtLnVyaV0gPSBpdGVtO1xuICAgICAgICBsZXQgaXRlbUluZm8gPSByZW1vdGVNZXRhSW5mb1tpdGVtLnVyaV07XG4gICAgICAgIGlmICghaXRlbUluZm8pIHtcbiAgICAgICAgICBpdGVtSW5mbyA9IHt9O1xuICAgICAgICAgIHJlbW90ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm9baXRlbS51cmldID0gaXRlbUluZm87XG4gICAgICAgIGlmICghaXRlbUluZm8ubW9kaWZpZWQpIHtcbiAgICAgICAgICBpdGVtSW5mby5tb2RpZmllZCA9IG5vdztcbiAgICAgICAgICByZW1vdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIH0sIHt9KTtcbiAgICAgIGxvY2FsRGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHM6IHsgdXJpLCBwb3NpdGlvbiwgbGFzdE1vZGlmaWVkIH0gfSA9IGl0ZW07XG4gICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSByZW1vdGVNZXRhRGF0YS5pbmZvW3VyaV07XG4gICAgICAgIGNvbnN0IHJlbW90ZUl0ZW0gPSByZW1vdGVJdGVtTWFwW3VyaV07XG4gICAgICAgIGlmIChyZW1vdGVJbmZvICYmIHJlbW90ZUl0ZW0pIHtcbiAgICAgICAgICBpZiAoZmlyc3RTeW5jIHx8ICFsYXN0TW9kaWZpZWQgfHwgcmVtb3RlSW5mby5tb2RpZmllZCA+IGxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgcHV0TG9jYWwucHVzaCh7IGxvY2FsOiBpdGVtLCByZW1vdGU6IHJlbW90ZUl0ZW0sIGluZm86IHJlbW90ZUluZm8gfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZW1vdGVJbmZvLm1vZGlmaWVkIDwgbGFzdE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgIHB1dFJlbW90ZS5wdXNoKHsgbG9jYWw6IGl0ZW0sIHJlbW90ZTogcmVtb3RlSXRlbSB9KTtcbiAgICAgICAgICAgICAgcmVtb3RlSW5mby5tb2RpZmllZCA9IGxhc3RNb2RpZmllZDtcbiAgICAgICAgICAgICAgcmVtb3RlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtb3RlSW5mby5wb3NpdGlvbiAhPT0gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgaWYgKHJlbW90ZUluZm8ucG9zaXRpb24gJiYgZ2xvYmFsTGFzdE1vZGlmaWVkIDw9IHJlbW90ZVRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUxvY2FsLnB1c2goeyBsb2NhbDogaXRlbSwgcmVtb3RlOiByZW1vdGVJdGVtLCBpbmZvOiByZW1vdGVJbmZvIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW90ZUluZm8ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICByZW1vdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgcmVtb3RlSXRlbU1hcFt1cmldO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0U3luYyB8fCAhb3V0ZGF0ZWQgfHwgbGFzdE1vZGlmaWVkID4gcmVtb3RlVGltZXN0YW1wKSB7XG4gICAgICAgICAgcHV0UmVtb3RlLnB1c2goeyBsb2NhbDogaXRlbSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxMb2NhbC5wdXNoKHsgbG9jYWw6IGl0ZW0gfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVtb3RlSXRlbU1hcDo6Zm9yRWFjaEVudHJ5KChbdXJpLCBpdGVtXSkgPT4ge1xuICAgICAgICBjb25zdCBpbmZvID0gcmVtb3RlTWV0YURhdGEuaW5mb1t1cmldO1xuICAgICAgICBpZiAob3V0ZGF0ZWQpIHtcbiAgICAgICAgICBwdXRMb2NhbC5wdXNoKHsgcmVtb3RlOiBpdGVtLCBpbmZvIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbFJlbW90ZS5wdXNoKHsgcmVtb3RlOiBpdGVtIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb21pc2VRdWV1ZSA9IFtcbiAgICAgICAgLi4ucHV0TG9jYWwubWFwKCh7IHJlbW90ZSwgaW5mbyB9KSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2coJ0Rvd25sb2FkIHNjcmlwdDonLCByZW1vdGUudXJpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXQocmVtb3RlKVxuICAgICAgICAgIC50aGVuKChyYXcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwYXJzZVNjcmlwdERhdGEocmF3KTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgZGF0YVxuICAgICAgICAgICAgaWYgKCFkYXRhLmNvZGUpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpbmZvLm1vZGlmaWVkKSBvYmplY3RTZXQoZGF0YSwgJ3Byb3BzLmxhc3RNb2RpZmllZCcsIGluZm8ubW9kaWZpZWQpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSAraW5mby5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikgZGF0YS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKCFnZXRPcHRpb24oJ3N5bmNTY3JpcHRTdGF0dXMnKSAmJiBkYXRhLmNvbmZpZykge1xuICAgICAgICAgICAgICBkZWxldGUgZGF0YS5jb25maWcuZW5hYmxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5TY3JpcHQudXBkYXRlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgLi4ucHV0UmVtb3RlLm1hcCgoeyBsb2NhbCwgcmVtb3RlIH0pID0+IHtcbiAgICAgICAgICB0aGlzLmxvZygnVXBsb2FkIHNjcmlwdDonLCBsb2NhbC5wcm9wcy51cmkpO1xuICAgICAgICAgIHJldHVybiBwbHVnaW5TY3JpcHQuZ2V0KGxvY2FsLnByb3BzLmlkKVxuICAgICAgICAgIC50aGVuKChjb2RlKSA9PiB7XG4gICAgICAgICAgICAvLyBYWFggdXNlIHZlcnNpb24gMSB0byBiZSBjb21wYXRpYmxlIHdpdGggVmlvbGVudG1vbmtleSBvbiBvdGhlciBwbGF0Zm9ybXNcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBnZXRTY3JpcHREYXRhKGxvY2FsLCAxLCB7IGNvZGUgfSk7XG4gICAgICAgICAgICByZW1vdGVNZXRhRGF0YS5pbmZvW2xvY2FsLnByb3BzLnVyaV0gPSB7XG4gICAgICAgICAgICAgIG1vZGlmaWVkOiBsb2NhbC5wcm9wcy5sYXN0TW9kaWZpZWQsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBsb2NhbC5wcm9wcy5wb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZW1vdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1dChcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcmVtb3RlLCB7XG4gICAgICAgICAgICAgICAgdXJpOiBsb2NhbC5wcm9wcy51cmksXG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbCwgLy8gcHJlZmVyIHVzaW5nIHVyaSBvbiBQVVRcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmRlbFJlbW90ZS5tYXAoKHsgcmVtb3RlIH0pID0+IHtcbiAgICAgICAgICB0aGlzLmxvZygnUmVtb3ZlIHJlbW90ZSBzY3JpcHQ6JywgcmVtb3RlLnVyaSk7XG4gICAgICAgICAgZGVsZXRlIHJlbW90ZU1ldGFEYXRhLmluZm9bcmVtb3RlLnVyaV07XG4gICAgICAgICAgcmVtb3RlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKHJlbW90ZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5kZWxMb2NhbC5tYXAoKHsgbG9jYWwgfSkgPT4ge1xuICAgICAgICAgIHRoaXMubG9nKCdSZW1vdmUgbG9jYWwgc2NyaXB0OicsIGxvY2FsLnByb3BzLnVyaSk7XG4gICAgICAgICAgcmV0dXJuIHBsdWdpblNjcmlwdC5yZW1vdmUobG9jYWwucHJvcHMuaWQpO1xuICAgICAgICB9KSxcbiAgICAgICAgLi4udXBkYXRlTG9jYWwubWFwKCh7IGxvY2FsLCBpbmZvIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVzID0ge307XG4gICAgICAgICAgaWYgKGluZm8ucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHVwZGF0ZXMucHJvcHMgPSB7IHBvc2l0aW9uOiBpbmZvLnBvc2l0aW9uIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1cGRhdGVTY3JpcHRJbmZvKGxvY2FsLnByb3BzLmlkLCB1cGRhdGVzKTtcbiAgICAgICAgfSksXG4gICAgICBdO1xuICAgICAgcHJvbWlzZVF1ZXVlLnB1c2goUHJvbWlzZS5hbGwocHJvbWlzZVF1ZXVlKS50aGVuKCgpID0+IHNvcnRTY3JpcHRzKCkpLnRoZW4oKGNoYW5nZWQpID0+IHtcbiAgICAgICAgaWYgKCFjaGFuZ2VkKSByZXR1cm47XG4gICAgICAgIHJlbW90ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcGx1Z2luU2NyaXB0Lmxpc3QoKVxuICAgICAgICAudGhlbigoc2NyaXB0cykgPT4ge1xuICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gcmVtb3RlTWV0YURhdGEuaW5mb1tzY3JpcHQucHJvcHMudXJpXTtcbiAgICAgICAgICAgIGlmIChyZW1vdGVJbmZvKSByZW1vdGVJbmZvLnBvc2l0aW9uID0gc2NyaXB0LnByb3BzLnBvc2l0aW9uO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICAgIHByb21pc2VRdWV1ZS5wdXNoKFByb21pc2UuYWxsKHByb21pc2VRdWV1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGlmIChyZW1vdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgcmVtb3RlTWV0YURhdGEudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMucHV0KHJlbW90ZU1ldGEsIEpTT04uc3RyaW5naWZ5KHJlbW90ZU1ldGFEYXRhKSkpO1xuICAgICAgICB9XG4gICAgICAgIGxvY2FsTWV0YS50aW1lc3RhbXAgPSByZW1vdGVNZXRhRGF0YS50aW1lc3RhbXA7XG4gICAgICAgIGxvY2FsTWV0YS5sYXN0U3luYyA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuY29uZmlnLnNldCgnbWV0YScsIGxvY2FsTWV0YSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICB9KSk7XG4gICAgICAvLyBpZ25vcmUgZXJyb3JzIHRvIGVuc3VyZSBhbGwgcHJvbWlzZXMgYXJlIGZ1bGZpbGxlZFxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VRdWV1ZS5tYXAocHJvbWlzZSA9PiBwcm9taXNlLnRoZW4obm9vcCwgZXJyID0+IGVyciB8fCB0cnVlKSkpXG4gICAgICAudGhlbihlcnJvcnMgPT4gZXJyb3JzLmZpbHRlcihCb29sZWFuKSlcbiAgICAgIC50aGVuKChlcnJvcnMpID0+IHsgaWYgKGVycm9ycy5sZW5ndGgpIHRocm93IGVycm9yczsgfSk7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnN5bmNTdGF0ZS5zZXQoJ2lkbGUnKTtcbiAgICAgIHRoaXMubG9nKCdTeW5jIGZpbmlzaGVkOicsIHRoaXMuZGlzcGxheU5hbWUpO1xuICAgIH0sIChlcnIpID0+IHtcbiAgICAgIHRoaXMuc3luY1N0YXRlLnNldCgnZXJyb3InKTtcbiAgICAgIHRoaXMubG9nKCdGYWlsZWQgc3luY2luZzonLCB0aGlzLmRpc3BsYXlOYW1lKTtcbiAgICAgIHRoaXMubG9nKGVycik7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiBQcm9taXNlLnJlc29sdmUodGhpcy5yZWxlYXNlTG9jaygpKS5jYXRjaChub29wKSk7XG4gIH0sXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKEZhY3RvcnkpIHtcbiAgc2VydmljZUNsYXNzZXMucHVzaChGYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gIHJldHVybiBzeW5jQ29uZmlnLmdldCgnY3VycmVudCcpO1xufVxuZnVuY3Rpb24gZ2V0U2VydmljZShuYW1lKSB7XG4gIHJldHVybiBzZXJ2aWNlc1tuYW1lIHx8IGdldEN1cnJlbnQoKV07XG59XG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgaWYgKCFzeW5jQ29uZmlnKSB7XG4gICAgc3luY0NvbmZpZyA9IGluaXRDb25maWcoKTtcbiAgICBzZXJ2aWNlQ2xhc3Nlcy5mb3JFYWNoKChGYWN0b3J5KSA9PiB7XG4gICAgICBjb25zdCBzZXJ2aWNlID0gbmV3IEZhY3RvcnkoKTtcbiAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc2VydmljZTtcbiAgICAgIHNlcnZpY2VOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgc2VydmljZXNbbmFtZV0gPSBzZXJ2aWNlO1xuICAgIH0pO1xuICB9XG4gIHN5bmMoKTtcbn1cblxuZnVuY3Rpb24gc3luY09uZShzZXJ2aWNlKSB7XG4gIGlmIChzZXJ2aWNlLnN5bmNTdGF0ZS5pcyhbJ3JlYWR5JywgJ3N5bmNpbmcnXSkpIHJldHVybjtcbiAgaWYgKHNlcnZpY2UuYXV0aFN0YXRlLmlzKFsnaWRsZScsICdlcnJvciddKSkgcmV0dXJuIHNlcnZpY2UuY2hlY2tTeW5jKCk7XG4gIGlmIChzZXJ2aWNlLmF1dGhTdGF0ZS5pcygnYXV0aG9yaXplZCcpKSByZXR1cm4gc2VydmljZS5zdGFydFN5bmMoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bmMoKSB7XG4gIGNvbnN0IHNlcnZpY2UgPSBnZXRTZXJ2aWNlKCk7XG4gIHJldHVybiBzZXJ2aWNlICYmIFByb21pc2UucmVzb2x2ZShzeW5jT25lKHNlcnZpY2UpKS50aGVuKGF1dG9TeW5jKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dGhvcml6ZSgpIHtcbiAgY29uc3Qgc2VydmljZSA9IGdldFNlcnZpY2UoKTtcbiAgaWYgKHNlcnZpY2UpIHNlcnZpY2UuYXV0aG9yaXplKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXZva2UoKSB7XG4gIGNvbnN0IHNlcnZpY2UgPSBnZXRTZXJ2aWNlKCk7XG4gIGlmIChzZXJ2aWNlKSBzZXJ2aWNlLnJldm9rZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29uZmlnKGNvbmZpZykge1xuICBjb25zdCBzZXJ2aWNlID0gZ2V0U2VydmljZSgpO1xuICBpZiAoc2VydmljZSkge1xuICAgIHNlcnZpY2Uuc2V0VXNlckNvbmZpZyhjb25maWcpO1xuICAgIHJldHVybiBzZXJ2aWNlLmNoZWNrU3luYygpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcGVuQXV0aFBhZ2UodXJsLCByZWRpcmVjdFVyaSkge1xuICB1bnJlZ2lzdGVyV2ViUmVxdWVzdCgpOyAvLyBvdGhlcndpc2Ugb3VyIG5ldyB0YWJJZCB3aWxsIGJlIGlnbm9yZWRcbiAgYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uQmVmb3JlUmVxdWVzdC5hZGRMaXN0ZW5lcihvbkJlZm9yZVJlcXVlc3QsIHtcbiAgICB1cmxzOiBbYCR7cmVkaXJlY3RVcml9KmBdLFxuICAgIHR5cGVzOiBbJ21haW5fZnJhbWUnXSxcbiAgICB0YWJJZDogKGF3YWl0IGJyb3dzZXIudGFicy5jcmVhdGUoeyB1cmwgfSkpLmlkLFxuICB9LCBbJ2Jsb2NraW5nJ10pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Y2hyb21lLndlYlJlcXVlc3QuV2ViUmVzcG9uc2VEZXRhaWxzfSBpbmZvXG4gKiBAcmV0dXJucyB7Y2hyb21lLndlYlJlcXVlc3QuQmxvY2tpbmdSZXNwb25zZX1cbiAqL1xuZnVuY3Rpb24gb25CZWZvcmVSZXF1ZXN0KGluZm8pIHtcbiAgaWYgKGdldFNlcnZpY2UoKS5jaGVja0F1dGg/LihpbmZvLnVybCkpIHtcbiAgICBicm93c2VyLnRhYnMucmVtb3ZlKGluZm8udGFiSWQpO1xuICAgIC8vIElmIHdlIHVucmVnaXN0ZXIgd2l0aG91dCBzZXRUaW1lb3V0LCBBUEkgd2lsbCBpZ25vcmUgeyBjYW5jZWw6IHRydWUgfVxuICAgIHNldFRpbWVvdXQodW5yZWdpc3RlcldlYlJlcXVlc3QsIDApO1xuICAgIHJldHVybiB7IGNhbmNlbDogdHJ1ZSB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXJXZWJSZXF1ZXN0KCkge1xuICBicm93c2VyLndlYlJlcXVlc3Qub25CZWZvcmVSZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKG9uQmVmb3JlUmVxdWVzdCk7XG59XG5cbmhvb2tPcHRpb25zKChkYXRhKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gZGF0YT8uWydzeW5jLmN1cnJlbnQnXTtcbiAgaWYgKHZhbHVlKSBpbml0aWFsaXplKCk7XG59KTtcbiIsImltcG9ydCB7IGxvYWRRdWVyeSwgZHVtcFF1ZXJ5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgZ2V0VVJJLCBnZXRJdGVtRmlsZW5hbWUsIEJhc2VTZXJ2aWNlLCBpc1NjcmlwdEZpbGUsIHJlZ2lzdGVyLFxuICBvcGVuQXV0aFBhZ2UsXG59IGZyb20gJy4vYmFzZSc7XG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgY2xpZW50X2lkOiAnZjBxMTJ6dXAydXlzNXc4JyxcbiAgcmVkaXJlY3RfdXJpOiAnaHR0cHM6Ly92aW9sZW50bW9ua2V5LmdpdGh1Yi5pby9hdXRoX2Ryb3Bib3guaHRtbCcsXG59O1xuXG5jb25zdCBlc2NSRSA9IC9bXFx1MDA3Zi1cXHVmZmZmXS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbmNvbnN0IGVzY0Z1bmMgPSBtID0+IGBcXFxcdSR7KG0uY2hhckNvZGVBdCgwKSArIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKX1gO1xuXG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5U2FmZShvYmopIHtcbiAgY29uc3Qgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGVzY1JFLCBlc2NGdW5jKTtcbn1cblxuY29uc3QgRHJvcGJveCA9IEJhc2VTZXJ2aWNlLmV4dGVuZCh7XG4gIG5hbWU6ICdkcm9wYm94JyxcbiAgZGlzcGxheU5hbWU6ICdEcm9wYm94JyxcbiAgdXNlcigpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogJ2h0dHBzOi8vYXBpLmRyb3Bib3hhcGkuY29tLzIvdXNlcnMvZ2V0X2N1cnJlbnRfYWNjb3VudCcsXG4gICAgfSlcbiAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgICAgIHR5cGU6ICd1bmF1dGhvcml6ZWQnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgIGRhdGE6IGVycixcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBoYW5kbGVNZXRhRXJyb3IocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDQwOSkgdGhyb3cgcmVzO1xuICB9LFxuICBsaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiAnaHR0cHM6Ly9hcGkuZHJvcGJveGFwaS5jb20vMi9maWxlcy9saXN0X2ZvbGRlcicsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHBhdGg6ICcnLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pXG4gICAgLnRoZW4oZGF0YSA9PiAoXG4gICAgICBkYXRhLmVudHJpZXMuZmlsdGVyKGl0ZW0gPT4gaXRlbVsnLnRhZyddID09PSAnZmlsZScgJiYgaXNTY3JpcHRGaWxlKGl0ZW0ubmFtZSkpLm1hcChub3JtYWxpemUpXG4gICAgKSk7XG4gIH0sXG4gIGdldChpdGVtKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldEl0ZW1GaWxlbmFtZShpdGVtKTtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogJ2h0dHBzOi8vY29udGVudC5kcm9wYm94YXBpLmNvbS8yL2ZpbGVzL2Rvd25sb2FkJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0Ryb3Bib3gtQVBJLUFyZyc6IGpzb25TdHJpbmdpZnlTYWZlKHtcbiAgICAgICAgICBwYXRoOiBgLyR7bmFtZX1gLFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIHB1dChpdGVtLCBkYXRhKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldEl0ZW1GaWxlbmFtZShpdGVtKTtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogJ2h0dHBzOi8vY29udGVudC5kcm9wYm94YXBpLmNvbS8yL2ZpbGVzL3VwbG9hZCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdEcm9wYm94LUFQSS1BcmcnOiBqc29uU3RyaW5naWZ5U2FmZSh7XG4gICAgICAgICAgcGF0aDogYC8ke25hbWV9YCxcbiAgICAgICAgICBtb2RlOiAnb3ZlcndyaXRlJyxcbiAgICAgICAgfSksXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBkYXRhLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSlcbiAgICAudGhlbihub3JtYWxpemUpO1xuICB9LFxuICByZW1vdmUoaXRlbSkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJdGVtRmlsZW5hbWUoaXRlbSk7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6ICdodHRwczovL2FwaS5kcm9wYm94YXBpLmNvbS8yL2ZpbGVzL2RlbGV0ZScsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHBhdGg6IGAvJHtuYW1lfWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSlcbiAgICAudGhlbihub3JtYWxpemUpO1xuICB9LFxuICBhdXRob3JpemUoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgcmVzcG9uc2VfdHlwZTogJ3Rva2VuJyxcbiAgICAgIGNsaWVudF9pZDogY29uZmlnLmNsaWVudF9pZCxcbiAgICAgIHJlZGlyZWN0X3VyaTogY29uZmlnLnJlZGlyZWN0X3VyaSxcbiAgICB9O1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovL3d3dy5kcm9wYm94LmNvbS9vYXV0aDIvYXV0aG9yaXplPyR7ZHVtcFF1ZXJ5KHBhcmFtcyl9YDtcbiAgICBvcGVuQXV0aFBhZ2UodXJsLCBjb25maWcucmVkaXJlY3RfdXJpKTtcbiAgfSxcbiAgYXV0aG9yaXplZChyYXcpIHtcbiAgICBjb25zdCBkYXRhID0gbG9hZFF1ZXJ5KHJhdyk7XG4gICAgaWYgKGRhdGEuYWNjZXNzX3Rva2VuKSB7XG4gICAgICB0aGlzLmNvbmZpZy5zZXQoe1xuICAgICAgICB1aWQ6IGRhdGEudWlkLFxuICAgICAgICB0b2tlbjogZGF0YS5hY2Nlc3NfdG9rZW4sXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNoZWNrQXV0aCh1cmwpIHtcbiAgICBjb25zdCByZWRpcmVjdFVyaSA9IGAke2NvbmZpZy5yZWRpcmVjdF91cml9I2A7XG4gICAgaWYgKHVybC5zdGFydHNXaXRoKHJlZGlyZWN0VXJpKSkge1xuICAgICAgdGhpcy5hdXRob3JpemVkKHVybC5zbGljZShyZWRpcmVjdFVyaS5sZW5ndGgpKTtcbiAgICAgIHRoaXMuY2hlY2tTeW5jKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIHJldm9rZSgpIHtcbiAgICB0aGlzLmNvbmZpZy5zZXQoe1xuICAgICAgdWlkOiBudWxsLFxuICAgICAgdG9rZW46IG51bGwsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucHJlcGFyZSgpO1xuICB9LFxufSk7XG5yZWdpc3RlcihEcm9wYm94KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplKGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgc2l6ZTogaXRlbS5zaXplLFxuICAgIHVyaTogZ2V0VVJJKGl0ZW0ubmFtZSksXG4gICAgLy8gbW9kaWZpZWQ6IG5ldyBEYXRlKGl0ZW0uc2VydmVyX21vZGlmaWVkKS5nZXRUaW1lKCksXG4gICAgLy8gaXNEZWxldGVkOiBpdGVtLmlzX2RlbGV0ZWQsXG4gIH07XG59XG4iLCIvLyBSZWZlcmVuY2U6XG4vLyAtIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2RyaXZlL3YzL3JlZmVyZW5jZS9maWxlc1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2dvb2dsZS1hcGktbm9kZWpzLWNsaWVudFxuaW1wb3J0IHsgZ2V0VW5pcUlkLCBub29wIH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgb2JqZWN0R2V0IH0gZnJvbSAnIy9jb21tb24vb2JqZWN0JztcbmltcG9ydCB7IGR1bXBRdWVyeSwgbm90aWZ5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgZ2V0VVJJLCBnZXRJdGVtRmlsZW5hbWUsIEJhc2VTZXJ2aWNlLCByZWdpc3RlciwgaXNTY3JpcHRGaWxlLFxuICBvcGVuQXV0aFBhZ2UsXG59IGZyb20gJy4vYmFzZSc7XG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgY2xpZW50X2lkOiBwcm9jZXNzLmVudi5TWU5DX0dPT0dMRV9DTElFTlRfSUQsXG4gIGNsaWVudF9zZWNyZXQ6IHByb2Nlc3MuZW52LlNZTkNfR09PR0xFX0NMSUVOVF9TRUNSRVQsXG4gIHJlZGlyZWN0X3VyaTogJ2h0dHBzOi8vdmlvbGVudG1vbmtleS5naXRodWIuaW8vYXV0aF9nb29nbGVkcml2ZS5odG1sJyxcbiAgc2NvcGU6ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLmFwcGRhdGEnLFxufTtcbmNvbnN0IFVOQVVUSE9SSVpFRCA9IHsgc3RhdHVzOiAnVU5BVVRIT1JJWkVEJyB9O1xuXG5jb25zdCBHb29nbGVEcml2ZSA9IEJhc2VTZXJ2aWNlLmV4dGVuZCh7XG4gIG5hbWU6ICdnb29nbGVkcml2ZScsXG4gIGRpc3BsYXlOYW1lOiAnR29vZ2xlIERyaXZlJyxcbiAgdXJsUHJlZml4OiAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZHJpdmUvdjMnLFxuICByZWZyZXNoVG9rZW4oKSB7XG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gdGhpcy5jb25maWcuZ2V0KCdyZWZyZXNoX3Rva2VuJyk7XG4gICAgaWYgKCFyZWZyZXNoVG9rZW4pIHJldHVybiBQcm9taXNlLnJlamVjdCh7IHR5cGU6ICd1bmF1dGhvcml6ZWQnIH0pO1xuICAgIHJldHVybiB0aGlzLmF1dGhvcml6ZWQoe1xuICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4gdGhpcy5wcmVwYXJlKCkpO1xuICB9LFxuICB1c2VyKCkge1xuICAgIGNvbnN0IHJlcXVlc3RVc2VyID0gKCkgPT4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICB1cmw6IGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9vYXV0aDIvdjMvdG9rZW5pbmZvPyR7ZHVtcFF1ZXJ5KHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmNvbmZpZy5nZXQoJ3Rva2VuJyksXG4gICAgICB9KX1gLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcXVlc3RVc2VyKClcbiAgICAudGhlbigoaW5mbykgPT4ge1xuICAgICAgLy8gSWYgYWNjZXNzIHdhcyBncmFudGVkIHdpdGggYWNjZXNzX3R5cGU9b25saW5lLCByZXZva2UgaXQuXG4gICAgICBpZiAoaW5mby5hY2Nlc3NfdHlwZSA9PT0gJ29ubGluZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIHVybDogYGh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi9yZXZva2U/dG9rZW49JHt0aGlzLmNvbmZpZy5nZXQoJ3Rva2VuJyl9YCxcbiAgICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgbm90aWZ5KHtcbiAgICAgICAgICAgIHRpdGxlOiAnU3luYyBVcGdyYWRlZCcsXG4gICAgICAgICAgICBib2R5OiAnUGxlYXNlIHJlYXV0aG9yaXplIGFjY2VzcyB0byB5b3VyIEdvb2dsZSBEcml2ZSB0byBjb21wbGV0ZSB0aGUgdXBncmFkYXRpb24uJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ09ubGluZSBhY2Nlc3MgcmV2b2tlZC4nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5zY29wZSAhPT0gY29uZmlnLnNjb3BlKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoVU5BVVRIT1JJWkVEKTtcbiAgICB9KVxuICAgIC5jYXRjaCgocmVzKSA9PiB7XG4gICAgICBpZiAocmVzID09PSBVTkFVVEhPUklaRUQgfHwgcmVzLnN0YXR1cyA9PT0gNDAwICYmIG9iamVjdEdldChyZXMsICdkYXRhLmVycm9yX2Rlc2NyaXB0aW9uJykgPT09ICdJbnZhbGlkIFZhbHVlJykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW4oKS50aGVuKHJlcXVlc3RVc2VyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgIGRhdGE6IHJlcyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBnZXRTeW5jRGF0YSgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBzcGFjZXM6ICdhcHBEYXRhRm9sZGVyJyxcbiAgICAgIGZpZWxkczogJ2ZpbGVzKGlkLG5hbWUsc2l6ZSknLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgdXJsOiBgL2ZpbGVzPyR7ZHVtcFF1ZXJ5KHBhcmFtcyl9YCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pXG4gICAgLnRoZW4oKHsgZmlsZXMgfSkgPT4ge1xuICAgICAgbGV0IG1ldGFGaWxlO1xuICAgICAgY29uc3QgcmVtb3RlRGF0YSA9IGZpbGVzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXNTY3JpcHRGaWxlKGl0ZW0ubmFtZSkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIW1ldGFGaWxlICYmIGl0ZW0ubmFtZSA9PT0gdGhpcy5tZXRhRmlsZSkge1xuICAgICAgICAgIG1ldGFGaWxlID0gaXRlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KVxuICAgICAgLm1hcChub3JtYWxpemUpXG4gICAgICAuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIGlmICghaXRlbS5zaXplKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBtZXRhSXRlbSA9IG1ldGFGaWxlID8gbm9ybWFsaXplKG1ldGFGaWxlKSA6IHt9O1xuICAgICAgY29uc3QgZ290TWV0YSA9IHRoaXMuZ2V0KG1ldGFJdGVtKVxuICAgICAgLnRoZW4oZGF0YSA9PiBKU09OLnBhcnNlKGRhdGEpKVxuICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLmhhbmRsZU1ldGFFcnJvcihlcnIpKVxuICAgICAgLnRoZW4oZGF0YSA9PiBPYmplY3QuYXNzaWduKHt9LCBtZXRhSXRlbSwge1xuICAgICAgICBuYW1lOiB0aGlzLm1ldGFGaWxlLFxuICAgICAgICB1cmk6IG51bGwsXG4gICAgICAgIGRhdGEsXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2dvdE1ldGEsIHJlbW90ZURhdGEsIHRoaXMuZ2V0TG9jYWxEYXRhKCldKTtcbiAgICB9KTtcbiAgfSxcbiAgYXV0aG9yaXplKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHJlc3BvbnNlX3R5cGU6ICdjb2RlJyxcbiAgICAgIGFjY2Vzc190eXBlOiAnb2ZmbGluZScsXG4gICAgICBjbGllbnRfaWQ6IGNvbmZpZy5jbGllbnRfaWQsXG4gICAgICByZWRpcmVjdF91cmk6IGNvbmZpZy5yZWRpcmVjdF91cmksXG4gICAgICBzY29wZTogY29uZmlnLnNjb3BlLFxuICAgIH07XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5nZXQoJ3JlZnJlc2hfdG9rZW4nKSkgcGFyYW1zLnByb21wdCA9ICdjb25zZW50JztcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL28vb2F1dGgyL3YyL2F1dGg/JHtkdW1wUXVlcnkocGFyYW1zKX1gO1xuICAgIG9wZW5BdXRoUGFnZSh1cmwsIGNvbmZpZy5yZWRpcmVjdF91cmkpO1xuICB9LFxuICBjaGVja0F1dGgodXJsKSB7XG4gICAgY29uc3QgcmVkaXJlY3RVcmkgPSBgJHtjb25maWcucmVkaXJlY3RfdXJpfT9jb2RlPWA7XG4gICAgaWYgKHVybC5zdGFydHNXaXRoKHJlZGlyZWN0VXJpKSkge1xuICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0KCdhdXRob3JpemluZycpO1xuICAgICAgdGhpcy5hdXRob3JpemVkKHtcbiAgICAgICAgY29kZTogZGVjb2RlVVJJQ29tcG9uZW50KHVybC5zcGxpdCgnIycpWzBdLnNsaWNlKHJlZGlyZWN0VXJpLmxlbmd0aCkpLFxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuY2hlY2tTeW5jKCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuICByZXZva2UoKSB7XG4gICAgdGhpcy5jb25maWcuc2V0KHtcbiAgICAgIHRva2VuOiBudWxsLFxuICAgICAgcmVmcmVzaF90b2tlbjogbnVsbCxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlKCk7XG4gIH0sXG4gIGF1dGhvcml6ZWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9vYXV0aDIvdjQvdG9rZW4nLFxuICAgICAgcHJlZml4OiAnJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IGR1bXBRdWVyeShPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgIGNsaWVudF9pZDogY29uZmlnLmNsaWVudF9pZCxcbiAgICAgICAgY2xpZW50X3NlY3JldDogY29uZmlnLmNsaWVudF9zZWNyZXQsXG4gICAgICAgIHJlZGlyZWN0X3VyaTogY29uZmlnLnJlZGlyZWN0X3VyaSxcbiAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICB9LCBwYXJhbXMpKSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pXG4gICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLmFjY2Vzc190b2tlbikge1xuICAgICAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICAgICAgdG9rZW46IGRhdGEuYWNjZXNzX3Rva2VuLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGF0YS5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgdXBkYXRlLnJlZnJlc2hfdG9rZW4gPSBkYXRhLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcuc2V0KHVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBkYXRhO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBoYW5kbGVNZXRhRXJyb3I6IG5vb3AsXG4gIGxpc3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkJyk7XG4gIH0sXG4gIGdldCh7IGlkIH0pIHtcbiAgICBpZiAoIWlkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICB1cmw6IGAvZmlsZXMvJHtpZH0/YWx0PW1lZGlhYCxcbiAgICB9KTtcbiAgfSxcbiAgcHV0KGl0ZW0sIGRhdGEpIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0SXRlbUZpbGVuYW1lKGl0ZW0pO1xuICAgIGNvbnN0IHsgaWQgfSA9IGl0ZW07XG4gICAgY29uc3QgYm91bmRhcnkgPSBnZXRVbmlxSWQoJ3Zpb2xlbnRtb25rZXktaXMtZ3JlYXQtJyk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiBgbXVsdGlwYXJ0L3JlbGF0ZWQ7IGJvdW5kYXJ5PSR7Ym91bmRhcnl9YCxcbiAgICB9O1xuICAgIGNvbnN0IG1ldGFkYXRhID0gaWQgPyB7XG4gICAgICBuYW1lLFxuICAgIH0gOiB7XG4gICAgICBuYW1lLFxuICAgICAgcGFyZW50czogWydhcHBEYXRhRm9sZGVyJ10sXG4gICAgfTtcbiAgICBjb25zdCBib2R5ID0gW1xuICAgICAgYC0tJHtib3VuZGFyeX1gLFxuICAgICAgJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCcsXG4gICAgICAnJyxcbiAgICAgIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSxcbiAgICAgIGAtLSR7Ym91bmRhcnl9YCxcbiAgICAgICdDb250ZW50LVR5cGU6IHRleHQvcGxhaW4nLFxuICAgICAgJycsXG4gICAgICBkYXRhLFxuICAgICAgYC0tJHtib3VuZGFyeX0tLWAsXG4gICAgICAnJyxcbiAgICBdLmpvaW4oJ1xcclxcbicpO1xuICAgIGNvbnN0IHVybCA9IGlkXG4gICAgICA/IGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS91cGxvYWQvZHJpdmUvdjMvZmlsZXMvJHtpZH0/dXBsb2FkVHlwZT1tdWx0aXBhcnRgXG4gICAgICA6ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS91cGxvYWQvZHJpdmUvdjMvZmlsZXM/dXBsb2FkVHlwZT1tdWx0aXBhcnQnO1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIHVybCxcbiAgICAgIGJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgICAgbWV0aG9kOiBpZCA/ICdQQVRDSCcgOiAnUE9TVCcsXG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZSh7IGlkIH0pIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgdXJsOiBgL2ZpbGVzLyR7aWR9YCxcbiAgICB9KTtcbiAgfSxcbn0pO1xucmVnaXN0ZXIoR29vZ2xlRHJpdmUpO1xuXG5mdW5jdGlvbiBub3JtYWxpemUoaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGlkOiBpdGVtLmlkLFxuICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICBzaXplOiAraXRlbS5zaXplLFxuICAgIHVyaTogZ2V0VVJJKGl0ZW0ubmFtZSksXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBpbml0aWFsaXplLFxuICBzeW5jLFxuICBnZXRTdGF0ZXMsXG4gIGF1dGhvcml6ZSxcbiAgcmV2b2tlLFxuICBzZXRDb25maWcsXG59IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgJy4vZHJvcGJveCc7XG5pbXBvcnQgJy4vb25lZHJpdmUnO1xuaW1wb3J0ICcuL2dvb2dsZWRyaXZlJztcbmltcG9ydCAnLi93ZWJkYXYnO1xuaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuLi91dGlscy9tZXNzYWdlJztcblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICBTeW5jQXV0aG9yaXplOiBhdXRob3JpemUsXG4gIFN5bmNSZXZva2U6IHJldm9rZSxcbiAgU3luY1N0YXJ0OiBzeW5jLFxuICBTeW5jU2V0Q29uZmlnOiBzZXRDb25maWcsXG59KTtcblxuZXhwb3J0IHtcbiAgaW5pdGlhbGl6ZSxcbiAgc3luYyxcbiAgZ2V0U3RhdGVzLFxuICBhdXRob3JpemUsXG4gIHJldm9rZSxcbn07XG4iLCIvLyBSZWZlcmVuY2U6IGh0dHBzOi8vZGV2Lm9uZWRyaXZlLmNvbS9SRUFETUUuaHRtXG5pbXBvcnQgeyBub29wIH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgb2JqZWN0R2V0IH0gZnJvbSAnIy9jb21tb24vb2JqZWN0JztcbmltcG9ydCB7IGR1bXBRdWVyeSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIGdldFVSSSwgZ2V0SXRlbUZpbGVuYW1lLCBCYXNlU2VydmljZSwgaXNTY3JpcHRGaWxlLCByZWdpc3RlcixcbiAgb3BlbkF1dGhQYWdlLFxufSBmcm9tICcuL2Jhc2UnO1xuXG5jb25zdCBjb25maWcgPSB7XG4gIGNsaWVudF9pZDogcHJvY2Vzcy5lbnYuU1lOQ19PTkVEUklWRV9DTElFTlRfSUQsXG4gIGNsaWVudF9zZWNyZXQ6IHByb2Nlc3MuZW52LlNZTkNfT05FRFJJVkVfQ0xJRU5UX1NFQ1JFVCxcbiAgcmVkaXJlY3RfdXJpOiAnaHR0cHM6Ly92aW9sZW50bW9ua2V5LmdpdGh1Yi5pby9hdXRoX29uZWRyaXZlLmh0bWwnLFxufTtcblxuY29uc3QgT25lRHJpdmUgPSBCYXNlU2VydmljZS5leHRlbmQoe1xuICBuYW1lOiAnb25lZHJpdmUnLFxuICBkaXNwbGF5TmFtZTogJ09uZURyaXZlJyxcbiAgdXJsUHJlZml4OiAnaHR0cHM6Ly9hcGkub25lZHJpdmUuY29tL3YxLjAnLFxuICByZWZyZXNoVG9rZW4oKSB7XG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gdGhpcy5jb25maWcuZ2V0KCdyZWZyZXNoX3Rva2VuJyk7XG4gICAgcmV0dXJuIHRoaXMuYXV0aG9yaXplZCh7XG4gICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB0aGlzLnByZXBhcmUoKSk7XG4gIH0sXG4gIHVzZXIoKSB7XG4gICAgY29uc3QgcmVxdWVzdFVzZXIgPSAoKSA9PiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIHVybDogJy9kcml2ZScsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVxdWVzdFVzZXIoKVxuICAgIC5jYXRjaCgocmVzKSA9PiB7XG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hUb2tlbigpLnRoZW4ocmVxdWVzdFVzZXIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgcmVzO1xuICAgIH0pXG4gICAgLmNhdGNoKChyZXMpID0+IHtcbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDAgJiYgb2JqZWN0R2V0KHJlcywgJ2RhdGEuZXJyb3InKSA9PT0gJ2ludmFsaWRfZ3JhbnQnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgdHlwZTogJ3VuYXV0aG9yaXplZCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgZGF0YTogcmVzLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIGhhbmRsZU1ldGFFcnJvcihyZXMpIHtcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICBjb25zdCBoZWFkZXIgPSByZXMuaGVhZGVycy5nZXQoJ1dXVy1BdXRoZW50aWNhdGUnKT8uWzBdIHx8ICcnO1xuICAgICAgaWYgKC9eQmVhcmVyIHJlYWxtPVwiT25lRHJpdmVBUElcIi8udGVzdChoZWFkZXIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hUb2tlbigpLnRoZW4oKCkgPT4gdGhpcy5nZXRNZXRhKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyByZXM7XG4gIH0sXG4gIGxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgdXJsOiAnL2RyaXZlL3NwZWNpYWwvYXBwcm9vdC9jaGlsZHJlbicsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KVxuICAgIC50aGVuKGRhdGEgPT4gZGF0YS52YWx1ZS5maWx0ZXIoaXRlbSA9PiBpdGVtLmZpbGUgJiYgaXNTY3JpcHRGaWxlKGl0ZW0ubmFtZSkpLm1hcChub3JtYWxpemUpKTtcbiAgfSxcbiAgZ2V0KGl0ZW0pIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0SXRlbUZpbGVuYW1lKGl0ZW0pO1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIHVybDogYC9kcml2ZS9zcGVjaWFsL2FwcHJvb3Q6LyR7ZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpfWAsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KVxuICAgIC50aGVuKGRhdGEgPT4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICB1cmw6IGRhdGFbJ0Bjb250ZW50LmRvd25sb2FkVXJsJ10sXG4gICAgICBkZWxheTogZmFsc2UsXG4gICAgfSkpO1xuICB9LFxuICBwdXQoaXRlbSwgZGF0YSkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJdGVtRmlsZW5hbWUoaXRlbSk7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIHVybDogYC9kcml2ZS9zcGVjaWFsL2FwcHJvb3Q6LyR7ZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpfTovY29udGVudGAsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBkYXRhLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSlcbiAgICAudGhlbihub3JtYWxpemUpO1xuICB9LFxuICByZW1vdmUoaXRlbSkge1xuICAgIC8vIHJldHVybiAyMDRcbiAgICBjb25zdCBuYW1lID0gZ2V0SXRlbUZpbGVuYW1lKGl0ZW0pO1xuICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICB1cmw6IGAvZHJpdmUvc3BlY2lhbC9hcHByb290Oi8ke2VuY29kZVVSSUNvbXBvbmVudChuYW1lKX1gLFxuICAgIH0pXG4gICAgLmNhdGNoKG5vb3ApO1xuICB9LFxuICBhdXRob3JpemUoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgY2xpZW50X2lkOiBjb25maWcuY2xpZW50X2lkLFxuICAgICAgc2NvcGU6ICdvbmVkcml2ZS5hcHBmb2xkZXIgd2wub2ZmbGluZV9hY2Nlc3MnLFxuICAgICAgcmVzcG9uc2VfdHlwZTogJ2NvZGUnLFxuICAgICAgcmVkaXJlY3RfdXJpOiBjb25maWcucmVkaXJlY3RfdXJpLFxuICAgIH07XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vbG9naW4ubGl2ZS5jb20vb2F1dGgyMF9hdXRob3JpemUuc3JmPyR7ZHVtcFF1ZXJ5KHBhcmFtcyl9YDtcbiAgICBvcGVuQXV0aFBhZ2UodXJsLCBjb25maWcucmVkaXJlY3RfdXJpKTtcbiAgfSxcbiAgY2hlY2tBdXRoKHVybCkge1xuICAgIGNvbnN0IHJlZGlyZWN0VXJpID0gYCR7Y29uZmlnLnJlZGlyZWN0X3VyaX0/Y29kZT1gO1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aChyZWRpcmVjdFVyaSkpIHtcbiAgICAgIHRoaXMuYXV0aFN0YXRlLnNldCgnYXV0aG9yaXppbmcnKTtcbiAgICAgIHRoaXMuYXV0aG9yaXplZCh7XG4gICAgICAgIGNvZGU6IHVybC5zbGljZShyZWRpcmVjdFVyaS5sZW5ndGgpLFxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuY2hlY2tTeW5jKCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuICByZXZva2UoKSB7XG4gICAgdGhpcy5jb25maWcuc2V0KHtcbiAgICAgIHVpZDogbnVsbCxcbiAgICAgIHRva2VuOiBudWxsLFxuICAgICAgcmVmcmVzaF90b2tlbjogbnVsbCxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlKCk7XG4gIH0sXG4gIGF1dGhvcml6ZWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6ICdodHRwczovL2xvZ2luLmxpdmUuY29tL29hdXRoMjBfdG9rZW4uc3JmJyxcbiAgICAgIHByZWZpeDogJycsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBkdW1wUXVlcnkoT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBjbGllbnRfaWQ6IGNvbmZpZy5jbGllbnRfaWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IGNvbmZpZy5jbGllbnRfc2VjcmV0LFxuICAgICAgICByZWRpcmVjdF91cmk6IGNvbmZpZy5yZWRpcmVjdF91cmksXG4gICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgfSwgcGFyYW1zKSksXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KVxuICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoZGF0YS5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgdGhpcy5jb25maWcuc2V0KHtcbiAgICAgICAgICB1aWQ6IGRhdGEudXNlcl9pZCxcbiAgICAgICAgICB0b2tlbjogZGF0YS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgcmVmcmVzaF90b2tlbjogZGF0YS5yZWZyZXNoX3Rva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGRhdGE7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG59KTtcbnJlZ2lzdGVyKE9uZURyaXZlKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplKGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgc2l6ZTogaXRlbS5zaXplLFxuICAgIHVyaTogZ2V0VVJJKGl0ZW0ubmFtZSksXG4gICAgLy8gbW9kaWZpZWQ6IG5ldyBEYXRlKGl0ZW0ubGFzdE1vZGlmaWVkRGF0ZVRpbWUpLmdldFRpbWUoKSxcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIGdldFVSSSwgZ2V0SXRlbUZpbGVuYW1lLCBCYXNlU2VydmljZSwgaXNTY3JpcHRGaWxlLCByZWdpc3Rlcixcbn0gZnJvbSAnLi9iYXNlJztcblxuY29uc3QgS0VZX0NISUxEUkVOID0gU3ltYm9sKCdjaGlsZHJlbicpO1xuXG5jbGFzcyBYTm9kZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIG5zTWFwKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLm5zTWFwID0geyAuLi5uc01hcCB9O1xuICAgIHRoaXMucGFyc2VBdHRycygpO1xuICAgIHRoaXMucGFyc2VOYW1lKCk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVhNTCh4bWwpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgY29uc3QgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICByZXR1cm4gbmV3IFhOb2RlKGRvYyk7XG4gIH1cblxuICBwYXJzZUF0dHJzKCkge1xuICAgIGNvbnN0IHsgbm9kZSwgbnNNYXAgfSA9IHRoaXM7XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IG5vZGU7XG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCB2YWx1ZSB9ID0gYXR0cjtcbiAgICAgICAgaWYgKG5hbWUgPT09ICd4bWxucycpIG5zTWFwLiQgPSB2YWx1ZTtcbiAgICAgICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd4bWxuczonKSkgbnNNYXBbbmFtZS5zbGljZSg2KV0gPSB2YWx1ZTtcbiAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICB9XG5cbiAgcGFyc2VOYW1lKCkge1xuICAgIGNvbnN0IHsgbm9kZSwgbnNNYXAgfSA9IHRoaXM7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGxldCBuYW1lID0gbm9kZS50YWdOYW1lO1xuICAgICAgbGV0IG5zID0gbnNNYXAuJDtcbiAgICAgIGlmIChuYW1lLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgbGV0IHByZWZpeDtcbiAgICAgICAgW3ByZWZpeCwgbmFtZV0gPSBuYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgIG5zID0gbnNNYXBbcHJlZml4XTtcbiAgICAgICAgaWYgKCFucykgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5hbWVzcGFjZTogJHtwcmVmaXh9YCk7XG4gICAgICB9XG4gICAgICB0aGlzLm5hbWUgPSBucyArIG5hbWU7XG4gICAgfVxuICB9XG5cbiAgdGV4dCgpIHtcbiAgICBjb25zdCB7IG5vZGUgfSA9IHRoaXM7XG4gICAgaWYgKG5vZGUpIHJldHVybiAobm9kZS50ZXh0Q29udGVudCB8fCAnJykudHJpbSgpO1xuICB9XG5cbiAgY2hpbGRyZW4oKSB7XG4gICAgaWYgKCF0aGlzW0tFWV9DSElMRFJFTl0pIHtcbiAgICAgIGNvbnN0IHsgbm9kZSwgbnNNYXAgfSA9IHRoaXM7XG4gICAgICB0aGlzW0tFWV9DSElMRFJFTl0gPSBbLi4ubm9kZS5jaGlsZHJlbl1cbiAgICAgIC5tYXAoY2hpbGQgPT4gbmV3IFhOb2RlKGNoaWxkLCBuc01hcCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tLRVlfQ0hJTERSRU5dO1xuICB9XG5cbiAgbWFwKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4oKS5tYXAoY2FsbGJhY2spO1xuICB9XG5cbiAgZ2V0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICh0YWdOYW1lID0+IG5vZGUgPT4gbm9kZS5uYW1lID09PSB0YWdOYW1lKShjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfVxuXG4gIGZpbHRlcihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuKCkuZmlsdGVyKHRoaXMuZ2V0Q2FsbGJhY2soY2FsbGJhY2spKTtcbiAgfVxuXG4gIGZpbmQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbigpLmZpbmQodGhpcy5nZXRDYWxsYmFjayhjYWxsYmFjaykpO1xuICB9XG5cbiAgYXR0cihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyc1trZXldO1xuICB9XG59XG5cbmNvbnN0IERFRkFVTFRfQ09ORklHID0ge1xuICBzZXJ2ZXJVcmw6ICcnLFxuICBhbm9ueW1vdXM6IGZhbHNlLFxuICB1c2VybmFtZTogJycsXG4gIHBhc3N3b3JkOiAnJyxcbn07XG5cbmNvbnN0IFdlYkRBViA9IEJhc2VTZXJ2aWNlLmV4dGVuZCh7XG4gIG5hbWU6ICd3ZWJkYXYnLFxuICBkaXNwbGF5TmFtZTogJ1dlYkRBVicsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBhdXRoVHlwZTogJ3Bhc3N3b3JkJyxcbiAgICBzZXJ2ZXJVcmw6IG51bGwsXG4gIH0sXG4gIGdldFVzZXJDb25maWcoKSB7XG4gICAgaWYgKCF0aGlzLnVzZXJDb25maWcpIHtcbiAgICAgIHRoaXMudXNlckNvbmZpZyA9IHtcbiAgICAgICAgLi4uREVGQVVMVF9DT05GSUcsXG4gICAgICAgIC4uLnRoaXMuY29uZmlnLmdldCgndXNlckNvbmZpZycpLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudXNlckNvbmZpZztcbiAgfSxcbiAgc2V0VXNlckNvbmZpZyhjb25maWcpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMudXNlckNvbmZpZywgY29uZmlnKTtcbiAgICB0aGlzLmNvbmZpZy5zZXQoJ3VzZXJDb25maWcnLCB0aGlzLnVzZXJDb25maWcpO1xuICB9LFxuICBpbml0VG9rZW4oKSB7XG4gICAgdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0VXNlckNvbmZpZygpO1xuICAgIGxldCB1cmwgPSBjb25maWcuc2VydmVyVXJsPy50cmltKCkgfHwgJyc7XG4gICAgaWYgKCF1cmwuaW5jbHVkZXMoJzovLycpKSB1cmwgPSBgaHR0cDovLyR7dXJsfWA7XG4gICAgaWYgKCF1cmwuZW5kc1dpdGgoJy8nKSkgdXJsICs9ICcvJztcbiAgICB0cnkge1xuICAgICAgbmV3IFVSTCh1cmwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMucHJvcGVydGllcy5zZXJ2ZXJVcmwgPSBudWxsO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnByb3BlcnRpZXMuc2VydmVyVXJsID0gYCR7dXJsfVZpb2xlbnRtb25rZXkvYDtcbiAgICBjb25zdCB7IGFub255bW91cywgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBjb25maWc7XG4gICAgaWYgKGFub255bW91cykgcmV0dXJuIHRydWU7XG4gICAgaWYgKCF1c2VybmFtZSB8fCAhcGFzc3dvcmQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBhdXRoID0gd2luZG93LmJ0b2EoYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCk7XG4gICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmFzaWMgJHthdXRofWA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGxvYWREYXRhKG9wdGlvbnMpIHtcbiAgICAvLyBCeXBhc3NpbmcgbG9naW4gQ1NSRiBwcm90ZWN0aW9uIGluIE5leHRjbG91ZCAvIE93bmNsb3VkIGJ5IG5vdCBzZW5kaW5nIGNvb2tpZXMuXG4gICAgLy8gV2UgYXJlIG5vdCB1c2luZyB3ZWIgVUkgYW5kIGNvb2tpZSBhdXRoZW50aWNhdGlvbiwgc28gd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGF0LlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlvbGVudG1vbmtleS92aW9sZW50bW9ua2V5L2lzc3Vlcy85NzZcbiAgICByZXR1cm4gQmFzZVNlcnZpY2UucHJvdG90eXBlLmxvYWREYXRhLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjcmVkZW50aWFsczogJ29taXQnLFxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfSxcbiAgaGFuZGxlTWV0YUVycm9yKHJlcykge1xuICAgIGlmICghW1xuICAgICAgNDA0LCAvLyBGaWxlIG5vdCBleGlzdHNcbiAgICAgIDQwOSwgLy8gRGlyZWN0b3J5IG5vdCBleGlzdHNcbiAgICBdLmluY2x1ZGVzKHJlcy5zdGF0dXMpKSB0aHJvdyByZXM7XG4gIH0sXG4gIC8vIFNvbWUgV2ViREFWIHNlcnZlcnMgZG8gbm90IGFsbG93IExPQ0sgLyBVTkxPQ0tcbiAgLypcbiAgYWNxdWlyZUxvY2soKSB7XG4gICAgY29uc3QgeyBzZXJ2ZXJVcmwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjcmVhdGVMb2NrID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ0FjcXVpcmUgbG9jay4uLicpO1xuICAgICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgICBtZXRob2Q6ICdMT0NLJyxcbiAgICAgICAgdXJsOiBzZXJ2ZXJVcmwsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBUaW1lb3V0OiBgU2Vjb25kLSR7MzAgKiA2MH1gLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBgXFxcbjw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cInV0Zi04XCIgPz5cbjxEOmxvY2tpbmZvIHhtbG5zOkQ9J0RBVjonPlxuICA8RDpsb2Nrc2NvcGU+PEQ6ZXhjbHVzaXZlLz48L0Q6bG9ja3Njb3BlPlxuICA8RDpsb2NrdHlwZT48RDp3cml0ZS8+PC9EOmxvY2t0eXBlPlxuPC9EOmxvY2tpbmZvPmAsXG4gICAgICB9KVxuICAgICAgLnRoZW4oeG1sID0+IHtcbiAgICAgICAgY29uc3QgZG9jID0gWE5vZGUuZnJvbVhNTCh4bWwpO1xuICAgICAgICBjb25zdCBsb2NrID0gZG9jLmZpbmQoJ0RBVjpwcm9wJylcbiAgICAgICAgLmZpbmQoJ0RBVjpsb2NrZGlzY292ZXJ5JylcbiAgICAgICAgLmZpbmQoJ0RBVjphY3RpdmVsb2NrJylcbiAgICAgICAgLmZpbmQoJ0RBVjpsb2NrdG9rZW4nKVxuICAgICAgICAuZmluZCgnREFWOmhyZWYnKVxuICAgICAgICAudGV4dCgpO1xuICAgICAgICB0aGlzLmxvZygnQWNxdWlyZWQgbG9jazonLCBsb2NrKTtcbiAgICAgICAgdGhpcy5jb25maWcuc2V0KHtcbiAgICAgICAgICBsb2NrLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbG9jayA9IHRoaXMuY29uZmlnLmdldCgnbG9jaycpO1xuICAgIGlmIChsb2NrKSB7XG4gICAgICB0aGlzLmxvZygnUmVmcmVzaCBsb2NrOicsIGxvY2spO1xuICAgICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgICBtZXRob2Q6ICdMT0NLJyxcbiAgICAgICAgdXJsOiBzZXJ2ZXJVcmwsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBJZjogYCg8JHtsb2NrfT4pYCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdSZWZyZXNoZWQgbG9jazonLCBsb2NrKTtcbiAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MTIpIHtcbiAgICAgICAgICB0aGlzLmxvZygnUmVmcmVzaCBsb2NrIGVycm9yJyk7XG4gICAgICAgICAgdGhpcy5jb25maWcuc2V0KHsgbG9jazogbnVsbCB9KTtcbiAgICAgICAgICAvLyBQcmVjb25kaXRpb24gRmFpbGVkXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2soKTtcbiAgfSxcbiAgcmVsZWFzZUxvY2soKSB7XG4gICAgY29uc3QgbG9jayA9IHRoaXMuY29uZmlnLmdldCgnbG9jaycpO1xuICAgIGlmIChsb2NrKSB7XG4gICAgICBjb25zdCB7IHNlcnZlclVybCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgdGhpcy5sb2coJ1JlbGVhc2UgbG9jazonLCBsb2NrKTtcbiAgICAgIHJldHVybiB0aGlzLmxvYWREYXRhKHtcbiAgICAgICAgbWV0aG9kOiAnVU5MT0NLJyxcbiAgICAgICAgdXJsOiBzZXJ2ZXJVcmwsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnTG9jay1Ub2tlbic6IGA8JHtsb2NrfT5gLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ1JlbGVhc2VkIGxvY2snKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ1JlbGVhc2UgbG9jayBlcnJvcicpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5jb25maWcuc2V0KHsgbG9jazogbnVsbCB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgKi9cbiAgbGlzdCgpIHtcbiAgICBjb25zdCB7IHNlcnZlclVybCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG1rZGlyID0gKCkgPT4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdNS0NPTCcsXG4gICAgICB1cmw6IHNlcnZlclVybCxcbiAgICB9KTtcbiAgICBjb25zdCByZWFkZGlyID0gKCkgPT4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdQUk9QRklORCcsXG4gICAgICB1cmw6IHNlcnZlclVybCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgZGVwdGg6ICcxJyxcbiAgICAgIH0sXG4gICAgfSlcbiAgICAudGhlbigoeG1sKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBYTm9kZS5mcm9tWE1MKHhtbCk7XG4gICAgICBjb25zdCBpdGVtcyA9IGRvYy5jaGlsZHJlbigpWzBdXG4gICAgICAubWFwKChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBub2RlLmZpbmQoJ0RBVjpwcm9wc3RhdCcpLmZpbmQoJ0RBVjpwcm9wJyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwcm9wLmZpbmQoJ0RBVjpyZXNvdXJjZXR5cGUnKS5maW5kKCdEQVY6Y29sbGVjdGlvbicpID8gJ2RpcmVjdG9yeScgOiAnZmlsZSc7XG4gICAgICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICBsZXQgZGlzcGxheU5hbWU7XG4gICAgICAgICAgY29uc3QgZGlzcGxheU5hbWVOb2RlID0gcHJvcC5maW5kKCdEQVY6ZGlzcGxheW5hbWUnKTtcblxuICAgICAgICAgIGlmIChkaXNwbGF5TmFtZU5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZU5vZGUudGV4dCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gbm9kZS5maW5kKCdEQVY6aHJlZicpLnRleHQoKTtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGhyZWYuc3Vic3RyaW5nKGhyZWYubGFzdEluZGV4T2YoJy8nKSArIDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNTY3JpcHRGaWxlKGRpc3BsYXlOYW1lKSkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHByb3AuZmluZCgnREFWOmdldGNvbnRlbnRsZW5ndGgnKTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUoe1xuICAgICAgICAgICAgICBuYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgc2l6ZTogc2l6ZSA/ICtzaXplLnRleHQoKSA6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVhZGRpcigpXG4gICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIG1rZGlyKCkudGhlbihyZWFkZGlyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0KGl0ZW0pIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0SXRlbUZpbGVuYW1lKGl0ZW0pO1xuICAgIGNvbnN0IHsgc2VydmVyVXJsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgdXJsOiBzZXJ2ZXJVcmwgKyBuYW1lLFxuICAgIH0pO1xuICB9LFxuICBwdXQoaXRlbSwgZGF0YSkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJdGVtRmlsZW5hbWUoaXRlbSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbicsXG4gICAgfTtcbiAgICBjb25zdCBsb2NrID0gdGhpcy5jb25maWcuZ2V0KCdsb2NrJyk7XG4gICAgaWYgKGxvY2spIGhlYWRlcnMuSWYgPSBgKDwke2xvY2t9PilgO1xuICAgIGNvbnN0IHsgc2VydmVyVXJsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHRoaXMubG9hZERhdGEoe1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIHVybDogc2VydmVyVXJsICsgbmFtZSxcbiAgICAgIGJvZHk6IGRhdGEsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pO1xuICB9LFxuICByZW1vdmUoaXRlbSkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJdGVtRmlsZW5hbWUoaXRlbSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGNvbnN0IGxvY2sgPSB0aGlzLmNvbmZpZy5nZXQoJ2xvY2snKTtcbiAgICBpZiAobG9jaykgaGVhZGVycy5JZiA9IGAoPCR7bG9ja30+KWA7XG4gICAgY29uc3QgeyBzZXJ2ZXJVcmwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gdGhpcy5sb2FkRGF0YSh7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgdXJsOiBzZXJ2ZXJVcmwgKyBuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcbiAgfSxcbn0pO1xucmVnaXN0ZXIoV2ViREFWKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplKGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgc2l6ZTogaXRlbS5zaXplLFxuICAgIHVyaTogZ2V0VVJJKGl0ZW0ubmFtZSksXG4gIH07XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vLyByZWZlciBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qc1xuXG5mdW5jdGlvbiByZW1vdmVQYWRkaW5nKGJ1ZmZlcikge1xuICBjb25zdCBvdXRwdXRCeXRlcyA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nQnl0ZXMgPSBvdXRwdXRCeXRlcyAmJiAobmV3IERhdGFWaWV3KGJ1ZmZlcikpLmdldFVpbnQ4KG91dHB1dEJ5dGVzIC0gMSk7XG4gIGlmIChwYWRkaW5nQnl0ZXMpIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIG91dHB1dEJ5dGVzIC0gcGFkZGluZ0J5dGVzKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuXG5leHBvcnQgY29uc3QgQUVTRGVjcnlwdG9yID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcbiAgICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cbiAgICAgIC8vIENoYW5nZXMgZHVyaW5nIHJ1bnRpbWVcbiAgICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuXG4gICAgICB0aGlzLmluaXRUYWJsZSgpO1xuICAgIH0sXG5cbiAgICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG4gICAgdWludDhBcnJheVRvVWludDMyQXJyYXlfKGFycmF5QnVmZmVyKSB7XG4gICAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgICBsZXQgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgIH0sXG5cbiAgICBpbml0VGFibGUoKSB7XG4gICAgICBsZXQgc0JveCA9IHRoaXMuc0JveDtcbiAgICAgIGxldCBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgICAgbGV0IHN1Yk1peCA9IHRoaXMuc3ViTWl4O1xuICAgICAgbGV0IHN1Yk1peDAgPSBzdWJNaXhbMF07XG4gICAgICBsZXQgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICAgIGxldCBzdWJNaXgyID0gc3ViTWl4WzJdO1xuICAgICAgbGV0IHN1Yk1peDMgPSBzdWJNaXhbM107XG4gICAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgICBsZXQgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgICBsZXQgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcblxuICAgICAgbGV0IGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICAgIGxldCB4ID0gMDtcbiAgICAgIGxldCB4aSA9IDA7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBsZXQgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcbiAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICAgICAgICBzQm94W3hdID0gc3g7XG4gICAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgICAgIGxldCB4MiA9IGRbeF07XG4gICAgICAgIGxldCB4NCA9IGRbeDJdO1xuICAgICAgICBsZXQgeDggPSBkW3g0XTtcblxuICAgICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgICBsZXQgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG4gICAgICAgIHN1Yk1peDBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICAgIHN1Yk1peDFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgICBzdWJNaXgyW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgICBzdWJNaXgzW3hdID0gdDtcblxuICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcbiAgICAgICAgaW52U3ViTWl4MFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICAgIGludlN1Yk1peDFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgICAgaW52U3ViTWl4MltzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gICAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcblxuICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgICBpZiAoIXgpIHtcbiAgICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZXhwYW5kS2V5KGtleUJ1ZmZlcikge1xuICAgICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICAgIGxldCBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xuICAgICAgbGV0IHNhbWVLZXkgPSB0cnVlO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgIHdoaWxlIChvZmZzZXQgPCBrZXkubGVuZ3RoICYmIHNhbWVLZXkpIHtcbiAgICAgICAgc2FtZUtleSA9IChrZXlbb2Zmc2V0XSA9PT0gdGhpcy5rZXlbb2Zmc2V0XSk7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2FtZUtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgbGV0IGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xuXG4gICAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBrc1Jvd3MgPSB0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNDtcbiAgICAgIGxldCBrc1JvdztcbiAgICAgIGxldCBpbnZLc1JvdztcblxuICAgICAgbGV0IGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgICAgbGV0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgICAgbGV0IHNib3ggPSB0aGlzLnNCb3g7XG4gICAgICBsZXQgcmNvbiA9IHRoaXMucmNvbjtcblxuICAgICAgbGV0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgICBsZXQgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICAgIGxldCBwcmV2O1xuICAgICAgbGV0IHQ7XG5cbiAgICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IHByZXY7XG5cbiAgICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcblxuICAgICAgICAgIC8vIE1peCBSY29uXG4gICAgICAgICAgdCBePSByY29uWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuICAgICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXiBpbnZTdWJNaXgxW3Nib3hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFsodCA+Pj4gOCkgJiAweGZmXV0gXiBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHdvcmQpIHtcbiAgICAgIHJldHVybiAod29yZCA8PCAyNCkgfCAoKHdvcmQgJiAweGZmMDApIDw8IDgpIHwgKCh3b3JkICYgMHhmZjAwMDApID4+IDgpIHwgKHdvcmQgPj4+IDI0KTtcbiAgICB9LFxuXG4gICAgZGVjcnlwdChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWLCByZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIGxldCBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgICBsZXQgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcblxuICAgICAgbGV0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgICBsZXQgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICAgIGxldCBpbml0VmVjdG9yID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oYWVzSVYpO1xuICAgICAgbGV0IGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcbiAgICAgIGxldCBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgICBsZXQgaW5pdFZlY3RvcjIgPSBpbml0VmVjdG9yWzJdO1xuICAgICAgbGV0IGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcblxuICAgICAgbGV0IGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcbiAgICAgIGxldCBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcblxuICAgICAgbGV0IHQwLCB0MSwgdDIsIHQzO1xuICAgICAgbGV0IHMwLCBzMSwgczIsIHMzO1xuICAgICAgbGV0IGlucHV0V29yZHMwLCBpbnB1dFdvcmRzMSwgaW5wdXRXb3JkczIsIGlucHV0V29yZHMzO1xuXG4gICAgICBsZXQga3NSb3csIGk7XG4gICAgICBsZXQgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG5cbiAgICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xuICAgICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XG4gICAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG5cbiAgICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgICBzMSA9IGlucHV0V29yZHMzIF4gaW52S2V5U2NoZWR1bGVbMV07XG4gICAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuXG4gICAgICAgIGtzUm93ID0gNDtcblxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcbiAgICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMxID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczIgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMyID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczMgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMyA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMwID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczAgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMSA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgICBzMCA9IHQwO1xuICAgICAgICAgIHMxID0gdDE7XG4gICAgICAgICAgczIgPSB0MjtcbiAgICAgICAgICBzMyA9IHQzO1xuXG4gICAgICAgICAga3NSb3cgPSBrc1JvdyArIDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICAgICAgdDAgPSAoKGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczEgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMyID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MzICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9ICgoaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMiA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczMgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczAgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICB0MiA9ICgoaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMyA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczAgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczEgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICB0MyA9ICgoaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMCA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczEgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczIgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICBrc1JvdyA9IGtzUm93ICsgMztcblxuICAgICAgICAvLyBXcml0ZVxuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXRdID0gc3dhcFdvcmQodDAgXiBpbml0VmVjdG9yMCk7XG4gICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDNdID0gc3dhcFdvcmQodDEgXiBpbml0VmVjdG9yMyk7XG5cbiAgICAgICAgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG4gICAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICAgIGluaXRWZWN0b3IyID0gaW5wdXRXb3JkczI7XG4gICAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG5cbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgNDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZVBLQ1M3UGFkZGluZyA/IHJlbW92ZVBhZGRpbmcob3V0cHV0SW50MzIuYnVmZmVyKSA6IG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgICB9LFxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5rZXlTaXplID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuc0JveCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW52U0JveCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbnZTdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmtleVNjaGVkdWxlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5yY29uID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gIH1cbn1cblxuIiwiaW1wb3J0IGluaXRDYWNoZSBmcm9tICcjL2NvbW1vbi9jYWNoZSc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5cbmNvbnN0IGNhY2hlID0gaW5pdENhY2hlKHtcbiAgLyogS2VlcGluZyB0aGUgZGF0YSBmb3Igb25lIGhvdXIgc2luY2UgY2hyb21lLnN0b3JhZ2UubG9jYWwgaXMgaW5zYW5lbHkgc2xvdyBpbiBDaHJvbWUsXG4gICAgIGl0IGNhbiB0YWtlcyBzZWNvbmRzIHRvIHJlYWQgaXQgd2hlbiBpbmplY3RpbmcgdGFicyB3aXRoIGEgYmlnIHNjcmlwdC92YWx1ZSwgd2hpY2ggZGVsYXlzXG4gICAgIGFsbCBvdGhlciBzY3JpcHRzIGluIHRoaXMgdGFiIGFuZCB0aGV5IHdpbGwgbmV2ZXIgYmUgYWJsZSB0byBydW4gYXQgZG9jdW1lbnQtc3RhcnQuICovXG4gIGxpZmV0aW1lOiA2MCAqIDYwICogMTAwMCxcbn0pO1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIENhY2hlTG9hZChkYXRhKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChkYXRhKSB8fCBudWxsO1xuICB9LFxuICBDYWNoZUhpdChkYXRhKSB7XG4gICAgY2FjaGUuaGl0KGRhdGEua2V5LCBkYXRhLmxpZmV0aW1lKTtcbiAgfSxcbiAgQ2FjaGVQb3Aoa2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcChrZXkpIHx8IG51bGw7XG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY2FjaGU7XG4iLCJpbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5cbmNvbnN0IHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbmxldCBjbGlwYm9hcmREYXRhO1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIFNldENsaXBib2FyZChkYXRhKSB7XG4gICAgY2xpcGJvYXJkRGF0YSA9IGRhdGE7XG4gICAgdGV4dGFyZWEuZm9jdXMoKTtcbiAgICBjb25zdCByZXQgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScsIGZhbHNlLCBudWxsKTtcbiAgICBpZiAoIXJldCAmJiBwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgY29uc29sZS53YXJuKCdDb3B5IGZhaWxlZCEnKTtcbiAgICB9XG4gIH0sXG59KTtcblxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBlID0+IHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IGNsaXBib2FyZERhdGE7XG4gIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKHR5cGUgfHwgJ3RleHQvcGxhaW4nLCBkYXRhKTtcbn0pO1xuIiwiaW1wb3J0IHtcbiAgY29tcGFyZVZlcnNpb24sIGkxOG4sIGdldEZ1bGxVcmwsIGdldFNjcmlwdE5hbWUsIGlzUmVtb3RlLCBzZW5kQ21kLCB0cnVlSm9pbixcbn0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ01EX1NDUklQVF9BREQsIENNRF9TQ1JJUFRfVVBEQVRFLCBJTkpFQ1RfUEFHRSwgSU5KRUNUX0FVVE8sIFRJTUVPVVRfV0VFSyxcbn0gZnJvbSAnIy9jb21tb24vY29uc3RzJztcbmltcG9ydCB7IGZvckVhY2hFbnRyeSwgZm9yRWFjaEtleSwgZm9yRWFjaFZhbHVlIH0gZnJvbSAnIy9jb21tb24vb2JqZWN0JztcbmltcG9ydCBzdG9yYWdlIGZyb20gJyMvY29tbW9uL3N0b3JhZ2UnO1xuaW1wb3J0IHBsdWdpbkV2ZW50cyBmcm9tICcuLi9wbHVnaW4vZXZlbnRzJztcbmltcG9ydCB7IGdldE5hbWVVUkksIHBhcnNlTWV0YSwgbmV3U2NyaXB0LCBnZXREZWZhdWx0Q3VzdG9tIH0gZnJvbSAnLi9zY3JpcHQnO1xuaW1wb3J0IHsgdGVzdFNjcmlwdCwgdGVzdEJsYWNrbGlzdCB9IGZyb20gJy4vdGVzdGVyJztcbmltcG9ydCB7IHByZUluaXRpYWxpemUgfSBmcm9tICcuL2luaXQnO1xuaW1wb3J0IHsgY29tbWFuZHMsIG5vdGlmeSB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgcGF0Y2hEQiBmcm9tICcuL3BhdGNoLWRiJztcbmltcG9ydCB7IHNldE9wdGlvbiB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgJy4vc3RvcmFnZS1mZXRjaCc7XG5pbXBvcnQgZGF0YUNhY2hlIGZyb20gJy4vY2FjaGUnO1xuXG5jb25zdCBzdG9yZSA9IHt9O1xuc3RvcmFnZS5iYXNlLnNldERhdGFDYWNoZShkYXRhQ2FjaGUpO1xuc3RvcmFnZS5zY3JpcHQub25EdW1wID0gKGl0ZW0pID0+IHtcbiAgc3RvcmUuc2NyaXB0TWFwW2l0ZW0ucHJvcHMuaWRdID0gaXRlbTtcbn07XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgQ2hlY2tQb3NpdGlvbjogc29ydFNjcmlwdHMsXG4gIENoZWNrUmVtb3ZlOiBjaGVja1JlbW92ZSxcbiAgLyoqIEByZXR1cm4ge1ZNU2NyaXB0fSAqL1xuICBHZXRTY3JpcHQ6IGdldFNjcmlwdCxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8eyBpdGVtczogVk1TY3JpcHRbXSwgdmFsdWVzPyB9Pn0gKi9cbiAgYXN5bmMgRXhwb3J0WmlwKHsgdmFsdWVzIH0pIHtcbiAgICBjb25zdCBzY3JpcHRzID0gZ2V0U2NyaXB0cygpO1xuICAgIGNvbnN0IGlkcyA9IHNjcmlwdHMubWFwKGdldFByb3BzSWQpO1xuICAgIGNvbnN0IGNvZGVNYXAgPSBhd2FpdCBzdG9yYWdlLmNvZGUuZ2V0TXVsdGkoaWRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXM6IHNjcmlwdHMubWFwKHNjcmlwdCA9PiAoeyBzY3JpcHQsIGNvZGU6IGNvZGVNYXBbc2NyaXB0LnByb3BzLmlkXSB9KSksXG4gICAgICB2YWx1ZXM6IHZhbHVlcyA/IGF3YWl0IHN0b3JhZ2UudmFsdWUuZ2V0TXVsdGkoaWRzKSA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9LFxuICAvKiogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fSAqL1xuICBHZXRTY3JpcHRDb2RlKGlkKSB7XG4gICAgcmV0dXJuIHN0b3JhZ2UuY29kZS5nZXRPbmUoaWQpO1xuICB9LFxuICBHZXRTY3JpcHRWZXIob3B0cykge1xuICAgIGNvbnN0IHNjcmlwdCA9IGdldFNjcmlwdChvcHRzKTtcbiAgICByZXR1cm4gc2NyaXB0ICYmICFzY3JpcHQuY29uZmlnLnJlbW92ZWRcbiAgICAgID8gc2NyaXB0Lm1ldGEudmVyc2lvblxuICAgICAgOiBudWxsO1xuICB9LFxuICAvKiogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gKi9cbiAgTWFya1JlbW92ZWQoeyBpZCwgcmVtb3ZlZCB9KSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNjcmlwdEluZm8oaWQsIHtcbiAgICAgIGNvbmZpZzogeyByZW1vdmVkOiByZW1vdmVkID8gMSA6IDAgfSxcbiAgICAgIHByb3BzOiB7IGxhc3RNb2RpZmllZDogRGF0ZS5ub3coKSB9LFxuICAgIH0pO1xuICB9LFxuICAvKiogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fSAqL1xuICBNb3ZlKHsgaWQsIG9mZnNldCB9KSB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZ2V0U2NyaXB0QnlJZChpZCk7XG4gICAgY29uc3QgaW5kZXggPSBzdG9yZS5zY3JpcHRzLmluZGV4T2Yoc2NyaXB0KTtcbiAgICBzdG9yZS5zY3JpcHRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgc3RvcmUuc2NyaXB0cy5zcGxpY2UoaW5kZXggKyBvZmZzZXQsIDAsIHNjcmlwdCk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVBvc2l0aW9uKCk7XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSAqL1xuICBhc3luYyBSZW1vdmVTY3JpcHQoaWQpIHtcbiAgICBjb25zdCBpID0gc3RvcmUuc2NyaXB0cy5pbmRleE9mKGdldFNjcmlwdEJ5SWQoaWQpKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBzdG9yZS5zY3JpcHRzLnNwbGljZShpLCAxKTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgc3RvcmFnZS5zY3JpcHQucmVtb3ZlKGlkKSxcbiAgICAgICAgc3RvcmFnZS5jb2RlLnJlbW92ZShpZCksXG4gICAgICAgIHN0b3JhZ2UudmFsdWUucmVtb3ZlKGlkKSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VuZENtZCgnUmVtb3ZlU2NyaXB0JywgaWQpO1xuICB9LFxuICBQYXJzZU1ldGE6IHBhcnNlTWV0YSxcbiAgUGFyc2VTY3JpcHQ6IHBhcnNlU2NyaXB0LFxuICAvKiogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gKi9cbiAgVXBkYXRlU2NyaXB0SW5mbyh7IGlkLCBjb25maWcsIGN1c3RvbSB9KSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNjcmlwdEluZm8oaWQsIHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGN1c3RvbSxcbiAgICAgIHByb3BzOiB7IGxhc3RNb2RpZmllZDogRGF0ZS5ub3coKSB9LFxuICAgIH0pO1xuICB9LFxuICAvKiogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fSAqL1xuICBWYWN1dW06IHZhY3V1bSxcbn0pO1xuXG5wcmVJbml0aWFsaXplLnB1c2goYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IHZlcnNpb246IGxhc3RWZXJzaW9uIH0gPSBhd2FpdCBicm93c2VyLnN0b3JhZ2UubG9jYWwuZ2V0KCd2ZXJzaW9uJyk7XG4gIGNvbnN0IHZlcnNpb24gPSBwcm9jZXNzLmVudi5WTV9WRVI7XG4gIGlmICghbGFzdFZlcnNpb24pIGF3YWl0IHBhdGNoREIoKTtcbiAgaWYgKHZlcnNpb24gIT09IGxhc3RWZXJzaW9uKSBicm93c2VyLnN0b3JhZ2UubG9jYWwuc2V0KHsgdmVyc2lvbiB9KTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGJyb3dzZXIuc3RvcmFnZS5sb2NhbC5nZXQoKTtcbiAgY29uc3Qgc2NyaXB0cyA9IFtdO1xuICBjb25zdCBzdG9yZUluZm8gPSB7XG4gICAgaWQ6IDAsXG4gICAgcG9zaXRpb246IDAsXG4gIH07XG4gIGNvbnN0IGlkTWFwID0ge307XG4gIGNvbnN0IHVyaU1hcCA9IHt9O1xuICBjb25zdCBtb2RzID0gW107XG4gIGNvbnN0IHJlc1VybHMgPSBbXTtcbiAgLyoqIEB0aGlzIFZNU2NyaXB0Q3VzdG9tLnBhdGhNYXAgKi9cbiAgY29uc3QgcmVtZW1iZXJVcmwgPSBmdW5jdGlvbiBfKHVybCkgeyByZXNVcmxzLnB1c2godGhpc1t1cmxdIHx8IHVybCk7IH07XG4gIGRhdGE6OmZvckVhY2hFbnRyeSgoW2tleSwgc2NyaXB0XSkgPT4ge1xuICAgIGRhdGFDYWNoZS5wdXQoa2V5LCBzY3JpcHQpO1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChzdG9yYWdlLnNjcmlwdC5wcmVmaXgpKSB7XG4gICAgICAvLyB7XG4gICAgICAvLyAgIG1ldGEsXG4gICAgICAvLyAgIGN1c3RvbSxcbiAgICAgIC8vICAgcHJvcHM6IHsgaWQsIHBvc2l0aW9uLCB1cmkgfSxcbiAgICAgIC8vICAgY29uZmlnOiB7IGVuYWJsZWQsIHNob3VsZFVwZGF0ZSB9LFxuICAgICAgLy8gfVxuICAgICAgY29uc3QgaWQgPSBnZXRJbnQoa2V5LnNsaWNlKHN0b3JhZ2Uuc2NyaXB0LnByZWZpeC5sZW5ndGgpKTtcbiAgICAgIGlmICghaWQgfHwgaWRNYXBbaWRdKSB7XG4gICAgICAgIC8vIElEIGNvbmZsaWN0cyFcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4sIGRpc2NhcmQgZHVwbGljYXRlcy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWRNYXBbaWRdID0gc2NyaXB0O1xuICAgICAgY29uc3QgdXJpID0gZ2V0TmFtZVVSSShzY3JpcHQpO1xuICAgICAgaWYgKHVyaU1hcFt1cmldKSB7XG4gICAgICAgIC8vIE5hbWVzcGFjZSBjb25mbGljdHMhXG4gICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuLCBkaXNjYXJkIGR1cGxpY2F0ZXMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVyaU1hcFt1cmldID0gc2NyaXB0O1xuICAgICAgc2NyaXB0LnByb3BzID0ge1xuICAgICAgICAuLi5zY3JpcHQucHJvcHMsXG4gICAgICAgIGlkLFxuICAgICAgICB1cmksXG4gICAgICB9O1xuICAgICAgc2NyaXB0LmN1c3RvbSA9IHtcbiAgICAgICAgLi4uZ2V0RGVmYXVsdEN1c3RvbSgpLFxuICAgICAgICAuLi5zY3JpcHQuY3VzdG9tLFxuICAgICAgfTtcbiAgICAgIHN0b3JlSW5mby5pZCA9IE1hdGgubWF4KHN0b3JlSW5mby5pZCwgaWQpO1xuICAgICAgc3RvcmVJbmZvLnBvc2l0aW9uID0gTWF0aC5tYXgoc3RvcmVJbmZvLnBvc2l0aW9uLCBnZXRJbnQoc2NyaXB0LnByb3BzLnBvc2l0aW9uKSk7XG4gICAgICBzY3JpcHRzLnB1c2goc2NyaXB0KTtcbiAgICAgIC8vIGxpc3RpbmcgYWxsIGtub3duIHJlc291cmNlIHVybHMgaW4gb3JkZXIgdG8gcmVtb3ZlIHVudXNlZCBtb2Qga2V5c1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXN0b206IHsgcGF0aE1hcCA9IHt9IH0gPSB7fSxcbiAgICAgICAgbWV0YSA9IHNjcmlwdC5tZXRhID0ge30sXG4gICAgICB9ID0gc2NyaXB0O1xuICAgICAgbWV0YS5ncmFudCA9IFsuLi5uZXcgU2V0KG1ldGEuZ3JhbnQgfHwgW10pXTsgLy8gZGVkdXBsaWNhdGVcbiAgICAgIG1ldGEucmVxdWlyZT8uZm9yRWFjaChyZW1lbWJlclVybCwgcGF0aE1hcCk7XG4gICAgICBPYmplY3QudmFsdWVzKG1ldGEucmVzb3VyY2VzIHx8IHt9KS5mb3JFYWNoKHJlbWVtYmVyVXJsLCBwYXRoTWFwKTtcbiAgICAgIHBhdGhNYXA6OnJlbWVtYmVyVXJsKG1ldGEuaWNvbik7XG4gICAgfSBlbHNlIGlmIChrZXkuc3RhcnRzV2l0aChzdG9yYWdlLm1vZC5wcmVmaXgpKSB7XG4gICAgICBtb2RzLnB1c2goa2V5LnNsaWNlKHN0b3JhZ2UubW9kLnByZWZpeC5sZW5ndGgpKTtcbiAgICB9XG4gIH0pO1xuICBzdG9yYWdlLm1vZC5yZW1vdmVNdWx0aShtb2RzLmZpbHRlcih1cmwgPT4gIXJlc1VybHMuaW5jbHVkZXModXJsKSkpO1xuICBPYmplY3QuYXNzaWduKHN0b3JlLCB7XG4gICAgc2NyaXB0cyxcbiAgICBzdG9yZUluZm8sXG4gICAgc2NyaXB0TWFwOiBzY3JpcHRzLnJlZHVjZSgobWFwLCBpdGVtKSA9PiB7XG4gICAgICBtYXBbaXRlbS5wcm9wcy5pZF0gPSBpdGVtO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCB7fSksXG4gIH0pO1xuICAvLyBTd2l0Y2ggZGVmYXVsdEluamVjdEludG8gZnJvbSBgcGFnZWAgdG8gYGF1dG9gIHdoZW4gdXBncmFkaW5nIFZNMi4xMi43IG9yIG9sZGVyXG4gIGlmICh2ZXJzaW9uICE9PSBsYXN0VmVyc2lvblxuICAmJiBJU19GSVJFRk9YXG4gICYmIGRhdGEub3B0aW9ucz8uZGVmYXVsdEluamVjdEludG8gPT09IElOSkVDVF9QQUdFXG4gICYmIGNvbXBhcmVWZXJzaW9uKGxhc3RWZXJzaW9uLCAnMi4xMi43JykgPD0gMCkge1xuICAgIHNldE9wdGlvbignZGVmYXVsdEluamVjdEludG8nLCBJTkpFQ1RfQVVUTyk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgY29uc29sZS5sb2coJ3N0b3JlOicsIHN0b3JlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH1cbiAgdmFjdXVtKGRhdGEpO1xuICByZXR1cm4gc29ydFNjcmlwdHMoKTtcbn0pO1xuXG4vKiogQHJldHVybiB7bnVtYmVyfSAqL1xuZnVuY3Rpb24gZ2V0SW50KHZhbCkge1xuICByZXR1cm4gK3ZhbCB8fCAwO1xufVxuXG4vKiogQHJldHVybiB7P251bWJlcn0gKi9cbmZ1bmN0aW9uIGdldFByb3BzSWQoc2NyaXB0KSB7XG4gIHJldHVybiBzY3JpcHQ/LnByb3BzLmlkO1xufVxuXG4vKiogQHJldHVybiB7dm9pZH0gKi9cbmZ1bmN0aW9uIHVwZGF0ZUxhc3RNb2RpZmllZCgpIHtcbiAgc2V0T3B0aW9uKCdsYXN0TW9kaWZpZWQnLCBEYXRlLm5vdygpKTtcbn1cblxuLyoqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBub3JtYWxpemVQb3NpdGlvbigpIHtcbiAgY29uc3QgdXBkYXRlcyA9IHN0b3JlLnNjcmlwdHMuZmlsdGVyKCh7IHByb3BzIH0sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCArIDE7XG4gICAgY29uc3QgcmVzID0gcHJvcHMucG9zaXRpb24gIT09IHBvc2l0aW9uO1xuICAgIGlmIChyZXMpIHByb3BzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgcmV0dXJuIHJlcztcbiAgfSk7XG4gIHN0b3JlLnN0b3JlSW5mby5wb3NpdGlvbiA9IHN0b3JlLnNjcmlwdHMubGVuZ3RoO1xuICBpZiAodXBkYXRlcy5sZW5ndGgpIHtcbiAgICBhd2FpdCBzdG9yYWdlLnNjcmlwdC5kdW1wKHVwZGF0ZXMpO1xuICAgIHVwZGF0ZUxhc3RNb2RpZmllZCgpO1xuICB9XG4gIHJldHVybiB1cGRhdGVzLmxlbmd0aDtcbn1cblxuLyoqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzb3J0U2NyaXB0cygpIHtcbiAgc3RvcmUuc2NyaXB0cy5zb3J0KChhLCBiKSA9PiBnZXRJbnQoYS5wcm9wcy5wb3NpdGlvbikgLSBnZXRJbnQoYi5wcm9wcy5wb3NpdGlvbikpO1xuICBjb25zdCBjaGFuZ2VkID0gYXdhaXQgbm9ybWFsaXplUG9zaXRpb24oKTtcbiAgc2VuZENtZCgnU2NyaXB0c1VwZGF0ZWQnLCBudWxsKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbi8qKiBAcmV0dXJuIHs/Vk1TY3JpcHR9ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NyaXB0QnlJZChpZCkge1xuICByZXR1cm4gc3RvcmUuc2NyaXB0TWFwW2lkXTtcbn1cblxuLyoqIEByZXR1cm4gez9WTVNjcmlwdH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JpcHQoeyBpZCwgdXJpLCBtZXRhIH0pIHtcbiAgbGV0IHNjcmlwdDtcbiAgaWYgKGlkKSB7XG4gICAgc2NyaXB0ID0gZ2V0U2NyaXB0QnlJZChpZCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCF1cmkpIHVyaSA9IGdldE5hbWVVUkkoeyBtZXRhLCBpZDogJ0BAc2hvdWxkLWhhdmUtbmFtZScgfSk7XG4gICAgc2NyaXB0ID0gc3RvcmUuc2NyaXB0cy5maW5kKCh7IHByb3BzIH0pID0+IHVyaSA9PT0gcHJvcHMudXJpKTtcbiAgfVxuICByZXR1cm4gc2NyaXB0O1xufVxuXG4vKiogQHJldHVybiB7Vk1TY3JpcHRbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JpcHRzKCkge1xuICByZXR1cm4gc3RvcmUuc2NyaXB0cy5maWx0ZXIoc2NyaXB0ID0+ICFzY3JpcHQuY29uZmlnLnJlbW92ZWQpO1xufVxuXG4vKipcbiAqIEBkZXNjIExvYWQgdmFsdWVzIGZvciBiYXRjaCB1cGRhdGVzLlxuICogQHBhcmFtIHtudW1iZXJbXX0gaWRzXG4gKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZVN0b3Jlc0J5SWRzKGlkcykge1xuICByZXR1cm4gc3RvcmFnZS52YWx1ZS5nZXRNdWx0aShpZHMpO1xufVxuXG4vKipcbiAqIEBkZXNjIER1bXAgdmFsdWVzIGZvciBiYXRjaCB1cGRhdGVzLlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlRGljdCB7IGlkMTogdmFsdWUxLCBpZDI6IHZhbHVlMiwgLi4uIH1cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGR1bXBWYWx1ZVN0b3Jlcyh2YWx1ZURpY3QpIHtcbiAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSBjb25zb2xlLmluZm8oJ1VwZGF0ZSB2YWx1ZSBzdG9yZXMnLCB2YWx1ZURpY3QpO1xuICBhd2FpdCBzdG9yYWdlLnZhbHVlLmR1bXAodmFsdWVEaWN0KTtcbiAgcmV0dXJuIHZhbHVlRGljdDtcbn1cblxuZXhwb3J0IGNvbnN0IEVOVl9DQUNIRV9LRVlTID0gJ2NhY2hlS2V5cyc7XG5leHBvcnQgY29uc3QgRU5WX1JFUV9LRVlTID0gJ3JlcUtleXMnO1xuZXhwb3J0IGNvbnN0IEVOVl9WQUxVRV9JRFMgPSAndmFsdWVJZHMnO1xuY29uc3QgR01WQUxVRVNfUkUgPSAvXkdNW18uXShsaXN0VmFsdWVzfChbZ3NdZXR8ZGVsZXRlKVZhbHVlKSQvO1xuY29uc3QgUlVOX0FUX1JFID0gL15kb2N1bWVudC0oc3RhcnR8Ym9keXxlbmR8aWRsZSkkLztcbi8qKlxuICogQGRlc2MgR2V0IHNjcmlwdHMgdG8gYmUgaW5qZWN0ZWQgdG8gcGFnZSB3aXRoIHNwZWNpZmljIFVSTC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNjcmlwdHNCeVVSTCh1cmwsIGlzVG9wKSB7XG4gIGNvbnN0IGFsbFNjcmlwdHMgPSB0ZXN0QmxhY2tsaXN0KHVybClcbiAgICA/IFtdXG4gICAgOiBzdG9yZS5zY3JpcHRzLmZpbHRlcihzY3JpcHQgPT4gKFxuICAgICAgIXNjcmlwdC5jb25maWcucmVtb3ZlZFxuICAgICAgJiYgKGlzVG9wIHx8ICEoc2NyaXB0LmN1c3RvbS5ub2ZyYW1lcyA/PyBzY3JpcHQubWV0YS5ub2ZyYW1lcykpXG4gICAgICAmJiB0ZXN0U2NyaXB0KHVybCwgc2NyaXB0KVxuICAgICkpO1xuICBjb25zdCBkaXNhYmxlZElkcyA9IFtdO1xuICAvKiogQG5hbWVzcGFjZSBWTVNjcmlwdEJ5VXJsRGF0YSAqL1xuICBjb25zdCBbZW52U3RhcnQsIGVudkRlbGF5ZWRdID0gWzAsIDFdLm1hcCgoKSA9PiAoe1xuICAgIGlkczogW10sXG4gICAgLyoqIEB0eXBlIHsoVk1TY3JpcHQgJiBWTUluamVjdGVkU2NyaXB0KVtdfSAqL1xuICAgIHNjcmlwdHM6IFtdLFxuICAgIFtFTlZfQ0FDSEVfS0VZU106IFtdLFxuICAgIFtFTlZfUkVRX0tFWVNdOiBbXSxcbiAgICBbRU5WX1ZBTFVFX0lEU106IFtdLFxuICB9KSk7XG4gIGFsbFNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KSA9PiB7XG4gICAgY29uc3QgeyBpZCB9ID0gc2NyaXB0LnByb3BzO1xuICAgIGlmICghc2NyaXB0LmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICBkaXNhYmxlZElkcy5wdXNoKGlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBtZXRhLCBjdXN0b20gfSA9IHNjcmlwdDtcbiAgICBjb25zdCB7IHBhdGhNYXAgPSBidWlsZFBhdGhNYXAoc2NyaXB0KSB9ID0gY3VzdG9tO1xuICAgIGNvbnN0IHJ1bkF0ID0gYCR7Y3VzdG9tLnJ1bkF0IHx8IG1ldGEucnVuQXQgfHwgJyd9YC5tYXRjaChSVU5fQVRfUkUpPy5bMV0gfHwgJ2VuZCc7XG4gICAgY29uc3QgZW52ID0gcnVuQXQgPT09ICdzdGFydCcgfHwgcnVuQXQgPT09ICdib2R5JyA/IGVudlN0YXJ0IDogZW52RGVsYXllZDtcbiAgICBlbnYuaWRzLnB1c2goaWQpO1xuICAgIGlmIChtZXRhLmdyYW50LnNvbWUoR01WQUxVRVNfUkUudGVzdCwgR01WQUxVRVNfUkUpKSB7XG4gICAgICBlbnZbRU5WX1ZBTFVFX0lEU10ucHVzaChpZCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2xpc3QsIG5hbWVdIG9mIFtcbiAgICAgIFttZXRhLnJlcXVpcmUsIEVOVl9SRVFfS0VZU10sXG4gICAgICBbT2JqZWN0LnZhbHVlcyhtZXRhLnJlc291cmNlcyksIEVOVl9DQUNIRV9LRVlTXSxcbiAgICBdKSB7XG4gICAgICBsaXN0LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAga2V5ID0gcGF0aE1hcFtrZXldIHx8IGtleTtcbiAgICAgICAgaWYgKCFlbnZTdGFydFtuYW1lXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgZW52W25hbWVdLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAbmFtZXNwYWNlIFZNSW5qZWN0ZWRTY3JpcHQgKi9cbiAgICBlbnYuc2NyaXB0cy5wdXNoKHsgLi4uc2NyaXB0LCBydW5BdCB9KTtcbiAgfSk7XG4gIGlmIChlbnZEZWxheWVkLmlkcy5sZW5ndGgpIHtcbiAgICBlbnZEZWxheWVkLnByb21pc2UgPSByZWFkRW52aXJvbm1lbnREYXRhKGVudkRlbGF5ZWQpO1xuICB9XG4gIC8qKiBAbmFtZXNwYWNlIFZNU2NyaXB0QnlVcmxEYXRhICovXG4gIHJldHVybiB7XG4gICAgLi4uZW52U3RhcnQsXG4gICAgLi4uYXdhaXQgcmVhZEVudmlyb25tZW50RGF0YShlbnZTdGFydCksXG4gICAgZGlzYWJsZWRJZHMsXG4gICAgZW52RGVsYXllZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBPYmplY3Qga2V5cyA9PSBhcmVhcyBpbiBgc3RvcmFnZWAgbW9kdWxlLlxuICogQG5hbWVzcGFjZSBWTVNjcmlwdEJ5VXJsRGF0YVxuICovXG5jb25zdCBTVE9SQUdFX1JPVVRFUyA9IE9iamVjdC5lbnRyaWVzKHtcbiAgY2FjaGU6IEVOVl9DQUNIRV9LRVlTLFxuICBjb2RlOiAnaWRzJyxcbiAgcmVxdWlyZTogRU5WX1JFUV9LRVlTLFxuICB2YWx1ZTogRU5WX1ZBTFVFX0lEUyxcbn0pO1xuY29uc3QgcmV0cmllZFN0b3JhZ2VLZXlzID0ge307XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRFbnZpcm9ubWVudERhdGEoZW52LCBpc1JldHJ5KSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgU1RPUkFHRV9ST1VURVMuZm9yRWFjaCgoW2FyZWEsIHNyY0lkc10pID0+IHtcbiAgICBlbnZbc3JjSWRzXS5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGtleXMucHVzaChzdG9yYWdlW2FyZWFdLmdldEtleShpZCkpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHN0b3JhZ2UuYmFzZS5nZXRNdWx0aShrZXlzKTtcbiAgZm9yIChjb25zdCBbYXJlYSwgc3JjSWRzXSBvZiBTVE9SQUdFX1JPVVRFUykge1xuICAgIGVudlthcmVhXSA9IHt9O1xuICAgIGZvciAoY29uc3QgaWQgb2YgZW52W3NyY0lkc10pIHtcbiAgICAgIGNvbnN0IHZhbCA9IGRhdGFbc3RvcmFnZVthcmVhXS5nZXRLZXkoaWQpXTtcbiAgICAgIGVudlthcmVhXVtpZF0gPSB2YWw7XG4gICAgICBpZiAodmFsID09IG51bGwgJiYgYXJlYSAhPT0gJ3ZhbHVlJyAmJiByZXRyaWVkU3RvcmFnZUtleXNbYXJlYSArIGlkXSAhPT0gMikge1xuICAgICAgICBjb25zdCBlcnIgPSBgVGhlIFwiJHthcmVhfVwiIHN0b3JhZ2UgaXMgbWlzc2luZyBcIiR7aWR9XCIhYDtcbiAgICAgICAgY29uc3QgZXJyMiA9ICdWYWN1dW1pbmcgZGlkIG5vdCBoZWxwLiBQbGVhc2UgcmVpbnN0YWxsIHRoZSBhZmZlY3RlZCBzY3JpcHRzLic7XG4gICAgICAgIHJldHJpZWRTdG9yYWdlS2V5c1thcmVhICsgaWRdID0gaXNSZXRyeSA/IDIgOiAxO1xuICAgICAgICBpZiAoIWlzUmV0cnkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZXJyLCAnVmFjdXVtaW5nLi4uJyk7XG4gICAgICAgICAgaWYgKGF3YWl0IHZhY3V1bSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEVudmlyb25tZW50RGF0YShlbnYsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGVyciwgZXJyMik7XG4gICAgICAgIG5vdGlmeSh7IHRpdGxlOiBlcnIsIGJvZHk6IGVycjIgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlbnY7XG59XG5cbi8qKlxuICogQGRlc2MgR2V0IGRhdGEgZm9yIGRhc2hib2FyZC5cbiAqIEByZXR1cm4ge1Byb21pc2U8eyBzY3JpcHRzOiBWTVNjcmlwdFtdLCBjYWNoZTogT2JqZWN0IH0+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGF0YShpZHMpIHtcbiAgY29uc3Qgc2NyaXB0cyA9IGlkcyA/IGlkcy5tYXAoZ2V0U2NyaXB0QnlJZCkgOiBzdG9yZS5zY3JpcHRzO1xuICByZXR1cm4ge1xuICAgIHNjcmlwdHMsXG4gICAgY2FjaGU6IGF3YWl0IGdldEljb25DYWNoZShzY3JpcHRzKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SWNvbkNhY2hlKHNjcmlwdHMpIHtcbiAgY29uc3QgaWNvblVybHMgPSBbXTtcbiAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpID0+IHtcbiAgICBjb25zdCB7IGljb24gfSA9IHNjcmlwdC5tZXRhO1xuICAgIGlmIChpc1JlbW90ZShpY29uKSkge1xuICAgICAgaWNvblVybHMucHVzaChzY3JpcHQuY3VzdG9tLnBhdGhNYXA/LltpY29uXSB8fCBpY29uKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaWNvblVybHMubGVuZ3RoXG4gICAgPyBzdG9yYWdlLmNhY2hlLmdldE11bHRpKGljb25VcmxzLCB1bmRlZmluZWQsIHN0b3JhZ2UuY2FjaGUubWFrZURhdGFVcmkpXG4gICAgOiB7fTtcbn1cblxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JlbW92ZSh7IGZvcmNlIH0gPSB7fSkge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBjb25zdCB0b1JlbW92ZSA9IHN0b3JlLnNjcmlwdHMuZmlsdGVyKHNjcmlwdCA9PiBzY3JpcHQuY29uZmlnLnJlbW92ZWQgJiYgKFxuICAgIGZvcmNlIHx8IG5vdyAtIGdldEludChzY3JpcHQucHJvcHMubGFzdE1vZGlmaWVkKSA+IFRJTUVPVVRfV0VFS1xuICApKTtcbiAgaWYgKHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgIHN0b3JlLnNjcmlwdHMgPSBzdG9yZS5zY3JpcHRzLmZpbHRlcihzY3JpcHQgPT4gIXNjcmlwdC5jb25maWcucmVtb3ZlZCk7XG4gICAgY29uc3QgaWRzID0gdG9SZW1vdmUubWFwKGdldFByb3BzSWQpO1xuICAgIHN0b3JhZ2Uuc2NyaXB0LnJlbW92ZU11bHRpKGlkcyk7XG4gICAgc3RvcmFnZS5jb2RlLnJlbW92ZU11bHRpKGlkcyk7XG4gICAgc3RvcmFnZS52YWx1ZS5yZW1vdmVNdWx0aShpZHMpO1xuICB9XG4gIHJldHVybiB0b1JlbW92ZS5sZW5ndGg7XG59XG5cbi8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXG5mdW5jdGlvbiBnZXRVVUlEKCkge1xuICBjb25zdCBybmQgPSBuZXcgVWludDE2QXJyYXkoOCk7XG4gIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJuZCk7XG4gIC8vIHh4eHh4eHh4LXh4eHgtTXh4eC1OeHh4LXh4eHh4eHh4eHh4eFxuICAvLyBXZSdyZSB1c2luZyBVVUlEdjQgdmFyaWFudCAxIHNvIE49NCBhbmQgTT04XG4gIC8vIFNlZSBmb3JtYXRfdXVpZF92M29yNSBpbiBodHRwczovL3Rvb2xzLmlldGYub3JnL3JmYy9yZmM0MTIyLnR4dFxuICBybmRbM10gPSBybmRbM10gJiAweDBGRkYgfCAweDQwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxuICBybmRbNF0gPSBybmRbNF0gJiAweDNGRkYgfCAweDgwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxuICByZXR1cm4gJzAxLTItMy00LTU2NycucmVwbGFjZSgvXFxkL2csIGkgPT4gKHJuZFtpXSArIDB4MV8wMDAwKS50b1N0cmluZygxNikuc2xpY2UoLTQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZNU2NyaXB0fSBzY3JpcHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKiBAcmV0dXJuIHtQcm9taXNlPFZNU2NyaXB0W10+fVxuICovXG5hc3luYyBmdW5jdGlvbiBzYXZlU2NyaXB0KHNjcmlwdCwgY29kZSkge1xuICBjb25zdCBjb25maWcgPSBzY3JpcHQuY29uZmlnIHx8IHt9O1xuICBjb25maWcuZW5hYmxlZCA9IGdldEludChjb25maWcuZW5hYmxlZCk7XG4gIGNvbmZpZy5zaG91bGRVcGRhdGUgPSBnZXRJbnQoY29uZmlnLnNob3VsZFVwZGF0ZSk7XG4gIGNvbnN0IHByb3BzID0gc2NyaXB0LnByb3BzIHx8IHt9O1xuICBsZXQgb2xkU2NyaXB0O1xuICBpZiAoIXByb3BzLmlkKSB7XG4gICAgc3RvcmUuc3RvcmVJbmZvLmlkICs9IDE7XG4gICAgcHJvcHMuaWQgPSBzdG9yZS5zdG9yZUluZm8uaWQ7XG4gIH0gZWxzZSB7XG4gICAgb2xkU2NyaXB0ID0gc3RvcmUuc2NyaXB0TWFwW3Byb3BzLmlkXTtcbiAgfVxuICBwcm9wcy51cmkgPSBnZXROYW1lVVJJKHNjcmlwdCk7XG4gIHByb3BzLnV1aWQgPSBwcm9wcy51dWlkIHx8IGNyeXB0by5yYW5kb21VVUlEPy4oKSB8fCBnZXRVVUlEKCk7XG4gIC8vIERvIG5vdCBhbGxvdyBzY3JpcHQgd2l0aCBzYW1lIG5hbWUgYW5kIG5hbWVzcGFjZVxuICBpZiAoc3RvcmUuc2NyaXB0cy5zb21lKCh7IHByb3BzOiB7IGlkLCB1cmkgfSA9IHt9IH0pID0+IHByb3BzLmlkICE9PSBpZCAmJiBwcm9wcy51cmkgPT09IHVyaSkpIHtcbiAgICB0aHJvdyBpMThuKCdtc2dOYW1lc3BhY2VDb25mbGljdCcpO1xuICB9XG4gIGlmIChvbGRTY3JpcHQpIHtcbiAgICBzY3JpcHQuY29uZmlnID0geyAuLi5vbGRTY3JpcHQuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICBzY3JpcHQucHJvcHMgPSB7IC4uLm9sZFNjcmlwdC5wcm9wcywgLi4ucHJvcHMgfTtcbiAgICBjb25zdCBpbmRleCA9IHN0b3JlLnNjcmlwdHMuaW5kZXhPZihvbGRTY3JpcHQpO1xuICAgIHN0b3JlLnNjcmlwdHNbaW5kZXhdID0gc2NyaXB0O1xuICB9IGVsc2Uge1xuICAgIGlmICghcHJvcHMucG9zaXRpb24pIHtcbiAgICAgIHN0b3JlLnN0b3JlSW5mby5wb3NpdGlvbiArPSAxO1xuICAgICAgcHJvcHMucG9zaXRpb24gPSBzdG9yZS5zdG9yZUluZm8ucG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChzdG9yZS5zdG9yZUluZm8ucG9zaXRpb24gPCBwcm9wcy5wb3NpdGlvbikge1xuICAgICAgc3RvcmUuc3RvcmVJbmZvLnBvc2l0aW9uID0gcHJvcHMucG9zaXRpb247XG4gICAgfVxuICAgIHNjcmlwdC5jb25maWcgPSBjb25maWc7XG4gICAgc2NyaXB0LnByb3BzID0gcHJvcHM7XG4gICAgc3RvcmUuc2NyaXB0cy5wdXNoKHNjcmlwdCk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICBzdG9yYWdlLnNjcmlwdC5kdW1wKHNjcmlwdCksXG4gICAgc3RvcmFnZS5jb2RlLnNldChwcm9wcy5pZCwgY29kZSksXG4gIF0pO1xufVxuXG4vKiogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVTY3JpcHRJbmZvKGlkLCBkYXRhKSB7XG4gIGNvbnN0IHNjcmlwdCA9IHN0b3JlLnNjcmlwdE1hcFtpZF07XG4gIGlmICghc2NyaXB0KSB0aHJvdyBudWxsO1xuICBzY3JpcHQucHJvcHMgPSB7IC4uLnNjcmlwdC5wcm9wcywgLi4uZGF0YS5wcm9wcyB9O1xuICBzY3JpcHQuY29uZmlnID0geyAuLi5zY3JpcHQuY29uZmlnLCAuLi5kYXRhLmNvbmZpZyB9O1xuICBzY3JpcHQuY3VzdG9tID0geyAuLi5zY3JpcHQuY3VzdG9tLCAuLi5kYXRhLmN1c3RvbSB9O1xuICBhd2FpdCBzdG9yYWdlLnNjcmlwdC5kdW1wKHNjcmlwdCk7XG4gIHJldHVybiBzZW5kQ21kKENNRF9TQ1JJUFRfVVBEQVRFLCB7IHdoZXJlOiB7IGlkIH0sIHVwZGF0ZTogc2NyaXB0IH0pO1xufVxuXG4vKiogQHJldHVybiB7UHJvbWlzZTx7IGlzTmV3PywgdXBkYXRlLCB3aGVyZSB9Pn0gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVNjcmlwdChzcmMpIHtcbiAgY29uc3QgbWV0YSA9IHBhcnNlTWV0YShzcmMuY29kZSk7XG4gIGlmICghbWV0YS5uYW1lKSB0aHJvdyBgJHtpMThuKCdtc2dJbnZhbGlkU2NyaXB0Jyl9XFxuJHtpMThuKCdsYWJlbE5vTmFtZScpfWA7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB1cGRhdGU6IHtcbiAgICAgIG1lc3NhZ2U6IHNyYy5tZXNzYWdlID09IG51bGwgPyBpMThuKCdtc2dVcGRhdGVkJykgOiBzcmMubWVzc2FnZSB8fCAnJyxcbiAgICB9LFxuICB9O1xuICBsZXQgY21kID0gQ01EX1NDUklQVF9VUERBVEU7XG4gIGxldCBzY3JpcHQ7XG4gIGNvbnN0IG9sZFNjcmlwdCA9IGF3YWl0IGdldFNjcmlwdCh7IGlkOiBzcmMuaWQsIG1ldGEgfSk7XG4gIGlmIChvbGRTY3JpcHQpIHtcbiAgICBpZiAoc3JjLmlzTmV3KSB0aHJvdyBpMThuKCdtc2dOYW1lc3BhY2VDb25mbGljdCcpO1xuICAgIHNjcmlwdCA9IHsgLi4ub2xkU2NyaXB0IH07XG4gIH0gZWxzZSB7XG4gICAgKHsgc2NyaXB0IH0gPSBuZXdTY3JpcHQoKSk7XG4gICAgY21kID0gQ01EX1NDUklQVF9BREQ7XG4gICAgcmVzdWx0LmlzTmV3ID0gdHJ1ZTtcbiAgICByZXN1bHQudXBkYXRlLm1lc3NhZ2UgPSBpMThuKCdtc2dJbnN0YWxsZWQnKTtcbiAgfVxuICBzY3JpcHQuY29uZmlnID0ge1xuICAgIC4uLnNjcmlwdC5jb25maWcsXG4gICAgLi4uc3JjLmNvbmZpZyxcbiAgICByZW1vdmVkOiAwLCAvLyBmb3JjZSByZXNldCBgcmVtb3ZlZGAgc2luY2UgdGhpcyBpcyBhbiBpbnN0YWxsYXRpb25cbiAgfTtcbiAgc2NyaXB0LmN1c3RvbSA9IHtcbiAgICAuLi5zY3JpcHQuY3VzdG9tLFxuICAgIC4uLnNyYy5jdXN0b20sXG4gIH07XG4gIHNjcmlwdC5wcm9wcyA9IHtcbiAgICAuLi5zY3JpcHQucHJvcHMsXG4gICAgbGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxuICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpLFxuICAgIC4uLnNyYy5wcm9wcyxcbiAgfTtcbiAgc2NyaXB0Lm1ldGEgPSBtZXRhO1xuICBpZiAoIW1ldGEuaG9tZXBhZ2VVUkwgJiYgIXNjcmlwdC5jdXN0b20uaG9tZXBhZ2VVUkwgJiYgaXNSZW1vdGUoc3JjLmZyb20pKSB7XG4gICAgc2NyaXB0LmN1c3RvbS5ob21lcGFnZVVSTCA9IHNyYy5mcm9tO1xuICB9XG4gIGlmIChpc1JlbW90ZShzcmMudXJsKSkgc2NyaXB0LmN1c3RvbS5sYXN0SW5zdGFsbFVSTCA9IHNyYy51cmw7XG4gIGlmIChzcmMucG9zaXRpb24pIHNjcmlwdC5wcm9wcy5wb3NpdGlvbiA9ICtzcmMucG9zaXRpb247XG4gIGJ1aWxkUGF0aE1hcChzY3JpcHQsIHNyYy51cmwpO1xuICBhd2FpdCBzYXZlU2NyaXB0KHNjcmlwdCwgc3JjLmNvZGUpO1xuICBmZXRjaFJlc291cmNlcyhzY3JpcHQsIHNyYyk7XG4gIE9iamVjdC5hc3NpZ24ocmVzdWx0LnVwZGF0ZSwgc2NyaXB0LCBzcmMudXBkYXRlKTtcbiAgcmVzdWx0LndoZXJlID0geyBpZDogc2NyaXB0LnByb3BzLmlkIH07XG4gIHNlbmRDbWQoY21kLCByZXN1bHQpO1xuICBwbHVnaW5FdmVudHMuZW1pdCgnc2NyaXB0Q2hhbmdlZCcsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJuIHtPYmplY3R9ICovXG5mdW5jdGlvbiBidWlsZFBhdGhNYXAoc2NyaXB0LCBiYXNlKSB7XG4gIGNvbnN0IHsgbWV0YSB9ID0gc2NyaXB0O1xuICBjb25zdCBiYXNlVXJsID0gYmFzZSB8fCBzY3JpcHQuY3VzdG9tLmxhc3RJbnN0YWxsVVJMO1xuICBjb25zdCBwYXRoTWFwID0gYmFzZVVybCA/IFtcbiAgICAuLi5tZXRhLnJlcXVpcmUsXG4gICAgLi4uT2JqZWN0LnZhbHVlcyhtZXRhLnJlc291cmNlcyksXG4gICAgbWV0YS5pY29uLFxuICBdLnJlZHVjZSgobWFwLCBrZXkpID0+IHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBjb25zdCBmdWxsVXJsID0gZ2V0RnVsbFVybChrZXksIGJhc2VVcmwpO1xuICAgICAgaWYgKGZ1bGxVcmwgIT09IGtleSkgbWFwW2tleV0gPSBmdWxsVXJsO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9LCB7fSkgOiB7fTtcbiAgc2NyaXB0LmN1c3RvbS5wYXRoTWFwID0gcGF0aE1hcDtcbiAgcmV0dXJuIHBhdGhNYXA7XG59XG5cbi8qKiBAcmV0dXJuIHtQcm9taXNlPD9zdHJpbmc+fSByZXNvbHZlcyB0byBlcnJvciB0ZXh0IGlmIGByZXNvdXJjZUNhY2hlYCBpcyBhYnNlbnQgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFJlc291cmNlcyhzY3JpcHQsIHJlc291cmNlQ2FjaGUsIHJlcU9wdGlvbnMpIHtcbiAgY29uc3QgeyBjdXN0b206IHsgcGF0aE1hcCB9LCBtZXRhIH0gPSBzY3JpcHQ7XG4gIGNvbnN0IHNuYXRjaCA9ICh1cmwsIHR5cGUsIHZhbGlkYXRvcikgPT4ge1xuICAgIHVybCA9IHBhdGhNYXBbdXJsXSB8fCB1cmw7XG4gICAgY29uc3QgY29udGVudHMgPSByZXNvdXJjZUNhY2hlPy5bdHlwZV0/Llt1cmxdO1xuICAgIHJldHVybiBjb250ZW50cyAhPSBudWxsICYmICF2YWxpZGF0b3JcbiAgICAgID8gc3RvcmFnZVt0eXBlXS5zZXQodXJsLCBjb250ZW50cykgJiYgbnVsbFxuICAgICAgOiBzdG9yYWdlW3R5cGVdLmZldGNoKHVybCwgcmVxT3B0aW9ucywgdmFsaWRhdG9yKS5jYXRjaChlcnIgPT4gZXJyKTtcbiAgfTtcbiAgY29uc3QgZXJyb3JzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgIC4uLm1ldGEucmVxdWlyZS5tYXAodXJsID0+IHNuYXRjaCh1cmwsICdyZXF1aXJlJykpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMobWV0YS5yZXNvdXJjZXMpLm1hcCh1cmwgPT4gc25hdGNoKHVybCwgJ2NhY2hlJykpLFxuICAgIGlzUmVtb3RlKG1ldGEuaWNvbikgJiYgc25hdGNoKG1ldGEuaWNvbiwgJ2NhY2hlJywgdmFsaWRhdGVJbWFnZSksXG4gIF0pO1xuICBpZiAoIXJlc291cmNlQ2FjaGU/Lmlnbm9yZURlcHNFcnJvcnMpIHtcbiAgICBjb25zdCBlcnJvciA9IGVycm9ycy5tYXAoZm9ybWF0SHR0cEVycm9yKTo6dHJ1ZUpvaW4oJ1xcbicpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGkxOG4oJ21zZ0Vycm9yRmV0Y2hpbmdSZXNvdXJjZScpO1xuICAgICAgc2VuZENtZChDTURfU0NSSVBUX1VQREFURSwge1xuICAgICAgICB1cGRhdGU6IHsgZXJyb3IsIG1lc3NhZ2UgfSxcbiAgICAgICAgd2hlcmU6IHsgaWQ6IHNjcmlwdC5wcm9wcy5pZCB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYCR7bWVzc2FnZX1cXG4ke2Vycm9yfWA7XG4gICAgfVxuICB9XG59XG5cbi8qKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSByZXNvbHZlcyBvbiBzdWNjZXNzLCByZWplY3RzIG9uIGVycm9yICovXG5mdW5jdGlvbiB2YWxpZGF0ZUltYWdlKHVybCwgYnVmLCB0eXBlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2J1Zl0sIHsgdHlwZSB9KSk7XG4gICAgY29uc3Qgb25Eb25lID0gKGUpID0+IHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gICAgICBpZiAoZS50eXBlID09PSAnbG9hZCcpIHJlc29sdmUoKTtcbiAgICAgIGVsc2UgcmVqZWN0KGBJTUFHRV9FUlJPUjogJHt1cmx9YCk7XG4gICAgfTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLm9ubG9hZCA9IG9uRG9uZTtcbiAgICBpbWFnZS5vbmVycm9yID0gb25Eb25lO1xuICAgIGltYWdlLnNyYyA9IGJsb2JVcmw7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIdHRwRXJyb3IoZSkge1xuICByZXR1cm4gZSAmJiBbZS5zdGF0dXMgJiYgYEhUVFAke2Uuc3RhdHVzfWAsIGUudXJsXTo6dHJ1ZUpvaW4oJyAnKSB8fCBlO1xufVxuXG5sZXQgX3ZhY3V1bWluZztcbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXVxuICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFjdXVtKGRhdGEpIHtcbiAgaWYgKF92YWN1dW1pbmcpIHJldHVybiBfdmFjdXVtaW5nO1xuICBsZXQgbnVtRml4ZXMgPSAwO1xuICBsZXQgcmVzb2x2ZVNlbGY7XG4gIF92YWN1dW1pbmcgPSBuZXcgUHJvbWlzZShyID0+IHsgcmVzb2x2ZVNlbGYgPSByOyB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHRvRmV0Y2ggPSBbXTtcbiAgY29uc3Qga2V5c1RvUmVtb3ZlID0gW107XG4gIGNvbnN0IHZhbHVlS2V5cyA9IHt9O1xuICBjb25zdCBjYWNoZUtleXMgPSB7fTtcbiAgY29uc3QgcmVxdWlyZUtleXMgPSB7fTtcbiAgY29uc3QgY29kZUtleXMgPSB7fTtcbiAgY29uc3QgbWFwcGluZ3MgPSBbXG4gICAgW3N0b3JhZ2UudmFsdWUsIHZhbHVlS2V5c10sXG4gICAgW3N0b3JhZ2UuY2FjaGUsIGNhY2hlS2V5c10sXG4gICAgW3N0b3JhZ2UucmVxdWlyZSwgcmVxdWlyZUtleXNdLFxuICAgIFtzdG9yYWdlLmNvZGUsIGNvZGVLZXlzXSxcbiAgXTtcbiAgaWYgKCFkYXRhKSBkYXRhID0gYXdhaXQgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmdldCgpO1xuICBkYXRhOjpmb3JFYWNoS2V5KChrZXkpID0+IHtcbiAgICBtYXBwaW5ncy5zb21lKChbc3Vic3RvcmUsIG1hcF0pID0+IHtcbiAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSBzdWJzdG9yZTtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgIC8vIC0xIGZvciB1bnRvdWNoZWQsIDEgZm9yIHRvdWNoZWQsIDIgZm9yIG1pc3NpbmdcbiAgICAgICAgbWFwW2tleS5zbGljZShwcmVmaXgubGVuZ3RoKV0gPSAtMTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCB0b3VjaCA9IChvYmosIGtleSwgc2NyaXB0SWQpID0+IHtcbiAgICBpZiAob2JqW2tleV0gPCAwKSB7XG4gICAgICBvYmpba2V5XSA9IDE7XG4gICAgfSBlbHNlIGlmICghb2JqW2tleV0pIHtcbiAgICAgIG9ialtrZXldID0gMiArIHNjcmlwdElkO1xuICAgIH1cbiAgfTtcbiAgc3RvcmUuc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpID0+IHtcbiAgICBjb25zdCB7IGlkIH0gPSBzY3JpcHQucHJvcHM7XG4gICAgdG91Y2goY29kZUtleXMsIGlkLCBpZCk7XG4gICAgdG91Y2godmFsdWVLZXlzLCBpZCwgaWQpO1xuICAgIGlmICghc2NyaXB0LmN1c3RvbS5wYXRoTWFwKSBidWlsZFBhdGhNYXAoc2NyaXB0KTtcbiAgICBjb25zdCB7IHBhdGhNYXAgfSA9IHNjcmlwdC5jdXN0b207XG4gICAgc2NyaXB0Lm1ldGEucmVxdWlyZS5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgIHRvdWNoKHJlcXVpcmVLZXlzLCBwYXRoTWFwW3VybF0gfHwgdXJsLCBpZCk7XG4gICAgfSk7XG4gICAgc2NyaXB0Lm1ldGEucmVzb3VyY2VzOjpmb3JFYWNoVmFsdWUoKHVybCkgPT4ge1xuICAgICAgdG91Y2goY2FjaGVLZXlzLCBwYXRoTWFwW3VybF0gfHwgdXJsLCBpZCk7XG4gICAgfSk7XG4gICAgY29uc3QgeyBpY29uIH0gPSBzY3JpcHQubWV0YTtcbiAgICBpZiAoaXNSZW1vdGUoaWNvbikpIHtcbiAgICAgIGNvbnN0IGZ1bGxVcmwgPSBwYXRoTWFwW2ljb25dIHx8IGljb247XG4gICAgICB0b3VjaChjYWNoZUtleXMsIGZ1bGxVcmwsIGlkKTtcbiAgICB9XG4gIH0pO1xuICBtYXBwaW5ncy5mb3JFYWNoKChbc3Vic3RvcmUsIG1hcF0pID0+IHtcbiAgICBtYXA6OmZvckVhY2hFbnRyeSgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIC8vIHJlZHVuZGFudCB2YWx1ZVxuICAgICAgICBrZXlzVG9SZW1vdmUucHVzaChzdWJzdG9yZS5nZXRLZXkoa2V5KSk7XG4gICAgICAgIG51bUZpeGVzICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID49IDIgJiYgc3Vic3RvcmUuZmV0Y2gpIHtcbiAgICAgICAgLy8gbWlzc2luZyByZXNvdXJjZVxuICAgICAgICBrZXlzVG9SZW1vdmUucHVzaChzdG9yYWdlLm1vZC5nZXRLZXkoa2V5KSk7XG4gICAgICAgIHRvRmV0Y2gucHVzaChzdWJzdG9yZS5mZXRjaChrZXkpLmNhdGNoKGVyciA9PiBgJHtcbiAgICAgICAgICBnZXRTY3JpcHROYW1lKGdldFNjcmlwdEJ5SWQodmFsdWUgLSAyKSlcbiAgICAgICAgfTogJHtcbiAgICAgICAgICBmb3JtYXRIdHRwRXJyb3IoZXJyKVxuICAgICAgICB9YCkpO1xuICAgICAgICBudW1GaXhlcyArPSAxO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgaWYgKG51bUZpeGVzKSB7XG4gICAgYXdhaXQgc3RvcmFnZS5iYXNlLnJlbW92ZU11bHRpKGtleXNUb1JlbW92ZSk7IC8vIFJlbW92aW5nIGBtb2RgIGJlZm9yZSBmZXRjaGluZ1xuICAgIHJlc3VsdC5lcnJvcnMgPSAoYXdhaXQgUHJvbWlzZS5hbGwodG9GZXRjaCkpLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICBfdmFjdXVtaW5nID0gbnVsbDtcbiAgcmVzdWx0LmZpeGVzID0gbnVtRml4ZXM7XG4gIHJlc29sdmVTZWxmKHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAdHlwZWRlZiBWTVNjcmlwdFxuICogQHByb3BlcnR5IHtWTVNjcmlwdENvbmZpZ30gY29uZmlnXG4gKiBAcHJvcGVydHkge1ZNU2NyaXB0Q3VzdG9tfSBjdXN0b21cbiAqIEBwcm9wZXJ0eSB7Vk1TY3JpcHRNZXRhfSBtZXRhXG4gKiBAcHJvcGVydHkge1ZNU2NyaXB0UHJvcHN9IHByb3BzXG4gKi9cbi8qKiBAdHlwZWRlZiBWTVNjcmlwdENvbmZpZyAqXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZWQgLSBzdG9yZWQgYXMgMCBvciAxXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHJlbW92ZWQgLSBzdG9yZWQgYXMgMCBvciAxXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNob3VsZFVwZGF0ZSAtIHN0b3JlZCBhcyAwIG9yIDFcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbiB8IG51bGx9IG5vdGlmeVVwZGF0ZXMgLSBzdG9yZWQgYXMgMCBvciAxIG9yIG51bGwgKGRlZmF1bHQpIHdoaWNoIG1lYW5zIFwidXNlIGdsb2JhbCBzZXR0aW5nXCJcbiAqL1xuLyoqIEB0eXBlZGVmIFZNU2NyaXB0Q3VzdG9tICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZG93bmxvYWRVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBob21lcGFnZVVSTFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhc3RJbnN0YWxsVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXBkYXRlVVJMXG4gKiBAcHJvcGVydHkgeydhdXRvJyB8ICdwYWdlJyB8ICdjb250ZW50J30gaW5qZWN0SW50b1xuICogQHByb3BlcnR5IHtudWxsIHwgMSB8IDB9IG5vZnJhbWVzIC0gbnVsbCBvciBhYnNlbmNlID09IGRlZmF1bHQgKHNjcmlwdCdzIHZhbHVlKVxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZXhjbHVkZVxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZXhjbHVkZU1hdGNoXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBpbmNsdWRlXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBtYXRjaFxuICogQHByb3BlcnR5IHtib29sZWFufSBvcmlnRXhjbHVkZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvcmlnRXhjbHVkZU1hdGNoXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9yaWdJbmNsdWRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9yaWdNYXRjaFxuICogQHByb3BlcnR5IHtPYmplY3R9IHBhdGhNYXBcbiAqIEBwcm9wZXJ0eSB7Vk1TY3JpcHRSdW5BdH0gcnVuQXRcbiAqL1xuLyoqIEB0eXBlZGVmIFZNU2NyaXB0TWV0YSAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkb3dubG9hZFVSTFxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZXhjbHVkZVxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZXhjbHVkZU1hdGNoXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBncmFudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvbWVwYWdlVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWNvblxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gaW5jbHVkZVxuICogQHByb3BlcnR5IHsnYXV0bycgfCAncGFnZScgfCAnY29udGVudCd9IGluamVjdEludG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IG1hdGNoXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtib29sZWFufSBub2ZyYW1lc1xuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gcmVxdWlyZVxuICogQHByb3BlcnR5IHtPYmplY3R9IHJlc291cmNlc1xuICogQHByb3BlcnR5IHtWTVNjcmlwdFJ1bkF0fSBydW5BdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN1cHBvcnRVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJzaW9uXG4gKi9cbi8qKiBAdHlwZWRlZiBWTVNjcmlwdFByb3BzICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RNb2RpZmllZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RVcGRhdGVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1dWlkXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge1xuICAgJ2RvY3VtZW50LXN0YXJ0JyB8ICdkb2N1bWVudC1ib2R5JyB8ICdkb2N1bWVudC1lbmQnIHwgJ2RvY3VtZW50LWlkbGUnXG4gfSBWTVNjcmlwdFJ1bkF0XG4gKi9cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEV2ZW50RW1pdHRlcigpIHtcbiAgY29uc3QgZXZlbnRzID0ge307XG4gIHJldHVybiB7IG9uLCBvZmYsIGZpcmUgfTtcblxuICBmdW5jdGlvbiBvbih0eXBlLCBmdW5jKSB7XG4gICAgbGV0IGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgICBldmVudHNbdHlwZV0gPSBsaXN0O1xuICAgIH1cbiAgICBsaXN0LnB1c2goZnVuYyk7XG4gIH1cbiAgZnVuY3Rpb24gb2ZmKHR5cGUsIGZ1bmMpIHtcbiAgICBjb25zdCBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmIChsaXN0KSB7XG4gICAgICBjb25zdCBpID0gbGlzdC5pbmRleE9mKGZ1bmMpO1xuICAgICAgaWYgKGkgPj0gMCkgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZpcmUodHlwZSwgZGF0YSkge1xuICAgIGNvbnN0IGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKGxpc3QpIHtcbiAgICAgIGxpc3QuZm9yRWFjaCgoZnVuYykgPT4ge1xuICAgICAgICBmdW5jKGRhdGEsIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBwb3N0SW5pdGlhbGl6ZSB9IGZyb20gJy4vaW5pdCc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5cbnBvc3RJbml0aWFsaXplLnB1c2goKCkgPT4ge1xuICBicm93c2VyLmNvbW1hbmRzLm9uQ29tbWFuZC5hZGRMaXN0ZW5lcigoY21kKSA9PiB7XG4gICAgaWYgKGNtZCA9PT0gJ25ld1NjcmlwdCcpIHtcbiAgICAgIGNvbW1hbmRzLk9wZW5FZGl0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91dGUgPSBjbWQgPT09ICdzZXR0aW5ncycgPyBgIyR7Y21kfWAgOiAnJztcbiAgICAgIGNvbW1hbmRzLlRhYk9wZW4oeyB1cmw6IGAvb3B0aW9ucy9pbmRleC5odG1sJHtyb3V0ZX1gIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsImltcG9ydCB7IGkxOG4sIG5vb3AgfSBmcm9tICcjL2NvbW1vbic7XG5pbXBvcnQgeyBJTkpFQ1RBQkxFX1RBQl9VUkxfUkUgfSBmcm9tICcjL2NvbW1vbi9jb25zdHMnO1xuaW1wb3J0IHsgb2JqZWN0UGljayB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgY2FjaGUgZnJvbSAnLi9jYWNoZSc7XG5pbXBvcnQgeyBwb3N0SW5pdGlhbGl6ZSB9IGZyb20gJy4vaW5pdCc7XG5pbXBvcnQgeyBjb21tYW5kcywgZm9yRWFjaFRhYiB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgeyBnZXRPcHRpb24sIGhvb2tPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IHRlc3RCbGFja2xpc3QgfSBmcm9tICcuL3Rlc3Rlcic7XG5cbi8vIHN0b3JpbmcgaW4gYGNhY2hlYCBvbmx5IGZvciB0aGUgZHVyYXRpb24gb2YgcGFnZSBsb2FkIGluIGNhc2UgdGhlcmUgYXJlIDIrIGlkZW50aWNhbCB1cmxzXG5jb25zdCBDQUNIRV9EVVJBVElPTiA9IDEwMDA7XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgYXN5bmMgR2V0SW1hZ2VEYXRhKHVybCkge1xuICAgIGNvbnN0IGtleSA9IGBHZXRJbWFnZURhdGE6JHt1cmx9YDtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSlcbiAgICAgIHx8IGNhY2hlLnB1dChrZXksIGxvYWRJbWFnZURhdGEodXJsLCB7IGJhc2U2NDogdHJ1ZSB9KS5jYXRjaChub29wKSwgQ0FDSEVfRFVSQVRJT04pO1xuICB9LFxuICBTZXRCYWRnZTogc2V0QmFkZ2UsXG59KTtcblxuLy8gRmlyZWZveCBBbmRyb2lkIGRvZXMgbm90IHN1cHBvcnQgc3VjaCBBUElzLCB1c2Ugbm9vcFxuXG5jb25zdCBicm93c2VyQWN0aW9uID0gKCgpID0+IHtcbiAgY29uc3QgeyBjaHJvbWUgfSA9IGdsb2JhbDtcbiAgLy8gVXNpbmcgYGNocm9tZWAgbmFtZXNwYWNlIGluIG9yZGVyIHRvIHNraXAgb3VyIGJyb3dzZXIuanMgcG9seWZpbGwgaW4gQ2hyb21lXG4gIGNvbnN0IGFwaSA9IGNocm9tZS5icm93c2VyQWN0aW9uO1xuICAvLyBTdXBwcmVzcyB0aGUgXCJubyB0YWIgaWRcIiBlcnJvciB3aGVuIHNldHRpbmcgYW4gaWNvbi9iYWRnZSBhcyBpdCBjYW5ub3QgYmUgcmVsaWFibHkgcHJldmVudGVkXG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9ICgpID0+IGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcjtcbiAgLy8gU29tZSBtZXRob2RzIGxpa2Ugc2V0QmFkZ2VUZXh0IGFkZGVkIGNhbGxiYWNrcyBvbmx5IGluIENocm9tZSA2NysuXG4gIGNvbnN0IG1ha2VNZXRob2QgPSBmbiA9PiAoLi4uYXJncykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhcGk6OmZuKC4uLmFyZ3MsIGlnbm9yZUVycm9ycyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXBpOjpmbiguLi5hcmdzKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBvYmplY3RQaWNrKGFwaSwgW1xuICAgICdzZXRJY29uJyxcbiAgICAnc2V0QmFkZ2VUZXh0JyxcbiAgICAnc2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3InLFxuICAgICdzZXRUaXRsZScsXG4gIF0sIGZuID0+IChmbiA/IG1ha2VNZXRob2QoZm4pIDogbm9vcCkpO1xufSkoKTtcblxuY29uc3QgYmFkZ2VzID0ge307XG5jb25zdCBLRVlfSVNfQVBQTElFRCA9ICdpc0FwcGxpZWQnO1xuY29uc3QgS0VZX1NIT1dfQkFER0UgPSAnc2hvd0JhZGdlJztcbmNvbnN0IEtFWV9CQURHRV9DT0xPUiA9ICdiYWRnZUNvbG9yJztcbmNvbnN0IEtFWV9CQURHRV9DT0xPUl9CTE9DS0VEID0gJ2JhZGdlQ29sb3JCbG9ja2VkJztcbi8qKiBAdHlwZSBib29sZWFuICovXG5sZXQgaXNBcHBsaWVkO1xuLyoqIEB0eXBlIFZNQmFkZ2VNb2RlICovXG5sZXQgc2hvd0JhZGdlO1xuLyoqIEB0eXBlIHN0cmluZyAqL1xubGV0IGJhZGdlQ29sb3I7XG4vKiogQHR5cGUgc3RyaW5nICovXG5sZXQgYmFkZ2VDb2xvckJsb2NrZWQ7XG4vKiogQHR5cGUgc3RyaW5nICovXG5sZXQgdGl0bGVCbGFja2xpc3RlZDtcbi8qKiBAdHlwZSBzdHJpbmcgKi9cbmxldCB0aXRsZU5vbmluamVjdGFibGU7XG5cbi8vIFdlJ2xsIGNhY2hlIHRoZSBpY29uIGRhdGEgaW4gQ2hyb21lIGFzIGl0IGRvZXNuJ3QgY2FjaGUgdGhlIGRhdGEgYW5kIHRha2VzIHVwIHRvIDQwbXNcbi8vIGluIG91ciBiYWNrZ3JvdW5kIHBhZ2UgY29udGV4dCB0byBzZXQgdGhlIDQgaWNvbiBzaXplcyBmb3IgZWFjaCBuZXcgdGFiIG9wZW5lZFxuY29uc3QgaWNvbkNhY2hlID0gIUlTX0ZJUkVGT1ggJiYge307XG5cbmhvb2tPcHRpb25zKChjaGFuZ2VzKSA9PiB7XG4gIGxldCB2O1xuICBjb25zdCBqb2JzID0gW107XG4gIGlmICgodiA9IGNoYW5nZXNbS0VZX0lTX0FQUExJRURdKSAhPSBudWxsKSB7XG4gICAgaXNBcHBsaWVkID0gdjtcbiAgICBzZXRJY29uKCk7IC8vIGNoYW5nZSB0aGUgZGVmYXVsdCBpY29uXG4gICAgam9icy5wdXNoKHNldEljb24pOyAvLyBjaGFuZ2UgdGhlIGN1cnJlbnQgdGFicycgaWNvbnNcbiAgfVxuICBpZiAoKHYgPSBjaGFuZ2VzW0tFWV9TSE9XX0JBREdFXSkgIT0gbnVsbCkge1xuICAgIHNob3dCYWRnZSA9IHY7XG4gICAgam9icy5wdXNoKHVwZGF0ZUJhZGdlKTtcbiAgfVxuICBpZiAoKHYgPSBjaGFuZ2VzW0tFWV9CQURHRV9DT0xPUl0pICYmIChiYWRnZUNvbG9yID0gdilcbiAgfHwgKHYgPSBjaGFuZ2VzW0tFWV9CQURHRV9DT0xPUl9CTE9DS0VEXSkgJiYgKGJhZGdlQ29sb3JCbG9ja2VkID0gdikpIHtcbiAgICBqb2JzLnB1c2godXBkYXRlQmFkZ2VDb2xvcik7XG4gIH1cbiAgaWYgKCdibGFja2xpc3QnIGluIGNoYW5nZXMpIHtcbiAgICBqb2JzLnB1c2godXBkYXRlU3RhdGUpO1xuICB9XG4gIGlmIChqb2JzLmxlbmd0aCkge1xuICAgIGZvckVhY2hUYWIodGFiID0+IGpvYnMuZm9yRWFjaChmbiA9PiBmbih0YWIpKSk7XG4gIH1cbn0pO1xuXG5wb3N0SW5pdGlhbGl6ZS5wdXNoKCgpID0+IHtcbiAgaXNBcHBsaWVkID0gZ2V0T3B0aW9uKEtFWV9JU19BUFBMSUVEKTtcbiAgc2hvd0JhZGdlID0gZ2V0T3B0aW9uKEtFWV9TSE9XX0JBREdFKTtcbiAgYmFkZ2VDb2xvciA9IGdldE9wdGlvbihLRVlfQkFER0VfQ09MT1IpO1xuICBiYWRnZUNvbG9yQmxvY2tlZCA9IGdldE9wdGlvbihLRVlfQkFER0VfQ09MT1JfQkxPQ0tFRCk7XG4gIHRpdGxlQmxhY2tsaXN0ZWQgPSBpMThuKCdmYWlsdXJlUmVhc29uQmxhY2tsaXN0ZWQnKTtcbiAgdGl0bGVOb25pbmplY3RhYmxlID0gaTE4bignZmFpbHVyZVJlYXNvbk5vbmluamVjdGFibGUnKTtcbiAgZm9yRWFjaFRhYih1cGRhdGVTdGF0ZSk7XG4gIGlmICghaXNBcHBsaWVkKSBzZXRJY29uKCk7IC8vIHNldHMgdGhlIGRpbW1lZCBpY29uIGFzIGRlZmF1bHRcbn0pO1xuXG5icm93c2VyLnRhYnMub25SZW1vdmVkLmFkZExpc3RlbmVyKChpZCkgPT4ge1xuICBkZWxldGUgYmFkZ2VzW2lkXTtcbn0pO1xuXG5icm93c2VyLnRhYnMub25VcGRhdGVkLmFkZExpc3RlbmVyKCh0YWJJZCwgaW5mbywgdGFiKSA9PiB7XG4gIGNvbnN0IHsgdXJsIH0gPSBpbmZvO1xuICBpZiAoaW5mby5zdGF0dXMgPT09ICdsb2FkaW5nJ1xuICAgICAgLy8gYXQgbGVhc3QgYWJvdXQ6bmV3dGFiIGluIEZpcmVmb3ggbWF5IG9wZW4gd2l0aG91dCAnbG9hZGluZycgc3RhdHVzXG4gICAgICB8fCBpbmZvLmZhdkljb25VcmwgJiYgdGFiLnVybC5zdGFydHNXaXRoKCdhYm91dDonKSkge1xuICAgIHVwZGF0ZVN0YXRlKHRhYiwgdXJsKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHNldEJhZGdlKGlkcywgeyB0YWIsIGZyYW1lSWQgfSkge1xuICBjb25zdCB0YWJJZCA9IHRhYi5pZDtcbiAgY29uc3QgZGF0YSA9IGJhZGdlc1t0YWJJZF0gfHwge307XG4gIGlmICghZGF0YS5pZE1hcCB8fCBmcmFtZUlkID09PSAwKSB7XG4gICAgLy8gMSkga2VlcGluZyBkYXRhIG9iamVjdCB0byBwcmVzZXJ2ZSBkYXRhLmJsb2NrZWRcbiAgICAvLyAyKSAndG90YWwnIGFuZCAndW5pcXVlJyBtdXN0IG1hdGNoIHNob3dCYWRnZSBpbiBvcHRpb25zLWRlZmF1bHRzLmpzXG4gICAgZGF0YS50b3RhbCA9IDA7XG4gICAgZGF0YS51bmlxdWUgPSAwO1xuICAgIGRhdGEuaWRNYXAgPSB7fTtcbiAgICBiYWRnZXNbdGFiSWRdID0gZGF0YTtcbiAgfVxuICBkYXRhLnRvdGFsICs9IGlkcy5sZW5ndGg7XG4gIGlmIChpZHMpIHtcbiAgICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIGRhdGEuaWRNYXBbaWRdID0gMTtcbiAgICB9KTtcbiAgICBkYXRhLnVuaXF1ZSA9IE9iamVjdC5rZXlzKGRhdGEuaWRNYXApLmxlbmd0aDtcbiAgfVxuICB1cGRhdGVCYWRnZUNvbG9yKHRhYiwgZGF0YSk7XG4gIHVwZGF0ZUJhZGdlKHRhYiwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJhZGdlKHRhYiwgZGF0YSA9IGJhZGdlc1t0YWIuaWRdKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgYnJvd3NlckFjdGlvbi5zZXRCYWRnZVRleHQoe1xuICAgICAgdGV4dDogYCR7ZGF0YVtzaG93QmFkZ2VdIHx8ICcnfWAsXG4gICAgICB0YWJJZDogdGFiLmlkLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJhZGdlQ29sb3IodGFiLCBkYXRhID0gYmFkZ2VzW3RhYi5pZF0pIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBicm93c2VyQWN0aW9uLnNldEJhZGdlQmFja2dyb3VuZENvbG9yKHtcbiAgICAgIGNvbG9yOiBkYXRhLmJsb2NrZWQgPyBiYWRnZUNvbG9yQmxvY2tlZCA6IGJhZGdlQ29sb3IsXG4gICAgICB0YWJJZDogdGFiLmlkLFxuICAgIH0pO1xuICB9XG59XG5cbi8vIENocm9tZSA3OSsgdXNlcyBwZW5kaW5nVXJsIHdoaWxlIHRoZSB0YWIgY29ubmVjdHMgdG8gdGhlIG5ld2x5IG5hdmlnYXRlZCBVUkxcbi8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZm9ydW0vIyF0b3BpYy9jaHJvbWl1bS1leHRlbnNpb25zLzV6dV9QVDBhcmxzXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZSh0YWIsIHVybCA9IHRhYi5wZW5kaW5nVXJsIHx8IHRhYi51cmwpIHtcbiAgY29uc3QgdGFiSWQgPSB0YWIuaWQ7XG4gIGNvbnN0IGluamVjdGFibGUgPSBJTkpFQ1RBQkxFX1RBQl9VUkxfUkUudGVzdCh1cmwpO1xuICBjb25zdCBibGFja2xpc3RlZCA9IGluamVjdGFibGUgPyB0ZXN0QmxhY2tsaXN0KHVybCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHRpdGxlID0gYmxhY2tsaXN0ZWQgJiYgdGl0bGVCbGFja2xpc3RlZCB8fCAhaW5qZWN0YWJsZSAmJiB0aXRsZU5vbmluamVjdGFibGUgfHwgJyc7XG4gIC8vIGlmIHRoZSB1c2VyIHVuYmxhY2tsaXN0ZWQgdGhpcyBwcmV2aW91c2x5IGJsb2NrZWQgdGFiIGluIHNldHRpbmdzLFxuICAvLyBidXQgZGlkbid0IHJlbG9hZCB0aGUgdGFiIHlldCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBpY29uIGFuZCB0aGUgdGl0bGVcbiAgaWYgKHRpdGxlIHx8IChiYWRnZXNbdGFiSWRdIHx8IHt9KS5ibG9ja2VkKSB7XG4gICAgYnJvd3NlckFjdGlvbi5zZXRUaXRsZSh7IHRpdGxlLCB0YWJJZCB9KTtcbiAgICBjb25zdCBkYXRhID0gdGl0bGUgPyB7IGJsb2NrZWQ6IHRydWUgfSA6IHt9O1xuICAgIGJhZGdlc1t0YWJJZF0gPSBkYXRhO1xuICAgIHNldEljb24odGFiLCBkYXRhKTtcbiAgICB1cGRhdGVCYWRnZSh0YWIsIGRhdGEpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNldEljb24odGFiID0ge30sIGRhdGEgPSB7fSkge1xuICAvLyBtb2Rlcm4gQ2hyb21lIGFuZCBGaXJlZm94IHVzZSAxNi8zMiwgb3RoZXIgYnJvd3NlcnMgbWF5IHN0aWxsIHVzZSAxOS8zOCAoZS5nLiBWaXZhbGRpKVxuICBjb25zdCBtb2QgPSBkYXRhLmJsb2NrZWQgJiYgJ2InIHx8ICFpc0FwcGxpZWQgJiYgJ3cnIHx8ICcnO1xuICBjb25zdCBpY29uRGF0YSA9IHt9O1xuICBmb3IgKGNvbnN0IG4gb2YgWzE2LCAxOSwgMzIsIDM4XSkge1xuICAgIGNvbnN0IHBhdGggPSBgL3B1YmxpYy9pbWFnZXMvaWNvbiR7bn0ke21vZH0ucG5nYDtcbiAgICBsZXQgaWNvbiA9IGljb25DYWNoZSA/IGljb25DYWNoZVtwYXRoXSA6IHBhdGg7XG4gICAgaWYgKCFpY29uKSB7XG4gICAgICBpY29uID0gYXdhaXQgbG9hZEltYWdlRGF0YShwYXRoKTtcbiAgICAgIGljb25DYWNoZVtwYXRoXSA9IGljb247XG4gICAgfVxuICAgIGljb25EYXRhW25dID0gaWNvbjtcbiAgfVxuICBicm93c2VyQWN0aW9uLnNldEljb24oe1xuICAgIHRhYklkOiB0YWIuaWQsXG4gICAgW2ljb25DYWNoZSA/ICdpbWFnZURhdGEnIDogJ3BhdGgnXTogaWNvbkRhdGEsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb2FkSW1hZ2VEYXRhKHBhdGgsIHsgYmFzZTY0IH0gPSB7fSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5zcmMgPSBwYXRoO1xuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltZztcbiAgICAgIGlmICghd2lkdGgpIHsgLy8gRkYgcmVwb3J0cyAwIGZvciBTVkdcbiAgICAgICAgcmVzb2x2ZShwYXRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJlc29sdmUoYmFzZTY0ID8gY2FudmFzLnRvRGF0YVVSTCgpIDogY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfTtcbiAgICBpbWcub25lcnJvciA9IHJlamVjdDtcbiAgfSk7XG59XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIGNhY2hlIH0gZnJvbSAnLi9jYWNoZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdldEV2ZW50RW1pdHRlciB9IGZyb20gJy4vZXZlbnRzJztcbmV4cG9ydCAqIGZyb20gJy4vbWVzc2FnZSc7XG5leHBvcnQgKiBmcm9tICcuL29wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9zZWFyY2gnO1xuIiwiZXhwb3J0IGNvbnN0IGV4dGVuc2lvblJvb3QgPSBicm93c2VyLnJ1bnRpbWUuZ2V0VVJMKCcvJyk7XG5cbmV4cG9ydCBjb25zdCBwcmVJbml0aWFsaXplID0gW107XG5leHBvcnQgY29uc3QgcG9zdEluaXRpYWxpemUgPSBbXTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemUobWFpbikge1xuICBjb25zdCBydW4gPSBpbml0ID0+ICh0eXBlb2YgaW5pdCA9PT0gJ2Z1bmN0aW9uJyA/IGluaXQoKSA6IGluaXQpO1xuICBhd2FpdCBQcm9taXNlLmFsbChwcmVJbml0aWFsaXplLm1hcChydW4pKTtcbiAgYXdhaXQgcnVuKG1haW4pO1xuICBhd2FpdCBQcm9taXNlLmFsbChwb3N0SW5pdGlhbGl6ZS5tYXAocnVuKSk7XG4gIHByZUluaXRpYWxpemUubGVuZ3RoID0gMDtcbiAgcG9zdEluaXRpYWxpemUubGVuZ3RoID0gMDtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIGNyZWRpdHNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb21vNzA3NTc3MDQ1L20zdTgtZG93bmxvYWRlclxuICogaHR0cHM6Ly9naXRodWIuY29tL3NoZWxsdm9uL3poLWRvd25sb2FkZXJcbiAqL1xuXG5pbXBvcnQgakJpbmFyeSBmcm9tICdqYmluYXJ5JztcbmltcG9ydCBNUEVHVFMgZnJvbSAnbXBlZ3RzX3RvX21wNC9tcGVndHNfdG9fbXA0L21wZWd0cyc7XG5pbXBvcnQgbXBlZ3RzX3RvX21wNCBmcm9tICdtcGVndHNfdG9fbXA0L21wZWd0c190b19tcDQvaW5kZXgnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuaW1wb3J0IHsgQUVTRGVjcnlwdG9yIH0gZnJvbSAnLi9hZXMtZGVjcnlwdG9yJztcblxubGV0IHRzTGlzdCA9IFtdO1xubGV0IHN0YXR1c0xpc3QgPSBbXTtcbmxldCBtZWRpYUZpbGVMaXN0ID0gW107XG5cbi8vIEFFUyDop4bpopHop6Plr4bphY3nva5cbmNvbnN0IEFFUyA9IHtcbiAgbWV0aG9kOiAnJywgLy8g5Yqg5a+G566X5rOVXG4gIHVyaTogJycsIC8vIGtleSDmiYDlnKjmlofku7bot6/lvoRcbiAgaXY6ICcnLCAvLyDlgY/np7vlgLxcbiAga2V5OiAnJywgLy8g56eY6ZKlXG4gIGRlY3J5cHRvcjogbnVsbCwgLy8g6Kej56CB5Zmo5a+56LGhXG4gIHN0cmluZ1RvQnVmZmVyOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpXG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBkb3dubG9hZE0zdTggPSBmdW5jdGlvbiAob3B0cykge1xuICAvLyBjbGVhclxuICB0c0xpc3QgPSBbXTtcbiAgc3RhdHVzTGlzdCA9IFtdO1xuICBtZWRpYUZpbGVMaXN0ID0gW107XG5cbiAgY29uc3QgbTN1OCA9IG9wdHMuZGF0YVswXTtcbiAgY29uc3QgYmFzZVVybCA9IG9wdHMudXJsO1xuICBsZXQgbGltaXQgPSA1O1xuICBtM3U4LnNwbGl0KCdcXG4nKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgaWYgKGxpbWl0ID4gMCAmJiB0c0xpc3QubGVuZ3RoID49IGxpbWl0KSByZXR1cm47XG4gICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcudHMnKSA+IC0xKSB7XG4gICAgICB0c0xpc3QucHVzaCh0c1VybChsaW5lLCBiYXNlVXJsKSk7XG4gICAgICBzdGF0dXNMaXN0LnB1c2goe1xuICAgICAgICB0aXRsZTogbGluZSxcbiAgICAgICAgc3RhdHVzOiAnaW5pdCcsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICAvLyBjb25zb2xlLmxvZygndHNMaXN0JywgdHNMaXN0KTtcblxuICBpZiAobTN1OC5pbmRleE9mKCcjRVhULVgtS0VZJykgPiAtMSkge1xuICAgIC8vIOinhumikSBBRVMg5Yqg5a+GXG4gICAgQUVTLm1ldGhvZCA9IChtM3U4Lm1hdGNoKC8oLipNRVRIT0Q9KFteLFxcc10rKSkvKSB8fCBbJycsICcnLCAnJ10pWzJdXG4gICAgQUVTLnVyaSA9IChtM3U4Lm1hdGNoKC8oLipVUkk9XCIoW15cIl0rKSlcIi8pIHx8IFsnJywgJycsICcnXSlbMl1cbiAgICBBRVMudXJpID0gdHNVcmwoQUVTLnVyaSwgYmFzZVVybClcbiAgICBBRVMuaXYgPSAobTN1OC5tYXRjaCgvKC4qSVY9KFteLFxcc10rKSkvKSB8fCBbJycsICcnLCAnJ10pWzJdXG4gICAgQUVTLml2ID0gQUVTLml2ID8gQUVTLnN0cmluZ1RvQnVmZmVyKEFFUy5pdikgOiAnJ1xuXG4gICAgLy8g5YWI5LiL6L2956eY6ZKlXG4gICAgZ2V0QUVTKCgpID0+IHtcbiAgICAgIGRvd25sb2FkVFMob3B0cyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHNMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAvLyDlpoLmnpzop4bpopHmsqHliqDlr4bvvIzliJnnm7TmjqXkuIvovb3niYfmrrVcbiAgICBkb3dubG9hZFRTKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuaW5mbygnZW1wdHkgbTN1OCEnKVxuICB9XG59XG5cbmNvbnN0IGdldEFFUyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBhamF4KHtcbiAgICB1cmw6IEFFUy51cmksXG4gICAgc3VjY2VzczogKGtleSkgPT4ge1xuICAgICAgQUVTLmtleSA9IGtleVxuICAgICAgQUVTLmRlY3J5cHRvciA9IG5ldyBBRVNEZWNyeXB0b3IoKVxuICAgICAgQUVTLmRlY3J5cHRvci5jb25zdHJ1Y3RvcigpXG4gICAgICBBRVMuZGVjcnlwdG9yLmV4cGFuZEtleShBRVMua2V5KTtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9LFxuICAgIGZhaWw6ICgpID0+IHtcbiAgICAgIGNvbnNvbGUuaW5mbygn6KeG6aKR5bey6L+b6KGM5a6a5Yi25YyW5Yqg5a+GJylcbiAgICB9LFxuICB9KVxufVxuXG5jb25zdCB0c1VybCA9IGZ1bmN0aW9uICh0c1VyaSwgYmFzZVVSTCkge1xuICBpZiAodHNVcmkuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIHRzVXJpXG4gIH0gZWxzZSBpZiAodHNVcmlbMF0gPT09ICcvJykge1xuICAgIGxldCBkb21haW4gPSBiYXNlVVJMLnNwbGl0KCcvJylcbiAgICByZXR1cm4gZG9tYWluWzBdICsgJy8vJyArIGRvbWFpblsyXSArIHRzVXJpXG4gIH0gZWxzZSB7XG4gICAgbGV0IGRvbWFpbiA9IGJhc2VVUkwuc3BsaXQoJy8nKVxuICAgIGRvbWFpbi5wb3AoKVxuICAgIHJldHVybiBkb21haW4uam9pbignLycpICsgJy8nICsgdHNVcmlcbiAgfVxufVxuXG4vLyB0cyDniYfmrrXnmoQgQUVTIOino+eggVxuY29uc3QgZGVjcnlwdFRzID0gZnVuY3Rpb24gKGRhdGEsIGluZGV4KSB7XG4gIGxldCBpdiA9IEFFUy5pdiB8fCBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgaW5kZXhdKVxuICByZXR1cm4gQUVTLmRlY3J5cHRvci5kZWNyeXB0KGRhdGEsIDAsIGl2LmJ1ZmZlciB8fCBpdiwgdHJ1ZSlcbn1cblxuLy8g5LiL6L295YiG54mHXG5jb25zdCBkb3dubG9hZFRTID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IHJldHJ5ID0gMDtcbiAgbGV0IGRvd25sb2FkID0gKCkgPT4ge1xuICAgIGNvbnN0IGkgPSBpbmRleDtcbiAgICBpbmRleCsrO1xuICAgIGlmIChpID49IHRzTGlzdC5sZW5ndGgpIHtcbiAgICAgIC8vIGFsbCBzdWNjXG4gICAgICBjb25zdCBwcm9jTGlzdCA9IHN0YXR1c0xpc3QuZmlsdGVyKHMgPT4gWydzdWNjJywgJ2xvYWRpbmcnXS5pbmNsdWRlcyhzLnN0YXR1cykpO1xuICAgICAgaWYgKHByb2NMaXN0Lmxlbmd0aCA9PT0gdHNMaXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXRyeSA8IDUpIHtcbiAgICAgICAgLy8gcmV0cnkgYWdhaW5cbiAgICAgICAgcmV0cnkgKys7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBkb3dubG9hZCgpLCAxMDAwKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3JldHJ5JywgcmV0cnksIHByb2NMaXN0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdkb3dubG9hZCcsIGkpO1xuICAgIGlmIChzdGF0dXNMaXN0W2ldICYmIFsnZXJyb3InLCAnaW5pdCddLmluY2x1ZGVzKHN0YXR1c0xpc3RbaV0uc3RhdHVzKSkge1xuICAgICAgc3RhdHVzTGlzdFtpXS5zdGF0dXMgPSAnbG9hZGluZydcbiAgICAgIGFqYXgoe1xuICAgICAgICB1cmw6IHRzTGlzdFtpXSxcbiAgICAgICAgc3VjY2VzczogKGRhdGEpID0+IHtcbiAgICAgICAgICBzdGF0dXNMaXN0W2ldLnN0YXR1cyA9ICdzdWNjJ1xuICAgICAgICAgIGRlYWxUUyhkYXRhLCBpLCBvcHRzLCAoKSA9PiB7XG4gICAgICAgICAgICBvcHRzLm9ucHJvZ3Jlc3MobWVkaWFGaWxlTGlzdC5sZW5ndGgsIHRzTGlzdC5sZW5ndGggKyAxKVxuICAgICAgICAgICAgZG93bmxvYWQoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGZhaWw6IChlKSA9PiB7XG4gICAgICAgICAgLy8gbGV0IGVyciA9IGUuc3RhdHVzVGV4dFxuICAgICAgICAgIGNvbnNvbGUubG9nKHsgZSwgaSB9KTtcbiAgICAgICAgICAvLyB0b2RvOiByZXRyeVxuICAgICAgICAgIHN0YXR1c0xpc3RbaV0uc3RhdHVzID0gJ2Vycm9yJ1xuICAgICAgICAgIGRvd25sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHsgLy8g6Lez6L+H5bey57uP5oiQ5Yqf55qE54mH5q61XG4gICAgICBkb3dubG9hZCgpXG4gICAgfVxuICB9XG5cbiAgLy8g5bm26KGMIE7nur/nqIvkuIvovb1cbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IDM7IGlpKyspIHtcbiAgICBkb3dubG9hZCgpXG4gIH1cbn1cblxuY29uc3QgbXA0QnlKYmluYXJ5ID0gKGRhdGFDaHVua3MsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihkYXRhQ2h1bmtzLm1hcChkYXRhID0+IG5ldyBVaW50OEFycmF5KGRhdGEpKSwgeyB0eXBlOiAndmlkZW8vbXAydCcgfSk7XG4gIGpCaW5hcnkubG9hZChibG9iLCBNUEVHVFMsIChlcnIsIG1wZWd0cykgPT4ge1xuICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKHsgZXJyIH0pO1xuICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgbXA0T2JqID0gbXBlZ3RzX3RvX21wNChtcGVndHMpO1xuICAgIGNvbnNvbGUubG9nKGBDb252ZXJ0ZWQgZmluaXNoZWQsIHRpbWUgZWxhcHNlZDogJHtuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0fW1zYCk7XG4gICAgY29uc3QgZGF0YSA9IHsgZG93bmxvYWRMaW5rOiBtcDRPYmoudG9VUkkoJ3ZpZGVvL21wNCcpIH07XG4gICAgY2FsbGJhY2soZGF0YSk7XG4gIH0pO1xufTtcblxuLy8g5aSE55CGIHRzIOeJh+aute+8jEFFUyDop6Plr4bjgIFtcDQg6L2s56CBXG5jb25zdCBkZWFsVFMgPSBmdW5jdGlvbiAocmF3RGF0YSwgaW5kZXgsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGRhdGEgPSBBRVMudXJpID8gZGVjcnlwdFRzKHJhd0RhdGEsIGluZGV4KSA6IHJhd0RhdGFcbiAgbWVkaWFGaWxlTGlzdFtpbmRleF0gPSBkYXRhO1xuICBpZiAobWVkaWFGaWxlTGlzdC5maWx0ZXIobSA9PiBtIHx8IGZhbHNlKS5sZW5ndGggPT09IHRzTGlzdC5sZW5ndGgpIHtcbiAgICBtcDRCeUpiaW5hcnkobWVkaWFGaWxlTGlzdCwgcmVzID0+IHtcbiAgICAgIGNocm9tZS5kb3dubG9hZHMuZG93bmxvYWQoe1xuICAgICAgICB1cmw6IHJlcy5kb3dubG9hZExpbmssXG4gICAgICAgIGZpbGVuYW1lOiBvcHRzLmZpbGVOYW1lLFxuICAgICAgfSwgZG93bmxvYWRJZCA9PiB7XG4gICAgICAgIG9wdHMub25sb2FkKClcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChyZXMuZG93bmxvYWRMaW5rKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gIH1cbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxufVxuXG5jb25zdCBhamF4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgIGxldCBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgIG9wdGlvbnMuc3VjY2VzcyAmJiBvcHRpb25zLnN1Y2Nlc3MoeGhyLnJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuZmFpbCAmJiBvcHRpb25zLmZhaWwoc3RhdHVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgeGhyLm9wZW4oXCJHRVRcIiwgb3B0aW9ucy51cmwsIHRydWUpO1xuICB4aHIuc2VuZChudWxsKTtcbn0iLCJpbXBvcnQgeyBkZWVwQ29weSB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5jb25zdCB7IGNyZWF0ZUZGbXBlZywgZmV0Y2hGaWxlIH0gPSByZXF1aXJlKCdAZmZtcGVnL2ZmbXBlZycpO1xuY29uc3QgeyBjaHJvbWUgfSA9IGdsb2JhbDtcblxubGV0IGZmbXBlZztcbmFzeW5jIGZ1bmN0aW9uIGxvYWQoKSB7XG4gIGlmIChmZm1wZWcpIHJldHVybiBmZm1wZWc7XG4gIGZmbXBlZyA9IGNyZWF0ZUZGbXBlZyh7XG4gICAgY29yZVBhdGg6ICcvcHVibGljL2xpYi9mZm1wZWctY29yZS5qcycsXG4gICAgbG9nOiBmYWxzZSxcbiAgfSk7XG4gIGF3YWl0IGZmbXBlZy5sb2FkKCk7XG4gIGNvbnNvbGUuaW5mbygnZmYgbG9hZGVkJywgeyBmZm1wZWcgfSk7XG4gIHJldHVybiBmZm1wZWc7XG59XG5cbmNvbnN0IG1lcmdlID0gYXN5bmMgKHZpZGVvLCBhdWRpbykgPT4ge1xuICAvLyBjb25zb2xlLmluZm8oeyB2aWRlbywgYXVkaW8gfSk7XG4gIGZmbXBlZy5GUygnd3JpdGVGaWxlJywgJ3ZpZGVvLm1wNCcsIGF3YWl0IGZldGNoRmlsZSh2aWRlbykpO1xuICBmZm1wZWcuRlMoJ3dyaXRlRmlsZScsICdhdWRpby5tcDMnLCBhd2FpdCBmZXRjaEZpbGUoYXVkaW8pKTtcbiAgYXdhaXQgZmZtcGVnLnJ1bignLWknLCAndmlkZW8ubXA0JywgJy1pJywgJ2F1ZGlvLm1wMycsICctYycsICdjb3B5JywgJ291dC5tcDQnKTtcbiAgcmV0dXJuIGZmbXBlZy5GUygncmVhZEZpbGUnLCAnb3V0Lm1wNCcpO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0KG9wdHMsIGh0dHBSZXF1ZXN0LCBwcm9ncmVzcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG9wdHMucmVxdWVzdHNbb3B0cy5pZF0gPSB7XG4gICAgICBpZDogb3B0cy5pZCxcbiAgICAgIHRhYklkOiBvcHRzLnNyYy50YWIuaWQsXG4gICAgICBldmVudHNUb05vdGlmeTogWydlcnJvcicsICdsb2FkJywgJ3Byb2dyZXNzJ10sXG4gICAgICB4aHI6IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgIH07XG4gICAgb3B0cy50eXBlID0gJ2Rvd25sb2FkJztcbiAgICBvcHRzLmZpbGVOYW1lID0gbnVsbDtcbiAgICBvcHRzLmRhdGEgPSBbXTtcbiAgICBodHRwUmVxdWVzdChvcHRzLCBvcHRzLnNyYywgcmVzID0+IHtcbiAgICAgIC8vIGNvbnNvbGUuaW5mbygnaHR0cFJlcXVlc3QnLCByZXMpO1xuICAgICAgaWYgKHJlcy50eXBlID09PSAncHJvZ3Jlc3MnKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuaW5mbygnaHR0cFJlcXVlc3QnLCByZXMuZGF0YT8ubG9hZGVkLCByZXMuZGF0YT8udG90YWwpO1xuICAgICAgICBwcm9ncmVzcyhyZXMuZGF0YT8ubG9hZGVkLCByZXMuZGF0YT8udG90YWwpO1xuICAgICAgfSBlbHNlIGlmIChyZXMudHlwZSA9PT0gJ2xvYWQnKSB7XG4gICAgICAgIHJlc29sdmUocmVzLmRhdGEpO1xuICAgICAgfSBlbHNlIGlmIChyZXMudHlwZSA9PT0gJ2xvYWRlbmQnKSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lcmdlVmlkZW8ob3B0cywgaHR0cFJlcXVlc3QpIHtcbiAgLy8gY29uc29sZS5pbmZvKCdtZXJnZVZpZGVvJywgb3B0cyk7XG4gIGNvbnN0IHByb2dyZXNzID0ge1xuICAgIHZpZGVvOiB7IGxvYWRlZDogMCwgdG90YWw6IDAgfSxcbiAgICBhdWRpbzogeyBsb2FkZWQ6IDAsIHRvdGFsOiAwIH0sXG4gIH07XG5cbiAgY29uc3Qgb25wcm9ncmVzcyA9IChwcCwgbG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgIGlmIChsb2FkZWQgJiYgdG90YWwpIE9iamVjdC5hc3NpZ24ocHAsIHsgbG9hZGVkLCB0b3RhbCB9KTtcbiAgICBjb25zdCBfbG9hZGVkID0gcHJvZ3Jlc3MudmlkZW8ubG9hZGVkICsgcHJvZ3Jlc3MuYXVkaW8ubG9hZGVkO1xuICAgIGNvbnN0IF90b3RhbCA9IHByb2dyZXNzLnZpZGVvLnRvdGFsICsgcHJvZ3Jlc3MuYXVkaW8udG90YWw7XG4gICAgaWYgKF9sb2FkZWQgJiYgX3RvdGFsKSBvcHRzLm9ucHJvZ3Jlc3MoX2xvYWRlZCwgX3RvdGFsICsgMSk7XG4gIH07XG5cbiAgY29uc3QgcHJlbG9hZHMgPSBbXTtcbiAgcHJlbG9hZHMucHVzaChsb2FkKCkpO1xuXG4gIGNvbnN0IHZpZGVvT3B0cyA9IGRlZXBDb3B5KG9wdHMpO1xuICB2aWRlb09wdHMucmVxdWVzdHMgPSBvcHRzLnJlcXVlc3RzO1xuICB2aWRlb09wdHMuaWQgPSBgJHtvcHRzLmlkfS52aWRlb2A7XG4gIHByZWxvYWRzLnB1c2goZ2V0KHZpZGVvT3B0cywgaHR0cFJlcXVlc3QsIChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgb25wcm9ncmVzcyhwcm9ncmVzcy52aWRlbywgbG9hZGVkLCB0b3RhbCk7XG4gIH0pKTtcblxuICBjb25zdCBhdWRpb09wdHMgPSBkZWVwQ29weShvcHRzKTtcbiAgYXVkaW9PcHRzLnJlcXVlc3RzID0gb3B0cy5yZXF1ZXN0cztcbiAgYXVkaW9PcHRzLnVybCA9IG9wdHMuZGF0YVswXTtcbiAgYXVkaW9PcHRzLmlkID0gYCR7b3B0cy5pZH0uYXVkaW9gO1xuICBwcmVsb2Fkcy5wdXNoKGdldChhdWRpb09wdHMsIGh0dHBSZXF1ZXN0LCAobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgIG9ucHJvZ3Jlc3MocHJvZ3Jlc3MuYXVkaW8sIGxvYWRlZCwgdG90YWwpO1xuICB9KSk7XG5cbiAgY29uc3QgdmFscyA9IGF3YWl0IFByb21pc2UuYWxsKHByZWxvYWRzKTtcbiAgaWYgKCF2YWxzWzFdIHx8ICF2YWxzWzJdKSB7XG4gICAgLy8gZmFpbFxuICAgIG9wdHMub25lcnJvcigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNvbnNvbGUuaW5mbyh7IHZhbHMgfSk7XG4gIGNvbnN0IG91dCA9IGF3YWl0IG1lcmdlKHZhbHNbMV0sIHZhbHNbMl0pO1xuICAvLyBjb25zb2xlLmluZm8oJ291dCcsIHsgb3V0IH0pO1xuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtvdXRdLCB7IHR5cGUgOiAndmlkZW8vbXA0JyB9KSk7XG4gIC8vIGNvbnNvbGUuaW5mbygncmVzJywgeyB1cmwsIGZpbGVuYW1lOiBvcHRzLmZpbGVOYW1lIH0pO1xuICBjaHJvbWUuZG93bmxvYWRzLmRvd25sb2FkKHtcbiAgICB1cmwsXG4gICAgZmlsZW5hbWU6IG9wdHMuZmlsZU5hbWUsXG4gIH0sIGRvd25sb2FkSWQgPT4ge1xuICAgIC8vIGNvbnNvbGUuaW5mbyhkb3dubG9hZElkKTtcbiAgICBvcHRzLm9ubG9hZChkb3dubG9hZElkKTtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgZGVmYXVsdEltYWdlLCBpMThuLCBub29wIH0gZnJvbSAnIy9jb21tb24nO1xuXG5leHBvcnQgY29uc3QgY29tbWFuZHMgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vdGlmeShvcHRpb25zKSB7XG4gIGJyb3dzZXIubm90aWZpY2F0aW9ucy5jcmVhdGUob3B0aW9ucy5pZCB8fCAnVmlvbGVudE1vbmtleScsIHtcbiAgICB0eXBlOiAnYmFzaWMnLFxuICAgIGljb25Vcmw6IGRlZmF1bHRJbWFnZSxcbiAgICB0aXRsZTogYCR7b3B0aW9ucy50aXRsZX0gLSAke2kxOG4oJ2V4dE5hbWUnKX1gLFxuICAgIG1lc3NhZ2U6IG9wdGlvbnMuYm9keSxcbiAgICBpc0NsaWNrYWJsZTogb3B0aW9ucy5pc0NsaWNrYWJsZSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicm9hZGNhc3QoZGF0YSkge1xuICBmb3JFYWNoVGFiKCh0YWIpID0+IHtcbiAgICBicm93c2VyLnRhYnMuc2VuZE1lc3NhZ2UodGFiLmlkLCBkYXRhKVxuICAgIC5jYXRjaChub29wKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZW5kTWVzc2FnZU9ySWdub3JlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGJyb3dzZXIucnVudGltZS5zZW5kTWVzc2FnZSguLi5hcmdzKS5jYXRjaChub29wKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZvckVhY2hUYWIoY2FsbGJhY2spIHtcbiAgY29uc3QgdGFicyA9IGF3YWl0IGJyb3dzZXIudGFicy5xdWVyeSh7fSk7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCB0YWIgb2YgdGFicykge1xuICAgIGNhbGxiYWNrKHRhYik7XG4gICAgaSArPSAxO1xuICAgIC8vIHdlJ2xsIHJ1biBhdCBtb3N0IHRoaXMgbWFueSB0YWJzIGluIG9uZSBldmVudCBsb29wIGN5Y2xlXG4gICAgLy8gYmVjYXVzZSBodW5kcmVkcyBvZiB0YWJzIHdvdWxkIG1ha2Ugb3VyIGV4dGVuc2lvbiBwcm9jZXNzIHVucmVzcG9uc2l2ZSxcbiAgICAvLyB0aGUgc2FtZSBwcm9jZXNzIHVzZWQgYnkgb3VyIG93biBwYWdlcyBsaWtlIHRoZSBiYWNrZ3JvdW5kIHBhZ2UsIGRhc2hib2FyZCwgb3IgcG9wdXBzXG4gICAgaWYgKGkgJSAyMCA9PT0gMCkgYXdhaXQgbmV3IFByb21pc2Uoc2V0VGltZW91dCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGkxOG4sIGRlZmF1bHRJbWFnZSwgc2VuZFRhYkNtZCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi9tZXNzYWdlJztcblxuY29uc3Qgb3BlbmVycyA9IHt9O1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59ICovXG4gIGFzeW5jIE5vdGlmaWNhdGlvbihkYXRhLCBzcmMsIGJnRXh0cmFzKSB7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uSWQgPSBhd2FpdCBicm93c2VyLm5vdGlmaWNhdGlvbnMuY3JlYXRlKHtcbiAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICB0aXRsZTogZGF0YS50aXRsZSB8fCAoSVNfRklSRUZPWCA/IGkxOG4oJ2V4dE5hbWUnKSA6ICcnKSwgLy8gQ2hyb21lIGFscmVhZHkgc2hvd3MgdGhlIG5hbWVcbiAgICAgIG1lc3NhZ2U6IGRhdGEudGV4dCxcbiAgICAgIGljb25Vcmw6IGRhdGEuaW1hZ2UgfHwgZGVmYXVsdEltYWdlLFxuICAgIH0pO1xuICAgIG9wZW5lcnNbbm90aWZpY2F0aW9uSWRdID0gYmdFeHRyYXM/Lm9uQ2xpY2sgfHwgc3JjLnRhYi5pZDtcbiAgICByZXR1cm4gbm90aWZpY2F0aW9uSWQ7XG4gIH0sXG4gIFJlbW92ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb25JZCkge1xuICAgIHJldHVybiBicm93c2VyLm5vdGlmaWNhdGlvbnMuY2xlYXIobm90aWZpY2F0aW9uSWQpO1xuICB9LFxufSk7XG5cbmJyb3dzZXIubm90aWZpY2F0aW9ucy5vbkNsaWNrZWQuYWRkTGlzdGVuZXIoKGlkKSA9PiB7XG4gIGNvbnN0IG9wZW5lcklkID0gb3BlbmVyc1tpZF07XG4gIGlmIChvcGVuZXJJZCA+PSAwKSB7XG4gICAgc2VuZFRhYkNtZChvcGVuZXJJZCwgJ05vdGlmaWNhdGlvbkNsaWNrJywgaWQpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3BlbmVySWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcGVuZXJJZCgpO1xuICB9XG59KTtcblxuYnJvd3Nlci5ub3RpZmljYXRpb25zLm9uQ2xvc2VkLmFkZExpc3RlbmVyKChpZCkgPT4ge1xuICBjb25zdCBvcGVuZXJJZCA9IG9wZW5lcnNbaWRdO1xuICBkZWxldGUgb3BlbmVyc1tpZF07XG4gIGlmIChvcGVuZXJJZCA+PSAwKSB7XG4gICAgc2VuZFRhYkNtZChvcGVuZXJJZCwgJ05vdGlmaWNhdGlvbkNsb3NlJywgaWQpO1xuICB9XG59KTtcbiIsImltcG9ydCB7XG4gIGRlYm91bmNlLCBlbnN1cmVBcnJheSwgaW5pdEhvb2tzLCBub3JtYWxpemVLZXlzLFxufSBmcm9tICcjL2NvbW1vbic7XG5pbXBvcnQgeyBtYXBFbnRyeSwgb2JqZWN0R2V0LCBvYmplY3RTZXQgfSBmcm9tICcjL2NvbW1vbi9vYmplY3QnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJyMvY29tbW9uL29wdGlvbnMtZGVmYXVsdHMnO1xuaW1wb3J0IHsgcHJlSW5pdGlhbGl6ZSB9IGZyb20gJy4vaW5pdCc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgLyoqIEByZXR1cm4ge09iamVjdH0gKi9cbiAgR2V0QWxsT3B0aW9ucygpIHtcbiAgICByZXR1cm4gY29tbWFuZHMuR2V0T3B0aW9ucyhkZWZhdWx0cyk7XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHtPYmplY3R9ICovXG4gIEdldE9wdGlvbnMoZGF0YSkge1xuICAgIHJldHVybiBkYXRhOjptYXBFbnRyeSgoW2tleV0pID0+IGdldE9wdGlvbihrZXkpKTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge3ZvaWR9ICovXG4gIFNldE9wdGlvbnMoZGF0YSkge1xuICAgIGVuc3VyZUFycmF5KGRhdGEpLmZvckVhY2goaXRlbSA9PiBzZXRPcHRpb24oaXRlbS5rZXksIGl0ZW0udmFsdWUpKTtcbiAgfSxcbn0pO1xuXG5sZXQgY2hhbmdlcyA9IHt9O1xuY29uc3QgaG9va3MgPSBpbml0SG9va3MoKTtcbmNvbnN0IGNhbGxIb29rc0xhdGVyID0gZGVib3VuY2UoY2FsbEhvb2tzLCAxMDApO1xuXG5sZXQgb3B0aW9ucyA9IHt9O1xubGV0IGluaXRQZW5kaW5nID0gYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmdldCgnb3B0aW9ucycpXG4udGhlbigoeyBvcHRpb25zOiBkYXRhIH0pID0+IHtcbiAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSBvcHRpb25zID0gZGF0YTtcbiAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgY29uc29sZS5sb2coJ29wdGlvbnM6Jywgb3B0aW9ucyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICB9XG4gIGlmICghb2JqZWN0R2V0KG9wdGlvbnMsICd2ZXJzaW9uJykpIHtcbiAgICBzZXRPcHRpb24oJ3ZlcnNpb24nLCAxKTtcbiAgfVxuICBpbml0UGVuZGluZyA9IG51bGw7XG59KTtcbnByZUluaXRpYWxpemUucHVzaChpbml0UGVuZGluZyk7XG5cbmZ1bmN0aW9uIGZpcmVDaGFuZ2Uoa2V5cywgdmFsdWUpIHtcbiAgLy8gRmxhdHRlbmluZyBrZXkgcGF0aCBzbyB0aGUgc3Vic2NyaWJlcnMgY2FuIHVwZGF0ZSBuZXN0ZWQgdmFsdWVzIHdpdGhvdXQgb3ZlcndyaXRpbmcgdGhlIHBhcmVudFxuICBjb25zdCBrZXkgPSBrZXlzLmpvaW4oJy4nKTtcbiAgLy8gRW5zdXJpbmcgdGhlIGNvcnJlY3Qgb3JkZXIgd2hlbiB1cGRhdGVzIHdlcmUgbWl4ZWQgbGlrZSB0aGlzOiBmb28uYmFyPTE7IGZvbz17YmFyOjJ9OyBmb28uYmFyPTNcbiAgZGVsZXRlIGNoYW5nZXNba2V5XTtcbiAgY2hhbmdlc1trZXldID0gdmFsdWU7XG4gIGNhbGxIb29rc0xhdGVyKCk7XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rcygpIHtcbiAgaG9va3MuZmlyZShjaGFuZ2VzKTtcbiAgY2hhbmdlcyA9IHt9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3B0aW9uKGtleSwgZGVmKSB7XG4gIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlzKGtleSk7XG4gIGNvbnN0IG1haW5LZXkgPSBrZXlzWzBdO1xuICBsZXQgdmFsdWUgPSBvcHRpb25zW21haW5LZXldO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSBkZWZhdWx0c1ttYWluS2V5XTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHZhbHVlID0gZGVmO1xuICByZXR1cm4ga2V5cy5sZW5ndGggPiAxID8gb2JqZWN0R2V0KHZhbHVlLCBrZXlzLnNsaWNlKDEpLCBkZWYpIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0T3B0aW9uKGtleSkge1xuICByZXR1cm4gb2JqZWN0R2V0KGRlZmF1bHRzLCBrZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcbiAgaWYgKGluaXRQZW5kaW5nKSB7XG4gICAgaW5pdFBlbmRpbmcudGhlbigoKSA9PiB7XG4gICAgICBzZXRPcHRpb24oa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlzKGtleSk7XG4gIGNvbnN0IG9wdGlvbktleSA9IGtleXMuam9pbignLicpO1xuICBsZXQgb3B0aW9uVmFsdWUgPSB2YWx1ZTtcbiAgY29uc3QgbWFpbktleSA9IGtleXNbMF07XG4gIGlmIChtYWluS2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoID4gMSkge1xuICAgICAgb3B0aW9uVmFsdWUgPSBvYmplY3RTZXQoZ2V0T3B0aW9uKG1haW5LZXkpLCBrZXlzLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgfVxuICAgIG9wdGlvbnNbbWFpbktleV0gPSBvcHRpb25WYWx1ZTtcbiAgICBicm93c2VyLnN0b3JhZ2UubG9jYWwuc2V0KHsgb3B0aW9ucyB9KTtcbiAgICBmaXJlQ2hhbmdlKGtleXMsIHZhbHVlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdPcHRpb25zIHVwZGF0ZWQ6Jywgb3B0aW9uS2V5LCB2YWx1ZSwgb3B0aW9ucyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaG9va09wdGlvbnMgPSBob29rcy5ob29rO1xuIiwiaW1wb3J0IHsgcGFyc2VNZXRhIH0gZnJvbSAnLi9zY3JpcHQnO1xuaW1wb3J0IHN0b3JhZ2UgZnJvbSAnIy9jb21tb24vc3RvcmFnZSc7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc29sZS5pbmZvKCdVcGdyYWRlIGRhdGFiYXNlLi4uJyk7XG4gIGluaXQoKTtcbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjb25zdCByZXEgPSBpbmRleGVkREIub3BlbignVmlvbGVudG1vbmtleScsIDEpO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0cmFuc2Zvcm0ocmVxLnJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IGRpZCBoYXBwZW4gaW4gRmlyZWZveC5cbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICByZXEub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xuICAgICAgLy8gTm8gYXZhaWxhYmxlIHVwZ3JhZGF0aW9uXG4gICAgICByZWplY3QoKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybShkYikge1xuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oWydzY3JpcHRzJywgJ3JlcXVpcmUnLCAnY2FjaGUnLCAndmFsdWVzJ10pO1xuICAgIGNvbnN0IHVwZGF0ZXMgPSB7fTtcbiAgICBsZXQgcHJvY2Vzc2luZyA9IDM7XG4gICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgIHByb2Nlc3NpbmcgLT0gMTtcbiAgICAgIGlmICghcHJvY2Vzc2luZykgcmVzb2x2ZShicm93c2VyLnN0b3JhZ2UubG9jYWwuc2V0KHVwZGF0ZXMpKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEFsbCA9IChzdG9yZU5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB0eC5vYmplY3RTdG9yZShzdG9yZU5hbWUpLmdldEFsbCgpO1xuICAgICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IGNhbGxiYWNrKHJlcS5yZXN1bHQpO1xuICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgfTtcbiAgICBnZXRBbGwoJ3NjcmlwdHMnLCAoYWxsU2NyaXB0cykgPT4ge1xuICAgICAgY29uc3QgdXJpTWFwID0ge307XG4gICAgICBhbGxTY3JpcHRzLmZvckVhY2goKHNjcmlwdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGNvZGUsIGlkLCB1cmkgfSA9IHNjcmlwdDtcbiAgICAgICAgdXBkYXRlc1tgJHtzdG9yYWdlLnNjcmlwdC5wcmVmaXh9JHtpZH1gXSA9IHRyYW5zZm9ybVNjcmlwdChzY3JpcHQpO1xuICAgICAgICB1cGRhdGVzW2Ake3N0b3JhZ2UuY29kZS5wcmVmaXh9JHtpZH1gXSA9IGNvZGU7XG4gICAgICAgIHVyaU1hcFt1cmldID0gaWQ7XG4gICAgICB9KTtcbiAgICAgIGdldEFsbCgndmFsdWVzJywgKGFsbFZhbHVlcykgPT4ge1xuICAgICAgICBhbGxWYWx1ZXMuZm9yRWFjaCgoeyB1cmksIHZhbHVlcyB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgaWQgPSB1cmlNYXBbdXJpXTtcbiAgICAgICAgICBpZiAoaWQpIHVwZGF0ZXNbYCR7c3RvcmFnZS52YWx1ZS5wcmVmaXh9JHtpZH1gXSA9IHZhbHVlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGdldEFsbCgnY2FjaGUnLCAoYWxsQ2FjaGUpID0+IHtcbiAgICAgIGFsbENhY2hlLmZvckVhY2goKHsgdXJpLCBkYXRhIH0pID0+IHtcbiAgICAgICAgdXBkYXRlc1tgJHtzdG9yYWdlLmNhY2hlLnByZWZpeH0ke3VyaX1gXSA9IGRhdGE7XG4gICAgICB9KTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgICBnZXRBbGwoJ3JlcXVpcmUnLCAoYWxsUmVxdWlyZSkgPT4ge1xuICAgICAgYWxsUmVxdWlyZS5mb3JFYWNoKCh7IHVyaSwgY29kZSB9KSA9PiB7XG4gICAgICAgIHVwZGF0ZXNbYCR7c3RvcmFnZS5yZXF1aXJlLnByZWZpeH0ke3VyaX1gXSA9IGNvZGU7XG4gICAgICB9KTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2Zvcm1TY3JpcHQoc2NyaXB0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGE6IHBhcnNlTWV0YShzY3JpcHQuY29kZSksXG4gICAgICBjdXN0b206IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBvcmlnSW5jbHVkZTogdHJ1ZSxcbiAgICAgICAgb3JpZ0V4Y2x1ZGU6IHRydWUsXG4gICAgICAgIG9yaWdNYXRjaDogdHJ1ZSxcbiAgICAgICAgb3JpZ0V4Y2x1ZGVNYXRjaDogdHJ1ZSxcbiAgICAgIH0sIHNjcmlwdC5jdXN0b20pLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaWQ6IHNjcmlwdC5pZCxcbiAgICAgICAgdXJpOiBzY3JpcHQudXJpLFxuICAgICAgICBwb3NpdGlvbjogc2NyaXB0LnBvc2l0aW9uLFxuICAgICAgfSxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBlbmFibGVkOiBzY3JpcHQuZW5hYmxlZCxcbiAgICAgICAgc2hvdWxkVXBkYXRlOiBzY3JpcHQudXBkYXRlLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG59KVxuLy8gSWdub3JlIGVycm9yXG4uY2F0Y2goKCkgPT4ge30pO1xuIiwiaW1wb3J0IHsgZ2V0QWN0aXZlVGFiLCBzZW5kVGFiQ21kIH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IGNhY2hlIGZyb20gJy4vY2FjaGUnO1xuaW1wb3J0IHsgZ2V0RGF0YSB9IGZyb20gJy4vZGInO1xuaW1wb3J0IHsgcG9zdEluaXRpYWxpemUgfSBmcm9tICcuL2luaXQnO1xuaW1wb3J0IHsgY29tbWFuZHMgfSBmcm9tICcuL21lc3NhZ2UnO1xuXG5leHBvcnQgY29uc3QgcG9wdXBUYWJzID0ge307IC8vIHsgdGFiSWQ6IDEgfVxuXG5wb3N0SW5pdGlhbGl6ZS5wdXNoKCgpID0+IHtcbiAgYnJvd3Nlci5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcihvblBvcHVwT3BlbmVkKTtcbiAgYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uQmVmb3JlUmVxdWVzdC5hZGRMaXN0ZW5lcihwcmVmZXRjaFNldFBvcHVwLCB7XG4gICAgdXJsczogW2Jyb3dzZXIucnVudGltZS5nZXRVUkwoYnJvd3Nlci5ydW50aW1lLmdldE1hbmlmZXN0KCkuYnJvd3Nlcl9hY3Rpb24uZGVmYXVsdF9wb3B1cCldLFxuICAgIHR5cGVzOiBbJ21haW5fZnJhbWUnXSxcbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gb25Qb3B1cE9wZW5lZChwb3J0KSB7XG4gIGNvbnN0IHRhYklkID0gK3BvcnQubmFtZTtcbiAgcG9wdXBUYWJzW3RhYklkXSA9IDE7XG4gIHNlbmRUYWJDbWQodGFiSWQsICdQb3B1cFNob3duJywgdHJ1ZSk7XG4gIHBvcnQub25EaXNjb25uZWN0LmFkZExpc3RlbmVyKG9uUG9wdXBDbG9zZWQpO1xuICBkZWxldGUgY29tbWFuZHMuU2V0UG9wdXA7XG59XG5cbmZ1bmN0aW9uIG9uUG9wdXBDbG9zZWQoeyBuYW1lIH0pIHtcbiAgZGVsZXRlIHBvcHVwVGFic1tuYW1lXTtcbiAgc2VuZFRhYkNtZCgrbmFtZSwgJ1BvcHVwU2hvd24nLCBmYWxzZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU2V0UG9wdXAoKSB7XG4gIGNvbnN0IHRhYklkID0gKGF3YWl0IGdldEFjdGl2ZVRhYigpKS5pZDtcbiAgc2VuZFRhYkNtZCh0YWJJZCwgJ1BvcHVwU2hvd24nLCB0cnVlKTtcbiAgY29tbWFuZHMuU2V0UG9wdXAgPSBhc3luYyAoZGF0YSwgc3JjKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihkYXRhLCBhd2FpdCBnZXREYXRhKGRhdGEuaWRzKSk7XG4gICAgY2FjaGUucHV0KCdTZXRQb3B1cCcsIE9iamVjdC5hc3NpZ24oeyBbc3JjLmZyYW1lSWRdOiBbZGF0YSwgc3JjXSB9LCBjYWNoZS5nZXQoJ1NldFBvcHVwJykpKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7IGdldFNjcmlwdE5hbWUsIGdldFVuaXFJZCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7XG4gIElOSkVDVF9BVVRPLCBJTkpFQ1RfQ09OVEVOVCwgSU5KRUNUX01BUFBJTkcsXG4gIElOSkVDVEFCTEVfVEFCX1VSTF9SRSwgTUVUQUJMT0NLX1JFLFxufSBmcm9tICcjL2NvbW1vbi9jb25zdHMnO1xuaW1wb3J0IGluaXRDYWNoZSBmcm9tICcjL2NvbW1vbi9jYWNoZSc7XG5pbXBvcnQgeyBmb3JFYWNoRW50cnksIG9iamVjdFBpY2ssIG9iamVjdFNldCB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgc3RvcmFnZSBmcm9tICcjL2NvbW1vbi9zdG9yYWdlJztcbmltcG9ydCB1YSBmcm9tICcjL2NvbW1vbi91YSc7XG5pbXBvcnQgeyBnZXRTY3JpcHRzQnlVUkwsIEVOVl9DQUNIRV9LRVlTLCBFTlZfUkVRX0tFWVMsIEVOVl9WQUxVRV9JRFMgfSBmcm9tICcuL2RiJztcbmltcG9ydCB7IGV4dGVuc2lvblJvb3QsIHBvc3RJbml0aWFsaXplIH0gZnJvbSAnLi9pbml0JztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IGdldE9wdGlvbiwgaG9va09wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnO1xuXG5jb25zdCBBUElfQ09ORklHID0ge1xuICB1cmxzOiBbJyo6Ly8qLyonXSwgLy8gYCpgIHNjaGVtZSBtYXRjaGVzIG9ubHkgaHR0cCBhbmQgaHR0cHNcbiAgdHlwZXM6IFsnbWFpbl9mcmFtZScsICdzdWJfZnJhbWUnXSxcbn07XG5jb25zdCBUSU1FX0FGVEVSX1NFTkQgPSAxMGUzOyAvLyBsb25nZXIgYXMgZXN0YWJsaXNoaW5nIGNvbm5lY3Rpb24gdG8gc2l0ZXMgbWF5IHRha2UgdGltZVxuY29uc3QgVElNRV9BRlRFUl9SRUNFSVZFID0gMWUzOyAvLyBzaG9ydGVyIGFzIHJlc3BvbnNlIGJvZHkgd2lsbCBiZSBjb21pbmcgdmVyeSBzb29uXG5jb25zdCBUSU1FX0tFRVBfREFUQSA9IDYwZTM7IC8vIDEwMG1zIHNob3VsZCBiZSBlbm91Z2ggYnV0IHRoZSB0YWIgbWF5IGhhbmcgb3IgZ2V0IHBhdXNlZCBpbiBkZWJ1Z2dlclxuY29uc3QgY2FjaGVDb2RlID0gaW5pdENhY2hlKHsgbGlmZXRpbWU6IFRJTUVfS0VFUF9EQVRBIH0pO1xuY29uc3QgY2FjaGUgPSBpbml0Q2FjaGUoe1xuICBsaWZldGltZTogVElNRV9LRUVQX0RBVEEsXG4gIG9uRGlzcG9zZTogYXN5bmMgcHJvbWlzZSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHByb21pc2U7XG4gICAgY29uc3QgcmNzID0gYXdhaXQgZGF0YT8ucmNzUHJvbWlzZTtcbiAgICByY3M/LnVucmVnaXN0ZXIoKTtcbiAgfSxcbn0pO1xuY29uc3QgSU5KRUNUX0lOVE8gPSAnaW5qZWN0SW50byc7XG4vLyBLRVlfWFhYIGZvciBob29rZWQgb3B0aW9uc1xuY29uc3QgS0VZX0VYUE9TRSA9ICdleHBvc2UnO1xuY29uc3QgS0VZX0RFRl9JTkpFQ1RfSU5UTyA9ICdkZWZhdWx0SW5qZWN0SW50byc7XG5jb25zdCBLRVlfSVNfQVBQTElFRCA9ICdpc0FwcGxpZWQnO1xuY29uc3QgS0VZX1hIUl9JTkpFQ1QgPSAneGhySW5qZWN0JztcbmNvbnN0IGV4cG9zZSA9IHt9O1xubGV0IGlzQXBwbGllZDtcbmxldCBpbmplY3RJbnRvO1xubGV0IHhockluamVjdDtcbmhvb2tPcHRpb25zKG9uT3B0aW9uQ2hhbmdlZCk7XG5wb3N0SW5pdGlhbGl6ZS5wdXNoKCgpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgb2YgW0tFWV9FWFBPU0UsIEtFWV9ERUZfSU5KRUNUX0lOVE8sIEtFWV9JU19BUFBMSUVELCBLRVlfWEhSX0lOSkVDVF0pIHtcbiAgICBvbk9wdGlvbkNoYW5nZWQoeyBba2V5XTogZ2V0T3B0aW9uKGtleSkgfSk7XG4gIH1cbn0pO1xuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIGFzeW5jIEluamVjdGlvbkZlZWRiYWNrKHsgZmVlZElkLCBmZWVkYmFjaywgZm9yY2VDb250ZW50IH0sIHNyYykge1xuICAgIGZlZWRiYWNrLmZvckVhY2gocHJvY2Vzc0ZlZWRiYWNrLCBzcmMpO1xuICAgIGlmIChmZWVkSWQpIHtcbiAgICAgIC8vIGNhY2hlIGNsZWFudXAgd2hlbiBnZXREYXRhRkYgb3V0cnVucyBHZXRJbmplY3RlZFxuICAgICAgY2FjaGUuZGVsKGZlZWRJZC5jYWNoZUtleSk7XG4gICAgICAvLyBlbnZEZWxheWVkXG4gICAgICBjb25zdCBlbnYgPSBhd2FpdCBjYWNoZS5wb3AoZmVlZElkLmVudktleSk7XG4gICAgICBpZiAoZW52KSB7XG4gICAgICAgIGVudi5mb3JjZUNvbnRlbnQgPSBmb3JjZUNvbnRlbnQ7XG4gICAgICAgIGVudi5zY3JpcHRzLm1hcChwcmVwYXJlU2NyaXB0LCBlbnYpLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKHByb2Nlc3NGZWVkYmFjaywgc3JjKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdFBpY2soZW52LCBbJ2NhY2hlJywgJ3NjcmlwdHMnXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxufSk7XG5cbi8qKiBAdGhpcyB7Y2hyb21lLnJ1bnRpbWUuTWVzc2FnZVNlbmRlcn0gKi9cbmZ1bmN0aW9uIHByb2Nlc3NGZWVkYmFjayhba2V5LCBuZWVkc0luamVjdGlvbl0pIHtcbiAgY29uc3QgY29kZSA9IGNhY2hlQ29kZS5wb3Aoa2V5KTtcbiAgLy8gc2VlIFRJTUVfS0VFUF9EQVRBIGNvbW1lbnRcbiAgaWYgKG5lZWRzSW5qZWN0aW9uICYmIGNvZGUpIHtcbiAgICBicm93c2VyLnRhYnMuZXhlY3V0ZVNjcmlwdCh0aGlzLnRhYi5pZCwge1xuICAgICAgY29kZSxcbiAgICAgIGZyYW1lSWQ6IHRoaXMuZnJhbWVJZCxcbiAgICAgIHJ1bkF0OiAnZG9jdW1lbnRfc3RhcnQnLFxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IHByb3BzVG9DbGVhciA9IHtcbiAgW3N0b3JhZ2UuY2FjaGUucHJlZml4XTogRU5WX0NBQ0hFX0tFWVMsXG4gIFtzdG9yYWdlLmNvZGUucHJlZml4XTogdHJ1ZSxcbiAgW3N0b3JhZ2UucmVxdWlyZS5wcmVmaXhdOiBFTlZfUkVRX0tFWVMsXG4gIFtzdG9yYWdlLnNjcmlwdC5wcmVmaXhdOiB0cnVlLFxuICBbc3RvcmFnZS52YWx1ZS5wcmVmaXhdOiBFTlZfVkFMVUVfSURTLFxufTtcblxuYnJvd3Nlci5zdG9yYWdlLm9uQ2hhbmdlZC5hZGRMaXN0ZW5lcihhc3luYyBjaGFuZ2VzID0+IHtcbiAgY29uc3QgZGJLZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG4gIGNvbnN0IGNhY2hlVmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FjaGUuZ2V0VmFsdWVzKCkpO1xuICBjb25zdCBkaXJ0eSA9IGNhY2hlVmFsdWVzLnNvbWUoZGF0YSA9PiBkYXRhLmluamVjdFxuICAgICYmIGRiS2V5cy5zb21lKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGtleS5zbGljZSgwLCBrZXkuaW5kZXhPZignOicpICsgMSk7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNUb0NsZWFyW3ByZWZpeF07XG4gICAgICBrZXkgPSBrZXkuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcHJvcCA9PT0gdHJ1ZVxuICAgICAgICB8fCBkYXRhW3Byb3BdPy5pbmNsdWRlcyhwcmVmaXggPT09IHN0b3JhZ2UudmFsdWUucHJlZml4ID8gK2tleSA6IGtleSk7XG4gICAgfSkpO1xuICBpZiAoZGlydHkpIHtcbiAgICBjYWNoZS5kZXN0cm95KCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBub3JtYWxpemVSZWFsbSh2YWx1ZSkge1xuICByZXR1cm4gSU5KRUNUX01BUFBJTkc6Omhhc093blByb3BlcnR5KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IGluamVjdEludG8gfHwgSU5KRUNUX0FVVE87XG59XG5cbmZ1bmN0aW9uIG9uT3B0aW9uQ2hhbmdlZChjaGFuZ2VzKSB7XG4gIGNoYW5nZXM6OmZvckVhY2hFbnRyeSgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIEtFWV9ERUZfSU5KRUNUX0lOVE86XG4gICAgICBpbmplY3RJbnRvID0gbm9ybWFsaXplUmVhbG0odmFsdWUpO1xuICAgICAgY2FjaGUuZGVzdHJveSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLRVlfWEhSX0lOSkVDVDpcbiAgICAgIHRvZ2dsZVhockluamVjdCh2YWx1ZSk7XG4gICAgICBjYWNoZS5kZXN0cm95KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEtFWV9JU19BUFBMSUVEOlxuICAgICAgdG9nZ2xlUHJlaW5qZWN0KHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgS0VZX0VYUE9TRTpcbiAgICAgIHZhbHVlOjpmb3JFYWNoRW50cnkoKFtzaXRlLCBpc0V4cG9zZWRdKSA9PiB7XG4gICAgICAgIGV4cG9zZVtkZWNvZGVVUklDb21wb25lbnQoc2l0ZSldID0gaXNFeHBvc2VkO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7IC8vIHVzZWQgYnkgYGV4cG9zZS51cmxgXG4gICAgICAgIG9uT3B0aW9uQ2hhbmdlZChvYmplY3RTZXQoe30sIGtleSwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKiogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluamVjdGVkU2NyaXB0cyh1cmwsIHRhYklkLCBmcmFtZUlkLCBmb3JjZUNvbnRlbnQpIHtcbiAgY29uc3Qga2V5ID0gZ2V0S2V5KHVybCwgIWZyYW1lSWQpO1xuICByZXR1cm4gY2FjaGUucG9wKGtleSkgfHwgcHJlcGFyZShrZXksIHVybCwgdGFiSWQsIGZyYW1lSWQsIGZvcmNlQ29udGVudCk7XG59XG5cbmZ1bmN0aW9uIGdldEtleSh1cmwsIGlzVG9wKSB7XG4gIHJldHVybiBpc1RvcCA/IHVybCA6IGAtJHt1cmx9YDtcbn1cblxuZnVuY3Rpb24gdG9nZ2xlUHJlaW5qZWN0KGVuYWJsZSkge1xuICBpc0FwcGxpZWQgPSBlbmFibGU7XG4gIC8vIFVzaW5nIG9uU2VuZEhlYWRlcnMgYmVjYXVzZSBvbkhlYWRlcnNSZWNlaXZlZCBpbiBGaXJlZm94IGZpcmVzICphZnRlciogY29udGVudCBzY3JpcHRzLlxuICAvLyBBbmQgZXZlbiBpbiBDaHJvbWUgYSBzaXRlIG1heSBiZSBzbyBmYXN0IHRoYXQgcHJlaW5qZWN0IG9uIG9uSGVhZGVyc1JlY2VpdmVkIHdvbid0IGJlIHVzZWZ1bC5cbiAgY29uc3Qgb25PZmYgPSBgJHtlbmFibGUgPyAnYWRkJyA6ICdyZW1vdmUnfUxpc3RlbmVyYDtcbiAgY29uc3QgY29uZmlnID0gZW5hYmxlID8gQVBJX0NPTkZJRyA6IHVuZGVmaW5lZDtcbiAgYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uU2VuZEhlYWRlcnNbb25PZmZdKG9uU2VuZEhlYWRlcnMsIGNvbmZpZyk7XG4gIGlmICghaXNBcHBsaWVkIHx8ICF4aHJJbmplY3QpIHsgLy8gd2lsbCBiZSByZWdpc3RlcmVkIGluIHRvZ2dsZVhockluamVjdFxuICAgIGJyb3dzZXIud2ViUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZFtvbk9mZl0ob25IZWFkZXJzUmVjZWl2ZWQsIGNvbmZpZyk7XG4gIH1cbiAgY2FjaGUuZGVzdHJveSgpO1xufVxuXG5mdW5jdGlvbiB0b2dnbGVYaHJJbmplY3QoZW5hYmxlKSB7XG4gIHhockluamVjdCA9IGVuYWJsZTtcbiAgYnJvd3Nlci53ZWJSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkLnJlbW92ZUxpc3RlbmVyKG9uSGVhZGVyc1JlY2VpdmVkKTtcbiAgaWYgKGVuYWJsZSkge1xuICAgIGJyb3dzZXIud2ViUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZC5hZGRMaXN0ZW5lcihvbkhlYWRlcnNSZWNlaXZlZCwgQVBJX0NPTkZJRywgW1xuICAgICAgJ2Jsb2NraW5nJyxcbiAgICAgICdyZXNwb25zZUhlYWRlcnMnLFxuICAgICAgYnJvd3Nlci53ZWJSZXF1ZXN0Lk9uSGVhZGVyc1JlY2VpdmVkT3B0aW9ucy5FWFRSQV9IRUFERVJTLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblNlbmRIZWFkZXJzKHsgdXJsLCB0YWJJZCwgZnJhbWVJZCB9KSB7XG4gIGlmICghSU5KRUNUQUJMRV9UQUJfVVJMX1JFLnRlc3QodXJsKSkgcmV0dXJuO1xuICBjb25zdCBpc1RvcCA9ICFmcmFtZUlkO1xuICBjb25zdCBrZXkgPSBnZXRLZXkodXJsLCBpc1RvcCk7XG4gIGlmICghY2FjaGUuaGFzKGtleSkpIHtcbiAgICAvLyBHZXRJbmplY3RlZCBtZXNzYWdlIHdpbGwgYmUgc2VudCBzb29uIGJ5IHRoZSBjb250ZW50IHNjcmlwdFxuICAgIC8vIGFuZCBpdCBtYXkgZWFzaWx5IGhhcHBlbiB3aGlsZSBnZXRTY3JpcHRzQnlVUkwgaXMgc3RpbGwgd2FpdGluZyBmb3IgYnJvd3Nlci5zdG9yYWdlXG4gICAgLy8gc28gd2UnbGwgbGV0IEdldEluamVjdGVkIGF3YWl0IHRoaXMgcGVuZGluZyBkYXRhIGJ5IHN0b3JpbmcgUHJvbWlzZSBpbiB0aGUgY2FjaGVcbiAgICBjYWNoZS5wdXQoa2V5LCBwcmVwYXJlKGtleSwgdXJsLCB0YWJJZCwgZnJhbWVJZCksIFRJTUVfQUZURVJfU0VORCk7XG4gIH1cbn1cblxuLyoqIEBwYXJhbSB7Y2hyb21lLndlYlJlcXVlc3QuV2ViUmVzcG9uc2VIZWFkZXJzRGV0YWlsc30gaW5mbyAqL1xuZnVuY3Rpb24gb25IZWFkZXJzUmVjZWl2ZWQoaW5mbykge1xuICBjb25zdCBrZXkgPSBnZXRLZXkoaW5mby51cmwsICFpbmZvLmZyYW1lSWQpO1xuICBjb25zdCBkYXRhID0geGhySW5qZWN0ICYmIGNhY2hlLmdldChrZXkpO1xuICBjYWNoZS5oaXQoa2V5LCBUSU1FX0FGVEVSX1JFQ0VJVkUpO1xuICByZXR1cm4gZGF0YT8uaW5qZWN0ICYmIHByZXBhcmVYaHJCbG9iKGluZm8sIGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Y2hyb21lLndlYlJlcXVlc3QuV2ViUmVzcG9uc2VIZWFkZXJzRGV0YWlsc30gaW5mb1xuICogQHBhcmFtIHtWTUdldEluamVjdGVkRGF0YUNvbnRhaW5lcn0gZGF0YVxuICovXG5mdW5jdGlvbiBwcmVwYXJlWGhyQmxvYih7IHVybCwgcmVzcG9uc2VIZWFkZXJzIH0sIGRhdGEpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwczonKSAmJiBkZXRlY3RTdHJpY3RDc3AocmVzcG9uc2VIZWFkZXJzKSkge1xuICAgIGZvcmNlQ29udGVudEluamVjdGlvbihkYXRhKTtcbiAgfVxuICBjb25zdCBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXG4gICAgSlNPTi5zdHJpbmdpZnkoZGF0YS5pbmplY3QpLFxuICBdKSk7XG4gIHJlc3BvbnNlSGVhZGVycy5wdXNoKHtcbiAgICBuYW1lOiAnU2V0LUNvb2tpZScsXG4gICAgdmFsdWU6IGBcIiR7cHJvY2Vzcy5lbnYuSU5JVF9GVU5DX05BTUV9XCI9JHtibG9iVXJsLnNwbGl0KCcvJykucG9wKCl9OyBTYW1lU2l0ZT1MYXhgLFxuICB9KTtcbiAgc2V0VGltZW91dChVUkwucmV2b2tlT2JqZWN0VVJMLCBUSU1FX0tFRVBfREFUQSwgYmxvYlVybCk7XG4gIHJldHVybiB7IHJlc3BvbnNlSGVhZGVycyB9O1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlKGtleSwgdXJsLCB0YWJJZCwgZnJhbWVJZCwgZm9yY2VDb250ZW50KSB7XG4gIC8qKiBAbmFtZXNwYWNlIFZNR2V0SW5qZWN0ZWREYXRhQ29udGFpbmVyICovXG4gIGNvbnN0IHJlcyA9IHtcbiAgICAvKiogQG5hbWVzcGFjZSBWTUdldEluamVjdGVkRGF0YSAqL1xuICAgIGluamVjdDoge1xuICAgICAgZXhwb3NlOiAhZnJhbWVJZFxuICAgICAgICAmJiB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKVxuICAgICAgICAmJiBleHBvc2VbdXJsLnNwbGl0KCcvJywgMylbMl1dLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiBpc0FwcGxpZWRcbiAgICA/IHByZXBhcmVTY3JpcHRzKHJlcywga2V5LCB1cmwsIHRhYklkLCBmcmFtZUlkLCBmb3JjZUNvbnRlbnQpXG4gICAgOiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVTY3JpcHRzKHJlcywgY2FjaGVLZXksIHVybCwgdGFiSWQsIGZyYW1lSWQsIGZvcmNlQ29udGVudCkge1xuICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0U2NyaXB0c0J5VVJMKHVybCwgIWZyYW1lSWQpO1xuICBjb25zdCB7IGVudkRlbGF5ZWQsIHNjcmlwdHMgfSA9IGRhdGE7XG4gIGNvbnN0IGlzTGF0ZSA9IGZvcmNlQ29udGVudCAhPSBudWxsO1xuICBkYXRhLmZvcmNlQ29udGVudCA9IGZvcmNlQ29udGVudDtcbiAgY29uc3QgZmVlZGJhY2sgPSBzY3JpcHRzLm1hcChwcmVwYXJlU2NyaXB0LCBkYXRhKS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IG1vcmUgPSBlbnZEZWxheWVkLnByb21pc2U7XG4gIGNvbnN0IGVudktleSA9IGdldFVuaXFJZChgJHt0YWJJZH06JHtmcmFtZUlkfTpgKTtcbiAgY29uc3QgeyBpbmplY3QgfSA9IHJlcztcbiAgLyoqIEBuYW1lc3BhY2UgVk1HZXRJbmplY3RlZERhdGEgKi9cbiAgT2JqZWN0LmFzc2lnbihpbmplY3QsIHtcbiAgICBzY3JpcHRzLFxuICAgIFtJTkpFQ1RfSU5UT106IGluamVjdEludG8sXG4gICAgY2FjaGU6IGRhdGEuY2FjaGUsXG4gICAgZmVlZElkOiB7XG4gICAgICBjYWNoZUtleSwgLy8gSW5qZWN0aW9uRmVlZGJhY2sgY2FjaGUga2V5IGZvciBjbGVhbnVwIHdoZW4gZ2V0RGF0YUZGIG91dHJ1bnMgR2V0SW5qZWN0ZWRcbiAgICAgIGVudktleSwgLy8gSW5qZWN0aW9uRmVlZGJhY2sgY2FjaGUga2V5IGZvciBlbnZEZWxheWVkXG4gICAgfSxcbiAgICBoYXNNb3JlOiAhIW1vcmUsIC8vIHRlbGxzIGNvbnRlbnQgYnJpZGdlIHRvIGV4cGVjdCBlbnZEZWxheWVkXG4gICAgZm9yY2VDb250ZW50OiBmb3JjZUNvbnRlbnQgfHwgKCAvLyBUcnlpbmcgdG8gc2tpcCBwYWdlIHNhbmRib3ggd2hlbiB4aHJJbmplY3QgaXMgb246XG4gICAgICBmZWVkYmFjay5sZW5ndGggPT09IHNjcmlwdHMubGVuZ3RoIC8vIC4uLndoZW4gYWxsIGBlbnZTdGFydGAgc2NyaXB0cyBhcmUgYGNvbnRlbnRgLFxuICAgICAgJiYgZW52RGVsYXllZC5zY3JpcHRzLmV2ZXJ5KHNjciA9PiBpc0NvbnRlbnRSZWFsbShzY3IsIGZvcmNlQ29udGVudCkpIC8vIGFuZCBgZW52RGVsYXllZGAgdG9vLlxuICAgICksXG4gICAgaWRzOiBkYXRhLmRpc2FibGVkSWRzLCAvLyBjb250ZW50IGJyaWRnZSBhZGRzIHRoZSBhY3R1YWxseSBydW5uaW5nIGlkcyBhbmQgc2VuZHMgdmlhIFNldFBvcHVwXG4gICAgaW5mbzoge1xuICAgICAgdWEsXG4gICAgfSxcbiAgfSk7XG4gIC8qKiBAbmFtZXNwYWNlIFZNR2V0SW5qZWN0ZWREYXRhQ29udGFpbmVyICovXG4gIE9iamVjdC5hc3NpZ24ocmVzLCB7XG4gICAgZmVlZGJhY2ssXG4gICAgdmFsT3BJZHM6IFsuLi5kYXRhW0VOVl9WQUxVRV9JRFNdLCAuLi5lbnZEZWxheWVkW0VOVl9WQUxVRV9JRFNdXSxcbiAgICByY3NQcm9taXNlOiAhaXNMYXRlICYmICF4aHJJbmplY3QgJiYgSVNfRklSRUZPWFxuICAgICAgPyByZWdpc3RlclNjcmlwdERhdGFGRihpbmplY3QsIHVybCwgISFmcmFtZUlkKVxuICAgICAgOiBudWxsLFxuICB9KTtcbiAgaWYgKG1vcmUpIGNhY2hlLnB1dChlbnZLZXksIG1vcmUpO1xuICBjYWNoZS5wdXQoY2FjaGVLZXksIHJlcyk7IC8vIG5lY2Vzc2FyeSBmb3IgdGhlIHN5bmNocm9ub3VzIG9uSGVhZGVyc1JlY2VpdmVkXG4gIHJldHVybiByZXM7XG59XG5cbi8qKiBAdGhpcyB7Vk1TY3JpcHRCeVVybERhdGF9ICovXG5mdW5jdGlvbiBwcmVwYXJlU2NyaXB0KHNjcmlwdCkge1xuICBjb25zdCB7IGN1c3RvbSwgbWV0YSwgcHJvcHMgfSA9IHNjcmlwdDtcbiAgY29uc3QgeyBpZCB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgZm9yY2VDb250ZW50LCByZXF1aXJlLCB2YWx1ZSB9ID0gdGhpcztcbiAgY29uc3QgY29kZSA9IHRoaXMuY29kZVtpZF07XG4gIGNvbnN0IGRhdGFLZXkgPSBnZXRVbmlxSWQoJ1ZNaW4nKTtcbiAgY29uc3QgZGlzcGxheU5hbWUgPSBnZXRTY3JpcHROYW1lKHNjcmlwdCk7XG4gIGNvbnN0IG5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGlzcGxheU5hbWUucmVwbGFjZSgvWyMmJywvOjs/QD0rXS9nLCByZXBsYWNlV2l0aEZ1bGxXaWR0aEZvcm0pKTtcbiAgY29uc3QgaXNDb250ZW50ID0gaXNDb250ZW50UmVhbG0oc2NyaXB0LCBmb3JjZUNvbnRlbnQpO1xuICBjb25zdCBwYXRoTWFwID0gY3VzdG9tLnBhdGhNYXAgfHwge307XG4gIGNvbnN0IHJlcXMgPSBtZXRhLnJlcXVpcmU/Lm1hcChrZXkgPT4gcmVxdWlyZVtwYXRoTWFwW2tleV0gfHwga2V5XSkuZmlsdGVyKEJvb2xlYW4pO1xuICAvLyB0cnlpbmcgdG8gYXZvaWQgcHJvZ3Jlc3NpdmUgc3RyaW5nIGNvbmNhdGVuYXRpb24gb2YgcG90ZW50aWFsbHkgaHVnZSBjb2RlIHNsaWNlc1xuICAvLyBhZGRpbmcgYDtgIG9uIGEgbmV3IGxpbmUgaW4gY2FzZSBzb21lIHJlcXVpcmVkIHNjcmlwdCBlbmRzIHdpdGggYSBsaW5lIGNvbW1lbnRcbiAgY29uc3QgcmVxc1NsaWNlcyA9IHJlcXMgPyBbXS5jb25jYXQoLi4ucmVxcy5tYXAocmVxID0+IFtyZXEsICdcXG47J10pKSA6IFtdO1xuICBjb25zdCBoYXNSZXFzID0gcmVxc1NsaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGluamVjdGVkQ29kZSA9IFtcbiAgICAvLyBoaWRpbmcgbW9kdWxlIGludGVyZmFjZSBmcm9tIEByZXF1aXJlJ2Qgc2NyaXB0cyBzbyB0aGV5IGRvbid0IG1pc3Rha2VubHkgdXNlIGl0XG4gICAgYHdpbmRvdy4ke2RhdGFLZXl9PWZ1bmN0aW9uKCR7ZGF0YUtleX0pe3RyeXt3aXRoKHRoaXMpKChkZWZpbmUsbW9kdWxlLGV4cG9ydHMpPT57YCxcbiAgICAuLi5yZXFzU2xpY2VzLFxuICAgIC8vIGFkZGluZyBhIG5lc3RlZCBJSUZFIHRvIHN1cHBvcnQgJ3VzZSBzdHJpY3QnIGluIHRoZSBjb2RlIHdoZW4gdGhlcmUgYXJlIEByZXF1aXJlc1xuICAgIGhhc1JlcXMgPyAnKCgpPT57JyA6ICcnLFxuICAgIGNvZGUsXG4gICAgLy8gYWRkaW5nIGEgbmV3IGxpbmUgaW4gY2FzZSB0aGUgY29kZSBlbmRzIHdpdGggYSBsaW5lIGNvbW1lbnRcbiAgICBjb2RlLmVuZHNXaXRoKCdcXG4nKSA/ICcnIDogJ1xcbicsXG4gICAgaGFzUmVxcyA/ICd9KSgpJyA6ICcnLFxuICAgIC8vIDAgYXQgdGhlIGVuZCB0byBzdXBwcmVzcyBlcnJvcnMgYWJvdXQgbm9uLWNsb25lYWJsZSByZXN1bHQgb2YgZXhlY3V0ZVNjcmlwdCBpbiBGRlxuICAgIGB9KSgpfWNhdGNoKGUpeyR7ZGF0YUtleX0oZSl9fTswYCxcbiAgICAvLyBGaXJlZm94IGxpc3RzIC51c2VyLmpzIGFtb25nIG91ciBvd24gY29udGVudCBzY3JpcHRzIHNvIGEgc3BhY2UgYXQgc3RhcnQgd2lsbCBncm91cCB0aGVtXG4gICAgYFxcbi8vIyBzb3VyY2VVUkw9JHtleHRlbnNpb25Sb290fSR7SVNfRklSRUZPWCA/ICclMjAnIDogJyd9JHtuYW1lfS51c2VyLmpzIyR7aWR9YCxcbiAgXS5qb2luKCcnKTtcbiAgY2FjaGVDb2RlLnB1dChkYXRhS2V5LCBpbmplY3RlZENvZGUsIFRJTUVfS0VFUF9EQVRBKTtcbiAgLyoqIEBuYW1lc3BhY2UgVk1JbmplY3RlZFNjcmlwdCAqL1xuICBPYmplY3QuYXNzaWduKHNjcmlwdCwge1xuICAgIGRhdGFLZXksXG4gICAgZGlzcGxheU5hbWUsXG4gICAgLy8gY29kZSB3aWxsIGJlIGB0cnVlYCBpZiB0aGUgZGVzaXJlZCByZWFsbSBpcyBQQUdFIHdoaWNoIGlzIG5vdCBpbmplY3RhYmxlXG4gICAgY29kZTogaXNDb250ZW50ID8gJycgOiBmb3JjZUNvbnRlbnQgfHwgaW5qZWN0ZWRDb2RlLFxuICAgIG1ldGFTdHI6IGNvZGUubWF0Y2goTUVUQUJMT0NLX1JFKVsxXSB8fCAnJyxcbiAgICB2YWx1ZXM6IHZhbHVlW2lkXSB8fCBudWxsLFxuICB9KTtcbiAgcmV0dXJuIGlzQ29udGVudCAmJiBbZGF0YUtleSwgdHJ1ZV07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VXaXRoRnVsbFdpZHRoRm9ybShzKSB7XG4gIC8vIGZ1bGx3aWR0aCByYW5nZSBzdGFydHMgYXQgMHhGRjAwLCBub3JtYWwgcmFuZ2Ugc3RhcnRzIGF0IHNwYWNlIGNoYXIgY29kZSAweDIwXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHMuY2hhckNvZGVBdCgwKSAtIDB4MjAgKyAweEZGMDApO1xufVxuXG5jb25zdCByZXNvbHZlRGF0YUNvZGVTdHIgPSBgKCR7ZnVuY3Rpb24gXyhkYXRhKSB7XG4gIC8qIGBmdW5jdGlvbmAgaXMgcmVxdWlyZWQgdG8gY29tcGlsZSBgdGhpc2AsIGFuZCBgdGhpc2AgaXMgcmVxdWlyZWQgYmVjYXVzZSBvdXIgc2FmZS1nbG9iYWxzXG4gICAqIHNoYWRvd3MgYHdpbmRvd2Agc28gaXRzIG5hbWUgaXMgbWluaWZpZWQgYW5kIGhlbmNlIGluYWNjZXNzaWJsZSBoZXJlICovXG4gIGNvbnN0IHsgdm1SZXNvbHZlIH0gPSB0aGlzO1xuICBpZiAodm1SZXNvbHZlKSB7XG4gICAgdm1SZXNvbHZlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJ1bm5pbmcgZWFybGllciB0aGFuIHRoZSBtYWluIGNvbnRlbnQgc2NyaXB0IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICB0aGlzLnZtRGF0YSA9IGRhdGE7XG4gIH1cbn19KWA7XG5cbi8vIFRPRE86IHJld29yayB0aGUgd2hvbGUgdGhpbmcgdG8gcmVnaXN0ZXIgc2NyaXB0cyBpbmRpdmlkdWFsbHkgd2l0aCByZWFsIGBtYXRjaGVzYFxuZnVuY3Rpb24gcmVnaXN0ZXJTY3JpcHREYXRhRkYoaW5qZWN0LCB1cmwsIGFsbEZyYW1lcykge1xuICByZXR1cm4gYnJvd3Nlci5jb250ZW50U2NyaXB0cz8ucmVnaXN0ZXIoe1xuICAgIGFsbEZyYW1lcyxcbiAgICBqczogW3tcbiAgICAgIGNvZGU6IGAke3Jlc29sdmVEYXRhQ29kZVN0cn0oJHtKU09OLnN0cmluZ2lmeShpbmplY3QpfSlgLFxuICAgIH1dLFxuICAgIG1hdGNoZXM6IHVybC5zcGxpdCgnIycsIDEpLFxuICAgIHJ1bkF0OiAnZG9jdW1lbnRfc3RhcnQnLFxuICB9KTtcbn1cblxuLyoqIEBwYXJhbSB7Y2hyb21lLndlYlJlcXVlc3QuSHR0cEhlYWRlcltdfSByZXNwb25zZUhlYWRlcnMgKi9cbmZ1bmN0aW9uIGRldGVjdFN0cmljdENzcChyZXNwb25zZUhlYWRlcnMpIHtcbiAgcmV0dXJuIHJlc3BvbnNlSGVhZGVycy5zb21lKCh7IG5hbWUsIHZhbHVlIH0pID0+IChcbiAgICAvXmNvbnRlbnQtc2VjdXJpdHktcG9saWN5JC9pLnRlc3QobmFtZSlcbiAgICAmJiAvXi4oPyEuKid1bnNhZmUtaW5saW5lJykvLnRlc3QoIC8vIHRydWUgaWYgbm90IGVtcHR5IGFuZCB3aXRob3V0ICd1bnNhZmUtaW5saW5lJ1xuICAgICAgdmFsdWUubWF0Y2goLyg/Ol58OylcXHMqc2NyaXB0LXNyYy1lbGVtXFxzW147XSsvKVxuICAgICAgfHwgdmFsdWUubWF0Y2goLyg/Ol58OylcXHMqc2NyaXB0LXNyY1xcc1teO10rLylcbiAgICAgIHx8IHZhbHVlLm1hdGNoKC8oPzpefDspXFxzKmRlZmF1bHQtc3JjXFxzW147XSsvKVxuICAgICAgfHwgJycsXG4gICAgKVxuICApKTtcbn1cblxuLyoqIEBwYXJhbSB7Vk1HZXRJbmplY3RlZERhdGFDb250YWluZXJ9IGRhdGEgKi9cbmZ1bmN0aW9uIGZvcmNlQ29udGVudEluamVjdGlvbihkYXRhKSB7XG4gIC8qKiBAdHlwZSBWTUdldEluamVjdGVkRGF0YSAqL1xuICBjb25zdCBpbmplY3QgPSBkYXRhLmluamVjdDtcbiAgaW5qZWN0LmZvcmNlQ29udGVudCA9IHRydWU7XG4gIGluamVjdC5zY3JpcHRzLmZvckVhY2goc2NyID0+IHtcbiAgICAvLyBXaGVuIHNjcmlwdCB3YW50cyBgcGFnZWAsIHRoZSByZXN1bHQgYmVsb3cgd2lsbCBiZSBgdHJ1ZWAgc28gdGhlIHNjcmlwdCBnb2VzIGludG8gYGZhaWxlZElkc2BcbiAgICBzY3IuY29kZSA9ICFpc0NvbnRlbnRSZWFsbShzY3IsIHRydWUpIHx8ICcnO1xuICAgIGRhdGEuZmVlZGJhY2sucHVzaChbc2NyLmRhdGFLZXksIHRydWVdKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGVudFJlYWxtKHNjciwgZm9yY2VDb250ZW50KSB7XG4gIGNvbnN0IHJlYWxtID0gc2NyW0lOSkVDVF9JTlRPXSB8fCAoXG4gICAgc2NyW0lOSkVDVF9JTlRPXSA9IG5vcm1hbGl6ZVJlYWxtKHNjci5jdXN0b21bSU5KRUNUX0lOVE9dIHx8IHNjci5tZXRhW0lOSkVDVF9JTlRPXSlcbiAgKTtcbiAgcmV0dXJuIHJlYWxtID09PSBJTkpFQ1RfQ09OVEVOVCB8fCBmb3JjZUNvbnRlbnQgJiYgcmVhbG0gPT09IElOSkVDVF9BVVRPO1xufVxuIiwiaW1wb3J0IHtcbiAgYmxvYjJiYXNlNjQsIGJ1ZmZlcjJzdHJpbmcsIGdldFVuaXFJZCwgcmVxdWVzdCwgaTE4biwgaXNFbXB0eSwgbm9vcCwgc2VuZFRhYkNtZCxcbiAgc3RyaW5nMnVpbnQ4YXJyYXksXG59IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IGZvckVhY2hFbnRyeSwgb2JqZWN0UGljayB9IGZyb20gJyMvY29tbW9uL29iamVjdCc7XG5pbXBvcnQgdWEgZnJvbSAnIy9jb21tb24vdWEnO1xuaW1wb3J0IGNhY2hlIGZyb20gJy4vY2FjaGUnO1xuaW1wb3J0IHsgaXNVc2VyU2NyaXB0LCBwYXJzZU1ldGEgfSBmcm9tICcuL3NjcmlwdCc7XG5pbXBvcnQgeyBleHRlbnNpb25Sb290IH0gZnJvbSAnLi9pbml0JztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IGRvd25sb2FkTTN1OCB9IGZyb20gJy4vbTN1OCc7XG5pbXBvcnQgeyBtZXJnZVZpZGVvIH0gZnJvbSAnLi9tZXJnZS12aWRlbyc7XG5cbmNvbnN0IHJlcUhhbmRsZXIgPSB7XG4gIG0zdTg6IGRvd25sb2FkTTN1OCxcbiAgbWVyZ2U6IG1lcmdlVmlkZW8sXG59O1xuXG5jb25zdCBWTV9WRVJJRlkgPSAnVk0tVmVyaWZ5JztcbmNvbnN0IENPTkZJUk1fVVJMX0JBU0UgPSBgJHtleHRlbnNpb25Sb290fWNvbmZpcm0vaW5kZXguaHRtbCNgO1xuLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLFZNSHR0cFJlcXVlc3Q+fSAqL1xuY29uc3QgcmVxdWVzdHMgPSB7fTtcbmNvbnN0IGRvd25sb2FkcyA9IHt9O1xuY29uc3QgdmVyaWZ5ID0ge307XG5jb25zdCB0YWJSZXF1ZXN0cyA9IHt9O1xuY29uc3QgeyBjaHJvbWUgfSA9IGdsb2JhbDtcbmxldCBlbmNvZGVyO1xuXG5pZiAoY2hyb21lKSB7XG4gIGNocm9tZS5kb3dubG9hZHMub25DaGFuZ2VkLmFkZExpc3RlbmVyKGV2dCA9PiB7XG4gICAgLy8gY29uc29sZS5pbmZvKCdkb3dubG9hZHMgb25DaGFuZ2VkJywgZXZ0KTtcbiAgICBpZiAoIWRvd25sb2Fkc1tldnQuaWRdKSByZXR1cm47XG4gICAgY29uc3QgeyByZXEsIHNyYyB9ID0gZG93bmxvYWRzW2V2dC5pZF07XG4gICAgY29uc3QgeyB0YWI6IHsgaWQ6IHRhYklkIH0sIGZyYW1lSWQgfSA9IHNyYztcblxuICAgIGlmIChldnQuc3RhdGU/LmN1cnJlbnQgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHNlbmRUYWJDbWQodGFiSWQsICdIdHRwUmVxdWVzdGVkJywge1xuICAgICAgICB0eXBlOiAnbG9hZCcsIGlkOiByZXEuaWQsIGRvd25sb2FkSWQ6IGV2dC5pZCxcbiAgICAgIH0sIHsgZnJhbWVJZCB9KTtcbiAgICB9IGVsc2UgaWYgKGV2dC5zdGF0ZT8uY3VycmVudCA9PT0gJ2ludGVycnVwdGVkJykge1xuICAgICAgc2VuZFRhYkNtZCh0YWJJZCwgJ0h0dHBSZXF1ZXN0ZWQnLCB7XG4gICAgICAgIHR5cGU6ICdlcnJvcicsIGlkOiByZXEuaWQsIGRvd25sb2FkSWQ6IGV2dC5pZCxcbiAgICAgIH0sIHsgZnJhbWVJZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgZG93bmxvYWRzW2V2dC5pZF07XG4gICAgZGVsZXRlIHJlcXVlc3RzW3JlcS5pZF07XG4gIH0pO1xufVxuXG5PYmplY3QuYXNzaWduKGNvbW1hbmRzLCB7XG4gIENvbmZpcm1JbnN0YWxsOiBjb25maXJtSW5zdGFsbCxcbiAgYXN5bmMgQ2hlY2tJbnN0YWxsZXJUYWIodGFiSWQsIHNyYykge1xuICAgIGNvbnN0IHRhYiA9IElTX0ZJUkVGT1ggJiYgKHNyYy51cmwgfHwgJycpLnN0YXJ0c1dpdGgoJ2ZpbGU6JylcbiAgICAgICYmIGF3YWl0IGJyb3dzZXIudGFicy5nZXQodGFiSWQpLmNhdGNoKG5vb3ApO1xuICAgIHJldHVybiB0YWIgJiYgKHRhYi5wZW5kaW5nVXJsIHx8IHRhYi51cmwgfHwgJycpLnN0YXJ0c1dpdGgoQ09ORklSTV9VUkxfQkFTRSk7XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHt2b2lkfSAqL1xuICBIdHRwUmVxdWVzdChvcHRzLCBzcmMpIHtcbiAgICBjb25zdCB7IHRhYjogeyBpZDogdGFiSWQgfSwgZnJhbWVJZCB9ID0gc3JjO1xuICAgIGNvbnN0IHsgaWQsIGV2ZW50c1RvTm90aWZ5IH0gPSBvcHRzO1xuXG4gICAgY29uc29sZS5pbmZvKCdyZXEgb3B0cycsIG9wdHMpO1xuXG4gICAgaWYgKHJlcUhhbmRsZXJbb3B0cy50eXBlXSkge1xuICAgICAgY29uc3QgZG93bmxvYWRJZCA9IGlkOyAvLyBmYWtlIGRvd25sb2FkSWQgZm9yIGluamVjdC5qc1xuICAgICAgb3B0cy5zcmMgPSBzcmM7XG4gICAgICBvcHRzLnJlcXVlc3RzID0gcmVxdWVzdHM7IC8vIG5lZWRlZCB0byBhcHBlbmQgcmVxIGluIG1lcmdlVmlkZW9cbiAgICAgIG9wdHMub25wcm9ncmVzcyA9IChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICAgIGlmIChldmVudHNUb05vdGlmeT8uaW5jbHVkZXMoJ3Byb2dyZXNzJykpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmluZm8oJ29ucHJvZ3Jlc3MnLCB7bG9hZGVkLCB0b3RhbH0pO1xuICAgICAgICAgIHNlbmRUYWJDbWQodGFiSWQsICdIdHRwUmVxdWVzdGVkJywge1xuICAgICAgICAgICAgdHlwZTogJ3Byb2dyZXNzJywgaWQsIGRvd25sb2FkSWQsIGxvYWRlZCwgdG90YWwsXG4gICAgICAgICAgfSwgeyBmcmFtZUlkIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgb3B0cy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHNlbmRUYWJDbWQodGFiSWQsICdIdHRwUmVxdWVzdGVkJywgeyB0eXBlOiAnbG9hZCcsIGRvd25sb2FkSWQsIGlkIH0sIHsgZnJhbWVJZCB9KTtcbiAgICAgIH07XG4gICAgICBvcHRzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgc2VuZFRhYkNtZCh0YWJJZCwgJ0h0dHBSZXF1ZXN0ZWQnLCB7IHR5cGU6ICdlcnJvcicsIGRvd25sb2FkSWQsIGlkLCBlcnJvciB9LCB7IGZyYW1lSWQgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlcUhhbmRsZXJbb3B0cy50eXBlXShvcHRzLCBodHRwUmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdHNbaWRdID0ge1xuICAgICAgaWQsXG4gICAgICB0YWJJZCxcbiAgICAgIGV2ZW50c1RvTm90aWZ5LFxuICAgICAgeGhyOiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICB9O1xuICAgICh0YWJSZXF1ZXN0c1t0YWJJZF0gfHwgKHRhYlJlcXVlc3RzW3RhYklkXSA9IHt9KSlbaWRdID0gMTtcbiAgICBodHRwUmVxdWVzdChvcHRzLCBzcmMsIHJlcyA9PiB7XG4gICAgICAvLyBjb25zb2xlLmluZm8oeyByZXMsIHJlcTogcmVxdWVzdHNbaWRdIH0pO1xuICAgICAgaWYgKHJlcXVlc3RzW2lkXSkge1xuICAgICAgICBzZW5kVGFiQ21kKHRhYklkLCAnSHR0cFJlcXVlc3RlZCcsIHJlcywgeyBmcmFtZUlkIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvKiogQHJldHVybiB7dm9pZH0gKi9cbiAgQWJvcnRSZXF1ZXN0KGlkKSB7XG4gICAgY29uc3QgcmVxID0gcmVxdWVzdHNbaWRdO1xuICAgIGlmIChyZXEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgaWYgKGNocm9tZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgY2hyb21lLmRvd25sb2Fkcy5jYW5jZWwocmVxLmlkKTtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3RzW3JlcS5pZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXEueGhyLmFib3J0KCk7XG4gICAgICAgIGNsZWFyUmVxdWVzdChyZXEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgUmV2b2tlQmxvYih1cmwpIHtcbiAgICBjb25zdCB0aW1lciA9IGNhY2hlLnBvcChgeGhyQmxvYjoke3VybH1gKTtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgfVxuICB9LFxufSk7XG5cbmNvbnN0IHNwZWNpYWxIZWFkZXJzID0gW1xuICAndXNlci1hZ2VudCcsXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvRm9yYmlkZGVuX2hlYWRlcl9uYW1lXG4gIC8vIGh0dHBzOi8vY3MuY2hyb21pdW0ub3JnLz9xPWZpbGU6Y2Mrc3ltYm9sOklzRm9yYmlkZGVuSGVhZGVyJTVDYlxuICAnYWNjZXB0LWNoYXJzZXQnLFxuICAnYWNjZXB0LWVuY29kaW5nJyxcbiAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycycsXG4gICdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZCcsXG4gICdjb25uZWN0aW9uJyxcbiAgJ2NvbnRlbnQtbGVuZ3RoJyxcbiAgJ2Nvb2tpZScsXG4gICdjb29raWUyJyxcbiAgJ2RhdGUnLFxuICAnZG50JyxcbiAgJ2V4cGVjdCcsXG4gICdob3N0JyxcbiAgJ2tlZXAtYWxpdmUnLFxuICAnb3JpZ2luJyxcbiAgJ3JlZmVyZXInLFxuICAndGUnLFxuICAndHJhaWxlcicsXG4gICd0cmFuc2Zlci1lbmNvZGluZycsXG4gICd1cGdyYWRlJyxcbiAgJ3ZpYScsXG5dO1xuLy8gY29uc3QgdGFza3MgPSB7fTtcbmNvbnN0IEhlYWRlckluamVjdG9yID0gKCgpID0+IHtcbiAgLyoqIEB0eXBlIGNocm9tZS53ZWJSZXF1ZXN0LlJlcXVlc3RGaWx0ZXIgKi9cbiAgY29uc3QgYXBpRmlsdGVyID0ge1xuICAgIHVybHM6IFsnPGFsbF91cmxzPiddLFxuICAgIHR5cGVzOiBbJ3htbGh0dHByZXF1ZXN0J10sXG4gIH07XG4gIGNvbnN0IEVYVFJBX0hFQURFUlMgPSBbXG4gICAgYnJvd3Nlci53ZWJSZXF1ZXN0Lk9uQmVmb3JlU2VuZEhlYWRlcnNPcHRpb25zLkVYVFJBX0hFQURFUlMsXG4gIF0uZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBoZWFkZXJzVG9JbmplY3QgPSB7fTtcbiAgLyoqIEBwYXJhbSB7Y2hyb21lLndlYlJlcXVlc3QuSHR0cEhlYWRlcn0gaGVhZGVyICovXG4gIGNvbnN0IGlzVm1WZXJpZnkgPSBoZWFkZXIgPT4gaGVhZGVyLm5hbWUgPT09IFZNX1ZFUklGWTtcbiAgY29uc3QgaXNOb3RDb29raWUgPSBoZWFkZXIgPT4gIS9eY29va2llMj8kL2kudGVzdChoZWFkZXIubmFtZSk7XG4gIGNvbnN0IGlzU2VuZGFibGUgPSBoZWFkZXIgPT4gaGVhZGVyLm5hbWUgIT09IFZNX1ZFUklGWTtcbiAgY29uc3QgaXNTZW5kYWJsZUFub24gPSBoZWFkZXIgPT4gaXNTZW5kYWJsZShoZWFkZXIpICYmIGlzTm90Q29va2llKGhlYWRlcik7XG4gIGNvbnN0IFJFX1NFVF9DT09LSUUgPSAvXnNldC1jb29raWUyPyQvaTtcbiAgY29uc3QgUkVfU0VUX0NPT0tJRV9WQUxVRSA9IC9eXFxzKig/Ol9fKFNlY3VyZXxIb3N0KS0pPyhbXj1cXHNdKylcXHMqPVxccyooXCIpPyhbISMtK1xcLS06PC1bXFxdLX5dKilcXDMoLiopLztcbiAgY29uc3QgUkVfU0VUX0NPT0tJRV9BVFRSID0gL1xccyo7P1xccyooXFx3KykoPzo9KFwiKT8oWyEjLStcXC0tOjwtW1xcXS1+XSopXFwyKT8veTtcbiAgY29uc3QgU0FNRV9TSVRFX01BUCA9IHtcbiAgICBzdHJpY3Q6ICdzdHJpY3QnLFxuICAgIGxheDogJ2xheCcsXG4gICAgbm9uZTogJ25vX3Jlc3RyaWN0aW9uJyxcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJWYWx1ZVxuICAgKiBAcGFyYW0ge1ZNSHR0cFJlcXVlc3R9IHJlcVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqL1xuICBjb25zdCBzZXRDb29raWVJblN0b3JlID0gKGhlYWRlclZhbHVlLCByZXEsIHVybCkgPT4ge1xuICAgIGxldCBtID0gUkVfU0VUX0NPT0tJRV9WQUxVRS5leGVjKGhlYWRlclZhbHVlKTtcbiAgICBpZiAobSkge1xuICAgICAgY29uc3QgWywgcHJlZml4LCBuYW1lLCAsIHZhbHVlLCBvcHRTdHJdID0gbTtcbiAgICAgIGNvbnN0IG9wdCA9IHt9O1xuICAgICAgY29uc3QgaXNIb3N0ID0gcHJlZml4ID09PSAnSG9zdCc7XG4gICAgICBSRV9TRVRfQ09PS0lFX0FUVFIubGFzdEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICgobSA9IFJFX1NFVF9DT09LSUVfQVRUUi5leGVjKG9wdFN0cikpKSB7XG4gICAgICAgIG9wdFttWzFdLnRvTG93ZXJDYXNlKCldID0gbVszXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNhbWVTaXRlID0gb3B0LnNhbWVTaXRlPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgYnJvd3Nlci5jb29raWVzLnNldCh7XG4gICAgICAgIHVybCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbWFpbjogaXNIb3N0ID8gdW5kZWZpbmVkIDogb3B0LmRvbWFpbixcbiAgICAgICAgZXhwaXJhdGlvbkRhdGU6IE1hdGgubWF4KDAsICtuZXcgRGF0ZShvcHRbJ21heC1hZ2UnXSAqIDEwMDAgfHwgb3B0LmV4cGlyZXMpKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGh0dHBPbmx5OiAnaHR0cG9ubHknIGluIG9wdCxcbiAgICAgICAgcGF0aDogaXNIb3N0ID8gJy8nIDogb3B0LnBhdGgsXG4gICAgICAgIHNhbWVTaXRlOiBTQU1FX1NJVEVfTUFQW3NhbWVTaXRlXSxcbiAgICAgICAgc2VjdXJlOiB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JykgJiYgKCEhcHJlZml4IHx8IHNhbWVTaXRlID09PSAnbm9uZScgfHwgJ3NlY3VyZScgaW4gb3B0KSxcbiAgICAgICAgc3RvcmVJZDogcmVxLnN0b3JlSWQsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGFwaUV2ZW50cyA9IHtcbiAgICBvbkJlZm9yZVNlbmRIZWFkZXJzOiB7XG4gICAgICBvcHRpb25zOiBbJ3JlcXVlc3RIZWFkZXJzJywgJ2Jsb2NraW5nJywgLi4uRVhUUkFfSEVBREVSU10sXG4gICAgICAvKiogQHBhcmFtIHtjaHJvbWUud2ViUmVxdWVzdC5XZWJSZXF1ZXN0SGVhZGVyc0RldGFpbHN9IGRldGFpbHMgKi9cbiAgICAgIGxpc3RlbmVyKHsgcmVxdWVzdEhlYWRlcnM6IGhlYWRlcnMsIHJlcXVlc3RJZCB9KSB7XG4gICAgICAgIC8vIG9ubHkgdGhlIGZpcnN0IGNhbGwgZHVyaW5nIGEgcmVkaXJlY3QvYXV0aCBjaGFpbiB3aWxsIGhhdmUgVk0tVmVyaWZ5IGhlYWRlclxuICAgICAgICBjb25zdCByZXFJZCA9IGhlYWRlcnMuZmluZChpc1ZtVmVyaWZ5KT8udmFsdWUgfHwgdmVyaWZ5W3JlcXVlc3RJZF07XG4gICAgICAgIGNvbnN0IHJlcSA9IHJlcUlkICYmIHJlcXVlc3RzW3JlcUlkXTtcbiAgICAgICAgaWYgKHJlcUlkICYmIHJlcSkge1xuICAgICAgICAgIHZlcmlmeVtyZXF1ZXN0SWRdID0gcmVxSWQ7XG4gICAgICAgICAgcmVxLmNvcmVJZCA9IHJlcXVlc3RJZDtcbiAgICAgICAgICBoZWFkZXJzID0gKHJlcS5ub05hdGl2ZUNvb2tpZSA/IGhlYWRlcnMuZmlsdGVyKGlzTm90Q29va2llKSA6IGhlYWRlcnMpXG4gICAgICAgICAgLmNvbmNhdChoZWFkZXJzVG9JbmplY3RbcmVxSWRdIHx8IFtdKVxuICAgICAgICAgIC5maWx0ZXIocmVxLmFub255bW91cyA/IGlzU2VuZGFibGVBbm9uIDogaXNTZW5kYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVxdWVzdEhlYWRlcnM6IGhlYWRlcnMgfTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBvbkhlYWRlcnNSZWNlaXZlZDoge1xuICAgICAgb3B0aW9uczogWydyZXNwb25zZUhlYWRlcnMnLCAnYmxvY2tpbmcnLCAuLi5FWFRSQV9IRUFERVJTXSxcbiAgICAgIC8qKiBAcGFyYW0ge2Nocm9tZS53ZWJSZXF1ZXN0LldlYlJlcXVlc3RIZWFkZXJzRGV0YWlsc30gZGV0YWlscyAqL1xuICAgICAgbGlzdGVuZXIoeyByZXNwb25zZUhlYWRlcnM6IGhlYWRlcnMsIHJlcXVlc3RJZCwgdXJsIH0pIHtcbiAgICAgICAgY29uc3QgcmVxID0gcmVxdWVzdHNbdmVyaWZ5W3JlcXVlc3RJZF1dO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgaWYgKHJlcS5hbm9ueW1vdXMgfHwgcmVxLnN0b3JlSWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSBoZWFkZXJzLmZpbHRlcihoID0+IChcbiAgICAgICAgICAgICAgIVJFX1NFVF9DT09LSUUudGVzdChoLm5hbWUpXG4gICAgICAgICAgICAgIHx8ICFyZXEuc3RvcmVJZFxuICAgICAgICAgICAgICB8fCBzZXRDb29raWVJblN0b3JlKGgudmFsdWUsIHJlcSwgdXJsKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcS5yZXNwb25zZUhlYWRlcnMgPSBoZWFkZXJzLm1hcChlbmNvZGVXZWJSZXF1ZXN0SGVhZGVyKS5qb2luKCcnKTtcbiAgICAgICAgICByZXR1cm4geyByZXNwb25zZUhlYWRlcnM6IGhlYWRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuICAvLyBDaHJvbWUgNzQtOTEgbmVlZHMgYW4gZXh0cmFIZWFkZXJzIGxpc3RlbmVyIGF0IHRhYiBsb2FkIHN0YXJ0LCBodHRwczovL2NyYnVnLmNvbS8xMDc0MjgyXG4gIC8vIFdlJ3JlIGF0dGFjaGluZyBhIG5vLW9wIGluIG5vbi1ibG9ja2luZyBtb2RlIHNvIGl0J3MgdmVyeSBsaWdodHdlaWdodCBhbmQgZmFzdC5cbiAgaWYgKHVhLmNocm9tZSA+PSA3NCAmJiB1YS5jaHJvbWUgPD0gOTEpIHtcbiAgICBicm93c2VyLndlYlJlcXVlc3Qub25CZWZvcmVTZW5kSGVhZGVycy5hZGRMaXN0ZW5lcihub29wLCBhcGlGaWx0ZXIsIFsnZXh0cmFIZWFkZXJzJ10pO1xuICB9XG4gIHJldHVybiB7XG4gICAgYWRkKHJlcUlkLCBoZWFkZXJzKSB7XG4gICAgICAvLyBuZWVkIHRvIHNldCB0aGUgZW50cnkgZXZlbiBpZiBpdCdzIGVtcHR5IFtdIHNvIHRoYXQgJ2lmJyBjaGVjayBpbiBkZWwoKSBydW5zIG9ubHkgb25jZVxuICAgICAgaGVhZGVyc1RvSW5qZWN0W3JlcUlkXSA9IGhlYWRlcnM7XG4gICAgICAvLyBuZWVkIHRoZSBsaXN0ZW5lciB0byBnZXQgdGhlIHJlcXVlc3RJZFxuICAgICAgYXBpRXZlbnRzOjpmb3JFYWNoRW50cnkoKFtuYW1lLCB7IGxpc3RlbmVyLCBvcHRpb25zIH1dKSA9PiB7XG4gICAgICAgIGJyb3dzZXIud2ViUmVxdWVzdFtuYW1lXS5hZGRMaXN0ZW5lcihsaXN0ZW5lciwgYXBpRmlsdGVyLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVsKHJlcUlkKSB7XG4gICAgICBpZiAocmVxSWQgaW4gaGVhZGVyc1RvSW5qZWN0KSB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzVG9JbmplY3RbcmVxSWRdO1xuICAgICAgICBpZiAoaXNFbXB0eShoZWFkZXJzVG9JbmplY3QpKSB7XG4gICAgICAgICAgYXBpRXZlbnRzOjpmb3JFYWNoRW50cnkoKFtuYW1lLCB7IGxpc3RlbmVyIH1dKSA9PiB7XG4gICAgICAgICAgICBicm93c2VyLndlYlJlcXVlc3RbbmFtZV0ucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn0pKCk7XG5cbi8qIDFNQiB0YWtlcyB+MjBtcyB0byBlbmNvZGUvZGVjb2RlIHNvIGl0IGRvZXNuJ3QgYmxvY2sgdGhlIHByb2Nlc3Mgb2YgdGhlIGV4dGVuc2lvbiBhbmQgd2ViIHBhZ2UsXG4gKiB3aGljaCBsZXRzIHVzIGFuZCB0aGVtIGJlIHJlc3BvbnNpdmUgdG8gb3RoZXIgZXZlbnRzIG9yIHVzZXIgaW5wdXQuICovXG5jb25zdCBDSFVOS19TSVpFID0gMWU2O1xuXG5hc3luYyBmdW5jdGlvbiBibG9iMmNodW5rKHJlc3BvbnNlLCBpbmRleCkge1xuICByZXR1cm4gYmxvYjJiYXNlNjQocmVzcG9uc2UsIGluZGV4ICogQ0hVTktfU0laRSwgQ0hVTktfU0laRSk7XG59XG5cbmZ1bmN0aW9uIGJsb2Iyb2JqZWN0VXJsKHJlc3BvbnNlKSB7XG4gIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVzcG9uc2UpO1xuICBjYWNoZS5wdXQoYHhockJsb2I6JHt1cmx9YCwgc2V0VGltZW91dChjb21tYW5kcy5SZXZva2VCbG9iLCA2MGUzLCB1cmwpLCA2MWUzKTtcbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqIEBwYXJhbSB7Vk1IdHRwUmVxdWVzdH0gcmVxICovXG5mdW5jdGlvbiB4aHJDYWxsYmFja1dyYXBwZXIocmVxKSB7XG4gIGxldCBsYXN0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBsZXQgY29udGVudFR5cGU7XG4gIGxldCBkYXRhU2l6ZTtcbiAgbGV0IG51bUNodW5rcztcbiAgbGV0IHJlc3BvbnNlO1xuICBsZXQgcmVzcG9uc2VUZXh0O1xuICBsZXQgcmVzcG9uc2VIZWFkZXJzO1xuICAvLyBsZXQgc2VudCA9IGZhbHNlO1xuICBjb25zdCB7IGlkLCBibG9iYmVkLCBjaHVua2VkLCB4aHIgfSA9IHJlcTtcbiAgLy8gQ2hyb21lIGVuY29kZXMgbWVzc2FnZXMgdG8gVVRGOCBzbyB0aGV5IGNhbiBncm93IHVwIHRvIDR4IGJ1dCA2NE1CIGlzIHRoZSBtZXNzYWdlIHNpemUgbGltaXRcbiAgY29uc3QgZ2V0Q2h1bmsgPSBibG9iYmVkICYmIGJsb2Iyb2JqZWN0VXJsIHx8IGNodW5rZWQgJiYgYmxvYjJjaHVuaztcbiAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IGhlYWRlcnMgPSByZXEucmVzcG9uc2VIZWFkZXJzIHx8IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICBpZiAocmVzcG9uc2VIZWFkZXJzICE9PSBoZWFkZXJzKSB7XG4gICAgICByZXNwb25zZUhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgcmV0dXJuIHsgcmVzcG9uc2VIZWFkZXJzIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gKGV2dCkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBldnQudHlwZTtcbiAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgfVxuICAgIGlmICh4aHIucmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICByZXNwb25zZSA9IHhoci5yZXNwb25zZTtcbiAgICAgIC8vIHNlbnQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlVGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGlmIChyZXNwb25zZVRleHQgPT09IHJlc3BvbnNlKSByZXNwb25zZVRleHQgPSBbJ3NhbWUnXTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlIGlmIHJlc3BvbnNlVGV4dCBpcyB1bnJlYWNoYWJsZVxuICAgICAgfVxuICAgICAgaWYgKChibG9iYmVkIHx8IGNodW5rZWQpICYmIHJlc3BvbnNlKSB7XG4gICAgICAgIGRhdGFTaXplID0gcmVzcG9uc2Uuc2l6ZTtcbiAgICAgICAgbnVtQ2h1bmtzID0gY2h1bmtlZCAmJiBNYXRoLmNlaWwoZGF0YVNpemUgLyBDSFVOS19TSVpFKSB8fCAxO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaG91bGROb3RpZnkgPSByZXEuZXZlbnRzVG9Ob3RpZnkuaW5jbHVkZXModHlwZSk7XG4gICAgLy8gb25seSBzZW5kIHJlc3BvbnNlIHdoZW4gWEhSIGlzIGNvbXBsZXRlXG4gICAgY29uc3Qgc2hvdWxkU2VuZFJlc3BvbnNlID0geGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgc2hvdWxkTm90aWZ5O1xuICAgIGxhc3RQcm9taXNlID0gbGFzdFByb21pc2UudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoc2hvdWxkU2VuZFJlc3BvbnNlICYmIGJsb2JiZWQgJiYgcmVxLnR5cGUgPT09ICdkb3dubG9hZCcpIHtcbiAgICAgICAgaWYgKHJlcS5maWxlTmFtZSAmJiBjaHJvbWUpIHtcbiAgICAgICAgICBjb25zdCBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuIGNocm9tZS5kb3dubG9hZHMuZG93bmxvYWQoe1xuICAgICAgICAgICAgdXJsOiBibG9iVXJsLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHJlcS5maWxlTmFtZSxcbiAgICAgICAgICB9LCBkb3dubG9hZElkID0+IHtcbiAgICAgICAgICAgIHJlcS5jYih7XG4gICAgICAgICAgICAgIGJsb2JiZWQsXG4gICAgICAgICAgICAgIGNodW5rZWQsXG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICBkYXRhU2l6ZSxcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGRhdGE6IHsgZmluYWxVcmw6IHhoci5yZXNwb25zZVVSTCwgcmVzcG9uc2U6ICcnLCByZXNwb25zZVRleHQ6IGRvd25sb2FkSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxLmNiKHtcbiAgICAgICAgICBibG9iYmVkLFxuICAgICAgICAgIGNodW5rZWQsXG4gICAgICAgICAgY29udGVudFR5cGUsXG4gICAgICAgICAgZGF0YVNpemUsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBkYXRhOiByZXNwb25zZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUuaW5mbyh7IGV2dCB9KTtcbiAgICAgIGF3YWl0IHJlcS5jYih7XG4gICAgICAgIGJsb2JiZWQsXG4gICAgICAgIGNodW5rZWQsXG4gICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICBkYXRhU2l6ZSxcbiAgICAgICAgaWQsXG4gICAgICAgIG51bUNodW5rcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGF0YTogc2hvdWxkTm90aWZ5ICYmIHtcbiAgICAgICAgICBmaW5hbFVybDogeGhyLnJlc3BvbnNlVVJMLFxuICAgICAgICAgIC4uLmdldFJlc3BvbnNlSGVhZGVycygpLFxuICAgICAgICAgIC4uLm9iamVjdFBpY2soeGhyLCBbJ3JlYWR5U3RhdGUnLCAnc3RhdHVzJywgJ3N0YXR1c1RleHQnXSksXG4gICAgICAgICAgLi4uKCdsb2FkZWQnIGluIGV2dCkgJiYgb2JqZWN0UGljayhldnQsIFsnbGVuZ3RoQ29tcHV0YWJsZScsICdsb2FkZWQnLCAndG90YWwnXSksXG4gICAgICAgICAgcmVzcG9uc2U6IHNob3VsZFNlbmRSZXNwb25zZVxuICAgICAgICAgICAgPyBudW1DaHVua3MgJiYgYXdhaXQgZ2V0Q2h1bmsocmVzcG9uc2UsIDApIHx8IHJlc3BvbnNlXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgcmVzcG9uc2VUZXh0OiBzaG91bGRTZW5kUmVzcG9uc2VcbiAgICAgICAgICAgID8gcmVzcG9uc2VUZXh0XG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGlmIChzaG91bGRTZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1DaHVua3M7IGkgKz0gMSkge1xuICAgICAgICAgIGF3YWl0IHJlcS5jYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgIHBvczogaSAqIENIVU5LX1NJWkUsXG4gICAgICAgICAgICAgIGRhdGE6IGF3YWl0IGdldENodW5rKHJlc3BvbnNlLCBpKSxcbiAgICAgICAgICAgICAgbGFzdDogaSArIDEgPT09IG51bUNodW5rcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnbG9hZGVuZCcpIHtcbiAgICAgICAgY2xlYXJSZXF1ZXN0KHJlcSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbEhlYWRlcihsb3dlckhlYWRlcikge1xuICByZXR1cm4gc3BlY2lhbEhlYWRlcnMuaW5jbHVkZXMobG93ZXJIZWFkZXIpXG4gICAgfHwgbG93ZXJIZWFkZXIuc3RhcnRzV2l0aCgncHJveHktJylcbiAgICB8fCBsb3dlckhlYWRlci5zdGFydHNXaXRoKCdzZWMtJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7Y2hyb21lLnJ1bnRpbWUuTWVzc2FnZVNlbmRlciB8IGJyb3dzZXIucnVudGltZS5NZXNzYWdlU2VuZGVyfSBzcmNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGh0dHBSZXF1ZXN0KG9wdHMsIHNyYywgY2IpIHtcbiAgY29uc3QgeyB0YWIgfSA9IHNyYztcbiAgY29uc3QgeyBpbmNvZ25pdG8gfSA9IHRhYjtcbiAgY29uc3QgeyBhbm9ueW1vdXMsIGlkLCBvdmVycmlkZU1pbWVUeXBlLCB4aHJUeXBlLCB1cmwgfSA9IG9wdHM7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3RzW2lkXTtcbiAgaWYgKCFyZXEgfHwgcmVxLmNiKSByZXR1cm47XG4gIHJlcS5jYiA9IGNiO1xuICByZXEudHlwZSA9IG9wdHMudHlwZTtcbiAgcmVxLmZpbGVOYW1lID0gb3B0cy5maWxlTmFtZTtcbiAgcmVxLmFub255bW91cyA9IGFub255bW91cztcbiAgY29uc3QgeyB4aHIgfSA9IHJlcTtcbiAgY29uc3Qgdm1IZWFkZXJzID0gW107XG4gIC8vIEZpcmVmb3ggY2FuIHNlbmQgQmxvYi9BcnJheUJ1ZmZlciBkaXJlY3RseVxuICBjb25zdCBjaHVua2VkID0gIUlTX0ZJUkVGT1ggJiYgaW5jb2duaXRvO1xuICBjb25zdCBibG9iYmVkID0geGhyVHlwZSAmJiAhSVNfRklSRUZPWCAmJiAhaW5jb2duaXRvO1xuICBjb25zdCBbYm9keSwgY29udGVudFR5cGVdID0gZGVjb2RlQm9keShvcHRzLmRhdGEpO1xuICAvLyBDaHJvbWUgY2FuJ3QgZmV0Y2ggQmxvYiBVUkwgaW4gaW5jb2duaXRvIHNvIHdlIHVzZSBjaHVua3NcbiAgcmVxLmJsb2JiZWQgPSBibG9iYmVkO1xuICByZXEuY2h1bmtlZCA9IGNodW5rZWQ7XG4gIC8vIEZpcmVmb3ggZG9lc24ndCBzZW5kIGNvb2tpZXMsIGh0dHBzOi8vZ2l0aHViLmNvbS92aW9sZW50bW9ua2V5L3Zpb2xlbnRtb25rZXkvaXNzdWVzLzYwNlxuICAvLyBCb3RoIENocm9tZSAmIEZGIG5lZWQgZXhwbGljaXQgcm91dGluZyBvZiBjb29raWVzIGluIGNvbnRhaW5lcnMgb3IgaW5jb2duaXRvXG4gIGxldCBzaG91bGRTZW5kQ29va2llcyA9ICFhbm9ueW1vdXMgJiYgKGluY29nbml0byB8fCBJU19GSVJFRk9YKTtcbiAgeGhyLm9wZW4ob3B0cy5tZXRob2QgfHwgJ0dFVCcsIHVybCwgdHJ1ZSwgb3B0cy51c2VyIHx8ICcnLCBvcHRzLnBhc3N3b3JkIHx8ICcnKTtcbiAgeGhyLnNldFJlcXVlc3RIZWFkZXIoVk1fVkVSSUZZLCBpZCk7XG4gIGlmIChjb250ZW50VHlwZSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcbiAgb3B0cy5oZWFkZXJzOjpmb3JFYWNoRW50cnkoKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzU3BlY2lhbEhlYWRlcihsb3dlck5hbWUpKSB7XG4gICAgICB2bUhlYWRlcnMucHVzaCh7IG5hbWUsIHZhbHVlIH0pO1xuICAgIH0gZWxzZSBpZiAoIWxvd2VyTmFtZS5zdGFydHNXaXRoKCd2bS0nKSkge1xuICAgICAgLy8gYFZNLWAgaGVhZGVycyBhcmUgcmVzZXJ2ZWRcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGxvd2VyTmFtZSA9PT0gJ2Nvb2tpZScpIHtcbiAgICAgIHNob3VsZFNlbmRDb29raWVzID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgeGhyLnJlc3BvbnNlVHlwZSA9IChjaHVua2VkIHx8IGJsb2JiZWQpICYmICdibG9iJyB8fCB4aHJUeXBlIHx8ICd0ZXh0JztcbiAgeGhyLnRpbWVvdXQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigweDdGRkZfRkZGRiwgb3B0cy50aW1lb3V0KSkgfHwgMDtcbiAgaWYgKG92ZXJyaWRlTWltZVR5cGUpIHhoci5vdmVycmlkZU1pbWVUeXBlKG92ZXJyaWRlTWltZVR5cGUpO1xuICBpZiAoc2hvdWxkU2VuZENvb2tpZXMpIHtcbiAgICByZXEubm9OYXRpdmVDb29raWUgPSB0cnVlO1xuICAgIGZvciAoY29uc3Qgc3RvcmUgb2YgYXdhaXQgYnJvd3Nlci5jb29raWVzLmdldEFsbENvb2tpZVN0b3JlcygpKSB7XG4gICAgICBpZiAoc3RvcmUudGFiSWRzLmluY2x1ZGVzKHRhYi5pZCkpIHtcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggPyBzdG9yZS5pZCAhPT0gJ2ZpcmVmb3gtZGVmYXVsdCcgOiBzdG9yZS5pZCAhPT0gJzAnKSB7XG4gICAgICAgICAgLyogQ29va2llIHJvdXRpbmcuIEZvciB0aGUgbWFpbiBzdG9yZSB3ZSByZWx5IG9uIHRoZSBicm93c2VyLlxuICAgICAgICAgICAqIFRoZSBpZHMgYXJlIGhhcmQtY29kZWQgYXMgYHN0b3Jlc2AgbWF5IG9taXQgdGhlIG1haW4gc3RvcmUgaWYgbm8gc3VjaCB0YWJzIGFyZSBvcGVuLiAqL1xuICAgICAgICAgIHJlcS5zdG9yZUlkID0gc3RvcmUuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IGNvb2tpZXMgPSAoYXdhaXQgYnJvd3Nlci5jb29raWVzLmdldEFsbCh7XG4gICAgICB1cmwsXG4gICAgICBzdG9yZUlkOiByZXEuc3RvcmVJZCxcbiAgICAgIC4uLnVhLmZpcmVmb3ggPj0gNTkgJiYgeyBmaXJzdFBhcnR5RG9tYWluOiBudWxsIH0sXG4gICAgfSkpLmZpbHRlcihjID0+IGMuc2Vzc2lvbiB8fCBjLmV4cGlyYXRpb25EYXRlID4gbm93KTsgLy8gRkYgcmVwb3J0cyBleHBpcmVkIGNvb2tpZXMhXG4gICAgaWYgKGNvb2tpZXMubGVuZ3RoKSB7XG4gICAgICB2bUhlYWRlcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdjb29raWUnLFxuICAgICAgICB2YWx1ZTogY29va2llcy5tYXAoYyA9PiBgJHtjLm5hbWV9PSR7Yy52YWx1ZX07YCkuam9pbignICcpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIEhlYWRlckluamVjdG9yLmFkZChpZCwgdm1IZWFkZXJzKTtcbiAgY29uc3QgY2FsbGJhY2sgPSB4aHJDYWxsYmFja1dyYXBwZXIocmVxKTtcbiAgcmVxLmV2ZW50c1RvTm90aWZ5LmZvckVhY2goZXZ0ID0+IHsgeGhyW2BvbiR7ZXZ0fWBdID0gY2FsbGJhY2s7IH0pO1xuICB4aHIub25sb2FkZW5kID0gY2FsbGJhY2s7IC8vIGFsd2F5cyBzZW5kIGl0IGZvciB0aGUgaW50ZXJuYWwgY2xlYW51cFxuICB4aHIuc2VuZChib2R5KTtcbn1cblxuLyoqIEBwYXJhbSB7Vk1IdHRwUmVxdWVzdH0gcmVxICovXG5mdW5jdGlvbiBjbGVhclJlcXVlc3QocmVxKSB7XG4gIGlmIChyZXEuY29yZUlkKSBkZWxldGUgdmVyaWZ5W3JlcS5jb3JlSWRdO1xuICBkZWxldGUgcmVxdWVzdHNbcmVxLmlkXTtcbiAgZGVsZXRlICh0YWJSZXF1ZXN0c1tyZXEudGFiSWRdIHx8IHt9KVtyZXEuaWRdO1xuICBIZWFkZXJJbmplY3Rvci5kZWwocmVxLmlkKTtcbn1cblxuLyoqIFBvbHlmaWxsIGZvciBDaHJvbWUncyBpbmFiaWxpdHkgdG8gc2VuZCBjb21wbGV4IHR5cGVzIG92ZXIgZXh0ZW5zaW9uIG1lc3NhZ2luZyAqL1xuZnVuY3Rpb24gZGVjb2RlQm9keShbYm9keSwgdHlwZSwgd2FzQmxvYl0pIHtcbiAgaWYgKHR5cGUgPT09ICdxdWVyeScpIHtcbiAgICB0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIH0gZWxzZSBpZiAodHlwZSkge1xuICAgIC8vIDV4IHRpbWVzIGZhc3RlciB0aGFuIGZldGNoKCkgd2hpY2ggd2FzdGVzIHRpbWUgb24gaW50ZXItcHJvY2VzcyBjb21tdW5pY2F0aW9uXG4gICAgY29uc3QgcmVzID0gc3RyaW5nMnVpbnQ4YXJyYXkoYXRvYihib2R5LnNsaWNlKGJvZHkuaW5kZXhPZignLCcpICsgMSkpKTtcbiAgICBpZiAoIXdhc0Jsb2IpIHtcbiAgICAgIHR5cGUgPSBib2R5Lm1hdGNoKC9eZGF0YTooLis/KTtiYXNlNjQvKVsxXS5yZXBsYWNlKC8oYm91bmRhcnk9KVteO10rLyxcbiAgICAgICAgLy8gdXNpbmcgYSBmdW5jdGlvbiBzbyBpdCBydW5zIG9ubHkgaWYgXCJib3VuZGFyeVwiIHdhcyBmb3VuZFxuICAgICAgICAoXywgcDEpID0+IHAxICsgU3RyaW5nLmZyb21DaGFyQ29kZSguLi5yZXMuc2xpY2UoMiwgcmVzLmluZGV4T2YoMTMpKSkpO1xuICAgIH1cbiAgICBib2R5ID0gcmVzO1xuICB9XG4gIHJldHVybiBbYm9keSwgdHlwZV07XG59XG5cbi8vIFdhdGNoIFVSTCByZWRpcmVjdHNcbi8vIGJyb3dzZXIud2ViUmVxdWVzdC5vbkJlZm9yZVJlZGlyZWN0LmFkZExpc3RlbmVyKGRldGFpbHMgPT4ge1xuLy8gICBjb25zdCByZXFJZCA9IHZlcmlmeVtkZXRhaWxzLnJlcXVlc3RJZF07XG4vLyAgIGlmIChyZXFJZCkge1xuLy8gICAgIGNvbnN0IHJlcSA9IHJlcXVlc3RzW3JlcUlkXTtcbi8vICAgICBpZiAocmVxKSByZXEuZmluYWxVcmwgPSBkZXRhaWxzLnJlZGlyZWN0VXJsO1xuLy8gICB9XG4vLyB9LCB7XG4vLyAgIHVybHM6IFsnPGFsbF91cmxzPiddLFxuLy8gICB0eXBlczogWyd4bWxodHRwcmVxdWVzdCddLFxuLy8gfSk7XG5cbi8vIHRhc2tzIGFyZSBub3QgbmVjZXNzYXJ5IG5vdywgdHVybmVkIG9mZlxuLy8gU3RvcCByZWRpcmVjdHNcbi8vIGJyb3dzZXIud2ViUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZC5hZGRMaXN0ZW5lcihkZXRhaWxzID0+IHtcbi8vICAgY29uc3QgdGFzayA9IHRhc2tzW2RldGFpbHMucmVxdWVzdElkXTtcbi8vICAgaWYgKHRhc2spIHtcbi8vICAgICBkZWxldGUgdGFza3NbZGV0YWlscy5yZXF1ZXN0SWRdO1xuLy8gICAgIGlmICh0YXNrID09PSAnR2V0LUxvY2F0aW9uJyAmJiBbMzAxLCAzMDIsIDMwM10uaW5jbHVkZXMoZGV0YWlscy5zdGF0dXNDb2RlKSkge1xuLy8gICAgICAgY29uc3QgbG9jYXRpb25IZWFkZXIgPSBkZXRhaWxzLnJlc3BvbnNlSGVhZGVycy5maW5kKFxuLy8gICAgICAgICBoZWFkZXIgPT4gaGVhZGVyLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2F0aW9uJyk7XG4vLyAgICAgICBjb25zdCBiYXNlNjQgPSBsb2NhdGlvbkhlYWRlciAmJiBsb2NhdGlvbkhlYWRlci52YWx1ZTtcbi8vICAgICAgIHJldHVybiB7XG4vLyAgICAgICAgIHJlZGlyZWN0VXJsOiBgZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJHtiYXNlNjQgfHwgJyd9YCxcbi8vICAgICAgIH07XG4vLyAgICAgfVxuLy8gICB9XG4vLyB9LCB7XG4vLyAgIHVybHM6IFsnPGFsbF91cmxzPiddLFxuLy8gICB0eXBlczogWyd4bWxodHRwcmVxdWVzdCddLFxuLy8gfSwgWydibG9ja2luZycsICdyZXNwb25zZUhlYWRlcnMnXSk7XG4vLyBicm93c2VyLndlYlJlcXVlc3Qub25Db21wbGV0ZWQuYWRkTGlzdGVuZXIoZGV0YWlscyA9PiB7XG4vLyAgIGRlbGV0ZSB0YXNrc1tkZXRhaWxzLnJlcXVlc3RJZF07XG4vLyB9LCB7XG4vLyAgIHVybHM6IFsnPGFsbF91cmxzPiddLFxuLy8gICB0eXBlczogWyd4bWxodHRwcmVxdWVzdCddLFxuLy8gfSk7XG4vLyBicm93c2VyLndlYlJlcXVlc3Qub25FcnJvck9jY3VycmVkLmFkZExpc3RlbmVyKGRldGFpbHMgPT4ge1xuLy8gICBkZWxldGUgdGFza3NbZGV0YWlscy5yZXF1ZXN0SWRdO1xuLy8gfSwge1xuLy8gICB1cmxzOiBbJzxhbGxfdXJscz4nXSxcbi8vICAgdHlwZXM6IFsneG1saHR0cHJlcXVlc3QnXSxcbi8vIH0pO1xuXG5hc3luYyBmdW5jdGlvbiBjb25maXJtSW5zdGFsbCh7IGNvZGUsIGZyb20sIHVybCB9LCB7IHRhYiA9IHt9IH0pIHtcbiAgaWYgKCFjb2RlKSBjb2RlID0gKGF3YWl0IHJlcXVlc3QodXJsKSkuZGF0YTtcbiAgLy8gVE9ETzogZGlzcGxheSB0aGUgZXJyb3IgaW4gVUlcbiAgaWYgKCFpc1VzZXJTY3JpcHQoY29kZSkpIHRocm93IGkxOG4oJ21zZ0ludmFsaWRTY3JpcHQnKTtcbiAgY2FjaGUucHV0KHVybCwgY29kZSwgMzAwMCk7XG4gIGNvbnN0IGNvbmZpcm1LZXkgPSBnZXRVbmlxSWQoKTtcbiAgY29uc3QgeyBhY3RpdmUsIGlkOiB0YWJJZCwgaW5jb2duaXRvIH0gPSB0YWI7XG4gIC8vIE5vdCB0ZXN0aW5nIHRhYi5wZW5kaW5nVXJsIGJlY2F1c2UgaXQgd2lsbCBiZSBhbHdheXMgZXF1YWwgdG8gYHVybGBcbiAgY29uc3QgY2FuUmVwbGFjZUN1clRhYiA9ICghaW5jb2duaXRvIHx8IElTX0ZJUkVGT1gpICYmIChcbiAgICB1cmwgPT09IGZyb21cbiAgICB8fCBjYWNoZS5oYXMoYGF1dG9jbG9zZToke3RhYklkfWApXG4gICAgfHwgL14oY2hyb21lOlxcL1xcLyhuZXd0YWJ8c3RhcnRwYWdlKVxcL3xhYm91dDooaG9tZXxuZXd0YWIpKSQvLnRlc3QoZnJvbSkpO1xuICAvKiogQG5hbWVzcGFjZSBWTUNvbmZpcm1DYWNoZSAqL1xuICBjYWNoZS5wdXQoYGNvbmZpcm0tJHtjb25maXJtS2V5fWAsIHsgaW5jb2duaXRvLCB1cmwsIGZyb20sIHRhYklkLCBmZjogdWEuZmlyZWZveCB9KTtcbiAgY29uc3QgY29uZmlybVVybCA9IENPTkZJUk1fVVJMX0JBU0UgKyBjb25maXJtS2V5O1xuICBjb25zdCB7IHdpbmRvd0lkIH0gPSBjYW5SZXBsYWNlQ3VyVGFiXG4gICAgPyBhd2FpdCBicm93c2VyLnRhYnMudXBkYXRlKHRhYklkLCB7IHVybDogY29uZmlybVVybCB9KVxuICAgIDogYXdhaXQgY29tbWFuZHMuVGFiT3Blbih7IHVybDogY29uZmlybVVybCwgYWN0aXZlOiAhIWFjdGl2ZSB9LCB7IHRhYiB9KTtcbiAgaWYgKGFjdGl2ZSAmJiB3aW5kb3dJZCAhPT0gdGFiLndpbmRvd0lkKSB7XG4gICAgYXdhaXQgYnJvd3Nlci53aW5kb3dzLnVwZGF0ZSh3aW5kb3dJZCwgeyBmb2N1c2VkOiB0cnVlIH0pO1xuICB9XG59XG5cbmNvbnN0IHdoaXRlbGlzdFJlID0gbmV3IFJlZ0V4cChgXmh0dHBzOi8vKCR7XG4gIFtcbiAgICAnZ3JlYXN5Zm9ya1xcXFwub3JnL3NjcmlwdHMvJS9jb2RlLycsXG4gICAgJ29wZW51c2VyanNcXFxcLm9yZy9pbnN0YWxsLyUvJyxcbiAgICAnZ2l0aHViXFxcXC5jb20vJS8lL3Jhdy8lLycsXG4gICAgJ2dpdGh1YlxcXFwuY29tLyUvJS9yZWxlYXNlcy8lL2Rvd25sb2FkLycsXG4gICAgJ3Jhd1xcXFwuZ2l0aHVidXNlcmNvbnRlbnRcXFxcLmNvbSgvJSl7M30vJyxcbiAgICAnZ2lzdFxcXFwuZ2l0aHViXFxcXC5jb20vLio/LycsXG4gIF0uam9pbignfCcpXG59KSU/XFxcXC51c2VyXFxcXC5qcyhbPyNdfCQpYC5yZXBsYWNlKC8lL2csICdbXi9dKicpKTtcblxuY29uc3QgYmxhY2tsaXN0UmUgPSBuZXcgUmVnRXhwKGBeaHR0cHM6Ly8oJHtcbiAgW1xuICAgICcoZ2lzdFxcXFwuKT9naXRodWJcXFxcLmNvbScsXG4gICAgJ2dyZWFzeWZvcmtcXFxcLm9yZycsXG4gICAgJ29wZW51c2VyanNcXFxcLm9yZycsXG4gIF0uam9pbignfCcpXG59KS9gKTtcblxuY29uc3QgcmVzb2x2ZVZpcnR1YWxVcmwgPSB1cmwgPT4gKFxuICBgJHtleHRlbnNpb25Sb290fW9wdGlvbnMvaW5kZXguaHRtbCNzY3JpcHRzLyR7K3VybC5zcGxpdCgnIycpWzFdfWBcbik7XG4vLyBGRiBjYW4ndCBpbnRlcmNlcHQgdmlydHVhbCAudXNlci5qcyBVUkwgdmlhIHdlYlJlcXVlc3QsIHNvIHdlIHJlZGlyZWN0IGl0IGV4cGxpY2l0bHlcbmNvbnN0IHZpcnR1YWxVcmxSZSA9IElTX0ZJUkVGT1ggJiYgbmV3IFJlZ0V4cCgoXG4gIGBeKHZpZXctc291cmNlOik/KCR7ZXh0ZW5zaW9uUm9vdC5yZXBsYWNlKCc6Ly8nLCAnJCYpPycpfVteL10qXFxcXC51c2VyXFxcXC5qcyNcXFxcZCtgXG4pKTtcbmNvbnN0IG1heWJlUmVkaXJlY3RWaXJ0dWFsVXJsRkYgPSB2aXJ0dWFsVXJsUmUgJiYgKCh0YWJJZCwgc3JjKSA9PiB7XG4gIGlmICh2aXJ0dWFsVXJsUmUudGVzdChzcmMpKSB7XG4gICAgYnJvd3Nlci50YWJzLnVwZGF0ZSh0YWJJZCwgeyB1cmw6IHJlc29sdmVWaXJ0dWFsVXJsKHNyYykgfSk7XG4gIH1cbn0pO1xuaWYgKHZpcnR1YWxVcmxSZSkge1xuICBjb25zdCBsaXN0ZW5lciA9ICh0YWJJZCwgeyB1cmwgfSkgPT4gdXJsICYmIG1heWJlUmVkaXJlY3RWaXJ0dWFsVXJsRkYodGFiSWQsIHVybCk7XG4gIGNvbnN0IGFwaUV2ZW50ID0gYnJvd3Nlci50YWJzLm9uVXBkYXRlZDtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSBhcGlFdmVudC5hZGRMaXN0ZW5lci5iaW5kKGFwaUV2ZW50LCBsaXN0ZW5lcik7XG4gIHRyeSB7IGFkZExpc3RlbmVyKHsgcHJvcGVydGllczogWyd1cmwnXSB9KTsgfSBjYXRjaCAoZSkgeyBhZGRMaXN0ZW5lcigpOyB9XG59XG5cbmJyb3dzZXIudGFicy5vbkNyZWF0ZWQuYWRkTGlzdGVuZXIoKHRhYikgPT4ge1xuICBjb25zdCB7IGlkLCB0aXRsZSwgdXJsIH0gPSB0YWI7XG4gIC8qIERldGVybWluaW5nIGlmIHRoaXMgdGFiIGNhbiBiZSBhdXRvLWNsb3NlZCAocmVwbGFjZWQsIGFjdHVhbGx5KS5cbiAgICAgRkY+PTY4IGFsbG93cyByZWFkaW5nIGZpbGU6IFVSTCBvbmx5IGluIHRoZSB0YWIncyBjb250ZW50IHNjcmlwdCBzbyB0aGUgdGFiIG11c3Qgc3RheSBvcGVuLiAqL1xuICBpZiAoKCF1cmwuc3RhcnRzV2l0aCgnZmlsZTonKSB8fCB1YS5maXJlZm94IDwgNjgpXG4gICAgICAmJiAvXFwudXNlclxcLmpzKFs/I118JCkvLnRlc3QodGFiLnBlbmRpbmdVcmwgfHwgdXJsKSkge1xuICAgIGNhY2hlLnB1dChgYXV0b2Nsb3NlOiR7aWR9YCwgdHJ1ZSwgMTBlMyk7XG4gIH1cbiAgaWYgKHZpcnR1YWxVcmxSZSAmJiB1cmwgPT09ICdhYm91dDpibGFuaycpIHtcbiAgICBtYXliZVJlZGlyZWN0VmlydHVhbFVybEZGKGlkLCB0aXRsZSk7XG4gIH1cbn0pO1xuXG5icm93c2VyLndlYlJlcXVlc3Qub25CZWZvcmVSZXF1ZXN0LmFkZExpc3RlbmVyKChyZXEpID0+IHtcbiAgY29uc3QgeyBtZXRob2QsIHRhYklkLCB1cmwgfSA9IHJlcTtcbiAgaWYgKG1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gb3BlbiBhIHJlYWwgVVJMIGZvciBzaW1wbGlmaWVkIHVzZXJzY3JpcHQgVVJMIGxpc3RlZCBpbiBkZXZ0b29scyBvZiB0aGUgd2ViIHBhZ2VcbiAgaWYgKHVybC5zdGFydHNXaXRoKGV4dGVuc2lvblJvb3QpKSB7XG4gICAgcmV0dXJuIHsgcmVkaXJlY3RVcmw6IHJlc29sdmVWaXJ0dWFsVXJsKHVybCkgfTtcbiAgfVxuICBpZiAoIWNhY2hlLmhhcyhgYnlwYXNzOiR7dXJsfWApXG4gICYmICghYmxhY2tsaXN0UmUudGVzdCh1cmwpIHx8IHdoaXRlbGlzdFJlLnRlc3QodXJsKSkpIHtcbiAgICBtYXliZUluc3RhbGxVc2VySnModGFiSWQsIHVybCk7XG4gICAgcmV0dXJuIHsgcmVkaXJlY3RVcmw6ICdqYXZhc2NyaXB0OnZvaWQgMCcgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIH1cbn0sIHtcbiAgdXJsczogW1xuICAgIC8vIDEuICo6Ly8gY29tcHJpc2VzIG9ubHkgaHR0cC9odHRwc1xuICAgIC8vIDIuIHRoZSBBUEkgaWdub3JlcyAjaGFzaCBwYXJ0XG4gICAgLy8gMy4gRmlyZWZveDogb25CZWZvcmVSZXF1ZXN0IGRvZXMgbm90IHdvcmsgd2l0aCBmaWxlOi8vIG9yIG1vei1leHRlbnNpb246Ly9cbiAgICAnKjovLyovKi51c2VyLmpzJyxcbiAgICAnKjovLyovKi51c2VyLmpzPyonLFxuICAgICdmaWxlOi8vKi8qLnVzZXIuanMnLFxuICAgICdmaWxlOi8vKi8qLnVzZXIuanM/KicsXG4gICAgYCR7ZXh0ZW5zaW9uUm9vdH0qLnVzZXIuanNgLFxuICBdLFxuICB0eXBlczogWydtYWluX2ZyYW1lJ10sXG59LCBbJ2Jsb2NraW5nJ10pO1xuXG5hc3luYyBmdW5jdGlvbiBtYXliZUluc3RhbGxVc2VySnModGFiSWQsIHVybCkge1xuICBjb25zdCB7IGRhdGE6IGNvZGUgfSA9IGF3YWl0IHJlcXVlc3QodXJsKS5jYXRjaChub29wKSB8fCB7fTtcbiAgaWYgKGNvZGUgJiYgcGFyc2VNZXRhKGNvZGUpLm5hbWUpIHtcbiAgICBjb25zdCB0YWIgPSB0YWJJZCA+PSAwICYmIGF3YWl0IGJyb3dzZXIudGFicy5nZXQodGFiSWQpIHx8IHt9O1xuICAgIGNvbmZpcm1JbnN0YWxsKHsgY29kZSwgdXJsLCBmcm9tOiB0YWIudXJsIH0sIHsgdGFiIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlLnB1dChgYnlwYXNzOiR7dXJsfWAsIHRydWUsIDEwZTMpO1xuICAgIGlmICh0YWJJZCA+PSAwKSBicm93c2VyLnRhYnMudXBkYXRlKHRhYklkLCB7IHVybCB9KTtcbiAgfVxufVxuXG4vLyBJbiBGaXJlZm94IHdpdGggcHJvZHVjdGlvbiBjb2RlIG9mIFZpb2xlbnRtb25rZXksIHNjcmlwdHMgY2FuIGJlIGluamVjdGVkIGJlZm9yZSBgdGFicy5vblVwZGF0ZWRgIGlzIGZpcmVkLlxuLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vdmlvbGVudG1vbmtleS92aW9sZW50bW9ua2V5L2lzc3Vlcy8xMjU1XG5cbmJyb3dzZXIudGFicy5vblJlbW92ZWQuYWRkTGlzdGVuZXIoKHRhYklkKSA9PiB7XG4gIGNsZWFyUmVxdWVzdHNCeVRhYklkKHRhYklkKTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJSZXF1ZXN0c0J5VGFiSWQodGFiSWQpIHtcbiAgY29uc3Qgc2V0ID0gdGFiUmVxdWVzdHNbdGFiSWRdO1xuICBpZiAoc2V0KSB7XG4gICAgZGVsZXRlIHRhYlJlcXVlc3RzW3RhYklkXTtcbiAgICBzZXQ6OmZvckVhY2hFbnRyeSgoW2lkXSkgPT4gY29tbWFuZHMuQWJvcnRSZXF1ZXN0KGlkKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbWl0YXRpbmcgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L2dldEFsbFJlc3BvbnNlSGVhZGVyc1xuICogUGVyIHRoZSBzcGVjaWZpY2F0aW9uIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwIHRoZSBoZWFkZXIgbmFtZSBpcyB3aXRoaW4gQVNDSUksXG4gKiBidXQgd2UnbGwgdHJ5IGVuY29kaW5nIGl0LCBpZiBuZWNlc3NhcnksIHRvIGhhbmRsZSBpbnZhbGlkIHNlcnZlciByZXNwb25zZXMuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVdlYlJlcXVlc3RIZWFkZXIoeyBuYW1lLCB2YWx1ZSwgYmluYXJ5VmFsdWUgfSkge1xuICByZXR1cm4gYCR7c3RyaW5nMmJ5dGVTdHJpbmcobmFtZSl9OiAke1xuICAgIGJpbmFyeVZhbHVlXG4gICAgICA/IGJ1ZmZlcjJzdHJpbmcoYmluYXJ5VmFsdWUpXG4gICAgICA6IHN0cmluZzJieXRlU3RyaW5nKHZhbHVlKVxuICB9XFxyXFxuYDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgVVRGOC1lbmNvZGVkIGJpbmFyeSBzdHJpbmcgaS5lLiBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyLlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc3RyaW5nIGluIGNhc2UgaXQgd2FzIGFscmVhZHkgd2l0aGluIEFTQ0lJLlxuICovXG5mdW5jdGlvbiBzdHJpbmcyYnl0ZVN0cmluZyhzdHIpIHtcbiAgaWYgKCEvW1xcdTAwODAtXFx1RkZGRl0vLnRlc3Qoc3RyKSkgcmV0dXJuIHN0cjtcbiAgaWYgKCFlbmNvZGVyKSBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBidWZmZXIyc3RyaW5nKGVuY29kZXIuZW5jb2RlKHN0cikpO1xufVxuXG4vKiogQHR5cGVkZWYge3tcbiAgYW5vbnltb3VzOiBib29sZWFuXG4gIGJsb2JiZWQ6IGJvb2xlYW5cbiAgY2I6IGZ1bmN0aW9uKE9iamVjdClcbiAgY2h1bmtlZDogYm9vbGVhblxuICBjb3JlSWQ6IG51bWJlclxuICBldmVudHNUb05vdGlmeTogc3RyaW5nW11cbiAgaWQ6IG51bWJlclxuICBub05hdGl2ZUNvb2tpZTogYm9vbGVhblxuICByZXNwb25zZUhlYWRlcnM6IHN0cmluZ1xuICBzdG9yZUlkOiBzdHJpbmdcbiAgdGFiSWQ6IG51bWJlclxuICB4aHI6IFhNTEh0dHBSZXF1ZXN0XG59fSBWTUh0dHBSZXF1ZXN0ICovXG4iLCJpbXBvcnQgeyBnZXRVbmlxSWQsIGVuY29kZUZpbGVuYW1lIH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgTUVUQUJMT0NLX1JFIH0gZnJvbSAnIy9jb21tb24vY29uc3RzJztcbmltcG9ydCB7IG1hcEVudHJ5IH0gZnJvbSAnIy9jb21tb24vb2JqZWN0JztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IGdldE9wdGlvbiB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgY2FjaGUgZnJvbSAnLi9jYWNoZSc7XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgLyoqIEByZXR1cm4ge3N0cmluZ30gKi9cbiAgQ2FjaGVOZXdTY3JpcHQoZGF0YSkge1xuICAgIGNvbnN0IGlkID0gZ2V0VW5pcUlkKCk7XG4gICAgY2FjaGUucHV0KGBuZXctJHtpZH1gLCBuZXdTY3JpcHQoZGF0YSkpO1xuICAgIHJldHVybiBpZDtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge1ZNU2NyaXB0fSAqL1xuICBOZXdTY3JpcHQoaWQpIHtcbiAgICByZXR1cm4gaWQgJiYgY2FjaGUuZ2V0KGBuZXctJHtpZH1gKSB8fCBuZXdTY3JpcHQoKTtcbiAgfSxcbiAgUGFyc2VNZXRhOiBwYXJzZU1ldGEsXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVXNlclNjcmlwdCh0ZXh0KSB7XG4gIGlmICgvXlxccyo8Ly50ZXN0KHRleHQpKSByZXR1cm4gZmFsc2U7IC8vIEhUTUxcbiAgaWYgKHRleHQuaW5kZXhPZignLy8gPT1Vc2VyU2NyaXB0PT0nKSA8IDApIHJldHVybiBmYWxzZTsgLy8gTGFjayBvZiBtZXRhIGJsb2NrXG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCBhcnJheVR5cGUgPSB7XG4gIGRlZmF1bHQ6ICgpID0+IFtdLFxuICB0cmFuc2Zvcm06IChyZXMsIHZhbCkgPT4ge1xuICAgIHJlcy5wdXNoKHZhbCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbn07XG5jb25zdCBkZWZhdWx0VHlwZSA9IHtcbiAgZGVmYXVsdDogKCkgPT4gbnVsbCxcbiAgdHJhbnNmb3JtOiAocmVzLCB2YWwpID0+IChyZXMgPT0gbnVsbCA/IHZhbCA6IHJlcyksXG59O1xuY29uc3QgbWV0YVR5cGVzID0ge1xuICBpbmNsdWRlOiBhcnJheVR5cGUsXG4gIGV4Y2x1ZGU6IGFycmF5VHlwZSxcbiAgbWF0Y2g6IGFycmF5VHlwZSxcbiAgZXhjbHVkZU1hdGNoOiBhcnJheVR5cGUsXG4gIHJlcXVpcmU6IGFycmF5VHlwZSxcbiAgcmVzb3VyY2U6IHtcbiAgICBkZWZhdWx0OiAoKSA9PiAoe30pLFxuICAgIHRyYW5zZm9ybTogKHJlcywgdmFsKSA9PiB7XG4gICAgICBjb25zdCBwYWlyID0gdmFsLm1hdGNoKC9eKFxcd1xcUyopXFxzKyguKikvKTtcbiAgICAgIGlmIChwYWlyKSByZXNbcGFpclsxXV0gPSBwYWlyWzJdO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICB9LFxuICBncmFudDogYXJyYXlUeXBlLFxuICBub2ZyYW1lczoge1xuICAgIGRlZmF1bHQ6ICgpID0+IGZhbHNlLFxuICAgIHRyYW5zZm9ybTogKCkgPT4gdHJ1ZSxcbiAgfSxcbn07XG5jb25zdCBtZXRhT3B0aW9uYWxUeXBlcyA9IHtcbiAgYW50aWZlYXR1cmU6IGFycmF5VHlwZSxcbiAgY29tcGF0aWJsZTogYXJyYXlUeXBlLFxuICBjb25uZWN0OiBhcnJheVR5cGUsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWV0YShjb2RlKSB7XG4gIC8vIGluaXRpYWxpemUgbWV0YVxuICBjb25zdCBtZXRhID0gbWV0YVR5cGVzOjptYXBFbnRyeSgoWywgdmFsdWVdKSA9PiB2YWx1ZS5kZWZhdWx0KCkpO1xuICBjb25zdCBtZXRhQm9keSA9IGNvZGUubWF0Y2goTUVUQUJMT0NLX1JFKVsxXSB8fCAnJztcbiAgbWV0YUJvZHkucmVwbGFjZSgvKD86XnxcXG4pXFxzKlxcL1xcL1xceDIwKEBcXFMrKSguKikvZywgKF9tYXRjaCwgcmF3S2V5LCByYXdWYWx1ZSkgPT4ge1xuICAgIGNvbnN0IFtrZXlOYW1lLCBsb2NhbGVdID0gcmF3S2V5LnNsaWNlKDEpLnNwbGl0KCc6Jyk7XG4gICAgY29uc3QgY2FtZWxLZXkgPSBrZXlOYW1lLnJlcGxhY2UoL1stX10oXFx3KS9nLCAobSwgZykgPT4gZy50b1VwcGVyQ2FzZSgpKTtcbiAgICBjb25zdCBrZXkgPSBsb2NhbGUgPyBgJHtjYW1lbEtleX06JHtsb2NhbGUudG9Mb3dlckNhc2UoKX1gIDogY2FtZWxLZXk7XG4gICAgY29uc3QgdmFsID0gcmF3VmFsdWUudHJpbSgpO1xuICAgIGNvbnN0IG1ldGFUeXBlID0gbWV0YVR5cGVzW2tleV0gfHwgbWV0YU9wdGlvbmFsVHlwZXNba2V5XSB8fCBkZWZhdWx0VHlwZTtcbiAgICBsZXQgb2xkVmFsdWUgPSBtZXRhW2tleV07XG4gICAgaWYgKHR5cGVvZiBvbGRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIG9sZFZhbHVlID0gbWV0YVR5cGUuZGVmYXVsdCgpO1xuICAgIG1ldGFba2V5XSA9IG1ldGFUeXBlLnRyYW5zZm9ybShvbGRWYWx1ZSwgdmFsKTtcbiAgfSk7XG4gIG1ldGEucmVzb3VyY2VzID0gbWV0YS5yZXNvdXJjZTtcbiAgZGVsZXRlIG1ldGEucmVzb3VyY2U7XG4gIC8vIEBob21lcGFnZVVSTDogY29tcGF0aWJsZSB3aXRoIEBob21lcGFnZVxuICBpZiAoIW1ldGEuaG9tZXBhZ2VVUkwgJiYgbWV0YS5ob21lcGFnZSkgbWV0YS5ob21lcGFnZVVSTCA9IG1ldGEuaG9tZXBhZ2U7XG4gIHJldHVybiBtZXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEN1c3RvbSgpIHtcbiAgcmV0dXJuIHtcbiAgICBvcmlnSW5jbHVkZTogdHJ1ZSxcbiAgICBvcmlnRXhjbHVkZTogdHJ1ZSxcbiAgICBvcmlnTWF0Y2g6IHRydWUsXG4gICAgb3JpZ0V4Y2x1ZGVNYXRjaDogdHJ1ZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld1NjcmlwdChkYXRhKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHVybDogJyo6Ly8qLyonLFxuICAgIG5hbWU6ICcnLFxuICAgIGRhdGU6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAuLi5kYXRhLFxuICB9O1xuICBjb25zdCBjb2RlID0gZ2V0T3B0aW9uKCdzY3JpcHRUZW1wbGF0ZScpXG4gIC5yZXBsYWNlKC97eyhcXHcrKX19L2csIChzdHIsIG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YXRlW25hbWVdO1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gc3RyIDogdmFsdWU7XG4gIH0pO1xuICBjb25zdCBzY3JpcHQgPSB7XG4gICAgY3VzdG9tOiBnZXREZWZhdWx0Q3VzdG9tKCksXG4gICAgY29uZmlnOiB7XG4gICAgICBlbmFibGVkOiAxLFxuICAgICAgc2hvdWxkVXBkYXRlOiAxLFxuICAgIH0sXG4gICAgbWV0YTogcGFyc2VNZXRhKGNvZGUpLFxuICAgIHByb3BzOiB7fSxcbiAgfTtcbiAgcmV0dXJuIHsgc2NyaXB0LCBjb2RlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROYW1lVVJJKHNjcmlwdCkge1xuICBjb25zdCBucyA9IHNjcmlwdC5tZXRhLm5hbWVzcGFjZSB8fCAnJztcbiAgY29uc3QgbmFtZSA9IHNjcmlwdC5tZXRhLm5hbWUgfHwgJyc7XG4gIGxldCBuYW1lVVJJID0gZW5jb2RlRmlsZW5hbWUoYCR7bnN9XFxuJHtuYW1lfVxcbmApO1xuICBpZiAoIW5zICYmICFuYW1lKSBuYW1lVVJJICs9IHNjcmlwdC5wcm9wcy5pZCB8fCAnJztcbiAgcmV0dXJuIG5hbWVVUkk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbG9hZFF1ZXJ5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcmJykucmVkdWNlKChkYXRhLCBwaWVjZSkgPT4ge1xuICAgIGNvbnN0IFtrZXksIHZhbF0gPSBwaWVjZS5zcGxpdCgnPScpLm1hcChkZWNvZGVVUklDb21wb25lbnQpO1xuICAgIGRhdGFba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZHVtcFF1ZXJ5KGRpY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGRpY3QpXG4gIC5tYXAoa2V5VmFsID0+IGtleVZhbC5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKCc9JykpXG4gIC5qb2luKCcmJyk7XG59XG4iLCJpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHN0b3JhZ2UgZnJvbSAnIy9jb21tb24vc3RvcmFnZSc7XG5cbi8qKiBAdHlwZSB7IGZ1bmN0aW9uKHVybCwgb3B0aW9ucywgY2hlY2spOiBQcm9taXNlPHZvaWQ+IH0gb3IgdGhyb3dzIG9uIGVycm9yICovXG5zdG9yYWdlLmNhY2hlLmZldGNoID0gY2FjaGVPckZldGNoKHtcbiAgaW5pdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgcmVzcG9uc2VUeXBlOiAnYmxvYicgfTtcbiAgfSxcbiAgYXN5bmMgdHJhbnNmb3JtKHJlc3BvbnNlLCB1cmwsIG9wdGlvbnMsIGNoZWNrKSB7XG4gICAgY29uc3QgW3R5cGUsIGJvZHldID0gYXdhaXQgc3RvcmFnZS5jYWNoZS5tYWtlUmF3KHJlc3BvbnNlLCB0cnVlKTtcbiAgICBhd2FpdCBjaGVjaz8uKHVybCwgcmVzcG9uc2UuZGF0YSwgdHlwZSk7XG4gICAgcmV0dXJuIGAke3R5cGV9LCR7Ym9keX1gO1xuICB9LFxufSk7XG5cbi8qKiBAdHlwZSB7IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyk6IFByb21pc2U8dm9pZD4gfSBvciB0aHJvd3Mgb24gZXJyb3IgKi9cbnN0b3JhZ2UucmVxdWlyZS5mZXRjaCA9IGNhY2hlT3JGZXRjaCh7XG4gIHRyYW5zZm9ybTogKHsgZGF0YSB9LCB1cmwpID0+IChcbiAgICAvXlxccyo8Ly50ZXN0KGRhdGEpXG4gICAgICA/IFByb21pc2UucmVqZWN0KGBOT1RfSlM6ICR7dXJsfSBcIiR7ZGF0YS5zbGljZSgwLCAxMDApLnRyaW0oKS5yZXBsYWNlKC9cXHN7Mix9L2csICcgJyl9XCJgKVxuICAgICAgOiBkYXRhXG4gICksXG59KTtcblxuZnVuY3Rpb24gY2FjaGVPckZldGNoKGhhbmRsZXJzID0ge30pIHtcbiAgY29uc3QgcmVxdWVzdHMgPSB7fTtcbiAgY29uc3QgeyBpbml0LCB0cmFuc2Zvcm0gfSA9IGhhbmRsZXJzO1xuICAvKiogQHRoaXMgVk1TdG9yYWdlQmFzZSAqL1xuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVPckZldGNoSGFuZGxlciguLi5hcmdzKSB7XG4gICAgY29uc3QgW3VybF0gPSBhcmdzO1xuICAgIGNvbnN0IHByb21pc2UgPSByZXF1ZXN0c1t1cmxdIHx8IChyZXF1ZXN0c1t1cmxdID0gdGhpczo6ZG9GZXRjaCguLi5hcmdzKSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIC8qKiBAdGhpcyBWTVN0b3JhZ2VCYXNlICovXG4gIGFzeW5jIGZ1bmN0aW9uIGRvRmV0Y2goLi4uYXJncykge1xuICAgIGNvbnN0IFt1cmwsIG9wdGlvbnNdID0gYXJncztcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdCh1cmwsIGluaXQ/LihvcHRpb25zKSB8fCBvcHRpb25zKTtcbiAgICAgIGlmIChhd2FpdCBpc01vZGlmaWVkKHJlcywgdXJsKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0cmFuc2Zvcm0gPyBhd2FpdCB0cmFuc2Zvcm0ocmVzLCAuLi5hcmdzKSA6IHJlcy5kYXRhO1xuICAgICAgICBhd2FpdCB0aGlzLnNldCh1cmwsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nOiAke3VybH1gLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZWxldGUgcmVxdWVzdHNbdXJsXTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNNb2RpZmllZCh7IGhlYWRlcnMgfSwgdXJsKSB7XG4gIGNvbnN0IG1vZCA9IGhlYWRlcnMuZ2V0KCdldGFnJylcbiAgfHwgK25ldyBEYXRlKGhlYWRlcnMuZ2V0KCdsYXN0LW1vZGlmaWVkJykpXG4gIHx8ICtuZXcgRGF0ZShoZWFkZXJzLmdldCgnZGF0ZScpKTtcbiAgaWYgKCFtb2QgfHwgbW9kICE9PSBhd2FpdCBzdG9yYWdlLm1vZC5nZXRPbmUodXJsKSkge1xuICAgIGlmIChtb2QpIGF3YWl0IHN0b3JhZ2UubW9kLnNldCh1cmwsIG1vZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsImltcG9ydCB7IGdldEFjdGl2ZVRhYiwgbm9vcCwgc2VuZFRhYkNtZCwgZ2V0RnVsbFVybCB9IGZyb20gJyMvY29tbW9uJztcbmltcG9ydCB7IGRlZXBDb3B5IH0gZnJvbSAnIy9jb21tb24vb2JqZWN0JztcbmltcG9ydCB1YSBmcm9tICcjL2NvbW1vbi91YSc7XG5pbXBvcnQgeyBleHRlbnNpb25Sb290IH0gZnJvbSAnLi9pbml0JztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IGdldE9wdGlvbiB9IGZyb20gJy4vb3B0aW9ucyc7XG5cbmNvbnN0IG9wZW5lcnMgPSB7fTtcblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoSWRdIC0gcGF0aCBvciBpZCB0byBhZGQgdG8gI3NjcmlwdHMgcm91dGUgaW4gZGFzaGJvYXJkLFxuICAgICBpZiBhYnNlbnQgYSBuZXcgc2NyaXB0IHdpbGwgYmUgY3JlYXRlZCBmb3IgYWN0aXZlIHRhYidzIFVSTFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7aWQ6IG51bWJlcn0+fVxuICAgKi9cbiAgYXN5bmMgT3BlbkVkaXRvcihwYXRoSWQpIHtcbiAgICBpZiAoIXBhdGhJZCkge1xuICAgICAgY29uc3QgeyB0YWIsIGRvbWFpbiB9ID0gYXdhaXQgY29tbWFuZHMuR2V0VGFiRG9tYWluKCk7XG4gICAgICBjb25zdCBpZCA9IGRvbWFpbiAmJiBjb21tYW5kcy5DYWNoZU5ld1NjcmlwdCh7XG4gICAgICAgIHVybDogKHRhYi5wZW5kaW5nVXJsIHx8IHRhYi51cmwpLnNwbGl0KC9bIz9dLylbMF0sXG4gICAgICAgIG5hbWU6IGAke2dldE9wdGlvbignc2NyaXB0VGVtcGxhdGVFZGl0ZWQnKSA/ICcnIDogJy0gJ30ke2RvbWFpbn1gLFxuICAgICAgfSk7XG4gICAgICBwYXRoSWQgPSBgX25ldyR7aWQgPyBgLyR7aWR9YCA6ICcnfWA7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGAke2V4dGVuc2lvblJvb3R9b3B0aW9ucy9pbmRleC5odG1sI3NjcmlwdHMvJHtwYXRoSWR9YDtcbiAgICAvLyBGaXJlZm94IHVudGlsIHY1NiBkb2Vzbid0IHN1cHBvcnQgbW96LWV4dGVuc2lvbjovLyBwYXR0ZXJuIGluIGJyb3dzZXIudGFicy5xdWVyeSgpXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIGJyb3dzZXIuZXh0ZW5zaW9uLmdldFZpZXdzKCkpIHtcbiAgICAgIGlmICh2aWV3LmxvY2F0aW9uLmhyZWYgPT09IHVybCkge1xuICAgICAgICAvLyBkZWVwLWNvcHlpbmcgdG8gYXZvaWQgZGVhZCBvYmplY3RzXG4gICAgICAgIGNvbnN0IHRhYiA9IGRlZXBDb3B5KGF3YWl0IHZpZXcuYnJvd3Nlci50YWJzLmdldEN1cnJlbnQoKSk7XG4gICAgICAgIGJyb3dzZXIudGFicy51cGRhdGUodGFiLmlkLCB7IGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICAgICAgYnJvd3Nlci53aW5kb3dzLnVwZGF0ZSh0YWIud2luZG93SWQsIHsgZm9jdXNlZDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHRhYjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzLlRhYk9wZW4oeyB1cmwsIG1heWJlSW5XaW5kb3c6IHRydWUgfSk7XG4gIH0sXG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPHsgaWQ6IG51bWJlciB9IHwgY2hyb21lLnRhYnMuVGFiPn0gbmV3IHRhYiBpcyByZXR1cm5lZCBmb3IgaW50ZXJuYWwgY2FsbHMgKi9cbiAgYXN5bmMgVGFiT3Blbih7XG4gICAgdXJsLFxuICAgIGFjdGl2ZSA9IHRydWUsXG4gICAgY29udGFpbmVyLFxuICAgIGluc2VydCA9IHRydWUsXG4gICAgbWF5YmVJbldpbmRvdyA9IGZhbHNlLFxuICAgIHBpbm5lZCxcbiAgfSwgc3JjID0ge30pIHtcbiAgICAvLyBzcmMudGFiIG1heSBiZSBhYnNlbnQgd2hlbiBpbnZva2VkIGZyb20gcG9wdXAgKGUuZy4gZWRpdC9jcmVhdGUgYnV0dG9ucylcbiAgICBjb25zdCBzcmNUYWIgPSBzcmMudGFiIHx8IGF3YWl0IGdldEFjdGl2ZVRhYigpIHx8IHt9O1xuICAgIC8vIHNyYy51cmwgbWF5IGJlIGFic2VudCB3aGVuIGludm9rZWQgZGlyZWN0bHkgYXMgY29tbWFuZHMuVGFiT3BlblxuICAgIGNvbnN0IHNyY1VybCA9IHNyYy51cmw7XG4gICAgY29uc3QgaXNJbnRlcm5hbCA9ICFzcmNVcmwgfHwgc3JjVXJsLnN0YXJ0c1dpdGgoZXh0ZW5zaW9uUm9vdCk7XG4gICAgLy8gb25seSBpbmNvZ25pdG8gc3RvcmVJZCBtYXkgYmUgc3BlY2lmaWVkIHdoZW4gb3BlbmluZyBpbiBhbiBpbmNvZ25pdG8gd2luZG93XG4gICAgY29uc3QgeyBpbmNvZ25pdG8sIHdpbmRvd0lkIH0gPSBzcmNUYWI7XG4gICAgLy8gQ2hyb21lIGNhbid0IG9wZW4gY2hyb21lLXh4eDogVVJMcyBpbiBpbmNvZ25pdG8gd2luZG93c1xuICAgIGxldCBzdG9yZUlkID0gc3JjVGFiLmNvb2tpZVN0b3JlSWQ7XG4gICAgaWYgKHN0b3JlSWQgJiYgIWluY29nbml0bykge1xuICAgICAgc3RvcmVJZCA9IGdldENvbnRhaW5lcklkKGlzSW50ZXJuYWwgPyAwIDogY29udGFpbmVyKSB8fCBzdG9yZUlkO1xuICAgIH1cbiAgICBpZiAoc3RvcmVJZCkgc3RvcmVJZCA9IHsgY29va2llU3RvcmVJZDogc3RvcmVJZCB9O1xuICAgIC8vIFVSTCBuZWVkcyB0byBiZSBleHBhbmRlZCBmb3IgYGNhbk9wZW5JbmNvZ25pdG9gIGJlbG93XG4gICAgaWYgKCEvXlstXFx3XSs6Ly50ZXN0KHVybCkpIHtcbiAgICAgIHVybCA9IGlzSW50ZXJuYWxcbiAgICAgICAgPyBicm93c2VyLnJ1bnRpbWUuZ2V0VVJMKHVybClcbiAgICAgICAgOiBnZXRGdWxsVXJsKHVybCwgc3JjVXJsKTtcbiAgICB9XG4gICAgY29uc3QgY2FuT3BlbkluY29nbml0byA9ICFpbmNvZ25pdG8gfHwgSVNfRklSRUZPWCB8fCAhL14oY2hyb21lWy1cXHddKik6Ly50ZXN0KHVybCk7XG4gICAgbGV0IG5ld1RhYjtcbiAgICBpZiAobWF5YmVJbldpbmRvd1xuICAgICAgICAmJiBicm93c2VyLndpbmRvd3NcbiAgICAgICAgJiYgZ2V0T3B0aW9uKCdlZGl0b3JXaW5kb3cnKVxuICAgICAgICAvKiBjb29raWVTdG9yZUlkIGluIHdpbmRvd3MuY3JlYXRlKCkgaXMgc3VwcG9ydGVkIHNpbmNlIEZGNjQgaHR0cHM6Ly9idWd6aWwubGEvMTM5MzU3MFxuICAgICAgICAgKiBhbmQgYSB3b3JrYXJvdW5kIGlzIHRvbyBjb252b2x1dGVkIHRvIGFkZCBpdCBmb3Igc3VjaCBhbiBhbmNpZW50IHZlcnNpb24gKi9cbiAgICAgICAgJiYgKCFzdG9yZUlkIHx8IHVhLmZpcmVmb3ggPj0gNjQpKSB7XG4gICAgICBjb25zdCB3bmRPcHRzID0ge1xuICAgICAgICB1cmwsXG4gICAgICAgIGluY29nbml0bzogY2FuT3BlbkluY29nbml0byAmJiBpbmNvZ25pdG8sXG4gICAgICAgIC4uLmdldE9wdGlvbignZWRpdG9yV2luZG93U2ltcGxlJykgJiYgeyB0eXBlOiAncG9wdXAnIH0sXG4gICAgICAgIC4uLiFJU19GSVJFRk9YICYmIHsgZm9jdXNlZDogISFhY3RpdmUgfSwgLy8gRkYgZG9lc24ndCBzdXBwb3J0IHRoaXNcbiAgICAgICAgLi4uc3RvcmVJZCxcbiAgICAgIH07XG4gICAgICBjb25zdCBwb3MgPSBnZXRPcHRpb24oJ2VkaXRvcldpbmRvd1BvcycpO1xuICAgICAgY29uc3QgaGFzUG9zID0gcG9zICYmICd0b3AnIGluIHBvcztcbiAgICAgIGNvbnN0IHduZCA9IGF3YWl0IGJyb3dzZXIud2luZG93cy5jcmVhdGUoeyAuLi53bmRPcHRzLCAuLi5wb3MgfSkuY2F0Y2goaGFzUG9zICYmIG5vb3ApXG4gICAgICAgIHx8IGhhc1BvcyAmJiBhd2FpdCBicm93c2VyLndpbmRvd3MuY3JlYXRlKHduZE9wdHMpO1xuICAgICAgbmV3VGFiID0gd25kLnRhYnNbMF07XG4gICAgfVxuICAgIGlmICghbmV3VGFiKSB7XG4gICAgICBuZXdUYWIgPSBhd2FpdCBicm93c2VyLnRhYnMuY3JlYXRlKHtcbiAgICAgICAgdXJsLFxuICAgICAgICAvLyBub3JtYWxpemluZyBhcyBib29sZWFuIGJlY2F1c2UgdGhlIEFQSSByZXF1aXJlcyBzdHJpY3QgdHlwZXNcbiAgICAgICAgYWN0aXZlOiAhIWFjdGl2ZSxcbiAgICAgICAgcGlubmVkOiAhIXBpbm5lZCxcbiAgICAgICAgLi4uc3RvcmVJZCxcbiAgICAgICAgLi4uY2FuT3BlbkluY29nbml0byAmJiB7XG4gICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgLi4uaW5zZXJ0ICYmIHsgaW5kZXg6IHNyY1RhYi5pbmRleCArIDEgfSxcbiAgICAgICAgICAuLi51YS5vcGVuZXJUYWJJZFN1cHBvcnRlZCAmJiB7IG9wZW5lclRhYklkOiBzcmNUYWIuaWQgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IGlkIH0gPSBuZXdUYWI7XG4gICAgaWYgKGFjdGl2ZSAmJiBuZXdUYWIud2luZG93SWQgIT09IHdpbmRvd0lkKSB7XG4gICAgICBhd2FpdCBicm93c2VyLndpbmRvd3MudXBkYXRlKG5ld1RhYi53aW5kb3dJZCwgeyBmb2N1c2VkOiB0cnVlIH0pO1xuICAgIH1cbiAgICBvcGVuZXJzW2lkXSA9IHNyY1RhYi5pZDtcbiAgICByZXR1cm4gaXNJbnRlcm5hbCA/IG5ld1RhYiA6IHsgaWQgfTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge3ZvaWR9ICovXG4gIFRhYkNsb3NlKHsgaWQgfSA9IHt9LCBzcmMpIHtcbiAgICBjb25zdCB0YWJJZCA9IGlkIHx8IHNyYz8udGFiPy5pZDtcbiAgICBpZiAodGFiSWQgPj0gMCkgYnJvd3Nlci50YWJzLnJlbW92ZSh0YWJJZCk7XG4gIH0sXG4gIFRhYkZvY3VzKF8sIHNyYykge1xuICAgIGJyb3dzZXIudGFicy51cGRhdGUoc3JjLnRhYi5pZCwgeyBhY3RpdmU6IHRydWUgfSkuY2F0Y2gobm9vcCk7XG4gICAgYnJvd3Nlci53aW5kb3dzLnVwZGF0ZShzcmMudGFiLndpbmRvd0lkLCB7IGZvY3VzZWQ6IHRydWUgfSkuY2F0Y2gobm9vcCk7XG4gIH0sXG59KTtcblxuLy8gRmlyZWZveCBBbmRyb2lkIGRvZXMgbm90IHN1cHBvcnQgYG9wZW5lclRhYklkYCBmaWVsZCwgaXQgZmFpbHMgaWYgdGhpcyBmaWVsZCBpcyBwYXNzZWRcbi8vIFhYWCBvcGVuZXJUYWJJZCBzZWVtcyBidWdneSBvbiBDaHJvbWUsIGh0dHBzOi8vY3JidWcuY29tLzk2NzE1MFxuLy8gSXQgc2VlbXMgdG8gZG8gbm90aGluZyBldmVuIHNldCBzdWNjZXNzZnVsbHkgd2l0aCBgYnJvd3Nlci50YWJzLnVwZGF0ZWAuXG51YS5yZWFkeS50aGVuKCgpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModWEsIHtcbiAgICBvcGVuZXJUYWJJZFN1cHBvcnRlZDoge1xuICAgICAgdmFsdWU6ICFJU19GSVJFRk9YIHx8IHVhLmZpcmVmb3ggPj0gNTcgJiYgdWEub3MgIT09ICdhbmRyb2lkJyxcbiAgICB9LFxuICB9KTtcbn0pO1xuXG5icm93c2VyLnRhYnMub25SZW1vdmVkLmFkZExpc3RlbmVyKChpZCkgPT4ge1xuICBjb25zdCBvcGVuZXJJZCA9IG9wZW5lcnNbaWRdO1xuICBpZiAob3BlbmVySWQgPj0gMCkge1xuICAgIHNlbmRUYWJDbWQob3BlbmVySWQsICdUYWJDbG9zZWQnLCBpZCk7XG4gICAgZGVsZXRlIG9wZW5lcnNbaWRdO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVySWQoaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ID09PSAwICYmICdmaXJlZm94LWRlZmF1bHQnXG4gICAgICAgICB8fCBpbmRleCA+IDAgJiYgYGZpcmVmb3gtY29udGFpbmVyLSR7aW5kZXh9YDtcbn1cbiIsImltcG9ydCB7IHBvc3RJbml0aWFsaXplIH0gZnJvbSAnLi9pbml0JztcbmltcG9ydCB7IGdldERlZmF1bHRPcHRpb24sIGdldE9wdGlvbiwgc2V0T3B0aW9uIH0gZnJvbSAnLi9vcHRpb25zJztcblxuZXhwb3J0IGNvbnN0IFNDUklQVF9URU1QTEFURSA9ICdzY3JpcHRUZW1wbGF0ZSc7XG5jb25zdCBTQ1JJUFRfVEVNUExBVEVfRURJVEVEID0gYCR7U0NSSVBUX1RFTVBMQVRFfUVkaXRlZGA7XG5jb25zdCBJTklUSUFMX1RFTVBMQVRFID0gYFxcXG4vLyA9PVVzZXJTY3JpcHQ9PVxuLy8gQG5hbWUgTmV3IFNjcmlwdFxuLy8gQG5hbWVzcGFjZSBWaW9sZW50bW9ua2V5IFNjcmlwdHNcbi8vIEBtYXRjaCB7e3VybH19XG4vLyBAZ3JhbnQgbm9uZVxuLy8gPT0vVXNlclNjcmlwdD09XG5gO1xuXG5wb3N0SW5pdGlhbGl6ZS5wdXNoKCgpID0+IHtcbiAgbGV0IGVkaXRlZCA9IGdldE9wdGlvbihTQ1JJUFRfVEVNUExBVEVfRURJVEVEKTtcbiAgLy8gUHJlc2VydmUgYW4gZWRpdGVkIHRlbXBsYXRlXG4gIGlmIChlZGl0ZWQpIHJldHVybjtcbiAgY29uc3QgdGVtcGxhdGUgPSBnZXRPcHRpb24oU0NSSVBUX1RFTVBMQVRFKTtcbiAgLy8gV2hlbiB1cGRhdGluZyBmcm9tIGFuIG9sZCB2ZXJzaW9uLCBzZXQgdGhlIGVkaXRlZCBmbGFnIHJldHJvYWN0aXZlbHlcbiAgaWYgKGVkaXRlZCA9PSBudWxsKSB7XG4gICAgZWRpdGVkID0gdGVtcGxhdGUgIT09IElOSVRJQUxfVEVNUExBVEU7XG4gICAgaWYgKGVkaXRlZCkgc2V0T3B0aW9uKFNDUklQVF9URU1QTEFURV9FRElURUQsIHRydWUpO1xuICAgIGVsc2UgcmVzZXRTY3JpcHRUZW1wbGF0ZSgpO1xuICAvLyBXaGVuIHVwZGF0aW5nIFZNLCB1cGRhdGUgdG8gdGhlIG5ldyBkZWZhdWx0IHRlbXBsYXRlXG4gIH0gZWxzZSBpZiAodGVtcGxhdGUgIT09IGdldERlZmF1bHRPcHRpb24oU0NSSVBUX1RFTVBMQVRFKSkge1xuICAgIHJlc2V0U2NyaXB0VGVtcGxhdGUoKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldFNjcmlwdFRlbXBsYXRlKGNoYW5nZXMgPSB7fSkge1xuICBjb25zdCBkZWZhdWx0VGVtcGxhdGUgPSBnZXREZWZhdWx0T3B0aW9uKFNDUklQVF9URU1QTEFURSk7XG4gIGxldCB0ZW1wbGF0ZSA9IGNoYW5nZXNbU0NSSVBUX1RFTVBMQVRFXTtcbiAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgIHRlbXBsYXRlID0gZGVmYXVsdFRlbXBsYXRlO1xuICAgIGNoYW5nZXNbU0NSSVBUX1RFTVBMQVRFXSA9IHRlbXBsYXRlO1xuICAgIHNldE9wdGlvbihTQ1JJUFRfVEVNUExBVEUsIHRlbXBsYXRlKTtcbiAgfVxuICBjb25zdCBlZGl0ZWQgPSB0ZW1wbGF0ZSAhPT0gZGVmYXVsdFRlbXBsYXRlO1xuICBpZiAoZWRpdGVkICE9PSBjaGFuZ2VzW1NDUklQVF9URU1QTEFURV9FRElURURdKSB7XG4gICAgY2hhbmdlc1tTQ1JJUFRfVEVNUExBVEVfRURJVEVEXSA9IGVkaXRlZDtcbiAgICBzZXRPcHRpb24oU0NSSVBUX1RFTVBMQVRFX0VESVRFRCwgZWRpdGVkKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgdGxkIGZyb20gJyMvY29tbW9uL3RsZCc7XG5pbXBvcnQgY2FjaGUgZnJvbSAnLi9jYWNoZSc7XG5pbXBvcnQgeyBwb3N0SW5pdGlhbGl6ZSB9IGZyb20gJy4vaW5pdCc7XG5pbXBvcnQgeyBjb21tYW5kcyB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgeyBnZXRPcHRpb24sIGhvb2tPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJztcblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICBUZXN0QmxhY2tsaXN0OiB0ZXN0QmxhY2tsaXN0LFxufSk7XG5cbnBvc3RJbml0aWFsaXplLnB1c2gocmVzZXRCbGFja2xpc3QpO1xuXG50bGQuaW5pdFRMRCh0cnVlKTtcblxuY29uc3QgUkVfTUFUQ0hfUEFSVFMgPSAvKC4qPyk6XFwvXFwvKFteL10qKVxcLyguKikvO1xubGV0IGJsYWNrbGlzdFJ1bGVzID0gW107XG5ob29rT3B0aW9ucygoY2hhbmdlcykgPT4ge1xuICBpZiAoJ2JsYWNrbGlzdCcgaW4gY2hhbmdlcykgcmVzZXRCbGFja2xpc3QoY2hhbmdlcy5ibGFja2xpc3QgfHwgJycpO1xufSk7XG5jb25zdCBSRV9IVFRQX09SX0hUVFBTID0gL15odHRwcz8kL2k7XG5cbi8qXG4gU2ltcGxlIEZJRk8gcXVldWUgZm9yIHRoZSByZXN1bHRzIG9mIHRlc3RCbGFja2xpc3QsIGNhY2hlZCBzZXBhcmF0ZWx5IGZyb20gdGhlIG1haW4gfGNhY2hlfFxuIGJlY2F1c2UgdGhlIGJsYWNrbGlzdCBpcyB1cGRhdGVkIG9ubHkgb25jZSBpbiBhIHdoaWxlIHNvIGl0cyBlbnRyaWVzIHdvdWxkIGJlIGNyb3dkaW5nXG4gdGhlIG1haW4gY2FjaGUgYW5kIHJlZHVjaW5nIGl0cyBwZXJmb3JtYW5jZSAob2JqZWN0cyB3aXRoIGxvdHMgb2Yga2V5cyBhcmUgc2xvdyB0byBhY2Nlc3MpLlxuXG4gV2UgYWxzbyBkb24ndCBuZWVkIHRvIGF1dG8tZXhwaXJlIHRoZSBlbnRyaWVzIGFmdGVyIGEgdGltZW91dC5cbiBUaGUgb25seSBsaW1pdCB3ZSdyZSBjb25jZXJuZWQgd2l0aCBpcyB0aGUgb3ZlcmFsbCBtZW1vcnkgdXNlZC5cbiBUaGUgbGltaXQgaXMgc3BlY2lmaWVkIGluIHRoZSBhbW91bnQgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIChzdHJpbmcgbGVuZ3RoKSBmb3Igc2ltcGxpY2l0eS5cbiBEaXNyZWdhcmRpbmcgZGVkdXBsaWNhdGlvbiBkdWUgdG8gaW50ZXJuaW5nLCB0aGUgYWN0dWFsIG1lbW9yeSB1c2VkIGlzIGFwcHJveGltYXRlbHkgdHdpY2UgYXMgYmlnOlxuIDIgKiBrZXlMZW5ndGggKyBvYmplY3RTdHJ1Y3R1cmVPdmVyaGVhZCAqIG9iamVjdENvdW50XG4qL1xuY29uc3QgTUFYX0JMX0NBQ0hFX0xFTkdUSCA9IDEwMGUzO1xubGV0IGJsQ2FjaGUgPSB7fTtcbmxldCBibENhY2hlU2l6ZSA9IDA7XG5cbmZ1bmN0aW9uIHRlc3RSdWxlcyh1cmwsIHJ1bGVzLCBwcmVmaXgsIHJ1bGVCdWlsZGVyKSB7XG4gIHJldHVybiBydWxlcy5zb21lKHJ1bGUgPT4ge1xuICAgIGNvbnN0IGtleSA9IGAke3ByZWZpeH06JHtydWxlfWA7XG4gICAgY29uc3QgbWF0Y2hlciA9IGNhY2hlLmdldChrZXkpIHx8IGNhY2hlLnB1dChrZXksIHJ1bGVCdWlsZGVyKHJ1bGUpKTtcbiAgICByZXR1cm4gbWF0Y2hlci50ZXN0KHVybCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRlc3QgZ2xvYiBydWxlcyBsaWtlIGBAaW5jbHVkZWAgYW5kIGBAZXhjbHVkZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0R2xvYih1cmwsIHJ1bGVzKSB7XG4gIHJldHVybiB0ZXN0UnVsZXModXJsLCBydWxlcywgJ3JlJywgYXV0b1JlZyk7XG59XG5cbi8qKlxuICogVGVzdCBtYXRjaCBydWxlcyBsaWtlIGBAbWF0Y2hgIGFuZCBgQGV4Y2x1ZGVfbWF0Y2hgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVzdE1hdGNoKHVybCwgcnVsZXMpIHtcbiAgcmV0dXJuIHRlc3RSdWxlcyh1cmwsIHJ1bGVzLCAnbWF0Y2gnLCBtYXRjaFRlc3Rlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0U2NyaXB0KHVybCwgc2NyaXB0KSB7XG4gIGNhY2hlLmJhdGNoKHRydWUpO1xuICBjb25zdCB7IGN1c3RvbSwgbWV0YSB9ID0gc2NyaXB0O1xuICBjb25zdCBtYXQgPSBtZXJnZUxpc3RzKGN1c3RvbS5vcmlnTWF0Y2ggJiYgbWV0YS5tYXRjaCwgY3VzdG9tLm1hdGNoKTtcbiAgY29uc3QgaW5jID0gbWVyZ2VMaXN0cyhjdXN0b20ub3JpZ0luY2x1ZGUgJiYgbWV0YS5pbmNsdWRlLCBjdXN0b20uaW5jbHVkZSk7XG4gIGNvbnN0IGV4YyA9IG1lcmdlTGlzdHMoY3VzdG9tLm9yaWdFeGNsdWRlICYmIG1ldGEuZXhjbHVkZSwgY3VzdG9tLmV4Y2x1ZGUpO1xuICBjb25zdCBleGNNYXQgPSBtZXJnZUxpc3RzKGN1c3RvbS5vcmlnRXhjbHVkZU1hdGNoICYmIG1ldGEuZXhjbHVkZU1hdGNoLCBjdXN0b20uZXhjbHVkZU1hdGNoKTtcbiAgLy8gbWF0Y2ggYWxsIGlmIG5vIEBtYXRjaCBvciBAaW5jbHVkZSBydWxlXG4gIGxldCBvayA9ICFtYXQubGVuZ3RoICYmICFpbmMubGVuZ3RoO1xuICAvLyBAbWF0Y2hcbiAgb2sgPSBvayB8fCB0ZXN0TWF0Y2godXJsLCBtYXQpO1xuICAvLyBAaW5jbHVkZVxuICBvayA9IG9rIHx8IHRlc3RHbG9iKHVybCwgaW5jKTtcbiAgLy8gQGV4Y2x1ZGUtbWF0Y2hcbiAgb2sgPSBvayAmJiAhdGVzdE1hdGNoKHVybCwgZXhjTWF0KTtcbiAgLy8gQGV4Y2x1ZGVcbiAgb2sgPSBvayAmJiAhdGVzdEdsb2IodXJsLCBleGMpO1xuICBjYWNoZS5iYXRjaChmYWxzZSk7XG4gIHJldHVybiBvaztcbn1cblxuZnVuY3Rpb24gbWVyZ2VMaXN0cyguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzLnJlZHVjZSgocmVzLCBpdGVtKSA9PiAoaXRlbSA/IHJlcy5jb25jYXQoaXRlbSkgOiByZXMpLCBbXSk7XG59XG5cbmZ1bmN0aW9uIHN0cjJSRShzdHIpIHtcbiAgY29uc3QgcmUgPSBzdHIucmVwbGFjZSgvKFsuPytbXFxde30oKXxeJF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICByZXR1cm4gcmU7XG59XG5cbmZ1bmN0aW9uIGJpbmRSRShyZSkge1xuICByZXR1cm4gcmUudGVzdC5iaW5kKHJlKTtcbn1cblxuZnVuY3Rpb24gYXV0b1JlZyhzdHIpIHtcbiAgLy8gcmVnZXhwIG1vZGU6IGNhc2UtaW5zZW5zaXRpdmUgcGVyIEdNIGRvY3VtZW50YXRpb25cbiAgaWYgKHN0ci5sZW5ndGggPiAxICYmIHN0clswXSA9PT0gJy8nICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgIGxldCByZTtcbiAgICB0cnkgeyByZSA9IG5ldyBSZWdFeHAoc3RyLnNsaWNlKDEsIC0xKSwgJ2knKTsgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgIHJldHVybiB7IHRlc3Q6IHJlID8gYmluZFJFKHJlKSA6ICgpID0+IGZhbHNlIH07XG4gIH1cbiAgLy8gZ2xvYiBtb2RlOiBjYXNlLWluc2Vuc2l0aXZlIHRvIG1hdGNoIEdNNCAmIFRhbXBlcm1vbmtleSBidWdnZWQgYmVoYXZpb3JcbiAgY29uc3QgcmVTdHIgPSBzdHIyUkUoc3RyLnRvTG93ZXJDYXNlKCkpO1xuICBpZiAodGxkLmlzUmVhZHkoKSAmJiBzdHIuaW5jbHVkZXMoJy50bGQvJykpIHtcbiAgICBjb25zdCByZVRsZFN0ciA9IHJlU3RyLnJlcGxhY2UoJ1xcXFwudGxkLycsICcoKD86XFxcXC5bLVxcXFx3XSspKykvJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlc3Q6ICh0c3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0c3RyLnRvTG93ZXJDYXNlKCkubWF0Y2gocmVUbGRTdHIpO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IG1hdGNoZXNbMV0uc2xpY2UoMSk7XG4gICAgICAgICAgaWYgKHRsZC5nZXRQdWJsaWNTdWZmaXgoc3VmZml4KSA9PT0gc3VmZml4KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKGBeJHtyZVN0cn0kYCwgJ2knKTsgLy8gU3RyaW5nIHdpdGggd2lsZGNhcmRzXG4gIHJldHVybiB7IHRlc3Q6IGJpbmRSRShyZSkgfTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTY2hlbWUocnVsZSwgZGF0YSkge1xuICAvLyBleGFjdCBtYXRjaFxuICBpZiAocnVsZSA9PT0gZGF0YSkgcmV0dXJuIDE7XG4gIC8vICogPSBodHRwIHwgaHR0cHNcbiAgLy8gc3VwcG9ydCBodHRwKlxuICBpZiAoW1xuICAgICcqJyxcbiAgICAnaHR0cConLFxuICBdLmluY2x1ZGVzKHJ1bGUpICYmIFJFX0hUVFBfT1JfSFRUUFMudGVzdChkYXRhKSkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG5jb25zdCBSRV9TVFJfQU5ZID0gJyg/OnwuKj9cXFxcLiknO1xuY29uc3QgUkVfU1RSX1RMRCA9ICcoKD86XFxcXC5bLVxcXFx3XSspKyknO1xuZnVuY3Rpb24gaG9zdE1hdGNoZXIocnVsZSkge1xuICAvLyAqIG1hdGNoZXMgYWxsXG4gIGlmIChydWxlID09PSAnKicpIHtcbiAgICByZXR1cm4gKCkgPT4gMTtcbiAgfVxuICAvLyAqLmV4YW1wbGUuY29tXG4gIC8vIHd3dy5nb29nbGUuKlxuICAvLyB3d3cuZ29vZ2xlLnRsZFxuICBjb25zdCBydWxlTEMgPSBydWxlLnRvTG93ZXJDYXNlKCk7IC8vIGhvc3QgbWF0Y2hpbmcgaXMgY2FzZS1pbnNlbnNpdGl2ZVxuICBsZXQgcHJlZml4ID0gJyc7XG4gIGxldCBiYXNlID0gcnVsZUxDO1xuICBsZXQgc3VmZml4ID0gJyc7XG4gIGlmIChydWxlLnN0YXJ0c1dpdGgoJyouJykpIHtcbiAgICBiYXNlID0gYmFzZS5zbGljZSgyKTtcbiAgICBwcmVmaXggPSBSRV9TVFJfQU5ZO1xuICB9XG4gIGlmICh0bGQuaXNSZWFkeSgpICYmIHJ1bGUuZW5kc1dpdGgoJy50bGQnKSkge1xuICAgIGJhc2UgPSBiYXNlLnNsaWNlKDAsIC00KTtcbiAgICBzdWZmaXggPSBSRV9TVFJfVExEO1xuICB9XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgXiR7cHJlZml4fSR7c3RyMlJFKGJhc2UpfSR7c3VmZml4fSRgKTtcbiAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgLy8gZXhhY3QgbWF0Y2gsIGNhc2UtaW5zZW5zaXRpdmVcbiAgICBkYXRhID0gZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChydWxlTEMgPT09IGRhdGEpIHJldHVybiAxO1xuICAgIC8vIGZ1bGwgY2hlY2tcbiAgICBjb25zdCBtYXRjaGVzID0gZGF0YS5tYXRjaChyZSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIGNvbnN0IFssIHRsZFN0cl0gPSBtYXRjaGVzO1xuICAgICAgaWYgKCF0bGRTdHIpIHJldHVybiAxO1xuICAgICAgY29uc3QgdGxkU3VmZml4ID0gdGxkU3RyLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIHRsZC5nZXRQdWJsaWNTdWZmaXgodGxkU3VmZml4KSA9PT0gdGxkU3VmZml4O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGF0aE1hdGNoZXIocnVsZSkge1xuICBjb25zdCBpSGFzaCA9IHJ1bGUuaW5kZXhPZignIycpO1xuICBsZXQgaVF1ZXJ5ID0gcnVsZS5pbmRleE9mKCc/Jyk7XG4gIGxldCBzdHJSZSA9IHN0cjJSRShydWxlKTtcbiAgaWYgKGlRdWVyeSA+IGlIYXNoKSBpUXVlcnkgPSAtMTtcbiAgaWYgKGlIYXNoIDwgMCkge1xuICAgIGlmIChpUXVlcnkgPCAwKSBzdHJSZSA9IGBeJHtzdHJSZX0oPzpbPyNdfCQpYDtcbiAgICBlbHNlIHN0clJlID0gYF4ke3N0clJlfSg/OiN8JClgO1xuICB9XG4gIHJldHVybiBiaW5kUkUobmV3IFJlZ0V4cChzdHJSZSkpO1xufVxuXG5mdW5jdGlvbiBtYXRjaFRlc3RlcihydWxlKSB7XG4gIGxldCB0ZXN0O1xuICBpZiAocnVsZSA9PT0gJzxhbGxfdXJscz4nKSB7XG4gICAgdGVzdCA9ICgpID0+IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcnVsZVBhcnRzID0gcnVsZS5tYXRjaChSRV9NQVRDSF9QQVJUUyk7XG4gICAgaWYgKHJ1bGVQYXJ0cykge1xuICAgICAgY29uc3QgbWF0Y2hIb3N0ID0gaG9zdE1hdGNoZXIocnVsZVBhcnRzWzJdKTtcbiAgICAgIGNvbnN0IG1hdGNoUGF0aCA9IHBhdGhNYXRjaGVyKHJ1bGVQYXJ0c1szXSk7XG4gICAgICB0ZXN0ID0gKHVybCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHVybC5tYXRjaChSRV9NQVRDSF9QQVJUUyk7XG4gICAgICAgIHJldHVybiAhIXJ1bGVQYXJ0cyAmJiAhIXBhcnRzXG4gICAgICAgICAgJiYgbWF0Y2hTY2hlbWUocnVsZVBhcnRzWzFdLCBwYXJ0c1sxXSlcbiAgICAgICAgICAmJiBtYXRjaEhvc3QocGFydHNbMl0pXG4gICAgICAgICAgJiYgbWF0Y2hQYXRoKHBhcnRzWzNdKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElnbm9yZSBpbnZhbGlkIG1hdGNoIHJ1bGVzXG4gICAgICB0ZXN0ID0gKCkgPT4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHRlc3QgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RCbGFja2xpc3QodXJsKSB7XG4gIGxldCByZXMgPSBibENhY2hlW3VybF07XG4gIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHJ1bGUgPSBibGFja2xpc3RSdWxlcy5maW5kKCh7IHRlc3QgfSkgPT4gdGVzdCh1cmwpKTtcbiAgICByZXMgPSBydWxlPy5yZWplY3QgJiYgcnVsZS50ZXh0O1xuICAgIHVwZGF0ZUJsYWNrbGlzdENhY2hlKHVybCwgcmVzIHx8IGZhbHNlKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRCbGFja2xpc3QobGlzdCkge1xuICBjYWNoZS5iYXRjaCh0cnVlKTtcbiAgY29uc3QgcnVsZXMgPSBsaXN0ID09IG51bGwgPyBnZXRPcHRpb24oJ2JsYWNrbGlzdCcpIDogbGlzdDtcbiAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgY29uc29sZS5pbmZvKCdSZXNldCBibGFja2xpc3Q6JywgcnVsZXMpO1xuICB9XG4gIC8vIFhYWCBjb21wYXRpYmxlIHdpdGgge0FycmF5fSBsaXN0IGluIHYyLjYuMS1cbiAgYmxhY2tsaXN0UnVsZXMgPSAoQXJyYXkuaXNBcnJheShydWxlcykgPyBydWxlcyA6IChydWxlcyB8fCAnJykuc3BsaXQoJ1xcbicpKVxuICAubWFwKCh0ZXh0KSA9PiB7XG4gICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICAgIGlmICghdGV4dCB8fCB0ZXh0LnN0YXJ0c1dpdGgoJyMnKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbW9kZSA9IHRleHQuc3RhcnRzV2l0aCgnQCcpICYmIHRleHQuc3BsaXQoL1xccy8sIDEpWzBdO1xuICAgIGNvbnN0IHJ1bGUgPSBtb2RlID8gdGV4dC5zbGljZShtb2RlLmxlbmd0aCArIDEpLnRyaW0oKSA6IHRleHQ7XG4gICAgY29uc3QgcmVqZWN0ID0gbW9kZSAhPT0gJ0BpbmNsdWRlJyAmJiBtb2RlICE9PSAnQG1hdGNoJzsgLy8gQGluY2x1ZGUgYW5kIEBtYXRjaCA9IHdoaXRlbGlzdFxuICAgIGNvbnN0IHsgdGVzdCB9ID0gbW9kZSA9PT0gJ0BpbmNsdWRlJyB8fCBtb2RlID09PSAnQGV4Y2x1ZGUnICYmIGF1dG9SZWcocnVsZSlcbiAgICAgIHx8ICFtb2RlICYmICFydWxlLmluY2x1ZGVzKCcvJykgJiYgbWF0Y2hUZXN0ZXIoYCo6Ly8ke3J1bGV9LypgKSAvLyBkb21haW5cbiAgICAgIHx8IG1hdGNoVGVzdGVyKHJ1bGUpOyAvLyBAbWF0Y2ggYW5kIEBleGNsdWRlLW1hdGNoXG4gICAgcmV0dXJuIHsgcmVqZWN0LCB0ZXN0LCB0ZXh0IH07XG4gIH0pXG4gIC5maWx0ZXIoQm9vbGVhbik7XG4gIGJsQ2FjaGUgPSB7fTtcbiAgYmxDYWNoZVNpemUgPSAwO1xuICBjYWNoZS5iYXRjaChmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJsYWNrbGlzdENhY2hlKGtleSwgdmFsdWUpIHtcbiAgYmxDYWNoZVtrZXldID0gdmFsdWU7XG4gIGJsQ2FjaGVTaXplICs9IGtleS5sZW5ndGg7XG4gIGlmIChibENhY2hlU2l6ZSA+IE1BWF9CTF9DQUNIRV9MRU5HVEgpIHtcbiAgICBPYmplY3Qua2V5cyhibENhY2hlKVxuICAgIC5zb21lKChrKSA9PiB7XG4gICAgICBibENhY2hlU2l6ZSAtPSBrLmxlbmd0aDtcbiAgICAgIGRlbGV0ZSBibENhY2hlW2tdO1xuICAgICAgLy8gcmVkdWNlIHRoZSBjYWNoZSB0byA3NSUgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgcnVuIHRvbyBvZnRlbi5cbiAgICAgIHJldHVybiBibENhY2hlU2l6ZSA8IE1BWF9CTF9DQUNIRV9MRU5HVEggKiAzIC8gNDtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0U2NyaXB0TmFtZSwgaTE4biwgcmVxdWVzdCwgY29tcGFyZVZlcnNpb24sIHNlbmRDbWQsIHRydWVKb2luIH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgQ01EX1NDUklQVF9VUERBVEUsIElTX0RFViB9IGZyb20gJyMvY29tbW9uL2NvbnN0cyc7XG5pbXBvcnQgeyBmZXRjaFJlc291cmNlcywgZ2V0U2NyaXB0QnlJZCwgZ2V0U2NyaXB0cywgcGFyc2VTY3JpcHQgfSBmcm9tICcuL2RiJztcbmltcG9ydCB7IHBhcnNlTWV0YSB9IGZyb20gJy4vc2NyaXB0JztcbmltcG9ydCB7IGdldE9wdGlvbiwgc2V0T3B0aW9uIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi9tZXNzYWdlJztcblxuT2JqZWN0LmFzc2lnbihjb21tYW5kcywge1xuICAvKiogQHJldHVybiB7UHJvbWlzZTx0cnVlPz59ICovXG4gIGFzeW5jIENoZWNrVXBkYXRlKGlkKSB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZ2V0U2NyaXB0QnlJZChpZCk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNoZWNrQWxsQW5kTm90aWZ5KFtzY3JpcHRdKTtcbiAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgfSxcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59ICovXG4gIGFzeW5jIENoZWNrVXBkYXRlQWxsKCkge1xuICAgIHNldE9wdGlvbignbGFzdFVwZGF0ZScsIERhdGUubm93KCkpO1xuICAgIGNvbnN0IHRvVXBkYXRlID0gZ2V0U2NyaXB0cygpLmZpbHRlcihpdGVtID0+IGl0ZW0uY29uZmlnLnNob3VsZFVwZGF0ZSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNoZWNrQWxsQW5kTm90aWZ5KHRvVXBkYXRlKTtcbiAgICByZXR1cm4gcmVzdWx0cy5pbmNsdWRlcyh0cnVlKTtcbiAgfSxcbn0pO1xuXG5hc3luYyBmdW5jdGlvbiBjaGVja0FsbEFuZE5vdGlmeShzY3JpcHRzKSB7XG4gIGNvbnN0IG5vdGVzID0gW107XG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChpdGVtID0+IGNoZWNrVXBkYXRlKGl0ZW0sIG5vdGVzKSkpO1xuICBpZiAobm90ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgbm90aWZ5KG5vdGVzWzBdKTtcbiAgfSBlbHNlIGlmIChub3Rlcy5sZW5ndGgpIHtcbiAgICBub3RpZnkoe1xuICAgICAgLy8gRkYgZG9lc24ndCBzaG93IG5vdGlmaWNhdGlvbnMgb2YgdHlwZTonbGlzdCcgc28gd2UnbGwgdXNlIGB0ZXh0YCBldmVyeXdoZXJlXG4gICAgICB0ZXh0OiBub3Rlcy5tYXAobiA9PiBuLnRleHQpLmpvaW4oJ1xcbicpLFxuICAgICAgb25DbGljazogYnJvd3Nlci5ydW50aW1lLm9wZW5PcHRpb25zUGFnZSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuY29uc3QgcHJvY2Vzc2VzID0ge307XG5cbi8vIHJlc29sdmVzIHRvIHRydWUgaWYgc3VjY2Vzc2Z1bGx5IHVwZGF0ZWRcbmZ1bmN0aW9uIGNoZWNrVXBkYXRlKHNjcmlwdCwgbm90ZXMpIHtcbiAgY29uc3QgeyBpZCB9ID0gc2NyaXB0LnByb3BzO1xuICBjb25zdCBwcm9taXNlID0gcHJvY2Vzc2VzW2lkXSB8fCAocHJvY2Vzc2VzW2lkXSA9IGRvQ2hlY2tVcGRhdGUoc2NyaXB0LCBub3RlcykpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG9DaGVja1VwZGF0ZShzY3JpcHQsIG5vdGVzKSB7XG4gIGNvbnN0IHsgaWQgfSA9IHNjcmlwdC5wcm9wcztcbiAgbGV0IG1zZ09rO1xuICBsZXQgbXNnRXJyO1xuICBsZXQgcmVzb3VyY2VPcHRzO1xuICB0cnkge1xuICAgIGNvbnN0IHsgdXBkYXRlIH0gPSBhd2FpdCBwYXJzZVNjcmlwdCh7XG4gICAgICBpZCxcbiAgICAgIGNvZGU6IGF3YWl0IGRvd25sb2FkVXBkYXRlKHNjcmlwdCksXG4gICAgICB1cGRhdGU6IHsgY2hlY2tpbmc6IGZhbHNlIH0sXG4gICAgfSk7XG4gICAgbXNnT2sgPSBpMThuKCdtc2dTY3JpcHRVcGRhdGVkJywgW2dldFNjcmlwdE5hbWUodXBkYXRlKV0pO1xuICAgIHJlc291cmNlT3B0cyA9IHsgY2FjaGU6ICduby1jYWNoZScgfTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAodXBkYXRlKSB7XG4gICAgbXNnRXJyID0gdXBkYXRlLmVycm9yO1xuICAgIC8vIEVpdGhlciBwcm9jZWVkIHdpdGggbm9ybWFsIGZldGNoIG9uIG5vLXVwZGF0ZSBvciBza2lwIGl0IGFsdG9nZXRoZXIgb24gZXJyb3JcbiAgICByZXNvdXJjZU9wdHMgPSAhdXBkYXRlLmVycm9yICYmICF1cGRhdGUuY2hlY2tpbmcgJiYge307XG4gICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSBjb25zb2xlLmVycm9yKHVwZGF0ZSk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHJlc291cmNlT3B0cyAmJiAhSVNfREVWKSB7IC8vIERFVueKtuaAgeS4jeabtOaWsHJlc291cmNlXG4gICAgICBtc2dFcnIgPSBhd2FpdCBmZXRjaFJlc291cmNlcyhzY3JpcHQsIG51bGwsIHJlc291cmNlT3B0cyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUcgJiYgbXNnRXJyKSBjb25zb2xlLmVycm9yKG1zZ0Vycik7XG4gICAgfVxuICAgIGlmIChjYW5Ob3RpZnkoc2NyaXB0KSAmJiAobXNnT2sgfHwgbXNnRXJyKSkge1xuICAgICAgbm90ZXMucHVzaCh7XG4gICAgICAgIHNjcmlwdCxcbiAgICAgICAgdGV4dDogW21zZ09rLCBtc2dFcnJdOjp0cnVlSm9pbignXFxuJyksXG4gICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlIHByb2Nlc3Nlc1tpZF07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRVcGRhdGUoeyBwcm9wczogeyBpZCB9LCBtZXRhLCBjdXN0b20gfSkge1xuICBjb25zdCBkb3dubG9hZFVSTCA9IGN1c3RvbS5kb3dubG9hZFVSTCB8fCBtZXRhLmRvd25sb2FkVVJMIHx8IGN1c3RvbS5sYXN0SW5zdGFsbFVSTDtcbiAgbGV0IHVwZGF0ZVVSTCA9IGN1c3RvbS51cGRhdGVVUkwgfHwgbWV0YS51cGRhdGVVUkwgfHwgZG93bmxvYWRVUkw7XG4gIGlmIChJU19ERVYgJiYgdXBkYXRlVVJMKSB7XG4gICAgaWYgKG1ldGEuZGV2KSB7XG4gICAgICBjb25zdCB1cmxzID0gdXBkYXRlVVJMLnNwbGl0KCcvJyk7XG4gICAgICB1cGRhdGVVUkwgPSBgaHR0cDovLzEyNy4wLjAuMToke21ldGEuZGV2fS8ke3VybHNbdXJscy5sZW5ndGggLSAxXX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVVUkwgPSBudWxsO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmluZm8oJ2Rvd25sb2FkVXBkYXRlJywgaWQsIHVwZGF0ZVVSTCk7XG4gIH1cbiAgaWYgKCF1cGRhdGVVUkwpIHRocm93IGZhbHNlO1xuICBsZXQgZXJyb3JNZXNzYWdlO1xuICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgY29uc3QgcmVzdWx0ID0geyB1cGRhdGUsIHdoZXJlOiB7IGlkIH0gfTtcbiAgYW5ub3VuY2UoaTE4bignbXNnQ2hlY2tpbmdGb3JVcGRhdGUnKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCByZXF1ZXN0KHVwZGF0ZVVSTCwge1xuICAgICAgLy8gVE9ETzogZG8gYSBIRUFEIHJlcXVlc3QgZmlyc3QgdG8gZ2V0IEVUYWcgaGVhZGVyIGFuZCBjb21wYXJlIHRvIHN0b3JhZ2UubW9kXG4gICAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiAndGV4dC94LXVzZXJzY3JpcHQtbWV0YSwqLyonIH0sXG4gICAgfSk7XG4gICAgY29uc3QgeyB2ZXJzaW9uIH0gPSBwYXJzZU1ldGEoZGF0YSk7XG4gICAgaWYgKElTX0RFVikge1xuICAgICAgaWYgKG1ldGEudmVyc2lvbiA9PT0gdmVyc2lvbikgdGhyb3cgZmFsc2U7XG4gICAgICBjb25zb2xlLmluZm8oJ3VwZGF0ZScsIG1ldGEubmFtZSwgdmVyc2lvbiwgY29tcGFyZVZlcnNpb24obWV0YS52ZXJzaW9uLCB2ZXJzaW9uKSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVWZXJzaW9uKG1ldGEudmVyc2lvbiwgdmVyc2lvbikgPj0gMCkge1xuICAgICAgYW5ub3VuY2UoaTE4bignbXNnTm9VcGRhdGUnKSwgeyBjaGVja2luZzogZmFsc2UgfSk7XG4gICAgfSBlbHNlIGlmICghZG93bmxvYWRVUkwpIHtcbiAgICAgIGFubm91bmNlKGkxOG4oJ21zZ05ld1ZlcnNpb24nKSwgeyBjaGVja2luZzogZmFsc2UgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFubm91bmNlKGkxOG4oJ21zZ1VwZGF0aW5nJykpO1xuICAgICAgZXJyb3JNZXNzYWdlID0gaTE4bignbXNnRXJyb3JGZXRjaGluZ1NjcmlwdCcpO1xuICAgICAgcmV0dXJuIChhd2FpdCByZXF1ZXN0KGRvd25sb2FkVVJMLCB7IGNhY2hlOiAnbm8tY2FjaGUnIH0pKS5kYXRhO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIGFubm91bmNlKGVycm9yTWVzc2FnZSB8fCBpMThuKCdtc2dFcnJvckZldGNoaW5nVXBkYXRlSW5mbycpLCB7IGVycm9yIH0pO1xuICB9XG4gIHRocm93IHVwZGF0ZTtcbiAgZnVuY3Rpb24gYW5ub3VuY2UobWVzc2FnZSwgeyBlcnJvciwgY2hlY2tpbmcgPSAhZXJyb3IgfSA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGUsIHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBjaGVja2luZyxcbiAgICAgIGVycm9yOiBlcnJvciA/IGAke2kxOG4oJ2dlbmVyaWNFcnJvcicpfSAke2Vycm9yLnN0YXR1c30sICR7ZXJyb3IudXJsfWAgOiBudWxsLFxuICAgICAgLy8gYG51bGxgIGlzIHRyYW5zZmVyYWJsZSBpbiBDaHJvbWUgdW5saWtlIGB1bmRlZmluZWRgXG4gICAgfSk7XG4gICAgc2VuZENtZChDTURfU0NSSVBUX1VQREFURSwgcmVzdWx0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5Ob3RpZnkoc2NyaXB0KSB7XG4gIGNvbnN0IGFsbG93ZWQgPSBnZXRPcHRpb24oJ25vdGlmeVVwZGF0ZXMnKTtcbiAgcmV0dXJuIGdldE9wdGlvbignbm90aWZ5VXBkYXRlc0dsb2JhbCcpXG4gICAgPyBhbGxvd2VkXG4gICAgOiBzY3JpcHQuY29uZmlnLm5vdGlmeVVwZGF0ZXMgPz8gYWxsb3dlZDtcbn1cblxuZnVuY3Rpb24gbm90aWZ5KHtcbiAgc2NyaXB0LFxuICB0ZXh0LFxuICBvbkNsaWNrID0gKCkgPT4gY29tbWFuZHMuT3BlbkVkaXRvcihzY3JpcHQucHJvcHMuaWQpLFxufSkge1xuICBjb21tYW5kcy5Ob3RpZmljYXRpb24oe1xuICAgIHRleHQsXG4gICAgLy8gRkYgZG9lc24ndCBzaG93IHRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gaW4gdGhlIHRpdGxlIG9mIHRoZSBub3RpZmljYXRpb25cbiAgICB0aXRsZTogSVNfRklSRUZPWCA/IGAke2kxOG4oJ3RpdGxlU2NyaXB0VXBkYXRlZCcpfSAtICR7aTE4bignZXh0TmFtZScpfWAgOiAnJyxcbiAgfSwgdW5kZWZpbmVkLCB7XG4gICAgb25DbGljayxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBpc0VtcHR5LCBzZW5kVGFiQ21kIH0gZnJvbSAnIy9jb21tb24nO1xuaW1wb3J0IHsgZm9yRWFjaEVudHJ5LCBmb3JFYWNoS2V5LCBvYmplY3RTZXQgfSBmcm9tICcjL2NvbW1vbi9vYmplY3QnO1xuaW1wb3J0IHsgZ2V0U2NyaXB0LCBnZXRWYWx1ZVN0b3Jlc0J5SWRzLCBkdW1wVmFsdWVTdG9yZXMgfSBmcm9tICcuL2RiJztcbmltcG9ydCB7IGNvbW1hbmRzIH0gZnJvbSAnLi9tZXNzYWdlJztcblxuY29uc3Qgb3BlbmVycyA9IHt9OyAvLyB7IHNjcmlwdElkOiB7IHRhYklkOiB7IGZyYW1lSWQ6IDEsIC4uLiB9LCAuLi4gfSB9XG5sZXQgY2FjaGUgPSB7fTsgLy8geyBzY3JpcHRJZDogeyBrZXk6IHsgbGFzdDogdmFsdWUsIHRhYklkOiB7IGZyYW1lSWQ6IHZhbHVlIH0gfSB9IH1cbmxldCB1cGRhdGVTY2hlZHVsZWQ7XG5cbk9iamVjdC5hc3NpZ24oY29tbWFuZHMsIHtcbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gKi9cbiAgYXN5bmMgR2V0VmFsdWVTdG9yZShpZCkge1xuICAgIGNvbnN0IHN0b3JlcyA9IGF3YWl0IGdldFZhbHVlU3RvcmVzQnlJZHMoW2lkXSk7XG4gICAgcmV0dXJuIHN0b3Jlc1tpZF0gfHwge307XG4gIH0sXG4gIC8qKiBAcGFyYW0ge3sgd2hlcmUsIHN0b3JlIH1bXX0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSAqL1xuICBhc3luYyBTZXRWYWx1ZVN0b3JlcyhkYXRhKSB7XG4gICAgLy8gVmFsdWUgc3RvcmUgd2lsbCBiZSByZXBsYWNlZCBzb29uLlxuICAgIGNvbnN0IHN0b3JlcyA9IGRhdGEucmVkdWNlKChyZXMsIHsgd2hlcmUsIHN0b3JlIH0pID0+IHtcbiAgICAgIGNvbnN0IGlkID0gd2hlcmUuaWQgfHwgZ2V0U2NyaXB0KHdoZXJlKT8ucHJvcHMuaWQ7XG4gICAgICBpZiAoaWQpIHJlc1tpZF0gPSBzdG9yZTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwge30pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGR1bXBWYWx1ZVN0b3JlcyhzdG9yZXMpLFxuICAgICAgYnJvYWRjYXN0VmFsdWVTdG9yZXMoZ3JvdXBTdG9yZXNCeUZyYW1lKHN0b3JlcykpLFxuICAgIF0pO1xuICB9LFxuICAvKiogQHJldHVybiB7dm9pZH0gKi9cbiAgVXBkYXRlVmFsdWUoeyBpZCwga2V5LCB2YWx1ZSA9IG51bGwgfSwgc3JjKSB7XG4gICAgb2JqZWN0U2V0KGNhY2hlLCBbaWQsIGtleSwgJ2xhc3QnXSwgdmFsdWUpO1xuICAgIG9iamVjdFNldChjYWNoZSwgW2lkLCBrZXksIHNyYy50YWIuaWQsIHNyYy5mcmFtZUlkXSwgdmFsdWUpO1xuICAgIHVwZGF0ZUxhdGVyKCk7XG4gIH0sXG59KTtcblxuYnJvd3Nlci50YWJzLm9uUmVtb3ZlZC5hZGRMaXN0ZW5lcihyZXNldFZhbHVlT3BlbmVyKTtcbmJyb3dzZXIudGFicy5vblJlcGxhY2VkLmFkZExpc3RlbmVyKChhZGRlZElkLCByZW1vdmVkSWQpID0+IHJlc2V0VmFsdWVPcGVuZXIocmVtb3ZlZElkKSk7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldFZhbHVlT3BlbmVyKHRhYklkKSB7XG4gIG9wZW5lcnM6OmZvckVhY2hFbnRyeSgoW2lkLCBvcGVuZXJUYWJzXSkgPT4ge1xuICAgIGlmICh0YWJJZCBpbiBvcGVuZXJUYWJzKSB7XG4gICAgICBkZWxldGUgb3BlbmVyVGFic1t0YWJJZF07XG4gICAgICBpZiAoaXNFbXB0eShvcGVuZXJUYWJzKSkgZGVsZXRlIG9wZW5lcnNbaWRdO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRWYWx1ZU9wZW5lcih0YWJJZCwgZnJhbWVJZCwgc2NyaXB0SWRzKSB7XG4gIHNjcmlwdElkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgIG9iamVjdFNldChvcGVuZXJzLCBbaWQsIHRhYklkLCBmcmFtZUlkXSwgMSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVMYXRlcigpIHtcbiAgd2hpbGUgKCF1cGRhdGVTY2hlZHVsZWQpIHtcbiAgICB1cGRhdGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIGF3YWl0IDA7XG4gICAgY29uc3QgY3VycmVudENhY2hlID0gY2FjaGU7XG4gICAgY2FjaGUgPSB7fTtcbiAgICBhd2FpdCBkb1VwZGF0ZShjdXJyZW50Q2FjaGUpO1xuICAgIHVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmIChpc0VtcHR5KGNhY2hlKSkgYnJlYWs7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZG9VcGRhdGUoY3VycmVudENhY2hlKSB7XG4gIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKGN1cnJlbnRDYWNoZSk7XG4gIGNvbnN0IHZhbHVlU3RvcmVzID0gYXdhaXQgZ2V0VmFsdWVTdG9yZXNCeUlkcyhpZHMpO1xuICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICBjdXJyZW50Q2FjaGVbaWRdOjpmb3JFYWNoRW50cnkoKFtrZXksIHsgbGFzdCB9XSkgPT4ge1xuICAgICAgb2JqZWN0U2V0KHZhbHVlU3RvcmVzLCBbaWQsIGtleV0sIGxhc3QgfHwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfSk7XG4gIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICBkdW1wVmFsdWVTdG9yZXModmFsdWVTdG9yZXMpLFxuICAgIGJyb2FkY2FzdFZhbHVlU3RvcmVzKGdyb3VwQ2FjaGVCeUZyYW1lKGN1cnJlbnRDYWNoZSksIHsgcGFydGlhbDogdHJ1ZSB9KSxcbiAgXSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJyb2FkY2FzdFZhbHVlU3RvcmVzKHRhYkZyYW1lRGF0YSwgeyBwYXJ0aWFsIH0gPSB7fSkge1xuICBjb25zdCB0YXNrcyA9IFtdO1xuICBmb3IgKGNvbnN0IFt0YWJJZCwgZnJhbWVzXSBvZiBPYmplY3QuZW50cmllcyh0YWJGcmFtZURhdGEpKSB7XG4gICAgZm9yIChjb25zdCBbZnJhbWVJZCwgZnJhbWVEYXRhXSBvZiBPYmplY3QuZW50cmllcyhmcmFtZXMpKSB7XG4gICAgICBpZiAoIWlzRW1wdHkoZnJhbWVEYXRhKSkge1xuICAgICAgICBpZiAocGFydGlhbCkgZnJhbWVEYXRhLnBhcnRpYWwgPSB0cnVlO1xuICAgICAgICB0YXNrcy5wdXNoKHNlbmRUYWJDbWQoK3RhYklkLCAnVXBkYXRlZFZhbHVlcycsIGZyYW1lRGF0YSwgeyBmcmFtZUlkOiArZnJhbWVJZCB9KSk7XG4gICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDIwKSBhd2FpdCBQcm9taXNlLmFsbCh0YXNrcy5zcGxpY2UoMCkpOyAvLyB0aHJvdHRsaW5nXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGF3YWl0IFByb21pc2UuYWxsKHRhc2tzKTtcbn1cblxuLy8gUmV0dXJucyBwZXIgdGFiL2ZyYW1lIGRhdGEgd2l0aCBvbmx5IHRoZSBjaGFuZ2VkIHZhbHVlc1xuZnVuY3Rpb24gZ3JvdXBDYWNoZUJ5RnJhbWUoY2FjaGVEYXRhKSB7XG4gIGNvbnN0IHRvU2VuZCA9IHt9O1xuICBjYWNoZURhdGE6OmZvckVhY2hFbnRyeSgoW2lkLCBzY3JpcHREYXRhXSkgPT4ge1xuICAgIGNvbnN0IGRhdGFFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoc2NyaXB0RGF0YSk7XG4gICAgb3BlbmVyc1tpZF06OmZvckVhY2hFbnRyeSgoW3RhYklkLCBmcmFtZXNdKSA9PiB7XG4gICAgICBmcmFtZXM6OmZvckVhY2hLZXkoKGZyYW1lSWQpID0+IHtcbiAgICAgICAgZGF0YUVudHJpZXMuZm9yRWFjaCgoW2tleSwgaGlzdG9yeV0pID0+IHtcbiAgICAgICAgICAvLyBTa2lwcGluZyB0aGlzIGZyYW1lIGlmIGl0cyBsYXN0IHJlY29yZGVkIHZhbHVlIGlzIGlkZW50aWNhbFxuICAgICAgICAgIGlmIChoaXN0b3J5Lmxhc3QgIT09IGhpc3RvcnlbdGFiSWRdPy5bZnJhbWVJZF0pIHtcbiAgICAgICAgICAgIG9iamVjdFNldCh0b1NlbmQsIFt0YWJJZCwgZnJhbWVJZCwgaWQsIGtleV0sIGhpc3RvcnkubGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRvU2VuZDtcbn1cblxuLy8gUmV0dXJucyBwZXIgdGFiL2ZyYW1lIGRhdGFcbmZ1bmN0aW9uIGdyb3VwU3RvcmVzQnlGcmFtZShzdG9yZXMpIHtcbiAgY29uc3QgdG9TZW5kID0ge307XG4gIHN0b3Jlczo6Zm9yRWFjaEVudHJ5KChbaWQsIHN0b3JlXSkgPT4ge1xuICAgIG9wZW5lcnNbaWRdOjpmb3JFYWNoRW50cnkoKFt0YWJJZCwgZnJhbWVzXSkgPT4ge1xuICAgICAgZnJhbWVzOjpmb3JFYWNoS2V5KGZyYW1lSWQgPT4ge1xuICAgICAgICBvYmplY3RTZXQodG9TZW5kLCBbdGFiSWQsIGZyYW1lSWQsIGlkXSwgc3RvcmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdG9TZW5kO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoYWxsb3dlZCkge1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgdGhpcy5hbGxvd2VkID0gYWxsb3dlZDtcbiAgfVxuXG4gIGNoZWNrVHlwZSh0eXBlKSB7XG4gICAgaWYgKHRoaXMuYWxsb3dlZCAmJiAhdGhpcy5hbGxvd2VkLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZXZlbnQgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgfVxuXG4gIG9uKHR5cGUsIGhhbmRsZSkge1xuICAgIHRoaXMuY2hlY2tUeXBlKHR5cGUpO1xuICAgIGNvbnN0IHsgZXZlbnRzIH0gPSB0aGlzO1xuICAgIGxldCBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVycyA9IFtdO1xuICAgICAgZXZlbnRzW3R5cGVdID0gaGFuZGxlcnM7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB0aGlzLm9mZih0eXBlLCBoYW5kbGUpO1xuICB9XG5cbiAgb2ZmKHR5cGUsIGhhbmRsZSkge1xuICAgIHRoaXMuY2hlY2tUeXBlKHR5cGUpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5ldmVudHNbdHlwZV07XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBjb25zdCBpID0gaGFuZGxlcnMuaW5kZXhPZihoYW5kbGUpO1xuICAgICAgaWYgKGkgPj0gMCkgaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuXG4gIGVtaXQodHlwZSwgZGF0YSkge1xuICAgIHRoaXMuY2hlY2tUeXBlKHR5cGUpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5ldmVudHNbdHlwZV07XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBjb25zdCBldnQgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICBldnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgaGFuZGxlcnMuc29tZSgoaGFuZGxlKSA9PiB7XG4gICAgICAgIGhhbmRsZShldnQpO1xuICAgICAgICByZXR1cm4gZXZ0LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB0bGRqcyBmcm9tICd0bGRqcyc7XG4vLyBpbXBvcnQgeyBmcm9tVXNlclNldHRpbmdzIH0gZnJvbSAndGxkanMnO1xuLy8gaW1wb3J0IFRyaWUgZnJvbSAndGxkanMvbGliL3N1ZmZpeC10cmllJztcbi8vIGltcG9ydCB7IHJlcXVlc3QgfSBmcm9tICcjL2NvbW1vbic7XG5cbi8vIGxldCB0bGRqcztcblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGluaXRUTEQocmVtb3RlKSB7XG4vLyAgIC8vIFRMRCBydWxlcyBhcmUgdG9vIGxhcmdlIHRvIGJlIHBhY2tlZCwgZG93bmxvYWQgdGhlbSBhdCBydW50aW1lLlxuLy8gICBjb25zdCB1cmwgPSAnaHR0cHM6Ly92aW9sZW50bW9ua2V5LnRvcC9zdGF0aWMvdGxkLXJ1bGVzLmpzb24nO1xuLy8gICBjb25zdCBrZXkgPSAnZGF0OnRsZFJ1bGVzJztcbi8vICAgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmdldChrZXkpXG4vLyAgIC50aGVuKCh7IFtrZXldOiB0bGRSdWxlcyB9KSA9PiB7XG4vLyAgICAgaWYgKHRsZFJ1bGVzKSByZXR1cm4gdGxkUnVsZXM7XG4vLyAgICAgaWYgKCFyZW1vdGUpIHJldHVybiBQcm9taXNlLnJlamVjdCgnaWdub3JlIFRMRCcpO1xuLy8gICAgIHJldHVybiByZXF1ZXN0KHVybCwgeyByZXNwb25zZVR5cGU6ICdqc29uJyB9KVxuLy8gICAgIC50aGVuKCh7IGRhdGE6IHJ1bGVzIH0pID0+IHtcbi8vICAgICAgIGNvbnNvbGUuaW5mbygnRG93bmxvYWRlZCBwdWJsaWMgc3VmZml4IGRhdGEnKTtcbi8vICAgICAgIHJldHVybiBicm93c2VyLnN0b3JhZ2UubG9jYWwuc2V0KHsgW2tleV06IHJ1bGVzIH0pXG4vLyAgICAgICAudGhlbigoKSA9PiBydWxlcyk7XG4vLyAgICAgfSk7XG4vLyAgIH0pXG4vLyAgIC50aGVuKHRsZFJ1bGVzID0+IHtcbi8vICAgICBjb25zb2xlLmluZm8oJ0luaXRpYWxpemVkIFRMRCcpO1xuLy8gICAgIHRsZGpzID0gZnJvbVVzZXJTZXR0aW5ncyh7IHJ1bGVzOiBUcmllLmZyb21Kc29uKHRsZFJ1bGVzKSB9KTtcbi8vICAgfSlcbi8vICAgLmNhdGNoKGVyciA9PiB7XG4vLyAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSBjb25zb2xlLmVycm9yKGVycik7XG4vLyAgICAgY29uc29sZS5pbmZvKCdGYWlsZWQgaW5pdGlhbGl6aW5nIFRMRCcpO1xuLy8gICB9KTtcbi8vIH1cbmV4cG9ydCBmdW5jdGlvbiBpbml0VExEKCkge31cblxuZnVuY3Rpb24gZXhwb3J0TWV0aG9kKGtleSkge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHRsZGpzICYmIHRsZGpzW2tleV0oLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlYWR5KCkge1xuICByZXR1cm4gISF0bGRqcztcbn1cblxuZXhwb3J0IGNvbnN0IGdldERvbWFpbiA9IGV4cG9ydE1ldGhvZCgnZ2V0RG9tYWluJyk7XG5leHBvcnQgY29uc3QgZ2V0U3ViZG9tYWluID0gZXhwb3J0TWV0aG9kKCdnZXRTdWJkb21haW4nKTtcbmV4cG9ydCBjb25zdCBnZXRQdWJsaWNTdWZmaXggPSBleHBvcnRNZXRob2QoJ2dldFB1YmxpY1N1ZmZpeCcpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==